! function() {
    return function t(n, r, e) {
        function i(u, c) {
            if (!r[u]) {
                if (!n[u]) {
                    var f = "function" == typeof require && require;
                    if (!c && f) return f(u, !0);
                    if (o) return o(u, !0);
                    var a = new Error("Cannot find module '" + u + "'");
                    throw a.code = "MODULE_NOT_FOUND", a
                }
                var s = r[u] = {
                    exports: {}
                };
                n[u][0].call(s.exports, function(t) {
                    return i(n[u][1][t] || t)
                }, s, s.exports, t, n, r, e)
            }
            return r[u].exports
        }
        for (var o = "function" == typeof require && require, u = 0; u < e.length; u++) i(e[u]);
        return i
    }
}()({
    1: [function(t, n, r) {
        (function(n) {
            "use strict";
            t(2), t(3), t(9), t(8), t(10), t(5), t(6), t(4), t(7), t(279), t(280), n._babelPolyfill && "undefined" != typeof console && console.warn && console.warn("@babel/polyfill is loaded more than once on this page. This is probably not desirable/intended and may have consequences if different versions of the polyfills are applied sequentially. If you do need to load the polyfill more than once, use @babel/polyfill/noConflict instead to bypass the warning."), n._babelPolyfill = !0
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {
        10: 10,
        2: 2,
        279: 279,
        280: 280,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9
    }],
    2: [function(t, n, r) {
        t(254), t(190), t(192), t(191), t(194), t(196), t(201), t(195), t(193), t(203), t(202), t(198), t(199), t(197), t(189), t(200), t(204), t(205), t(156), t(158), t(157), t(207), t(206), t(177), t(187), t(188), t(178), t(179), t(180), t(181), t(182), t(183), t(184), t(185), t(186), t(160), t(161), t(162), t(163), t(164), t(165), t(166), t(167), t(168), t(169), t(170), t(171), t(172), t(173), t(174), t(175), t(176), t(241), t(246), t(253), t(244), t(236), t(237), t(242), t(247), t(249), t(232), t(233), t(234), t(235), t(238), t(239), t(240), t(243), t(245), t(248), t(250), t(251), t(252), t(151), t(153), t(152), t(155), t(154), t(139), t(137), t(144), t(141), t(147), t(149), t(136), t(143), t(133), t(148), t(131), t(146), t(145), t(138), t(142), t(130), t(132), t(135), t(134), t(150), t(140), t(223), t(224), t(230), t(225), t(226), t(227), t(228), t(229), t(208), t(159), t(231), t(266), t(267), t(255), t(256), t(261), t(264), t(265), t(259), t(262), t(260), t(263), t(257), t(258), t(209), t(210), t(211), t(212), t(213), t(216), t(214), t(215), t(217), t(218), t(219), t(220), t(222), t(221), n.exports = t(30)
    }, {
        130: 130,
        131: 131,
        132: 132,
        133: 133,
        134: 134,
        135: 135,
        136: 136,
        137: 137,
        138: 138,
        139: 139,
        140: 140,
        141: 141,
        142: 142,
        143: 143,
        144: 144,
        145: 145,
        146: 146,
        147: 147,
        148: 148,
        149: 149,
        150: 150,
        151: 151,
        152: 152,
        153: 153,
        154: 154,
        155: 155,
        156: 156,
        157: 157,
        158: 158,
        159: 159,
        160: 160,
        161: 161,
        162: 162,
        163: 163,
        164: 164,
        165: 165,
        166: 166,
        167: 167,
        168: 168,
        169: 169,
        170: 170,
        171: 171,
        172: 172,
        173: 173,
        174: 174,
        175: 175,
        176: 176,
        177: 177,
        178: 178,
        179: 179,
        180: 180,
        181: 181,
        182: 182,
        183: 183,
        184: 184,
        185: 185,
        186: 186,
        187: 187,
        188: 188,
        189: 189,
        190: 190,
        191: 191,
        192: 192,
        193: 193,
        194: 194,
        195: 195,
        196: 196,
        197: 197,
        198: 198,
        199: 199,
        200: 200,
        201: 201,
        202: 202,
        203: 203,
        204: 204,
        205: 205,
        206: 206,
        207: 207,
        208: 208,
        209: 209,
        210: 210,
        211: 211,
        212: 212,
        213: 213,
        214: 214,
        215: 215,
        216: 216,
        217: 217,
        218: 218,
        219: 219,
        220: 220,
        221: 221,
        222: 222,
        223: 223,
        224: 224,
        225: 225,
        226: 226,
        227: 227,
        228: 228,
        229: 229,
        230: 230,
        231: 231,
        232: 232,
        233: 233,
        234: 234,
        235: 235,
        236: 236,
        237: 237,
        238: 238,
        239: 239,
        240: 240,
        241: 241,
        242: 242,
        243: 243,
        244: 244,
        245: 245,
        246: 246,
        247: 247,
        248: 248,
        249: 249,
        250: 250,
        251: 251,
        252: 252,
        253: 253,
        254: 254,
        255: 255,
        256: 256,
        257: 257,
        258: 258,
        259: 259,
        260: 260,
        261: 261,
        262: 262,
        263: 263,
        264: 264,
        265: 265,
        266: 266,
        267: 267,
        30: 30
    }],
    3: [function(t, n, r) {
        t(268), n.exports = t(30).Array.includes
    }, {
        268: 268,
        30: 30
    }],
    4: [function(t, n, r) {
        t(269), n.exports = t(30).Object.entries
    }, {
        269: 269,
        30: 30
    }],
    5: [function(t, n, r) {
        t(270), n.exports = t(30).Object.getOwnPropertyDescriptors
    }, {
        270: 270,
        30: 30
    }],
    6: [function(t, n, r) {
        t(271), n.exports = t(30).Object.values
    }, {
        271: 271,
        30: 30
    }],
    7: [function(t, n, r) {
        "use strict";
        t(208), t(272), n.exports = t(30).Promise.finally
    }, {
        208: 208,
        272: 272,
        30: 30
    }],
    8: [function(t, n, r) {
        t(273), n.exports = t(30).String.padEnd
    }, {
        273: 273,
        30: 30
    }],
    9: [function(t, n, r) {
        t(274), n.exports = t(30).String.padStart
    }, {
        274: 274,
        30: 30
    }],
    10: [function(t, n, r) {
        t(275), n.exports = t(127).f("asyncIterator")
    }, {
        127: 127,
        275: 275
    }],
    11: [function(t, n, r) {
        n.exports = function(t) {
            if ("function" != typeof t) throw TypeError(t + " is not a function!");
            return t
        }
    }, {}],
    12: [function(t, n, r) {
        var e = t(26);
        n.exports = function(t, n) {
            if ("number" != typeof t && "Number" != e(t)) throw TypeError(n);
            return +t
        }
    }, {
        26: 26
    }],
    13: [function(t, n, r) {
        var e = t(128)("unscopables"),
            i = Array.prototype;
        null == i[e] && t(48)(i, e, {}), n.exports = function(t) {
            i[e][t] = !0
        }
    }, {
        128: 128,
        48: 48
    }],
    14: [function(t, n, r) {
        "use strict";
        var e = t(105)(!0);
        n.exports = function(t, n, r) {
            return n + (r ? e(t, n).length : 1)
        }
    }, {
        105: 105
    }],
    15: [function(t, n, r) {
        n.exports = function(t, n, r, e) {
            if (!(t instanceof n) || void 0 !== e && e in t) throw TypeError(r + ": incorrect invocation!");
            return t
        }
    }, {}],
    16: [function(t, n, r) {
        var e = t(57);
        n.exports = function(t) {
            if (!e(t)) throw TypeError(t + " is not an object!");
            return t
        }
    }, {
        57: 57
    }],
    17: [function(t, n, r) {
        "use strict";
        var e = t(118),
            i = t(113),
            o = t(117);
        n.exports = [].copyWithin || function(t, n) {
            var r = e(this),
                u = o(r.length),
                c = i(t, u),
                f = i(n, u),
                a = arguments.length > 2 ? arguments[2] : void 0,
                s = Math.min((void 0 === a ? u : i(a, u)) - f, u - c),
                l = 1;
            for (f < c && c < f + s && (l = -1, f += s - 1, c += s - 1); s-- > 0;) f in r ? r[c] = r[f] : delete r[c], c += l, f += l;
            return r
        }
    }, {
        113: 113,
        117: 117,
        118: 118
    }],
    18: [function(t, n, r) {
        "use strict";
        var e = t(118),
            i = t(113),
            o = t(117);
        n.exports = function(t) {
            for (var n = e(this), r = o(n.length), u = arguments.length, c = i(u > 1 ? arguments[1] : void 0, r), f = u > 2 ? arguments[2] : void 0, a = void 0 === f ? r : i(f, r); a > c;) n[c++] = t;
            return n
        }
    }, {
        113: 113,
        117: 117,
        118: 118
    }],
    19: [function(t, n, r) {
        var e = t(116),
            i = t(117),
            o = t(113);
        n.exports = function(t) {
            return function(n, r, u) {
                var c, f = e(n),
                    a = i(f.length),
                    s = o(u, a);
                if (t && r != r) {
                    for (; a > s;)
                        if ((c = f[s++]) != c) return !0
                } else
                    for (; a > s; s++)
                        if ((t || s in f) && f[s] === r) return t || s || 0;
                return !t && -1
            }
        }
    }, {
        113: 113,
        116: 116,
        117: 117
    }],
    20: [function(t, n, r) {
        var e = t(32),
            i = t(53),
            o = t(118),
            u = t(117),
            c = t(23);
        n.exports = function(t, n) {
            var r = 1 == t,
                f = 2 == t,
                a = 3 == t,
                s = 4 == t,
                l = 6 == t,
                h = 5 == t || l,
                v = n || c;
            return function(n, c, p) {
                for (var g, y, d = o(n), x = i(d), m = e(c, p, 3), b = u(x.length), S = 0, w = r ? v(n, b) : f ? v(n, 0) : void 0; b > S; S++)
                    if ((h || S in x) && (y = m(g = x[S], S, d), t))
                        if (r) w[S] = y;
                        else if (y) switch (t) {
                    case 3:
                        return !0;
                    case 5:
                        return g;
                    case 6:
                        return S;
                    case 2:
                        w.push(g)
                } else if (s) return !1;
                return l ? -1 : a || s ? s : w
            }
        }
    }, {
        117: 117,
        118: 118,
        23: 23,
        32: 32,
        53: 53
    }],
    21: [function(t, n, r) {
        var e = t(11),
            i = t(118),
            o = t(53),
            u = t(117);
        n.exports = function(t, n, r, c, f) {
            e(n);
            var a = i(t),
                s = o(a),
                l = u(a.length),
                h = f ? l - 1 : 0,
                v = f ? -1 : 1;
            if (r < 2)
                for (;;) {
                    if (h in s) {
                        c = s[h], h += v;
                        break
                    }
                    if (h += v, f ? h < 0 : l <= h) throw TypeError("Reduce of empty array with no initial value")
                }
            for (; f ? h >= 0 : l > h; h += v) h in s && (c = n(c, s[h], h, a));
            return c
        }
    }, {
        11: 11,
        117: 117,
        118: 118,
        53: 53
    }],
    22: [function(t, n, r) {
        var e = t(57),
            i = t(55),
            o = t(128)("species");
        n.exports = function(t) {
            var n;
            return i(t) && ("function" != typeof(n = t.constructor) || n !== Array && !i(n.prototype) || (n = void 0), e(n) && null === (n = n[o]) && (n = void 0)), void 0 === n ? Array : n
        }
    }, {
        128: 128,
        55: 55,
        57: 57
    }],
    23: [function(t, n, r) {
        var e = t(22);
        n.exports = function(t, n) {
            return new(e(t))(n)
        }
    }, {
        22: 22
    }],
    24: [function(t, n, r) {
        "use strict";
        var e = t(11),
            i = t(57),
            o = t(52),
            u = [].slice,
            c = {},
            f = function(t, n, r) {
                if (!(n in c)) {
                    for (var e = [], i = 0; i < n; i++) e[i] = "a[" + i + "]";
                    c[n] = Function("F,a", "return new F(" + e.join(",") + ")")
                }
                return c[n](t, r)
            };
        n.exports = Function.bind || function(t) {
            var n = e(this),
                r = u.call(arguments, 1),
                c = function() {
                    var e = r.concat(u.call(arguments));
                    return this instanceof c ? f(n, e.length, e) : o(n, e, t)
                };
            return i(n.prototype) && (c.prototype = n.prototype), c
        }
    }, {
        11: 11,
        52: 52,
        57: 57
    }],
    25: [function(t, n, r) {
        var e = t(26),
            i = t(128)("toStringTag"),
            o = "Arguments" == e(function() {
                return arguments
            }());
        n.exports = function(t) {
            var n, r, u;
            return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof(r = function(t, n) {
                try {
                    return t[n]
                } catch (t) {}
            }(n = Object(t), i)) ? r : o ? e(n) : "Object" == (u = e(n)) && "function" == typeof n.callee ? "Arguments" : u
        }
    }, {
        128: 128,
        26: 26
    }],
    26: [function(t, n, r) {
        var e = {}.toString;
        n.exports = function(t) {
            return e.call(t).slice(8, -1)
        }
    }, {}],
    27: [function(t, n, r) {
        "use strict";
        var e = t(75).f,
            i = t(74),
            o = t(93),
            u = t(32),
            c = t(15),
            f = t(45),
            a = t(61),
            s = t(63),
            l = t(99),
            h = t(36),
            v = t(70).fastKey,
            p = t(125),
            g = h ? "_s" : "size",
            y = function(t, n) {
                var r, e = v(n);
                if ("F" !== e) return t._i[e];
                for (r = t._f; r; r = r.n)
                    if (r.k == n) return r
            };
        n.exports = {
            getConstructor: function(t, n, r, a) {
                var s = t(function(t, e) {
                    c(t, s, n, "_i"), t._t = n, t._i = i(null), t._f = void 0, t._l = void 0, t[g] = 0, null != e && f(e, r, t[a], t)
                });
                return o(s.prototype, {
                    clear: function() {
                        for (var t = p(this, n), r = t._i, e = t._f; e; e = e.n) e.r = !0, e.p && (e.p = e.p.n = void 0), delete r[e.i];
                        t._f = t._l = void 0, t[g] = 0
                    },
                    delete: function(t) {
                        var r = p(this, n),
                            e = y(r, t);
                        if (e) {
                            var i = e.n,
                                o = e.p;
                            delete r._i[e.i], e.r = !0, o && (o.n = i), i && (i.p = o), r._f == e && (r._f = i), r._l == e && (r._l = o), r[g]--
                        }
                        return !!e
                    },
                    forEach: function(t) {
                        p(this, n);
                        for (var r, e = u(t, arguments.length > 1 ? arguments[1] : void 0, 3); r = r ? r.n : this._f;)
                            for (e(r.v, r.k, this); r && r.r;) r = r.p
                    },
                    has: function(t) {
                        return !!y(p(this, n), t)
                    }
                }), h && e(s.prototype, "size", {
                    get: function() {
                        return p(this, n)[g]
                    }
                }), s
            },
            def: function(t, n, r) {
                var e, i, o = y(t, n);
                return o ? o.v = r : (t._l = o = {
                    i: i = v(n, !0),
                    k: n,
                    v: r,
                    p: e = t._l,
                    n: void 0,
                    r: !1
                }, t._f || (t._f = o), e && (e.n = o), t[g]++, "F" !== i && (t._i[i] = o)), t
            },
            getEntry: y,
            setStrong: function(t, n, r) {
                a(t, n, function(t, r) {
                    this._t = p(t, n), this._k = r, this._l = void 0
                }, function() {
                    for (var t = this, n = t._k, r = t._l; r && r.r;) r = r.p;
                    return t._t && (t._l = r = r ? r.n : t._t._f) ? s(0, "keys" == n ? r.k : "values" == n ? r.v : [r.k, r.v]) : (t._t = void 0, s(1))
                }, r ? "entries" : "values", !r, !0), l(n)
            }
        }
    }, {
        125: 125,
        15: 15,
        32: 32,
        36: 36,
        45: 45,
        61: 61,
        63: 63,
        70: 70,
        74: 74,
        75: 75,
        93: 93,
        99: 99
    }],
    28: [function(t, n, r) {
        "use strict";
        var e = t(93),
            i = t(70).getWeak,
            o = t(16),
            u = t(57),
            c = t(15),
            f = t(45),
            a = t(20),
            s = t(47),
            l = t(125),
            h = a(5),
            v = a(6),
            p = 0,
            g = function(t) {
                return t._l || (t._l = new y)
            },
            y = function() {
                this.a = []
            },
            d = function(t, n) {
                return h(t.a, function(t) {
                    return t[0] === n
                })
            };
        y.prototype = {
            get: function(t) {
                var n = d(this, t);
                if (n) return n[1]
            },
            has: function(t) {
                return !!d(this, t)
            },
            set: function(t, n) {
                var r = d(this, t);
                r ? r[1] = n : this.a.push([t, n])
            },
            delete: function(t) {
                var n = v(this.a, function(n) {
                    return n[0] === t
                });
                return ~n && this.a.splice(n, 1), !!~n
            }
        }, n.exports = {
            getConstructor: function(t, n, r, o) {
                var a = t(function(t, e) {
                    c(t, a, n, "_i"), t._t = n, t._i = p++, t._l = void 0, null != e && f(e, r, t[o], t)
                });
                return e(a.prototype, {
                    delete: function(t) {
                        if (!u(t)) return !1;
                        var r = i(t);
                        return !0 === r ? g(l(this, n)).delete(t) : r && s(r, this._i) && delete r[this._i]
                    },
                    has: function(t) {
                        if (!u(t)) return !1;
                        var r = i(t);
                        return !0 === r ? g(l(this, n)).has(t) : r && s(r, this._i)
                    }
                }), a
            },
            def: function(t, n, r) {
                var e = i(o(n), !0);
                return !0 === e ? g(t).set(n, r) : e[t._i] = r, t
            },
            ufstore: g
        }
    }, {
        125: 125,
        15: 15,
        16: 16,
        20: 20,
        45: 45,
        47: 47,
        57: 57,
        70: 70,
        93: 93
    }],
    29: [function(t, n, r) {
        "use strict";
        var e = t(46),
            i = t(40),
            o = t(94),
            u = t(93),
            c = t(70),
            f = t(45),
            a = t(15),
            s = t(57),
            l = t(42),
            h = t(62),
            v = t(100),
            p = t(51);
        n.exports = function(t, n, r, g, y, d) {
            var x = e[t],
                m = x,
                b = y ? "set" : "add",
                S = m && m.prototype,
                w = {},
                _ = function(t) {
                    var n = S[t];
                    o(S, t, "delete" == t ? function(t) {
                        return !(d && !s(t)) && n.call(this, 0 === t ? 0 : t)
                    } : "has" == t ? function(t) {
                        return !(d && !s(t)) && n.call(this, 0 === t ? 0 : t)
                    } : "get" == t ? function(t) {
                        return d && !s(t) ? void 0 : n.call(this, 0 === t ? 0 : t)
                    } : "add" == t ? function(t) {
                        return n.call(this, 0 === t ? 0 : t), this
                    } : function(t, r) {
                        return n.call(this, 0 === t ? 0 : t, r), this
                    })
                };
            if ("function" == typeof m && (d || S.forEach && !l(function() {
                    (new m).entries().next()
                }))) {
                var E = new m,
                    O = E[b](d ? {} : -0, 1) != E,
                    F = l(function() {
                        E.has(1)
                    }),
                    P = h(function(t) {
                        new m(t)
                    }),
                    M = !d && l(function() {
                        for (var t = new m, n = 5; n--;) t[b](n, n);
                        return !t.has(-0)
                    });
                P || ((m = n(function(n, r) {
                    a(n, m, t);
                    var e = p(new x, n, m);
                    return null != r && f(r, y, e[b], e), e
                })).prototype = S, S.constructor = m), (F || M) && (_("delete"), _("has"), y && _("get")), (M || O) && _(b), d && S.clear && delete S.clear
            } else m = g.getConstructor(n, t, y, b), u(m.prototype, r), c.NEED = !0;
            return v(m, t), w[t] = m, i(i.G + i.W + i.F * (m != x), w), d || g.setStrong(m, t, y), m
        }
    }, {
        100: 100,
        15: 15,
        40: 40,
        42: 42,
        45: 45,
        46: 46,
        51: 51,
        57: 57,
        62: 62,
        70: 70,
        93: 93,
        94: 94
    }],
    30: [function(t, n, r) {
        var e = n.exports = {
            version: "2.6.1"
        };
        "number" == typeof __e && (__e = e)
    }, {}],
    31: [function(t, n, r) {
        "use strict";
        var e = t(75),
            i = t(92);
        n.exports = function(t, n, r) {
            n in t ? e.f(t, n, i(0, r)) : t[n] = r
        }
    }, {
        75: 75,
        92: 92
    }],
    32: [function(t, n, r) {
        var e = t(11);
        n.exports = function(t, n, r) {
            if (e(t), void 0 === n) return t;
            switch (r) {
                case 1:
                    return function(r) {
                        return t.call(n, r)
                    };
                case 2:
                    return function(r, e) {
                        return t.call(n, r, e)
                    };
                case 3:
                    return function(r, e, i) {
                        return t.call(n, r, e, i)
                    }
            }
            return function() {
                return t.apply(n, arguments)
            }
        }
    }, {
        11: 11
    }],
    33: [function(t, n, r) {
        "use strict";
        var e = t(42),
            i = Date.prototype.getTime,
            o = Date.prototype.toISOString,
            u = function(t) {
                return t > 9 ? t : "0" + t
            };
        n.exports = e(function() {
            return "0385-07-25T07:06:39.999Z" != o.call(new Date(-5e13 - 1))
        }) || !e(function() {
            o.call(new Date(NaN))
        }) ? function() {
            if (!isFinite(i.call(this))) throw RangeError("Invalid time value");
            var t = this,
                n = t.getUTCFullYear(),
                r = t.getUTCMilliseconds(),
                e = n < 0 ? "-" : n > 9999 ? "+" : "";
            return e + ("00000" + Math.abs(n)).slice(e ? -6 : -4) + "-" + u(t.getUTCMonth() + 1) + "-" + u(t.getUTCDate()) + "T" + u(t.getUTCHours()) + ":" + u(t.getUTCMinutes()) + ":" + u(t.getUTCSeconds()) + "." + (r > 99 ? r : "0" + u(r)) + "Z"
        } : o
    }, {
        42: 42
    }],
    34: [function(t, n, r) {
        "use strict";
        var e = t(16),
            i = t(119);
        n.exports = function(t) {
            if ("string" !== t && "number" !== t && "default" !== t) throw TypeError("Incorrect hint");
            return i(e(this), "number" != t)
        }
    }, {
        119: 119,
        16: 16
    }],
    35: [function(t, n, r) {
        n.exports = function(t) {
            if (null == t) throw TypeError("Can't call method on  " + t);
            return t
        }
    }, {}],
    36: [function(t, n, r) {
        n.exports = !t(42)(function() {
            return 7 != Object.defineProperty({}, "a", {
                get: function() {
                    return 7
                }
            }).a
        })
    }, {
        42: 42
    }],
    37: [function(t, n, r) {
        var e = t(57),
            i = t(46).document,
            o = e(i) && e(i.createElement);
        n.exports = function(t) {
            return o ? i.createElement(t) : {}
        }
    }, {
        46: 46,
        57: 57
    }],
    38: [function(t, n, r) {
        n.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")
    }, {}],
    39: [function(t, n, r) {
        var e = t(83),
            i = t(80),
            o = t(84);
        n.exports = function(t) {
            var n = e(t),
                r = i.f;
            if (r)
                for (var u, c = r(t), f = o.f, a = 0; c.length > a;) f.call(t, u = c[a++]) && n.push(u);
            return n
        }
    }, {
        80: 80,
        83: 83,
        84: 84
    }],
    40: [function(t, n, r) {
        var e = t(46),
            i = t(30),
            o = t(48),
            u = t(94),
            c = t(32),
            f = function(t, n, r) {
                var a, s, l, h, v = t & f.F,
                    p = t & f.G,
                    g = t & f.S,
                    y = t & f.P,
                    d = t & f.B,
                    x = p ? e : g ? e[n] || (e[n] = {}) : (e[n] || {}).prototype,
                    m = p ? i : i[n] || (i[n] = {}),
                    b = m.prototype || (m.prototype = {});
                for (a in p && (r = n), r) l = ((s = !v && x && void 0 !== x[a]) ? x : r)[a], h = d && s ? c(l, e) : y && "function" == typeof l ? c(Function.call, l) : l, x && u(x, a, l, t & f.U), m[a] != l && o(m, a, h), y && b[a] != l && (b[a] = l)
            };
        e.core = i, f.F = 1, f.G = 2, f.S = 4, f.P = 8, f.B = 16, f.W = 32, f.U = 64, f.R = 128, n.exports = f
    }, {
        30: 30,
        32: 32,
        46: 46,
        48: 48,
        94: 94
    }],
    41: [function(t, n, r) {
        var e = t(128)("match");
        n.exports = function(t) {
            var n = /./;
            try {
                "/./" [t](n)
            } catch (r) {
                try {
                    return n[e] = !1, !"/./" [t](n)
                } catch (t) {}
            }
            return !0
        }
    }, {
        128: 128
    }],
    42: [function(t, n, r) {
        n.exports = function(t) {
            try {
                return !!t()
            } catch (t) {
                return !0
            }
        }
    }, {}],
    43: [function(t, n, r) {
        "use strict";
        t(224);
        var e = t(94),
            i = t(48),
            o = t(42),
            u = t(35),
            c = t(128),
            f = t(96),
            a = c("species"),
            s = !o(function() {
                var t = /./;
                return t.exec = function() {
                    var t = [];
                    return t.groups = {
                        a: "7"
                    }, t
                }, "7" !== "".replace(t, "$<a>")
            }),
            l = function() {
                var t = /(?:)/,
                    n = t.exec;
                t.exec = function() {
                    return n.apply(this, arguments)
                };
                var r = "ab".split(t);
                return 2 === r.length && "a" === r[0] && "b" === r[1]
            }();
        n.exports = function(t, n, r) {
            var h = c(t),
                v = !o(function() {
                    var n = {};
                    return n[h] = function() {
                        return 7
                    }, 7 != "" [t](n)
                }),
                p = v ? !o(function() {
                    var n = !1,
                        r = /a/;
                    return r.exec = function() {
                        return n = !0, null
                    }, "split" === t && (r.constructor = {}, r.constructor[a] = function() {
                        return r
                    }), r[h](""), !n
                }) : void 0;
            if (!v || !p || "replace" === t && !s || "split" === t && !l) {
                var g = /./ [h],
                    y = r(u, h, "" [t], function(t, n, r, e, i) {
                        return n.exec === f ? v && !i ? {
                            done: !0,
                            value: g.call(n, r, e)
                        } : {
                            done: !0,
                            value: t.call(r, n, e)
                        } : {
                            done: !1
                        }
                    }),
                    d = y[0],
                    x = y[1];
                e(String.prototype, t, d), i(RegExp.prototype, h, 2 == n ? function(t, n) {
                    return x.call(t, this, n)
                } : function(t) {
                    return x.call(t, this)
                })
            }
        }
    }, {
        128: 128,
        224: 224,
        35: 35,
        42: 42,
        48: 48,
        94: 94,
        96: 96
    }],
    44: [function(t, n, r) {
        "use strict";
        var e = t(16);
        n.exports = function() {
            var t = e(this),
                n = "";
            return t.global && (n += "g"), t.ignoreCase && (n += "i"), t.multiline && (n += "m"), t.unicode && (n += "u"), t.sticky && (n += "y"), n
        }
    }, {
        16: 16
    }],
    45: [function(t, n, r) {
        var e = t(32),
            i = t(59),
            o = t(54),
            u = t(16),
            c = t(117),
            f = t(129),
            a = {},
            s = {};
        (r = n.exports = function(t, n, r, l, h) {
            var v, p, g, y, d = h ? function() {
                    return t
                } : f(t),
                x = e(r, l, n ? 2 : 1),
                m = 0;
            if ("function" != typeof d) throw TypeError(t + " is not iterable!");
            if (o(d)) {
                for (v = c(t.length); v > m; m++)
                    if ((y = n ? x(u(p = t[m])[0], p[1]) : x(t[m])) === a || y === s) return y
            } else
                for (g = d.call(t); !(p = g.next()).done;)
                    if ((y = i(g, x, p.value, n)) === a || y === s) return y
        }).BREAK = a, r.RETURN = s
    }, {
        117: 117,
        129: 129,
        16: 16,
        32: 32,
        54: 54,
        59: 59
    }],
    46: [function(t, n, r) {
        var e = n.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
        "number" == typeof __g && (__g = e)
    }, {}],
    47: [function(t, n, r) {
        var e = {}.hasOwnProperty;
        n.exports = function(t, n) {
            return e.call(t, n)
        }
    }, {}],
    48: [function(t, n, r) {
        var e = t(75),
            i = t(92);
        n.exports = t(36) ? function(t, n, r) {
            return e.f(t, n, i(1, r))
        } : function(t, n, r) {
            return t[n] = r, t
        }
    }, {
        36: 36,
        75: 75,
        92: 92
    }],
    49: [function(t, n, r) {
        var e = t(46).document;
        n.exports = e && e.documentElement
    }, {
        46: 46
    }],
    50: [function(t, n, r) {
        n.exports = !t(36) && !t(42)(function() {
            return 7 != Object.defineProperty(t(37)("div"), "a", {
                get: function() {
                    return 7
                }
            }).a
        })
    }, {
        36: 36,
        37: 37,
        42: 42
    }],
    51: [function(t, n, r) {
        var e = t(57),
            i = t(98).set;
        n.exports = function(t, n, r) {
            var o, u = n.constructor;
            return u !== r && "function" == typeof u && (o = u.prototype) !== r.prototype && e(o) && i && i(t, o), t
        }
    }, {
        57: 57,
        98: 98
    }],
    52: [function(t, n, r) {
        n.exports = function(t, n, r) {
            var e = void 0 === r;
            switch (n.length) {
                case 0:
                    return e ? t() : t.call(r);
                case 1:
                    return e ? t(n[0]) : t.call(r, n[0]);
                case 2:
                    return e ? t(n[0], n[1]) : t.call(r, n[0], n[1]);
                case 3:
                    return e ? t(n[0], n[1], n[2]) : t.call(r, n[0], n[1], n[2]);
                case 4:
                    return e ? t(n[0], n[1], n[2], n[3]) : t.call(r, n[0], n[1], n[2], n[3])
            }
            return t.apply(r, n)
        }
    }, {}],
    53: [function(t, n, r) {
        var e = t(26);
        n.exports = Object("z").propertyIsEnumerable(0) ? Object : function(t) {
            return "String" == e(t) ? t.split("") : Object(t)
        }
    }, {
        26: 26
    }],
    54: [function(t, n, r) {
        var e = t(64),
            i = t(128)("iterator"),
            o = Array.prototype;
        n.exports = function(t) {
            return void 0 !== t && (e.Array === t || o[i] === t)
        }
    }, {
        128: 128,
        64: 64
    }],
    55: [function(t, n, r) {
        var e = t(26);
        n.exports = Array.isArray || function(t) {
            return "Array" == e(t)
        }
    }, {
        26: 26
    }],
    56: [function(t, n, r) {
        var e = t(57),
            i = Math.floor;
        n.exports = function(t) {
            return !e(t) && isFinite(t) && i(t) === t
        }
    }, {
        57: 57
    }],
    57: [function(t, n, r) {
        n.exports = function(t) {
            return "object" == typeof t ? null !== t : "function" == typeof t
        }
    }, {}],
    58: [function(t, n, r) {
        var e = t(57),
            i = t(26),
            o = t(128)("match");
        n.exports = function(t) {
            var n;
            return e(t) && (void 0 !== (n = t[o]) ? !!n : "RegExp" == i(t))
        }
    }, {
        128: 128,
        26: 26,
        57: 57
    }],
    59: [function(t, n, r) {
        var e = t(16);
        n.exports = function(t, n, r, i) {
            try {
                return i ? n(e(r)[0], r[1]) : n(r)
            } catch (n) {
                var o = t.return;
                throw void 0 !== o && e(o.call(t)), n
            }
        }
    }, {
        16: 16
    }],
    60: [function(t, n, r) {
        "use strict";
        var e = t(74),
            i = t(92),
            o = t(100),
            u = {};
        t(48)(u, t(128)("iterator"), function() {
            return this
        }), n.exports = function(t, n, r) {
            t.prototype = e(u, {
                next: i(1, r)
            }), o(t, n + " Iterator")
        }
    }, {
        100: 100,
        128: 128,
        48: 48,
        74: 74,
        92: 92
    }],
    61: [function(t, n, r) {
        "use strict";
        var e = t(65),
            i = t(40),
            o = t(94),
            u = t(48),
            c = t(64),
            f = t(60),
            a = t(100),
            s = t(81),
            l = t(128)("iterator"),
            h = !([].keys && "next" in [].keys()),
            v = function() {
                return this
            };
        n.exports = function(t, n, r, p, g, y, d) {
            f(r, n, p);
            var x, m, b, S = function(t) {
                    if (!h && t in O) return O[t];
                    switch (t) {
                        case "keys":
                        case "values":
                            return function() {
                                return new r(this, t)
                            }
                    }
                    return function() {
                        return new r(this, t)
                    }
                },
                w = n + " Iterator",
                _ = "values" == g,
                E = !1,
                O = t.prototype,
                F = O[l] || O["@@iterator"] || g && O[g],
                P = F || S(g),
                M = g ? _ ? S("entries") : P : void 0,
                A = "Array" == n && O.entries || F;
            if (A && (b = s(A.call(new t))) !== Object.prototype && b.next && (a(b, w, !0), e || "function" == typeof b[l] || u(b, l, v)), _ && F && "values" !== F.name && (E = !0, P = function() {
                    return F.call(this)
                }), e && !d || !h && !E && O[l] || u(O, l, P), c[n] = P, c[w] = v, g)
                if (x = {
                        values: _ ? P : S("values"),
                        keys: y ? P : S("keys"),
                        entries: M
                    }, d)
                    for (m in x) m in O || o(O, m, x[m]);
                else i(i.P + i.F * (h || E), n, x);
            return x
        }
    }, {
        100: 100,
        128: 128,
        40: 40,
        48: 48,
        60: 60,
        64: 64,
        65: 65,
        81: 81,
        94: 94
    }],
    62: [function(t, n, r) {
        var e = t(128)("iterator"),
            i = !1;
        try {
            var o = [7][e]();
            o.return = function() {
                i = !0
            }, Array.from(o, function() {
                throw 2
            })
        } catch (t) {}
        n.exports = function(t, n) {
            if (!n && !i) return !1;
            var r = !1;
            try {
                var o = [7],
                    u = o[e]();
                u.next = function() {
                    return {
                        done: r = !0
                    }
                }, o[e] = function() {
                    return u
                }, t(o)
            } catch (t) {}
            return r
        }
    }, {
        128: 128
    }],
    63: [function(t, n, r) {
        n.exports = function(t, n) {
            return {
                value: n,
                done: !!t
            }
        }
    }, {}],
    64: [function(t, n, r) {
        n.exports = {}
    }, {}],
    65: [function(t, n, r) {
        n.exports = !1
    }, {}],
    66: [function(t, n, r) {
        var e = Math.expm1;
        n.exports = !e || e(10) > 22025.465794806718 || e(10) < 22025.465794806718 || -2e-17 != e(-2e-17) ? function(t) {
            return 0 == (t = +t) ? t : t > -1e-6 && t < 1e-6 ? t + t * t / 2 : Math.exp(t) - 1
        } : e
    }, {}],
    67: [function(t, n, r) {
        var e = t(69),
            i = Math.pow,
            o = i(2, -52),
            u = i(2, -23),
            c = i(2, 127) * (2 - u),
            f = i(2, -126);
        n.exports = Math.fround || function(t) {
            var n, r, i = Math.abs(t),
                a = e(t);
            return i < f ? a * function(t) {
                return t + 1 / o - 1 / o
            }(i / f / u) * f * u : (r = (n = (1 + u / o) * i) - (n - i)) > c || r != r ? a * (1 / 0) : a * r
        }
    }, {
        69: 69
    }],
    68: [function(t, n, r) {
        n.exports = Math.log1p || function(t) {
            return (t = +t) > -1e-8 && t < 1e-8 ? t - t * t / 2 : Math.log(1 + t)
        }
    }, {}],
    69: [function(t, n, r) {
        n.exports = Math.sign || function(t) {
            return 0 == (t = +t) || t != t ? t : t < 0 ? -1 : 1
        }
    }, {}],
    70: [function(t, n, r) {
        var e = t(123)("meta"),
            i = t(57),
            o = t(47),
            u = t(75).f,
            c = 0,
            f = Object.isExtensible || function() {
                return !0
            },
            a = !t(42)(function() {
                return f(Object.preventExtensions({}))
            }),
            s = function(t) {
                u(t, e, {
                    value: {
                        i: "O" + ++c,
                        w: {}
                    }
                })
            },
            l = n.exports = {
                KEY: e,
                NEED: !1,
                fastKey: function(t, n) {
                    if (!i(t)) return "symbol" == typeof t ? t : ("string" == typeof t ? "S" : "P") + t;
                    if (!o(t, e)) {
                        if (!f(t)) return "F";
                        if (!n) return "E";
                        s(t)
                    }
                    return t[e].i
                },
                getWeak: function(t, n) {
                    if (!o(t, e)) {
                        if (!f(t)) return !0;
                        if (!n) return !1;
                        s(t)
                    }
                    return t[e].w
                },
                onFreeze: function(t) {
                    return a && l.NEED && f(t) && !o(t, e) && s(t), t
                }
            }
    }, {
        123: 123,
        42: 42,
        47: 47,
        57: 57,
        75: 75
    }],
    71: [function(t, n, r) {
        var e = t(46),
            i = t(112).set,
            o = e.MutationObserver || e.WebKitMutationObserver,
            u = e.process,
            c = e.Promise,
            f = "process" == t(26)(u);
        n.exports = function() {
            var t, n, r, a = function() {
                var e, i;
                for (f && (e = u.domain) && e.exit(); t;) {
                    i = t.fn, t = t.next;
                    try {
                        i()
                    } catch (e) {
                        throw t ? r() : n = void 0, e
                    }
                }
                n = void 0, e && e.enter()
            };
            if (f) r = function() {
                u.nextTick(a)
            };
            else if (!o || e.navigator && e.navigator.standalone)
                if (c && c.resolve) {
                    var s = c.resolve(void 0);
                    r = function() {
                        s.then(a)
                    }
                } else r = function() {
                    i.call(e, a)
                };
            else {
                var l = !0,
                    h = document.createTextNode("");
                new o(a).observe(h, {
                    characterData: !0
                }), r = function() {
                    h.data = l = !l
                }
            }
            return function(e) {
                var i = {
                    fn: e,
                    next: void 0
                };
                n && (n.next = i), t || (t = i, r()), n = i
            }
        }
    }, {
        112: 112,
        26: 26,
        46: 46
    }],
    72: [function(t, n, r) {
        "use strict";

        function e(t) {
            var n, r;
            this.promise = new t(function(t, e) {
                if (void 0 !== n || void 0 !== r) throw TypeError("Bad Promise constructor");
                n = t, r = e
            }), this.resolve = i(n), this.reject = i(r)
        }
        var i = t(11);
        n.exports.f = function(t) {
            return new e(t)
        }
    }, {
        11: 11
    }],
    73: [function(t, n, r) {
        "use strict";
        var e = t(83),
            i = t(80),
            o = t(84),
            u = t(118),
            c = t(53),
            f = Object.assign;
        n.exports = !f || t(42)(function() {
            var t = {},
                n = {},
                r = Symbol(),
                e = "abcdefghijklmnopqrst";
            return t[r] = 7, e.split("").forEach(function(t) {
                n[t] = t
            }), 7 != f({}, t)[r] || Object.keys(f({}, n)).join("") != e
        }) ? function(t, n) {
            for (var r = u(t), f = arguments.length, a = 1, s = i.f, l = o.f; f > a;)
                for (var h, v = c(arguments[a++]), p = s ? e(v).concat(s(v)) : e(v), g = p.length, y = 0; g > y;) l.call(v, h = p[y++]) && (r[h] = v[h]);
            return r
        } : f
    }, {
        118: 118,
        42: 42,
        53: 53,
        80: 80,
        83: 83,
        84: 84
    }],
    74: [function(t, n, r) {
        var e = t(16),
            i = t(76),
            o = t(38),
            u = t(101)("IE_PROTO"),
            c = function() {},
            f = function() {
                var n, r = t(37)("iframe"),
                    e = o.length;
                for (r.style.display = "none", t(49).appendChild(r), r.src = "javascript:", (n = r.contentWindow.document).open(), n.write("<script>document.F=Object<\/script>"), n.close(), f = n.F; e--;) delete f.prototype[o[e]];
                return f()
            };
        n.exports = Object.create || function(t, n) {
            var r;
            return null !== t ? (c.prototype = e(t), r = new c, c.prototype = null, r[u] = t) : r = f(), void 0 === n ? r : i(r, n)
        }
    }, {
        101: 101,
        16: 16,
        37: 37,
        38: 38,
        49: 49,
        76: 76
    }],
    75: [function(t, n, r) {
        var e = t(16),
            i = t(50),
            o = t(119),
            u = Object.defineProperty;
        r.f = t(36) ? Object.defineProperty : function(t, n, r) {
            if (e(t), n = o(n, !0), e(r), i) try {
                return u(t, n, r)
            } catch (t) {}
            if ("get" in r || "set" in r) throw TypeError("Accessors not supported!");
            return "value" in r && (t[n] = r.value), t
        }
    }, {
        119: 119,
        16: 16,
        36: 36,
        50: 50
    }],
    76: [function(t, n, r) {
        var e = t(75),
            i = t(16),
            o = t(83);
        n.exports = t(36) ? Object.defineProperties : function(t, n) {
            i(t);
            for (var r, u = o(n), c = u.length, f = 0; c > f;) e.f(t, r = u[f++], n[r]);
            return t
        }
    }, {
        16: 16,
        36: 36,
        75: 75,
        83: 83
    }],
    77: [function(t, n, r) {
        var e = t(84),
            i = t(92),
            o = t(116),
            u = t(119),
            c = t(47),
            f = t(50),
            a = Object.getOwnPropertyDescriptor;
        r.f = t(36) ? a : function(t, n) {
            if (t = o(t), n = u(n, !0), f) try {
                return a(t, n)
            } catch (t) {}
            if (c(t, n)) return i(!e.f.call(t, n), t[n])
        }
    }, {
        116: 116,
        119: 119,
        36: 36,
        47: 47,
        50: 50,
        84: 84,
        92: 92
    }],
    78: [function(t, n, r) {
        var e = t(116),
            i = t(79).f,
            o = {}.toString,
            u = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
        n.exports.f = function(t) {
            return u && "[object Window]" == o.call(t) ? function(t) {
                try {
                    return i(t)
                } catch (t) {
                    return u.slice()
                }
            }(t) : i(e(t))
        }
    }, {
        116: 116,
        79: 79
    }],
    79: [function(t, n, r) {
        var e = t(82),
            i = t(38).concat("length", "prototype");
        r.f = Object.getOwnPropertyNames || function(t) {
            return e(t, i)
        }
    }, {
        38: 38,
        82: 82
    }],
    80: [function(t, n, r) {
        r.f = Object.getOwnPropertySymbols
    }, {}],
    81: [function(t, n, r) {
        var e = t(47),
            i = t(118),
            o = t(101)("IE_PROTO"),
            u = Object.prototype;
        n.exports = Object.getPrototypeOf || function(t) {
            return t = i(t), e(t, o) ? t[o] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? u : null
        }
    }, {
        101: 101,
        118: 118,
        47: 47
    }],
    82: [function(t, n, r) {
        var e = t(47),
            i = t(116),
            o = t(19)(!1),
            u = t(101)("IE_PROTO");
        n.exports = function(t, n) {
            var r, c = i(t),
                f = 0,
                a = [];
            for (r in c) r != u && e(c, r) && a.push(r);
            for (; n.length > f;) e(c, r = n[f++]) && (~o(a, r) || a.push(r));
            return a
        }
    }, {
        101: 101,
        116: 116,
        19: 19,
        47: 47
    }],
    83: [function(t, n, r) {
        var e = t(82),
            i = t(38);
        n.exports = Object.keys || function(t) {
            return e(t, i)
        }
    }, {
        38: 38,
        82: 82
    }],
    84: [function(t, n, r) {
        r.f = {}.propertyIsEnumerable
    }, {}],
    85: [function(t, n, r) {
        var e = t(40),
            i = t(30),
            o = t(42);
        n.exports = function(t, n) {
            var r = (i.Object || {})[t] || Object[t],
                u = {};
            u[t] = n(r), e(e.S + e.F * o(function() {
                r(1)
            }), "Object", u)
        }
    }, {
        30: 30,
        40: 40,
        42: 42
    }],
    86: [function(t, n, r) {
        var e = t(83),
            i = t(116),
            o = t(84).f;
        n.exports = function(t) {
            return function(n) {
                for (var r, u = i(n), c = e(u), f = c.length, a = 0, s = []; f > a;) o.call(u, r = c[a++]) && s.push(t ? [r, u[r]] : u[r]);
                return s
            }
        }
    }, {
        116: 116,
        83: 83,
        84: 84
    }],
    87: [function(t, n, r) {
        var e = t(79),
            i = t(80),
            o = t(16),
            u = t(46).Reflect;
        n.exports = u && u.ownKeys || function(t) {
            var n = e.f(o(t)),
                r = i.f;
            return r ? n.concat(r(t)) : n
        }
    }, {
        16: 16,
        46: 46,
        79: 79,
        80: 80
    }],
    88: [function(t, n, r) {
        var e = t(46).parseFloat,
            i = t(110).trim;
        n.exports = 1 / e(t(111) + "-0") != -1 / 0 ? function(t) {
            var n = i(String(t), 3),
                r = e(n);
            return 0 === r && "-" == n.charAt(0) ? -0 : r
        } : e
    }, {
        110: 110,
        111: 111,
        46: 46
    }],
    89: [function(t, n, r) {
        var e = t(46).parseInt,
            i = t(110).trim,
            o = t(111),
            u = /^[-+]?0[xX]/;
        n.exports = 8 !== e(o + "08") || 22 !== e(o + "0x16") ? function(t, n) {
            var r = i(String(t), 3);
            return e(r, n >>> 0 || (u.test(r) ? 16 : 10))
        } : e
    }, {
        110: 110,
        111: 111,
        46: 46
    }],
    90: [function(t, n, r) {
        n.exports = function(t) {
            try {
                return {
                    e: !1,
                    v: t()
                }
            } catch (t) {
                return {
                    e: !0,
                    v: t
                }
            }
        }
    }, {}],
    91: [function(t, n, r) {
        var e = t(16),
            i = t(57),
            o = t(72);
        n.exports = function(t, n) {
            if (e(t), i(n) && n.constructor === t) return n;
            var r = o.f(t);
            return (0, r.resolve)(n), r.promise
        }
    }, {
        16: 16,
        57: 57,
        72: 72
    }],
    92: [function(t, n, r) {
        n.exports = function(t, n) {
            return {
                enumerable: !(1 & t),
                configurable: !(2 & t),
                writable: !(4 & t),
                value: n
            }
        }
    }, {}],
    93: [function(t, n, r) {
        var e = t(94);
        n.exports = function(t, n, r) {
            for (var i in n) e(t, i, n[i], r);
            return t
        }
    }, {
        94: 94
    }],
    94: [function(t, n, r) {
        var e = t(46),
            i = t(48),
            o = t(47),
            u = t(123)("src"),
            c = Function.toString,
            f = ("" + c).split("toString");
        t(30).inspectSource = function(t) {
            return c.call(t)
        }, (n.exports = function(t, n, r, c) {
            var a = "function" == typeof r;
            a && (o(r, "name") || i(r, "name", n)), t[n] !== r && (a && (o(r, u) || i(r, u, t[n] ? "" + t[n] : f.join(String(n)))), t === e ? t[n] = r : c ? t[n] ? t[n] = r : i(t, n, r) : (delete t[n], i(t, n, r)))
        })(Function.prototype, "toString", function() {
            return "function" == typeof this && this[u] || c.call(this)
        })
    }, {
        123: 123,
        30: 30,
        46: 46,
        47: 47,
        48: 48
    }],
    95: [function(t, n, r) {
        "use strict";
        var e = t(25),
            i = RegExp.prototype.exec;
        n.exports = function(t, n) {
            var r = t.exec;
            if ("function" == typeof r) {
                var o = r.call(t, n);
                if ("object" != typeof o) throw new TypeError("RegExp exec method returned something other than an Object or null");
                return o
            }
            if ("RegExp" !== e(t)) throw new TypeError("RegExp#exec called on incompatible receiver");
            return i.call(t, n)
        }
    }, {
        25: 25
    }],
    96: [function(t, n, r) {
        "use strict";
        var e = t(44),
            i = RegExp.prototype.exec,
            o = String.prototype.replace,
            u = i,
            c = function() {
                var t = /a/,
                    n = /b*/g;
                return i.call(t, "a"), i.call(n, "a"), 0 !== t.lastIndex || 0 !== n.lastIndex
            }(),
            f = void 0 !== /()??/.exec("")[1];
        (c || f) && (u = function(t) {
            var n, r, u, a, s = this;
            return f && (r = new RegExp("^" + s.source + "$(?!\\s)", e.call(s))), c && (n = s.lastIndex), u = i.call(s, t), c && u && (s.lastIndex = s.global ? u.index + u[0].length : n), f && u && u.length > 1 && o.call(u[0], r, function() {
                for (a = 1; a < arguments.length - 2; a++) void 0 === arguments[a] && (u[a] = void 0)
            }), u
        }), n.exports = u
    }, {
        44: 44
    }],
    97: [function(t, n, r) {
        n.exports = Object.is || function(t, n) {
            return t === n ? 0 !== t || 1 / t == 1 / n : t != t && n != n
        }
    }, {}],
    98: [function(t, n, r) {
        var e = t(57),
            i = t(16),
            o = function(t, n) {
                if (i(t), !e(n) && null !== n) throw TypeError(n + ": can't set as prototype!")
            };
        n.exports = {
            set: Object.setPrototypeOf || ("__proto__" in {} ? function(n, r, e) {
                try {
                    (e = t(32)(Function.call, t(77).f(Object.prototype, "__proto__").set, 2))(n, []), r = !(n instanceof Array)
                } catch (t) {
                    r = !0
                }
                return function(t, n) {
                    return o(t, n), r ? t.__proto__ = n : e(t, n), t
                }
            }({}, !1) : void 0),
            check: o
        }
    }, {
        16: 16,
        32: 32,
        57: 57,
        77: 77
    }],
    99: [function(t, n, r) {
        "use strict";
        var e = t(46),
            i = t(75),
            o = t(36),
            u = t(128)("species");
        n.exports = function(t) {
            var n = e[t];
            o && n && !n[u] && i.f(n, u, {
                configurable: !0,
                get: function() {
                    return this
                }
            })
        }
    }, {
        128: 128,
        36: 36,
        46: 46,
        75: 75
    }],
    100: [function(t, n, r) {
        var e = t(75).f,
            i = t(47),
            o = t(128)("toStringTag");
        n.exports = function(t, n, r) {
            t && !i(t = r ? t : t.prototype, o) && e(t, o, {
                configurable: !0,
                value: n
            })
        }
    }, {
        128: 128,
        47: 47,
        75: 75
    }],
    101: [function(t, n, r) {
        var e = t(102)("keys"),
            i = t(123);
        n.exports = function(t) {
            return e[t] || (e[t] = i(t))
        }
    }, {
        102: 102,
        123: 123
    }],
    102: [function(t, n, r) {
        var e = t(30),
            i = t(46),
            o = i["__core-js_shared__"] || (i["__core-js_shared__"] = {});
        (n.exports = function(t, n) {
            return o[t] || (o[t] = void 0 !== n ? n : {})
        })("versions", []).push({
            version: e.version,
            mode: t(65) ? "pure" : "global",
            copyright: " 2018 Denis Pushkarev (zloirock.ru)"
        })
    }, {
        30: 30,
        46: 46,
        65: 65
    }],
    103: [function(t, n, r) {
        var e = t(16),
            i = t(11),
            o = t(128)("species");
        n.exports = function(t, n) {
            var r, u = e(t).constructor;
            return void 0 === u || null == (r = e(u)[o]) ? n : i(r)
        }
    }, {
        11: 11,
        128: 128,
        16: 16
    }],
    104: [function(t, n, r) {
        "use strict";
        var e = t(42);
        n.exports = function(t, n) {
            return !!t && e(function() {
                n ? t.call(null, function() {}, 1) : t.call(null)
            })
        }
    }, {
        42: 42
    }],
    105: [function(t, n, r) {
        var e = t(115),
            i = t(35);
        n.exports = function(t) {
            return function(n, r) {
                var o, u, c = String(i(n)),
                    f = e(r),
                    a = c.length;
                return f < 0 || f >= a ? t ? "" : void 0 : (o = c.charCodeAt(f)) < 55296 || o > 56319 || f + 1 === a || (u = c.charCodeAt(f + 1)) < 56320 || u > 57343 ? t ? c.charAt(f) : o : t ? c.slice(f, f + 2) : u - 56320 + (o - 55296 << 10) + 65536
            }
        }
    }, {
        115: 115,
        35: 35
    }],
    106: [function(t, n, r) {
        var e = t(58),
            i = t(35);
        n.exports = function(t, n, r) {
            if (e(n)) throw TypeError("String#" + r + " doesn't accept regex!");
            return String(i(t))
        }
    }, {
        35: 35,
        58: 58
    }],
    107: [function(t, n, r) {
        var e = t(40),
            i = t(42),
            o = t(35),
            u = /"/g,
            c = function(t, n, r, e) {
                var i = String(o(t)),
                    c = "<" + n;
                return "" !== r && (c += " " + r + '="' + String(e).replace(u, "&quot;") + '"'), c + ">" + i + "</" + n + ">"
            };
        n.exports = function(t, n) {
            var r = {};
            r[t] = n(c), e(e.P + e.F * i(function() {
                var n = "" [t]('"');
                return n !== n.toLowerCase() || n.split('"').length > 3
            }), "String", r)
        }
    }, {
        35: 35,
        40: 40,
        42: 42
    }],
    108: [function(t, n, r) {
        var e = t(117),
            i = t(109),
            o = t(35);
        n.exports = function(t, n, r, u) {
            var c = String(o(t)),
                f = c.length,
                a = void 0 === r ? " " : String(r),
                s = e(n);
            if (s <= f || "" == a) return c;
            var l = s - f,
                h = i.call(a, Math.ceil(l / a.length));
            return h.length > l && (h = h.slice(0, l)), u ? h + c : c + h
        }
    }, {
        109: 109,
        117: 117,
        35: 35
    }],
    109: [function(t, n, r) {
        "use strict";
        var e = t(115),
            i = t(35);
        n.exports = function(t) {
            var n = String(i(this)),
                r = "",
                o = e(t);
            if (o < 0 || o == 1 / 0) throw RangeError("Count can't be negative");
            for (; o > 0;
                (o >>>= 1) && (n += n)) 1 & o && (r += n);
            return r
        }
    }, {
        115: 115,
        35: 35
    }],
    110: [function(t, n, r) {
        var e = t(40),
            i = t(35),
            o = t(42),
            u = t(111),
            c = "[" + u + "]",
            f = RegExp("^" + c + c + "*"),
            a = RegExp(c + c + "*$"),
            s = function(t, n, r) {
                var i = {},
                    c = o(function() {
                        return !!u[t]() || "" != "" [t]()
                    }),
                    f = i[t] = c ? n(l) : u[t];
                r && (i[r] = f), e(e.P + e.F * c, "String", i)
            },
            l = s.trim = function(t, n) {
                return t = String(i(t)), 1 & n && (t = t.replace(f, "")), 2 & n && (t = t.replace(a, "")), t
            };
        n.exports = s
    }, {
        111: 111,
        35: 35,
        40: 40,
        42: 42
    }],
    111: [function(t, n, r) {
        n.exports = "\t\n\v\f\r \u2028\u2029\ufeff"
    }, {}],
    112: [function(t, n, r) {
        var e, i, o, u = t(32),
            c = t(52),
            f = t(49),
            a = t(37),
            s = t(46),
            l = s.process,
            h = s.setImmediate,
            v = s.clearImmediate,
            p = s.MessageChannel,
            g = s.Dispatch,
            y = 0,
            d = {},
            x = function() {
                var t = +this;
                if (d.hasOwnProperty(t)) {
                    var n = d[t];
                    delete d[t], n()
                }
            },
            m = function(t) {
                x.call(t.data)
            };
        h && v || (h = function(t) {
            for (var n = [], r = 1; arguments.length > r;) n.push(arguments[r++]);
            return d[++y] = function() {
                c("function" == typeof t ? t : Function(t), n)
            }, e(y), y
        }, v = function(t) {
            delete d[t]
        }, "process" == t(26)(l) ? e = function(t) {
            l.nextTick(u(x, t, 1))
        } : g && g.now ? e = function(t) {
            g.now(u(x, t, 1))
        } : p ? (o = (i = new p).port2, i.port1.onmessage = m, e = u(o.postMessage, o, 1)) : s.addEventListener && "function" == typeof postMessage && !s.importScripts ? (e = function(t) {
            s.postMessage(t + "", "*")
        }, s.addEventListener("message", m, !1)) : e = "onreadystatechange" in a("script") ? function(t) {
            f.appendChild(a("script")).onreadystatechange = function() {
                f.removeChild(this), x.call(t)
            }
        } : function(t) {
            setTimeout(u(x, t, 1), 0)
        }), n.exports = {
            set: h,
            clear: v
        }
    }, {
        26: 26,
        32: 32,
        37: 37,
        46: 46,
        49: 49,
        52: 52
    }],
    113: [function(t, n, r) {
        var e = t(115),
            i = Math.max,
            o = Math.min;
        n.exports = function(t, n) {
            return (t = e(t)) < 0 ? i(t + n, 0) : o(t, n)
        }
    }, {
        115: 115
    }],
    114: [function(t, n, r) {
        var e = t(115),
            i = t(117);
        n.exports = function(t) {
            if (void 0 === t) return 0;
            var n = e(t),
                r = i(n);
            if (n !== r) throw RangeError("Wrong length!");
            return r
        }
    }, {
        115: 115,
        117: 117
    }],
    115: [function(t, n, r) {
        var e = Math.ceil,
            i = Math.floor;
        n.exports = function(t) {
            return isNaN(t = +t) ? 0 : (t > 0 ? i : e)(t)
        }
    }, {}],
    116: [function(t, n, r) {
        var e = t(53),
            i = t(35);
        n.exports = function(t) {
            return e(i(t))
        }
    }, {
        35: 35,
        53: 53
    }],
    117: [function(t, n, r) {
        var e = t(115),
            i = Math.min;
        n.exports = function(t) {
            return t > 0 ? i(e(t), 9007199254740991) : 0
        }
    }, {
        115: 115
    }],
    118: [function(t, n, r) {
        var e = t(35);
        n.exports = function(t) {
            return Object(e(t))
        }
    }, {
        35: 35
    }],
    119: [function(t, n, r) {
        var e = t(57);
        n.exports = function(t, n) {
            if (!e(t)) return t;
            var r, i;
            if (n && "function" == typeof(r = t.toString) && !e(i = r.call(t))) return i;
            if ("function" == typeof(r = t.valueOf) && !e(i = r.call(t))) return i;
            if (!n && "function" == typeof(r = t.toString) && !e(i = r.call(t))) return i;
            throw TypeError("Can't convert object to primitive value")
        }
    }, {
        57: 57
    }],
    120: [function(t, n, r) {
        "use strict";
        if (t(36)) {
            var e = t(65),
                i = t(46),
                o = t(42),
                u = t(40),
                c = t(122),
                f = t(121),
                a = t(32),
                s = t(15),
                l = t(92),
                h = t(48),
                v = t(93),
                p = t(115),
                g = t(117),
                y = t(114),
                d = t(113),
                x = t(119),
                m = t(47),
                b = t(25),
                S = t(57),
                w = t(118),
                _ = t(54),
                E = t(74),
                O = t(81),
                F = t(79).f,
                P = t(129),
                M = t(123),
                A = t(128),
                I = t(20),
                j = t(19),
                N = t(103),
                T = t(140),
                L = t(64),
                R = t(62),
                k = t(99),
                D = t(18),
                C = t(17),
                W = t(75),
                U = t(77),
                V = W.f,
                B = U.f,
                G = i.RangeError,
                z = i.TypeError,
                q = i.Uint8Array,
                Y = Array.prototype,
                $ = f.ArrayBuffer,
                K = f.DataView,
                J = I(0),
                H = I(2),
                X = I(3),
                Z = I(4),
                Q = I(5),
                tt = I(6),
                nt = j(!0),
                rt = j(!1),
                et = T.values,
                it = T.keys,
                ot = T.entries,
                ut = Y.lastIndexOf,
                ct = Y.reduce,
                ft = Y.reduceRight,
                at = Y.join,
                st = Y.sort,
                lt = Y.slice,
                ht = Y.toString,
                vt = Y.toLocaleString,
                pt = A("iterator"),
                gt = A("toStringTag"),
                yt = M("typed_constructor"),
                dt = M("def_constructor"),
                xt = c.CONSTR,
                mt = c.TYPED,
                bt = c.VIEW,
                St = I(1, function(t, n) {
                    return Ft(N(t, t[dt]), n)
                }),
                wt = o(function() {
                    return 1 === new q(new Uint16Array([1]).buffer)[0]
                }),
                _t = !!q && !!q.prototype.set && o(function() {
                    new q(1).set({})
                }),
                Et = function(t, n) {
                    var r = p(t);
                    if (r < 0 || r % n) throw G("Wrong offset!");
                    return r
                },
                Ot = function(t) {
                    if (S(t) && mt in t) return t;
                    throw z(t + " is not a typed array!")
                },
                Ft = function(t, n) {
                    if (!(S(t) && yt in t)) throw z("It is not a typed array constructor!");
                    return new t(n)
                },
                Pt = function(t, n) {
                    return Mt(N(t, t[dt]), n)
                },
                Mt = function(t, n) {
                    for (var r = 0, e = n.length, i = Ft(t, e); e > r;) i[r] = n[r++];
                    return i
                },
                At = function(t, n, r) {
                    V(t, n, {
                        get: function() {
                            return this._d[r]
                        }
                    })
                },
                It = function(t) {
                    var n, r, e, i, o, u, c = w(t),
                        f = arguments.length,
                        s = f > 1 ? arguments[1] : void 0,
                        l = void 0 !== s,
                        h = P(c);
                    if (null != h && !_(h)) {
                        for (u = h.call(c), e = [], n = 0; !(o = u.next()).done; n++) e.push(o.value);
                        c = e
                    }
                    for (l && f > 2 && (s = a(s, arguments[2], 2)), n = 0, r = g(c.length), i = Ft(this, r); r > n; n++) i[n] = l ? s(c[n], n) : c[n];
                    return i
                },
                jt = function() {
                    for (var t = 0, n = arguments.length, r = Ft(this, n); n > t;) r[t] = arguments[t++];
                    return r
                },
                Nt = !!q && o(function() {
                    vt.call(new q(1))
                }),
                Tt = function() {
                    return vt.apply(Nt ? lt.call(Ot(this)) : Ot(this), arguments)
                },
                Lt = {
                    copyWithin: function(t, n) {
                        return C.call(Ot(this), t, n, arguments.length > 2 ? arguments[2] : void 0)
                    },
                    every: function(t) {
                        return Z(Ot(this), t, arguments.length > 1 ? arguments[1] : void 0)
                    },
                    fill: function(t) {
                        return D.apply(Ot(this), arguments)
                    },
                    filter: function(t) {
                        return Pt(this, H(Ot(this), t, arguments.length > 1 ? arguments[1] : void 0))
                    },
                    find: function(t) {
                        return Q(Ot(this), t, arguments.length > 1 ? arguments[1] : void 0)
                    },
                    findIndex: function(t) {
                        return tt(Ot(this), t, arguments.length > 1 ? arguments[1] : void 0)
                    },
                    forEach: function(t) {
                        J(Ot(this), t, arguments.length > 1 ? arguments[1] : void 0)
                    },
                    indexOf: function(t) {
                        return rt(Ot(this), t, arguments.length > 1 ? arguments[1] : void 0)
                    },
                    includes: function(t) {
                        return nt(Ot(this), t, arguments.length > 1 ? arguments[1] : void 0)
                    },
                    join: function(t) {
                        return at.apply(Ot(this), arguments)
                    },
                    lastIndexOf: function(t) {
                        return ut.apply(Ot(this), arguments)
                    },
                    map: function(t) {
                        return St(Ot(this), t, arguments.length > 1 ? arguments[1] : void 0)
                    },
                    reduce: function(t) {
                        return ct.apply(Ot(this), arguments)
                    },
                    reduceRight: function(t) {
                        return ft.apply(Ot(this), arguments)
                    },
                    reverse: function() {
                        for (var t, n = this, r = Ot(n).length, e = Math.floor(r / 2), i = 0; i < e;) t = n[i], n[i++] = n[--r], n[r] = t;
                        return n
                    },
                    some: function(t) {
                        return X(Ot(this), t, arguments.length > 1 ? arguments[1] : void 0)
                    },
                    sort: function(t) {
                        return st.call(Ot(this), t)
                    },
                    subarray: function(t, n) {
                        var r = Ot(this),
                            e = r.length,
                            i = d(t, e);
                        return new(N(r, r[dt]))(r.buffer, r.byteOffset + i * r.BYTES_PER_ELEMENT, g((void 0 === n ? e : d(n, e)) - i))
                    }
                },
                Rt = function(t, n) {
                    return Pt(this, lt.call(Ot(this), t, n))
                },
                kt = function(t) {
                    Ot(this);
                    var n = Et(arguments[1], 1),
                        r = this.length,
                        e = w(t),
                        i = g(e.length),
                        o = 0;
                    if (i + n > r) throw G("Wrong length!");
                    for (; o < i;) this[n + o] = e[o++]
                },
                Dt = {
                    entries: function() {
                        return ot.call(Ot(this))
                    },
                    keys: function() {
                        return it.call(Ot(this))
                    },
                    values: function() {
                        return et.call(Ot(this))
                    }
                },
                Ct = function(t, n) {
                    return S(t) && t[mt] && "symbol" != typeof n && n in t && String(+n) == String(n)
                },
                Wt = function(t, n) {
                    return Ct(t, n = x(n, !0)) ? l(2, t[n]) : B(t, n)
                },
                Ut = function(t, n, r) {
                    return !(Ct(t, n = x(n, !0)) && S(r) && m(r, "value")) || m(r, "get") || m(r, "set") || r.configurable || m(r, "writable") && !r.writable || m(r, "enumerable") && !r.enumerable ? V(t, n, r) : (t[n] = r.value, t)
                };
            xt || (U.f = Wt, W.f = Ut), u(u.S + u.F * !xt, "Object", {
                getOwnPropertyDescriptor: Wt,
                defineProperty: Ut
            }), o(function() {
                ht.call({})
            }) && (ht = vt = function() {
                return at.call(this)
            });
            var Vt = v({}, Lt);
            v(Vt, Dt), h(Vt, pt, Dt.values), v(Vt, {
                slice: Rt,
                set: kt,
                constructor: function() {},
                toString: ht,
                toLocaleString: Tt
            }), At(Vt, "buffer", "b"), At(Vt, "byteOffset", "o"), At(Vt, "byteLength", "l"), At(Vt, "length", "e"), V(Vt, gt, {
                get: function() {
                    return this[mt]
                }
            }), n.exports = function(t, n, r, f) {
                var a = t + ((f = !!f) ? "Clamped" : "") + "Array",
                    l = "get" + t,
                    v = "set" + t,
                    p = i[a],
                    d = p || {},
                    x = p && O(p),
                    m = !p || !c.ABV,
                    w = {},
                    _ = p && p.prototype,
                    P = function(t, r) {
                        var e = t._d;
                        return e.v[l](r * n + e.o, wt)
                    },
                    M = function(t, r, e) {
                        var i = t._d;
                        f && (e = (e = Math.round(e)) < 0 ? 0 : e > 255 ? 255 : 255 & e), i.v[v](r * n + i.o, e, wt)
                    },
                    A = function(t, n) {
                        V(t, n, {
                            get: function() {
                                return P(this, n)
                            },
                            set: function(t) {
                                return M(this, n, t)
                            },
                            enumerable: !0
                        })
                    };
                m ? (p = r(function(t, r, e, i) {
                    s(t, p, a, "_d");
                    var o, u, c, f, l = 0,
                        v = 0;
                    if (S(r)) {
                        if (!(r instanceof $ || "ArrayBuffer" == (f = b(r)) || "SharedArrayBuffer" == f)) return mt in r ? Mt(p, r) : It.call(p, r);
                        o = r, v = Et(e, n);
                        var d = r.byteLength;
                        if (void 0 === i) {
                            if (d % n) throw G("Wrong length!");
                            if ((u = d - v) < 0) throw G("Wrong length!")
                        } else if ((u = g(i) * n) + v > d) throw G("Wrong length!");
                        c = u / n
                    } else c = y(r), o = new $(u = c * n);
                    for (h(t, "_d", {
                            b: o,
                            o: v,
                            l: u,
                            e: c,
                            v: new K(o)
                        }); l < c;) A(t, l++)
                }), _ = p.prototype = E(Vt), h(_, "constructor", p)) : o(function() {
                    p(1)
                }) && o(function() {
                    new p(-1)
                }) && R(function(t) {
                    new p, new p(null), new p(1.5), new p(t)
                }, !0) || (p = r(function(t, r, e, i) {
                    var o;
                    return s(t, p, a), S(r) ? r instanceof $ || "ArrayBuffer" == (o = b(r)) || "SharedArrayBuffer" == o ? void 0 !== i ? new d(r, Et(e, n), i) : void 0 !== e ? new d(r, Et(e, n)) : new d(r) : mt in r ? Mt(p, r) : It.call(p, r) : new d(y(r))
                }), J(x !== Function.prototype ? F(d).concat(F(x)) : F(d), function(t) {
                    t in p || h(p, t, d[t])
                }), p.prototype = _, e || (_.constructor = p));
                var I = _[pt],
                    j = !!I && ("values" == I.name || null == I.name),
                    N = Dt.values;
                h(p, yt, !0), h(_, mt, a), h(_, bt, !0), h(_, dt, p), (f ? new p(1)[gt] == a : gt in _) || V(_, gt, {
                    get: function() {
                        return a
                    }
                }), w[a] = p, u(u.G + u.W + u.F * (p != d), w), u(u.S, a, {
                    BYTES_PER_ELEMENT: n
                }), u(u.S + u.F * o(function() {
                    d.of.call(p, 1)
                }), a, {
                    from: It,
                    of: jt
                }), "BYTES_PER_ELEMENT" in _ || h(_, "BYTES_PER_ELEMENT", n), u(u.P, a, Lt), k(a), u(u.P + u.F * _t, a, {
                    set: kt
                }), u(u.P + u.F * !j, a, Dt), e || _.toString == ht || (_.toString = ht), u(u.P + u.F * o(function() {
                    new p(1).slice()
                }), a, {
                    slice: Rt
                }), u(u.P + u.F * (o(function() {
                    return [1, 2].toLocaleString() != new p([1, 2]).toLocaleString()
                }) || !o(function() {
                    _.toLocaleString.call([1, 2])
                })), a, {
                    toLocaleString: Tt
                }), L[a] = j ? I : N, e || j || h(_, pt, N)
            }
        } else n.exports = function() {}
    }, {
        103: 103,
        113: 113,
        114: 114,
        115: 115,
        117: 117,
        118: 118,
        119: 119,
        121: 121,
        122: 122,
        123: 123,
        128: 128,
        129: 129,
        140: 140,
        15: 15,
        17: 17,
        18: 18,
        19: 19,
        20: 20,
        25: 25,
        32: 32,
        36: 36,
        40: 40,
        42: 42,
        46: 46,
        47: 47,
        48: 48,
        54: 54,
        57: 57,
        62: 62,
        64: 64,
        65: 65,
        74: 74,
        75: 75,
        77: 77,
        79: 79,
        81: 81,
        92: 92,
        93: 93,
        99: 99
    }],
    121: [function(t, n, r) {
        "use strict";

        function e(t, n, r) {
            var e, i, o, u = new Array(r),
                c = 8 * r - n - 1,
                f = (1 << c) - 1,
                a = f >> 1,
                s = 23 === n ? C(2, -24) - C(2, -77) : 0,
                l = 0,
                h = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;
            for ((t = D(t)) != t || t === R ? (i = t != t ? 1 : 0, e = f) : (e = W(U(t) / V), t * (o = C(2, -e)) < 1 && (e--, o *= 2), (t += e + a >= 1 ? s / o : s * C(2, 1 - a)) * o >= 2 && (e++, o /= 2), e + a >= f ? (i = 0, e = f) : e + a >= 1 ? (i = (t * o - 1) * C(2, n), e += a) : (i = t * C(2, a - 1) * C(2, n), e = 0)); n >= 8; u[l++] = 255 & i, i /= 256, n -= 8);
            for (e = e << n | i, c += n; c > 0; u[l++] = 255 & e, e /= 256, c -= 8);
            return u[--l] |= 128 * h, u
        }

        function i(t, n, r) {
            var e, i = 8 * r - n - 1,
                o = (1 << i) - 1,
                u = o >> 1,
                c = i - 7,
                f = r - 1,
                a = t[f--],
                s = 127 & a;
            for (a >>= 7; c > 0; s = 256 * s + t[f], f--, c -= 8);
            for (e = s & (1 << -c) - 1, s >>= -c, c += n; c > 0; e = 256 * e + t[f], f--, c -= 8);
            if (0 === s) s = 1 - u;
            else {
                if (s === o) return e ? NaN : a ? -R : R;
                e += C(2, n), s -= u
            }
            return (a ? -1 : 1) * e * C(2, s - n)
        }

        function o(t) {
            return t[3] << 24 | t[2] << 16 | t[1] << 8 | t[0]
        }

        function u(t) {
            return [255 & t]
        }

        function c(t) {
            return [255 & t, t >> 8 & 255]
        }

        function f(t) {
            return [255 & t, t >> 8 & 255, t >> 16 & 255, t >> 24 & 255]
        }

        function a(t) {
            return e(t, 52, 8)
        }

        function s(t) {
            return e(t, 23, 4)
        }

        function l(t, n, r) {
            F(t[A], n, {
                get: function() {
                    return this[r]
                }
            })
        }

        function h(t, n, r, e) {
            var i = E(+r);
            if (i + n > t[G]) throw L(I);
            var o = t[B]._b,
                u = i + t[z],
                c = o.slice(u, u + n);
            return e ? c : c.reverse()
        }

        function v(t, n, r, e, i, o) {
            var u = E(+r);
            if (u + n > t[G]) throw L(I);
            for (var c = t[B]._b, f = u + t[z], a = e(+i), s = 0; s < n; s++) c[f + s] = a[o ? s : n - s - 1]
        }
        var p = t(46),
            g = t(36),
            y = t(65),
            d = t(122),
            x = t(48),
            m = t(93),
            b = t(42),
            S = t(15),
            w = t(115),
            _ = t(117),
            E = t(114),
            O = t(79).f,
            F = t(75).f,
            P = t(18),
            M = t(100),
            A = "prototype",
            I = "Wrong index!",
            j = p.ArrayBuffer,
            N = p.DataView,
            T = p.Math,
            L = p.RangeError,
            R = p.Infinity,
            k = j,
            D = T.abs,
            C = T.pow,
            W = T.floor,
            U = T.log,
            V = T.LN2,
            B = g ? "_b" : "buffer",
            G = g ? "_l" : "byteLength",
            z = g ? "_o" : "byteOffset";
        if (d.ABV) {
            if (!b(function() {
                    j(1)
                }) || !b(function() {
                    new j(-1)
                }) || b(function() {
                    return new j, new j(1.5), new j(NaN), "ArrayBuffer" != j.name
                })) {
                for (var q, Y = (j = function(t) {
                        return S(this, j), new k(E(t))
                    })[A] = k[A], $ = O(k), K = 0; $.length > K;)(q = $[K++]) in j || x(j, q, k[q]);
                y || (Y.constructor = j)
            }
            var J = new N(new j(2)),
                H = N[A].setInt8;
            J.setInt8(0, 2147483648), J.setInt8(1, 2147483649), !J.getInt8(0) && J.getInt8(1) || m(N[A], {
                setInt8: function(t, n) {
                    H.call(this, t, n << 24 >> 24)
                },
                setUint8: function(t, n) {
                    H.call(this, t, n << 24 >> 24)
                }
            }, !0)
        } else j = function(t) {
            S(this, j, "ArrayBuffer");
            var n = E(t);
            this._b = P.call(new Array(n), 0), this[G] = n
        }, N = function(t, n, r) {
            S(this, N, "DataView"), S(t, j, "DataView");
            var e = t[G],
                i = w(n);
            if (i < 0 || i > e) throw L("Wrong offset!");
            if (i + (r = void 0 === r ? e - i : _(r)) > e) throw L("Wrong length!");
            this[B] = t, this[z] = i, this[G] = r
        }, g && (l(j, "byteLength", "_l"), l(N, "buffer", "_b"), l(N, "byteLength", "_l"), l(N, "byteOffset", "_o")), m(N[A], {
            getInt8: function(t) {
                return h(this, 1, t)[0] << 24 >> 24
            },
            getUint8: function(t) {
                return h(this, 1, t)[0]
            },
            getInt16: function(t) {
                var n = h(this, 2, t, arguments[1]);
                return (n[1] << 8 | n[0]) << 16 >> 16
            },
            getUint16: function(t) {
                var n = h(this, 2, t, arguments[1]);
                return n[1] << 8 | n[0]
            },
            getInt32: function(t) {
                return o(h(this, 4, t, arguments[1]))
            },
            getUint32: function(t) {
                return o(h(this, 4, t, arguments[1])) >>> 0
            },
            getFloat32: function(t) {
                return i(h(this, 4, t, arguments[1]), 23, 4)
            },
            getFloat64: function(t) {
                return i(h(this, 8, t, arguments[1]), 52, 8)
            },
            setInt8: function(t, n) {
                v(this, 1, t, u, n)
            },
            setUint8: function(t, n) {
                v(this, 1, t, u, n)
            },
            setInt16: function(t, n) {
                v(this, 2, t, c, n, arguments[2])
            },
            setUint16: function(t, n) {
                v(this, 2, t, c, n, arguments[2])
            },
            setInt32: function(t, n) {
                v(this, 4, t, f, n, arguments[2])
            },
            setUint32: function(t, n) {
                v(this, 4, t, f, n, arguments[2])
            },
            setFloat32: function(t, n) {
                v(this, 4, t, s, n, arguments[2])
            },
            setFloat64: function(t, n) {
                v(this, 8, t, a, n, arguments[2])
            }
        });
        M(j, "ArrayBuffer"), M(N, "DataView"), x(N[A], d.VIEW, !0), r.ArrayBuffer = j, r.DataView = N
    }, {
        100: 100,
        114: 114,
        115: 115,
        117: 117,
        122: 122,
        15: 15,
        18: 18,
        36: 36,
        42: 42,
        46: 46,
        48: 48,
        65: 65,
        75: 75,
        79: 79,
        93: 93
    }],
    122: [function(t, n, r) {
        for (var e, i = t(46), o = t(48), u = t(123), c = u("typed_array"), f = u("view"), a = !(!i.ArrayBuffer || !i.DataView), s = a, l = 0, h = "Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(","); l < 9;)(e = i[h[l++]]) ? (o(e.prototype, c, !0), o(e.prototype, f, !0)) : s = !1;
        n.exports = {
            ABV: a,
            CONSTR: s,
            TYPED: c,
            VIEW: f
        }
    }, {
        123: 123,
        46: 46,
        48: 48
    }],
    123: [function(t, n, r) {
        var e = 0,
            i = Math.random();
        n.exports = function(t) {
            return "Symbol(".concat(void 0 === t ? "" : t, ")_", (++e + i).toString(36))
        }
    }, {}],
    124: [function(t, n, r) {
        var e = t(46).navigator;
        n.exports = e && e.userAgent || ""
    }, {
        46: 46
    }],
    125: [function(t, n, r) {
        var e = t(57);
        n.exports = function(t, n) {
            if (!e(t) || t._t !== n) throw TypeError("Incompatible receiver, " + n + " required!");
            return t
        }
    }, {
        57: 57
    }],
    126: [function(t, n, r) {
        var e = t(46),
            i = t(30),
            o = t(65),
            u = t(127),
            c = t(75).f;
        n.exports = function(t) {
            var n = i.Symbol || (i.Symbol = o ? {} : e.Symbol || {});
            "_" == t.charAt(0) || t in n || c(n, t, {
                value: u.f(t)
            })
        }
    }, {
        127: 127,
        30: 30,
        46: 46,
        65: 65,
        75: 75
    }],
    127: [function(t, n, r) {
        r.f = t(128)
    }, {
        128: 128
    }],
    128: [function(t, n, r) {
        var e = t(102)("wks"),
            i = t(123),
            o = t(46).Symbol,
            u = "function" == typeof o;
        (n.exports = function(t) {
            return e[t] || (e[t] = u && o[t] || (u ? o : i)("Symbol." + t))
        }).store = e
    }, {
        102: 102,
        123: 123,
        46: 46
    }],
    129: [function(t, n, r) {
        var e = t(25),
            i = t(128)("iterator"),
            o = t(64);
        n.exports = t(30).getIteratorMethod = function(t) {
            if (null != t) return t[i] || t["@@iterator"] || o[e(t)]
        }
    }, {
        128: 128,
        25: 25,
        30: 30,
        64: 64
    }],
    130: [function(t, n, r) {
        var e = t(40);
        e(e.P, "Array", {
            copyWithin: t(17)
        }), t(13)("copyWithin")
    }, {
        13: 13,
        17: 17,
        40: 40
    }],
    131: [function(t, n, r) {
        "use strict";
        var e = t(40),
            i = t(20)(4);
        e(e.P + e.F * !t(104)([].every, !0), "Array", {
            every: function(t) {
                return i(this, t, arguments[1])
            }
        })
    }, {
        104: 104,
        20: 20,
        40: 40
    }],
    132: [function(t, n, r) {
        var e = t(40);
        e(e.P, "Array", {
            fill: t(18)
        }), t(13)("fill")
    }, {
        13: 13,
        18: 18,
        40: 40
    }],
    133: [function(t, n, r) {
        "use strict";
        var e = t(40),
            i = t(20)(2);
        e(e.P + e.F * !t(104)([].filter, !0), "Array", {
            filter: function(t) {
                return i(this, t, arguments[1])
            }
        })
    }, {
        104: 104,
        20: 20,
        40: 40
    }],
    134: [function(t, n, r) {
        "use strict";
        var e = t(40),
            i = t(20)(6),
            o = "findIndex",
            u = !0;
        o in [] && Array(1)[o](function() {
            u = !1
        }), e(e.P + e.F * u, "Array", {
            findIndex: function(t) {
                return i(this, t, arguments.length > 1 ? arguments[1] : void 0)
            }
        }), t(13)(o)
    }, {
        13: 13,
        20: 20,
        40: 40
    }],
    135: [function(t, n, r) {
        "use strict";
        var e = t(40),
            i = t(20)(5),
            o = !0;
        "find" in [] && Array(1).find(function() {
            o = !1
        }), e(e.P + e.F * o, "Array", {
            find: function(t) {
                return i(this, t, arguments.length > 1 ? arguments[1] : void 0)
            }
        }), t(13)("find")
    }, {
        13: 13,
        20: 20,
        40: 40
    }],
    136: [function(t, n, r) {
        "use strict";
        var e = t(40),
            i = t(20)(0),
            o = t(104)([].forEach, !0);
        e(e.P + e.F * !o, "Array", {
            forEach: function(t) {
                return i(this, t, arguments[1])
            }
        })
    }, {
        104: 104,
        20: 20,
        40: 40
    }],
    137: [function(t, n, r) {
        "use strict";
        var e = t(32),
            i = t(40),
            o = t(118),
            u = t(59),
            c = t(54),
            f = t(117),
            a = t(31),
            s = t(129);
        i(i.S + i.F * !t(62)(function(t) {
            Array.from(t)
        }), "Array", {
            from: function(t) {
                var n, r, i, l, h = o(t),
                    v = "function" == typeof this ? this : Array,
                    p = arguments.length,
                    g = p > 1 ? arguments[1] : void 0,
                    y = void 0 !== g,
                    d = 0,
                    x = s(h);
                if (y && (g = e(g, p > 2 ? arguments[2] : void 0, 2)), null == x || v == Array && c(x))
                    for (r = new v(n = f(h.length)); n > d; d++) a(r, d, y ? g(h[d], d) : h[d]);
                else
                    for (l = x.call(h), r = new v; !(i = l.next()).done; d++) a(r, d, y ? u(l, g, [i.value, d], !0) : i.value);
                return r.length = d, r
            }
        })
    }, {
        117: 117,
        118: 118,
        129: 129,
        31: 31,
        32: 32,
        40: 40,
        54: 54,
        59: 59,
        62: 62
    }],
    138: [function(t, n, r) {
        "use strict";
        var e = t(40),
            i = t(19)(!1),
            o = [].indexOf,
            u = !!o && 1 / [1].indexOf(1, -0) < 0;
        e(e.P + e.F * (u || !t(104)(o)), "Array", {
            indexOf: function(t) {
                return u ? o.apply(this, arguments) || 0 : i(this, t, arguments[1])
            }
        })
    }, {
        104: 104,
        19: 19,
        40: 40
    }],
    139: [function(t, n, r) {
        var e = t(40);
        e(e.S, "Array", {
            isArray: t(55)
        })
    }, {
        40: 40,
        55: 55
    }],
    140: [function(t, n, r) {
        "use strict";
        var e = t(13),
            i = t(63),
            o = t(64),
            u = t(116);
        n.exports = t(61)(Array, "Array", function(t, n) {
            this._t = u(t), this._i = 0, this._k = n
        }, function() {
            var t = this._t,
                n = this._k,
                r = this._i++;
            return !t || r >= t.length ? (this._t = void 0, i(1)) : i(0, "keys" == n ? r : "values" == n ? t[r] : [r, t[r]])
        }, "values"), o.Arguments = o.Array, e("keys"), e("values"), e("entries")
    }, {
        116: 116,
        13: 13,
        61: 61,
        63: 63,
        64: 64
    }],
    141: [function(t, n, r) {
        "use strict";
        var e = t(40),
            i = t(116),
            o = [].join;
        e(e.P + e.F * (t(53) != Object || !t(104)(o)), "Array", {
            join: function(t) {
                return o.call(i(this), void 0 === t ? "," : t)
            }
        })
    }, {
        104: 104,
        116: 116,
        40: 40,
        53: 53
    }],
    142: [function(t, n, r) {
        "use strict";
        var e = t(40),
            i = t(116),
            o = t(115),
            u = t(117),
            c = [].lastIndexOf,
            f = !!c && 1 / [1].lastIndexOf(1, -0) < 0;
        e(e.P + e.F * (f || !t(104)(c)), "Array", {
            lastIndexOf: function(t) {
                if (f) return c.apply(this, arguments) || 0;
                var n = i(this),
                    r = u(n.length),
                    e = r - 1;
                for (arguments.length > 1 && (e = Math.min(e, o(arguments[1]))), e < 0 && (e = r + e); e >= 0; e--)
                    if (e in n && n[e] === t) return e || 0;
                return -1
            }
        })
    }, {
        104: 104,
        115: 115,
        116: 116,
        117: 117,
        40: 40
    }],
    143: [function(t, n, r) {
        "use strict";
        var e = t(40),
            i = t(20)(1);
        e(e.P + e.F * !t(104)([].map, !0), "Array", {
            map: function(t) {
                return i(this, t, arguments[1])
            }
        })
    }, {
        104: 104,
        20: 20,
        40: 40
    }],
    144: [function(t, n, r) {
        "use strict";
        var e = t(40),
            i = t(31);
        e(e.S + e.F * t(42)(function() {
            function t() {}
            return !(Array.of.call(t) instanceof t)
        }), "Array", { of: function() {
                for (var t = 0, n = arguments.length, r = new("function" == typeof this ? this : Array)(n); n > t;) i(r, t, arguments[t++]);
                return r.length = n, r
            }
        })
    }, {
        31: 31,
        40: 40,
        42: 42
    }],
    145: [function(t, n, r) {
        "use strict";
        var e = t(40),
            i = t(21);
        e(e.P + e.F * !t(104)([].reduceRight, !0), "Array", {
            reduceRight: function(t) {
                return i(this, t, arguments.length, arguments[1], !0)
            }
        })
    }, {
        104: 104,
        21: 21,
        40: 40
    }],
    146: [function(t, n, r) {
        "use strict";
        var e = t(40),
            i = t(21);
        e(e.P + e.F * !t(104)([].reduce, !0), "Array", {
            reduce: function(t) {
                return i(this, t, arguments.length, arguments[1], !1)
            }
        })
    }, {
        104: 104,
        21: 21,
        40: 40
    }],
    147: [function(t, n, r) {
        "use strict";
        var e = t(40),
            i = t(49),
            o = t(26),
            u = t(113),
            c = t(117),
            f = [].slice;
        e(e.P + e.F * t(42)(function() {
            i && f.call(i)
        }), "Array", {
            slice: function(t, n) {
                var r = c(this.length),
                    e = o(this);
                if (n = void 0 === n ? r : n, "Array" == e) return f.call(this, t, n);
                for (var i = u(t, r), a = u(n, r), s = c(a - i), l = new Array(s), h = 0; h < s; h++) l[h] = "String" == e ? this.charAt(i + h) : this[i + h];
                return l
            }
        })
    }, {
        113: 113,
        117: 117,
        26: 26,
        40: 40,
        42: 42,
        49: 49
    }],
    148: [function(t, n, r) {
        "use strict";
        var e = t(40),
            i = t(20)(3);
        e(e.P + e.F * !t(104)([].some, !0), "Array", {
            some: function(t) {
                return i(this, t, arguments[1])
            }
        })
    }, {
        104: 104,
        20: 20,
        40: 40
    }],
    149: [function(t, n, r) {
        "use strict";
        var e = t(40),
            i = t(11),
            o = t(118),
            u = t(42),
            c = [].sort,
            f = [1, 2, 3];
        e(e.P + e.F * (u(function() {
            f.sort(void 0)
        }) || !u(function() {
            f.sort(null)
        }) || !t(104)(c)), "Array", {
            sort: function(t) {
                return void 0 === t ? c.call(o(this)) : c.call(o(this), i(t))
            }
        })
    }, {
        104: 104,
        11: 11,
        118: 118,
        40: 40,
        42: 42
    }],
    150: [function(t, n, r) {
        t(99)("Array")
    }, {
        99: 99
    }],
    151: [function(t, n, r) {
        var e = t(40);
        e(e.S, "Date", {
            now: function() {
                return (new Date).getTime()
            }
        })
    }, {
        40: 40
    }],
    152: [function(t, n, r) {
        var e = t(40),
            i = t(33);
        e(e.P + e.F * (Date.prototype.toISOString !== i), "Date", {
            toISOString: i
        })
    }, {
        33: 33,
        40: 40
    }],
    153: [function(t, n, r) {
        "use strict";
        var e = t(40),
            i = t(118),
            o = t(119);
        e(e.P + e.F * t(42)(function() {
            return null !== new Date(NaN).toJSON() || 1 !== Date.prototype.toJSON.call({
                toISOString: function() {
                    return 1
                }
            })
        }), "Date", {
            toJSON: function(t) {
                var n = i(this),
                    r = o(n);
                return "number" != typeof r || isFinite(r) ? n.toISOString() : null
            }
        })
    }, {
        118: 118,
        119: 119,
        40: 40,
        42: 42
    }],
    154: [function(t, n, r) {
        var e = t(128)("toPrimitive"),
            i = Date.prototype;
        e in i || t(48)(i, e, t(34))
    }, {
        128: 128,
        34: 34,
        48: 48
    }],
    155: [function(t, n, r) {
        var e = Date.prototype,
            i = e.toString,
            o = e.getTime;
        new Date(NaN) + "" != "Invalid Date" && t(94)(e, "toString", function() {
            var t = o.call(this);
            return t == t ? i.call(this) : "Invalid Date"
        })
    }, {
        94: 94
    }],
    156: [function(t, n, r) {
        var e = t(40);
        e(e.P, "Function", {
            bind: t(24)
        })
    }, {
        24: 24,
        40: 40
    }],
    157: [function(t, n, r) {
        "use strict";
        var e = t(57),
            i = t(81),
            o = t(128)("hasInstance"),
            u = Function.prototype;
        o in u || t(75).f(u, o, {
            value: function(t) {
                if ("function" != typeof this || !e(t)) return !1;
                if (!e(this.prototype)) return t instanceof this;
                for (; t = i(t);)
                    if (this.prototype === t) return !0;
                return !1
            }
        })
    }, {
        128: 128,
        57: 57,
        75: 75,
        81: 81
    }],
    158: [function(t, n, r) {
        var e = t(75).f,
            i = Function.prototype,
            o = /^\s*function ([^ (]*)/;
        "name" in i || t(36) && e(i, "name", {
            configurable: !0,
            get: function() {
                try {
                    return ("" + this).match(o)[1]
                } catch (t) {
                    return ""
                }
            }
        })
    }, {
        36: 36,
        75: 75
    }],
    159: [function(t, n, r) {
        "use strict";
        var e = t(27),
            i = t(125);
        n.exports = t(29)("Map", function(t) {
            return function() {
                return t(this, arguments.length > 0 ? arguments[0] : void 0)
            }
        }, {
            get: function(t) {
                var n = e.getEntry(i(this, "Map"), t);
                return n && n.v
            },
            set: function(t, n) {
                return e.def(i(this, "Map"), 0 === t ? 0 : t, n)
            }
        }, e, !0)
    }, {
        125: 125,
        27: 27,
        29: 29
    }],
    160: [function(t, n, r) {
        var e = t(40),
            i = t(68),
            o = Math.sqrt,
            u = Math.acosh;
        e(e.S + e.F * !(u && 710 == Math.floor(u(Number.MAX_VALUE)) && u(1 / 0) == 1 / 0), "Math", {
            acosh: function(t) {
                return (t = +t) < 1 ? NaN : t > 94906265.62425156 ? Math.log(t) + Math.LN2 : i(t - 1 + o(t - 1) * o(t + 1))
            }
        })
    }, {
        40: 40,
        68: 68
    }],
    161: [function(t, n, r) {
        var e = t(40),
            i = Math.asinh;
        e(e.S + e.F * !(i && 1 / i(0) > 0), "Math", {
            asinh: function t(n) {
                return isFinite(n = +n) && 0 != n ? n < 0 ? -t(-n) : Math.log(n + Math.sqrt(n * n + 1)) : n
            }
        })
    }, {
        40: 40
    }],
    162: [function(t, n, r) {
        var e = t(40),
            i = Math.atanh;
        e(e.S + e.F * !(i && 1 / i(-0) < 0), "Math", {
            atanh: function(t) {
                return 0 == (t = +t) ? t : Math.log((1 + t) / (1 - t)) / 2
            }
        })
    }, {
        40: 40
    }],
    163: [function(t, n, r) {
        var e = t(40),
            i = t(69);
        e(e.S, "Math", {
            cbrt: function(t) {
                return i(t = +t) * Math.pow(Math.abs(t), 1 / 3)
            }
        })
    }, {
        40: 40,
        69: 69
    }],
    164: [function(t, n, r) {
        var e = t(40);
        e(e.S, "Math", {
            clz32: function(t) {
                return (t >>>= 0) ? 31 - Math.floor(Math.log(t + .5) * Math.LOG2E) : 32
            }
        })
    }, {
        40: 40
    }],
    165: [function(t, n, r) {
        var e = t(40),
            i = Math.exp;
        e(e.S, "Math", {
            cosh: function(t) {
                return (i(t = +t) + i(-t)) / 2
            }
        })
    }, {
        40: 40
    }],
    166: [function(t, n, r) {
        var e = t(40),
            i = t(66);
        e(e.S + e.F * (i != Math.expm1), "Math", {
            expm1: i
        })
    }, {
        40: 40,
        66: 66
    }],
    167: [function(t, n, r) {
        var e = t(40);
        e(e.S, "Math", {
            fround: t(67)
        })
    }, {
        40: 40,
        67: 67
    }],
    168: [function(t, n, r) {
        var e = t(40),
            i = Math.abs;
        e(e.S, "Math", {
            hypot: function(t, n) {
                for (var r, e, o = 0, u = 0, c = arguments.length, f = 0; u < c;) f < (r = i(arguments[u++])) ? (o = o * (e = f / r) * e + 1, f = r) : r > 0 ? o += (e = r / f) * e : o += r;
                return f === 1 / 0 ? 1 / 0 : f * Math.sqrt(o)
            }
        })
    }, {
        40: 40
    }],
    169: [function(t, n, r) {
        var e = t(40),
            i = Math.imul;
        e(e.S + e.F * t(42)(function() {
            return -5 != i(4294967295, 5) || 2 != i.length
        }), "Math", {
            imul: function(t, n) {
                var r = +t,
                    e = +n,
                    i = 65535 & r,
                    o = 65535 & e;
                return 0 | i * o + ((65535 & r >>> 16) * o + i * (65535 & e >>> 16) << 16 >>> 0)
            }
        })
    }, {
        40: 40,
        42: 42
    }],
    170: [function(t, n, r) {
        var e = t(40);
        e(e.S, "Math", {
            log10: function(t) {
                return Math.log(t) * Math.LOG10E
            }
        })
    }, {
        40: 40
    }],
    171: [function(t, n, r) {
        var e = t(40);
        e(e.S, "Math", {
            log1p: t(68)
        })
    }, {
        40: 40,
        68: 68
    }],
    172: [function(t, n, r) {
        var e = t(40);
        e(e.S, "Math", {
            log2: function(t) {
                return Math.log(t) / Math.LN2
            }
        })
    }, {
        40: 40
    }],
    173: [function(t, n, r) {
        var e = t(40);
        e(e.S, "Math", {
            sign: t(69)
        })
    }, {
        40: 40,
        69: 69
    }],
    174: [function(t, n, r) {
        var e = t(40),
            i = t(66),
            o = Math.exp;
        e(e.S + e.F * t(42)(function() {
            return -2e-17 != !Math.sinh(-2e-17)
        }), "Math", {
            sinh: function(t) {
                return Math.abs(t = +t) < 1 ? (i(t) - i(-t)) / 2 : (o(t - 1) - o(-t - 1)) * (Math.E / 2)
            }
        })
    }, {
        40: 40,
        42: 42,
        66: 66
    }],
    175: [function(t, n, r) {
        var e = t(40),
            i = t(66),
            o = Math.exp;
        e(e.S, "Math", {
            tanh: function(t) {
                var n = i(t = +t),
                    r = i(-t);
                return n == 1 / 0 ? 1 : r == 1 / 0 ? -1 : (n - r) / (o(t) + o(-t))
            }
        })
    }, {
        40: 40,
        66: 66
    }],
    176: [function(t, n, r) {
        var e = t(40);
        e(e.S, "Math", {
            trunc: function(t) {
                return (t > 0 ? Math.floor : Math.ceil)(t)
            }
        })
    }, {
        40: 40
    }],
    177: [function(t, n, r) {
        "use strict";
        var e = t(46),
            i = t(47),
            o = t(26),
            u = t(51),
            c = t(119),
            f = t(42),
            a = t(79).f,
            s = t(77).f,
            l = t(75).f,
            h = t(110).trim,
            v = e.Number,
            p = v,
            g = v.prototype,
            y = "Number" == o(t(74)(g)),
            d = "trim" in String.prototype,
            x = function(t) {
                var n = c(t, !1);
                if ("string" == typeof n && n.length > 2) {
                    var r, e, i, o = (n = d ? n.trim() : h(n, 3)).charCodeAt(0);
                    if (43 === o || 45 === o) {
                        if (88 === (r = n.charCodeAt(2)) || 120 === r) return NaN
                    } else if (48 === o) {
                        switch (n.charCodeAt(1)) {
                            case 66:
                            case 98:
                                e = 2, i = 49;
                                break;
                            case 79:
                            case 111:
                                e = 8, i = 55;
                                break;
                            default:
                                return +n
                        }
                        for (var u, f = n.slice(2), a = 0, s = f.length; a < s; a++)
                            if ((u = f.charCodeAt(a)) < 48 || u > i) return NaN;
                        return parseInt(f, e)
                    }
                }
                return +n
            };
        if (!v(" 0o1") || !v("0b1") || v("+0x1")) {
            v = function(t) {
                var n = arguments.length < 1 ? 0 : t,
                    r = this;
                return r instanceof v && (y ? f(function() {
                    g.valueOf.call(r)
                }) : "Number" != o(r)) ? u(new p(x(n)), r, v) : x(n)
            };
            for (var m, b = t(36) ? a(p) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","), S = 0; b.length > S; S++) i(p, m = b[S]) && !i(v, m) && l(v, m, s(p, m));
            v.prototype = g, g.constructor = v, t(94)(e, "Number", v)
        }
    }, {
        110: 110,
        119: 119,
        26: 26,
        36: 36,
        42: 42,
        46: 46,
        47: 47,
        51: 51,
        74: 74,
        75: 75,
        77: 77,
        79: 79,
        94: 94
    }],
    178: [function(t, n, r) {
        var e = t(40);
        e(e.S, "Number", {
            EPSILON: Math.pow(2, -52)
        })
    }, {
        40: 40
    }],
    179: [function(t, n, r) {
        var e = t(40),
            i = t(46).isFinite;
        e(e.S, "Number", {
            isFinite: function(t) {
                return "number" == typeof t && i(t)
            }
        })
    }, {
        40: 40,
        46: 46
    }],
    180: [function(t, n, r) {
        var e = t(40);
        e(e.S, "Number", {
            isInteger: t(56)
        })
    }, {
        40: 40,
        56: 56
    }],
    181: [function(t, n, r) {
        var e = t(40);
        e(e.S, "Number", {
            isNaN: function(t) {
                return t != t
            }
        })
    }, {
        40: 40
    }],
    182: [function(t, n, r) {
        var e = t(40),
            i = t(56),
            o = Math.abs;
        e(e.S, "Number", {
            isSafeInteger: function(t) {
                return i(t) && o(t) <= 9007199254740991
            }
        })
    }, {
        40: 40,
        56: 56
    }],
    183: [function(t, n, r) {
        var e = t(40);
        e(e.S, "Number", {
            MAX_SAFE_INTEGER: 9007199254740991
        })
    }, {
        40: 40
    }],
    184: [function(t, n, r) {
        var e = t(40);
        e(e.S, "Number", {
            MIN_SAFE_INTEGER: -9007199254740991
        })
    }, {
        40: 40
    }],
    185: [function(t, n, r) {
        var e = t(40),
            i = t(88);
        e(e.S + e.F * (Number.parseFloat != i), "Number", {
            parseFloat: i
        })
    }, {
        40: 40,
        88: 88
    }],
    186: [function(t, n, r) {
        var e = t(40),
            i = t(89);
        e(e.S + e.F * (Number.parseInt != i), "Number", {
            parseInt: i
        })
    }, {
        40: 40,
        89: 89
    }],
    187: [function(t, n, r) {
        "use strict";
        var e = t(40),
            i = t(115),
            o = t(12),
            u = t(109),
            c = 1..toFixed,
            f = Math.floor,
            a = [0, 0, 0, 0, 0, 0],
            s = "Number.toFixed: incorrect invocation!",
            l = function(t, n) {
                for (var r = -1, e = n; ++r < 6;) e += t * a[r], a[r] = e % 1e7, e = f(e / 1e7)
            },
            h = function(t) {
                for (var n = 6, r = 0; --n >= 0;) r += a[n], a[n] = f(r / t), r = r % t * 1e7
            },
            v = function() {
                for (var t = 6, n = ""; --t >= 0;)
                    if ("" !== n || 0 === t || 0 !== a[t]) {
                        var r = String(a[t]);
                        n = "" === n ? r : n + u.call("0", 7 - r.length) + r
                    }
                return n
            },
            p = function(t, n, r) {
                return 0 === n ? r : n % 2 == 1 ? p(t, n - 1, r * t) : p(t * t, n / 2, r)
            };
        e(e.P + e.F * (!!c && ("0.000" !== 8e-5.toFixed(3) || "1" !== .9.toFixed(0) || "1.25" !== 1.255.toFixed(2) || "1000000000000000128" !== (0xde0b6b3a7640080).toFixed(0)) || !t(42)(function() {
            c.call({})
        })), "Number", {
            toFixed: function(t) {
                var n, r, e, c, f = o(this, s),
                    a = i(t),
                    g = "",
                    y = "0";
                if (a < 0 || a > 20) throw RangeError(s);
                if (f != f) return "NaN";
                if (f <= -1e21 || f >= 1e21) return String(f);
                if (f < 0 && (g = "-", f = -f), f > 1e-21)
                    if (n = function(t) {
                            for (var n = 0, r = t; r >= 4096;) n += 12, r /= 4096;
                            for (; r >= 2;) n += 1, r /= 2;
                            return n
                        }(f * p(2, 69, 1)) - 69, r = n < 0 ? f * p(2, -n, 1) : f / p(2, n, 1), r *= 4503599627370496, (n = 52 - n) > 0) {
                        for (l(0, r), e = a; e >= 7;) l(1e7, 0), e -= 7;
                        for (l(p(10, e, 1), 0), e = n - 1; e >= 23;) h(1 << 23), e -= 23;
                        h(1 << e), l(1, 1), h(2), y = v()
                    } else l(0, r), l(1 << -n, 0), y = v() + u.call("0", a);
                return a > 0 ? y = g + ((c = y.length) <= a ? "0." + u.call("0", a - c) + y : y.slice(0, c - a) + "." + y.slice(c - a)) : y = g + y, y
            }
        })
    }, {
        109: 109,
        115: 115,
        12: 12,
        40: 40,
        42: 42
    }],
    188: [function(t, n, r) {
        "use strict";
        var e = t(40),
            i = t(42),
            o = t(12),
            u = 1..toPrecision;
        e(e.P + e.F * (i(function() {
            return "1" !== u.call(1, void 0)
        }) || !i(function() {
            u.call({})
        })), "Number", {
            toPrecision: function(t) {
                var n = o(this, "Number#toPrecision: incorrect invocation!");
                return void 0 === t ? u.call(n) : u.call(n, t)
            }
        })
    }, {
        12: 12,
        40: 40,
        42: 42
    }],
    189: [function(t, n, r) {
        var e = t(40);
        e(e.S + e.F, "Object", {
            assign: t(73)
        })
    }, {
        40: 40,
        73: 73
    }],
    190: [function(t, n, r) {
        var e = t(40);
        e(e.S, "Object", {
            create: t(74)
        })
    }, {
        40: 40,
        74: 74
    }],
    191: [function(t, n, r) {
        var e = t(40);
        e(e.S + e.F * !t(36), "Object", {
            defineProperties: t(76)
        })
    }, {
        36: 36,
        40: 40,
        76: 76
    }],
    192: [function(t, n, r) {
        var e = t(40);
        e(e.S + e.F * !t(36), "Object", {
            defineProperty: t(75).f
        })
    }, {
        36: 36,
        40: 40,
        75: 75
    }],
    193: [function(t, n, r) {
        var e = t(57),
            i = t(70).onFreeze;
        t(85)("freeze", function(t) {
            return function(n) {
                return t && e(n) ? t(i(n)) : n
            }
        })
    }, {
        57: 57,
        70: 70,
        85: 85
    }],
    194: [function(t, n, r) {
        var e = t(116),
            i = t(77).f;
        t(85)("getOwnPropertyDescriptor", function() {
            return function(t, n) {
                return i(e(t), n)
            }
        })
    }, {
        116: 116,
        77: 77,
        85: 85
    }],
    195: [function(t, n, r) {
        t(85)("getOwnPropertyNames", function() {
            return t(78).f
        })
    }, {
        78: 78,
        85: 85
    }],
    196: [function(t, n, r) {
        var e = t(118),
            i = t(81);
        t(85)("getPrototypeOf", function() {
            return function(t) {
                return i(e(t))
            }
        })
    }, {
        118: 118,
        81: 81,
        85: 85
    }],
    197: [function(t, n, r) {
        var e = t(57);
        t(85)("isExtensible", function(t) {
            return function(n) {
                return !!e(n) && (!t || t(n))
            }
        })
    }, {
        57: 57,
        85: 85
    }],
    198: [function(t, n, r) {
        var e = t(57);
        t(85)("isFrozen", function(t) {
            return function(n) {
                return !e(n) || !!t && t(n)
            }
        })
    }, {
        57: 57,
        85: 85
    }],
    199: [function(t, n, r) {
        var e = t(57);
        t(85)("isSealed", function(t) {
            return function(n) {
                return !e(n) || !!t && t(n)
            }
        })
    }, {
        57: 57,
        85: 85
    }],
    200: [function(t, n, r) {
        var e = t(40);
        e(e.S, "Object", {
            is: t(97)
        })
    }, {
        40: 40,
        97: 97
    }],
    201: [function(t, n, r) {
        var e = t(118),
            i = t(83);
        t(85)("keys", function() {
            return function(t) {
                return i(e(t))
            }
        })
    }, {
        118: 118,
        83: 83,
        85: 85
    }],
    202: [function(t, n, r) {
        var e = t(57),
            i = t(70).onFreeze;
        t(85)("preventExtensions", function(t) {
            return function(n) {
                return t && e(n) ? t(i(n)) : n
            }
        })
    }, {
        57: 57,
        70: 70,
        85: 85
    }],
    203: [function(t, n, r) {
        var e = t(57),
            i = t(70).onFreeze;
        t(85)("seal", function(t) {
            return function(n) {
                return t && e(n) ? t(i(n)) : n
            }
        })
    }, {
        57: 57,
        70: 70,
        85: 85
    }],
    204: [function(t, n, r) {
        var e = t(40);
        e(e.S, "Object", {
            setPrototypeOf: t(98).set
        })
    }, {
        40: 40,
        98: 98
    }],
    205: [function(t, n, r) {
        "use strict";
        var e = t(25),
            i = {};
        i[t(128)("toStringTag")] = "z", i + "" != "[object z]" && t(94)(Object.prototype, "toString", function() {
            return "[object " + e(this) + "]"
        }, !0)
    }, {
        128: 128,
        25: 25,
        94: 94
    }],
    206: [function(t, n, r) {
        var e = t(40),
            i = t(88);
        e(e.G + e.F * (parseFloat != i), {
            parseFloat: i
        })
    }, {
        40: 40,
        88: 88
    }],
    207: [function(t, n, r) {
        var e = t(40),
            i = t(89);
        e(e.G + e.F * (parseInt != i), {
            parseInt: i
        })
    }, {
        40: 40,
        89: 89
    }],
    208: [function(t, n, r) {
        "use strict";
        var e, i, o, u, c = t(65),
            f = t(46),
            a = t(32),
            s = t(25),
            l = t(40),
            h = t(57),
            v = t(11),
            p = t(15),
            g = t(45),
            y = t(103),
            d = t(112).set,
            x = t(71)(),
            m = t(72),
            b = t(90),
            S = t(124),
            w = t(91),
            _ = f.TypeError,
            E = f.process,
            O = E && E.versions,
            F = O && O.v8 || "",
            P = f.Promise,
            M = "process" == s(E),
            A = function() {},
            I = i = m.f,
            j = !! function() {
                try {
                    var n = P.resolve(1),
                        r = (n.constructor = {})[t(128)("species")] = function(t) {
                            t(A, A)
                        };
                    return (M || "function" == typeof PromiseRejectionEvent) && n.then(A) instanceof r && 0 !== F.indexOf("6.6") && -1 === S.indexOf("Chrome/66")
                } catch (t) {}
            }(),
            N = function(t) {
                var n;
                return !(!h(t) || "function" != typeof(n = t.then)) && n
            },
            T = function(t, n) {
                if (!t._n) {
                    t._n = !0;
                    var r = t._c;
                    x(function() {
                        for (var e = t._v, i = 1 == t._s, o = 0; r.length > o;) ! function(n) {
                            var r, o, u, c = i ? n.ok : n.fail,
                                f = n.resolve,
                                a = n.reject,
                                s = n.domain;
                            try {
                                c ? (i || (2 == t._h && k(t), t._h = 1), !0 === c ? r = e : (s && s.enter(), r = c(e), s && (s.exit(), u = !0)), r === n.promise ? a(_("Promise-chain cycle")) : (o = N(r)) ? o.call(r, f, a) : f(r)) : a(e)
                            } catch (t) {
                                s && !u && s.exit(), a(t)
                            }
                        }(r[o++]);
                        t._c = [], t._n = !1, n && !t._h && L(t)
                    })
                }
            },
            L = function(t) {
                d.call(f, function() {
                    var n, r, e, i = t._v,
                        o = R(t);
                    if (o && (n = b(function() {
                            M ? E.emit("unhandledRejection", i, t) : (r = f.onunhandledrejection) ? r({
                                promise: t,
                                reason: i
                            }) : (e = f.console) && e.error && e.error("Unhandled promise rejection", i)
                        }), t._h = M || R(t) ? 2 : 1), t._a = void 0, o && n.e) throw n.v
                })
            },
            R = function(t) {
                return 1 !== t._h && 0 === (t._a || t._c).length
            },
            k = function(t) {
                d.call(f, function() {
                    var n;
                    M ? E.emit("rejectionHandled", t) : (n = f.onrejectionhandled) && n({
                        promise: t,
                        reason: t._v
                    })
                })
            },
            D = function(t) {
                var n = this;
                n._d || (n._d = !0, (n = n._w || n)._v = t, n._s = 2, n._a || (n._a = n._c.slice()), T(n, !0))
            },
            C = function(t) {
                var n, r = this;
                if (!r._d) {
                    r._d = !0, r = r._w || r;
                    try {
                        if (r === t) throw _("Promise can't be resolved itself");
                        (n = N(t)) ? x(function() {
                            var e = {
                                _w: r,
                                _d: !1
                            };
                            try {
                                n.call(t, a(C, e, 1), a(D, e, 1))
                            } catch (t) {
                                D.call(e, t)
                            }
                        }): (r._v = t, r._s = 1, T(r, !1))
                    } catch (t) {
                        D.call({
                            _w: r,
                            _d: !1
                        }, t)
                    }
                }
            };
        j || (P = function(t) {
            p(this, P, "Promise", "_h"), v(t), e.call(this);
            try {
                t(a(C, this, 1), a(D, this, 1))
            } catch (t) {
                D.call(this, t)
            }
        }, (e = function(t) {
            this._c = [], this._a = void 0, this._s = 0, this._d = !1, this._v = void 0, this._h = 0, this._n = !1
        }).prototype = t(93)(P.prototype, {
            then: function(t, n) {
                var r = I(y(this, P));
                return r.ok = "function" != typeof t || t, r.fail = "function" == typeof n && n, r.domain = M ? E.domain : void 0, this._c.push(r), this._a && this._a.push(r), this._s && T(this, !1), r.promise
            },
            catch: function(t) {
                return this.then(void 0, t)
            }
        }), o = function() {
            var t = new e;
            this.promise = t, this.resolve = a(C, t, 1), this.reject = a(D, t, 1)
        }, m.f = I = function(t) {
            return t === P || t === u ? new o(t) : i(t)
        }), l(l.G + l.W + l.F * !j, {
            Promise: P
        }), t(100)(P, "Promise"), t(99)("Promise"), u = t(30).Promise, l(l.S + l.F * !j, "Promise", {
            reject: function(t) {
                var n = I(this);
                return (0, n.reject)(t), n.promise
            }
        }), l(l.S + l.F * (c || !j), "Promise", {
            resolve: function(t) {
                return w(c && this === u ? P : this, t)
            }
        }), l(l.S + l.F * !(j && t(62)(function(t) {
            P.all(t).catch(A)
        })), "Promise", {
            all: function(t) {
                var n = this,
                    r = I(n),
                    e = r.resolve,
                    i = r.reject,
                    o = b(function() {
                        var r = [],
                            o = 0,
                            u = 1;
                        g(t, !1, function(t) {
                            var c = o++,
                                f = !1;
                            r.push(void 0), u++, n.resolve(t).then(function(t) {
                                f || (f = !0, r[c] = t, --u || e(r))
                            }, i)
                        }), --u || e(r)
                    });
                return o.e && i(o.v), r.promise
            },
            race: function(t) {
                var n = this,
                    r = I(n),
                    e = r.reject,
                    i = b(function() {
                        g(t, !1, function(t) {
                            n.resolve(t).then(r.resolve, e)
                        })
                    });
                return i.e && e(i.v), r.promise
            }
        })
    }, {
        100: 100,
        103: 103,
        11: 11,
        112: 112,
        124: 124,
        128: 128,
        15: 15,
        25: 25,
        30: 30,
        32: 32,
        40: 40,
        45: 45,
        46: 46,
        57: 57,
        62: 62,
        65: 65,
        71: 71,
        72: 72,
        90: 90,
        91: 91,
        93: 93,
        99: 99
    }],
    209: [function(t, n, r) {
        var e = t(40),
            i = t(11),
            o = t(16),
            u = (t(46).Reflect || {}).apply,
            c = Function.apply;
        e(e.S + e.F * !t(42)(function() {
            u(function() {})
        }), "Reflect", {
            apply: function(t, n, r) {
                var e = i(t),
                    f = o(r);
                return u ? u(e, n, f) : c.call(e, n, f)
            }
        })
    }, {
        11: 11,
        16: 16,
        40: 40,
        42: 42,
        46: 46
    }],
    210: [function(t, n, r) {
        var e = t(40),
            i = t(74),
            o = t(11),
            u = t(16),
            c = t(57),
            f = t(42),
            a = t(24),
            s = (t(46).Reflect || {}).construct,
            l = f(function() {
                function t() {}
                return !(s(function() {}, [], t) instanceof t)
            }),
            h = !f(function() {
                s(function() {})
            });
        e(e.S + e.F * (l || h), "Reflect", {
            construct: function(t, n) {
                o(t), u(n);
                var r = arguments.length < 3 ? t : o(arguments[2]);
                if (h && !l) return s(t, n, r);
                if (t == r) {
                    switch (n.length) {
                        case 0:
                            return new t;
                        case 1:
                            return new t(n[0]);
                        case 2:
                            return new t(n[0], n[1]);
                        case 3:
                            return new t(n[0], n[1], n[2]);
                        case 4:
                            return new t(n[0], n[1], n[2], n[3])
                    }
                    var e = [null];
                    return e.push.apply(e, n), new(a.apply(t, e))
                }
                var f = r.prototype,
                    v = i(c(f) ? f : Object.prototype),
                    p = Function.apply.call(t, v, n);
                return c(p) ? p : v
            }
        })
    }, {
        11: 11,
        16: 16,
        24: 24,
        40: 40,
        42: 42,
        46: 46,
        57: 57,
        74: 74
    }],
    211: [function(t, n, r) {
        var e = t(75),
            i = t(40),
            o = t(16),
            u = t(119);
        i(i.S + i.F * t(42)(function() {
            Reflect.defineProperty(e.f({}, 1, {
                value: 1
            }), 1, {
                value: 2
            })
        }), "Reflect", {
            defineProperty: function(t, n, r) {
                o(t), n = u(n, !0), o(r);
                try {
                    return e.f(t, n, r), !0
                } catch (t) {
                    return !1
                }
            }
        })
    }, {
        119: 119,
        16: 16,
        40: 40,
        42: 42,
        75: 75
    }],
    212: [function(t, n, r) {
        var e = t(40),
            i = t(77).f,
            o = t(16);
        e(e.S, "Reflect", {
            deleteProperty: function(t, n) {
                var r = i(o(t), n);
                return !(r && !r.configurable) && delete t[n]
            }
        })
    }, {
        16: 16,
        40: 40,
        77: 77
    }],
    213: [function(t, n, r) {
        "use strict";
        var e = t(40),
            i = t(16),
            o = function(t) {
                this._t = i(t), this._i = 0;
                var n, r = this._k = [];
                for (n in t) r.push(n)
            };
        t(60)(o, "Object", function() {
            var t, n = this,
                r = n._k;
            do {
                if (n._i >= r.length) return {
                    value: void 0,
                    done: !0
                }
            } while (!((t = r[n._i++]) in n._t));
            return {
                value: t,
                done: !1
            }
        }), e(e.S, "Reflect", {
            enumerate: function(t) {
                return new o(t)
            }
        })
    }, {
        16: 16,
        40: 40,
        60: 60
    }],
    214: [function(t, n, r) {
        var e = t(77),
            i = t(40),
            o = t(16);
        i(i.S, "Reflect", {
            getOwnPropertyDescriptor: function(t, n) {
                return e.f(o(t), n)
            }
        })
    }, {
        16: 16,
        40: 40,
        77: 77
    }],
    215: [function(t, n, r) {
        var e = t(40),
            i = t(81),
            o = t(16);
        e(e.S, "Reflect", {
            getPrototypeOf: function(t) {
                return i(o(t))
            }
        })
    }, {
        16: 16,
        40: 40,
        81: 81
    }],
    216: [function(t, n, r) {
        var e = t(77),
            i = t(81),
            o = t(47),
            u = t(40),
            c = t(57),
            f = t(16);
        u(u.S, "Reflect", {
            get: function t(n, r) {
                var u, a, s = arguments.length < 3 ? n : arguments[2];
                return f(n) === s ? n[r] : (u = e.f(n, r)) ? o(u, "value") ? u.value : void 0 !== u.get ? u.get.call(s) : void 0 : c(a = i(n)) ? t(a, r, s) : void 0
            }
        })
    }, {
        16: 16,
        40: 40,
        47: 47,
        57: 57,
        77: 77,
        81: 81
    }],
    217: [function(t, n, r) {
        var e = t(40);
        e(e.S, "Reflect", {
            has: function(t, n) {
                return n in t
            }
        })
    }, {
        40: 40
    }],
    218: [function(t, n, r) {
        var e = t(40),
            i = t(16),
            o = Object.isExtensible;
        e(e.S, "Reflect", {
            isExtensible: function(t) {
                return i(t), !o || o(t)
            }
        })
    }, {
        16: 16,
        40: 40
    }],
    219: [function(t, n, r) {
        var e = t(40);
        e(e.S, "Reflect", {
            ownKeys: t(87)
        })
    }, {
        40: 40,
        87: 87
    }],
    220: [function(t, n, r) {
        var e = t(40),
            i = t(16),
            o = Object.preventExtensions;
        e(e.S, "Reflect", {
            preventExtensions: function(t) {
                i(t);
                try {
                    return o && o(t), !0
                } catch (t) {
                    return !1
                }
            }
        })
    }, {
        16: 16,
        40: 40
    }],
    221: [function(t, n, r) {
        var e = t(40),
            i = t(98);
        i && e(e.S, "Reflect", {
            setPrototypeOf: function(t, n) {
                i.check(t, n);
                try {
                    return i.set(t, n), !0
                } catch (t) {
                    return !1
                }
            }
        })
    }, {
        40: 40,
        98: 98
    }],
    222: [function(t, n, r) {
        var e = t(75),
            i = t(77),
            o = t(81),
            u = t(47),
            c = t(40),
            f = t(92),
            a = t(16),
            s = t(57);
        c(c.S, "Reflect", {
            set: function t(n, r, c) {
                var l, h, v = arguments.length < 4 ? n : arguments[3],
                    p = i.f(a(n), r);
                if (!p) {
                    if (s(h = o(n))) return t(h, r, c, v);
                    p = f(0)
                }
                if (u(p, "value")) {
                    if (!1 === p.writable || !s(v)) return !1;
                    if (l = i.f(v, r)) {
                        if (l.get || l.set || !1 === l.writable) return !1;
                        l.value = c, e.f(v, r, l)
                    } else e.f(v, r, f(0, c));
                    return !0
                }
                return void 0 !== p.set && (p.set.call(v, c), !0)
            }
        })
    }, {
        16: 16,
        40: 40,
        47: 47,
        57: 57,
        75: 75,
        77: 77,
        81: 81,
        92: 92
    }],
    223: [function(t, n, r) {
        var e = t(46),
            i = t(51),
            o = t(75).f,
            u = t(79).f,
            c = t(58),
            f = t(44),
            a = e.RegExp,
            s = a,
            l = a.prototype,
            h = /a/g,
            v = /a/g,
            p = new a(h) !== h;
        if (t(36) && (!p || t(42)(function() {
                return v[t(128)("match")] = !1, a(h) != h || a(v) == v || "/a/i" != a(h, "i")
            }))) {
            a = function(t, n) {
                var r = this instanceof a,
                    e = c(t),
                    o = void 0 === n;
                return !r && e && t.constructor === a && o ? t : i(p ? new s(e && !o ? t.source : t, n) : s((e = t instanceof a) ? t.source : t, e && o ? f.call(t) : n), r ? this : l, a)
            };
            for (var g = u(s), y = 0; g.length > y;) ! function(t) {
                t in a || o(a, t, {
                    configurable: !0,
                    get: function() {
                        return s[t]
                    },
                    set: function(n) {
                        s[t] = n
                    }
                })
            }(g[y++]);
            l.constructor = a, a.prototype = l, t(94)(e, "RegExp", a)
        }
        t(99)("RegExp")
    }, {
        128: 128,
        36: 36,
        42: 42,
        44: 44,
        46: 46,
        51: 51,
        58: 58,
        75: 75,
        79: 79,
        94: 94,
        99: 99
    }],
    224: [function(t, n, r) {
        "use strict";
        var e = t(96);
        t(40)({
            target: "RegExp",
            proto: !0,
            forced: e !== /./.exec
        }, {
            exec: e
        })
    }, {
        40: 40,
        96: 96
    }],
    225: [function(t, n, r) {
        t(36) && "g" != /./g.flags && t(75).f(RegExp.prototype, "flags", {
            configurable: !0,
            get: t(44)
        })
    }, {
        36: 36,
        44: 44,
        75: 75
    }],
    226: [function(t, n, r) {
        "use strict";
        var e = t(16),
            i = t(117),
            o = t(14),
            u = t(95);
        t(43)("match", 1, function(t, n, r, c) {
            return [function(r) {
                var e = t(this),
                    i = null == r ? void 0 : r[n];
                return void 0 !== i ? i.call(r, e) : new RegExp(r)[n](String(e))
            }, function(t) {
                var n = c(r, t, this);
                if (n.done) return n.value;
                var f = e(t),
                    a = String(this);
                if (!f.global) return u(f, a);
                var s = f.unicode;
                f.lastIndex = 0;
                for (var l, h = [], v = 0; null !== (l = u(f, a));) {
                    var p = String(l[0]);
                    h[v] = p, "" === p && (f.lastIndex = o(a, i(f.lastIndex), s)), v++
                }
                return 0 === v ? null : h
            }]
        })
    }, {
        117: 117,
        14: 14,
        16: 16,
        43: 43,
        95: 95
    }],
    227: [function(t, n, r) {
        "use strict";
        var e = t(16),
            i = t(118),
            o = t(117),
            u = t(115),
            c = t(14),
            f = t(95),
            a = Math.max,
            s = Math.min,
            l = Math.floor,
            h = /\$([$&`']|\d\d?|<[^>]*>)/g,
            v = /\$([$&`']|\d\d?)/g,
            p = function(t) {
                return void 0 === t ? t : String(t)
            };
        t(43)("replace", 2, function(t, n, r, g) {
            function y(t, n, e, o, u, c) {
                var f = e + t.length,
                    a = o.length,
                    s = v;
                return void 0 !== u && (u = i(u), s = h), r.call(c, s, function(r, i) {
                    var c;
                    switch (i.charAt(0)) {
                        case "$":
                            return "$";
                        case "&":
                            return t;
                        case "`":
                            return n.slice(0, e);
                        case "'":
                            return n.slice(f);
                        case "<":
                            c = u[i.slice(1, -1)];
                            break;
                        default:
                            var s = +i;
                            if (0 === s) return i;
                            if (s > a) {
                                var h = l(s / 10);
                                return 0 === h ? i : h <= a ? void 0 === o[h - 1] ? i.charAt(1) : o[h - 1] + i.charAt(1) : i
                            }
                            c = o[s - 1]
                    }
                    return void 0 === c ? "" : c
                })
            }
            return [function(e, i) {
                var o = t(this),
                    u = null == e ? void 0 : e[n];
                return void 0 !== u ? u.call(e, o, i) : r.call(String(o), e, i)
            }, function(t, n) {
                var i = g(r, t, this, n);
                if (i.done) return i.value;
                var l = e(t),
                    h = String(this),
                    v = "function" == typeof n;
                v || (n = String(n));
                var d = l.global;
                if (d) {
                    var x = l.unicode;
                    l.lastIndex = 0
                }
                for (var m = [];;) {
                    var b = f(l, h);
                    if (null === b) break;
                    if (m.push(b), !d) break;
                    "" === String(b[0]) && (l.lastIndex = c(h, o(l.lastIndex), x))
                }
                for (var S = "", w = 0, _ = 0; _ < m.length; _++) {
                    b = m[_];
                    for (var E = String(b[0]), O = a(s(u(b.index), h.length), 0), F = [], P = 1; P < b.length; P++) F.push(p(b[P]));
                    var M = b.groups;
                    if (v) {
                        var A = [E].concat(F, O, h);
                        void 0 !== M && A.push(M);
                        var I = String(n.apply(void 0, A))
                    } else I = y(E, h, O, F, M, n);
                    O >= w && (S += h.slice(w, O) + I, w = O + E.length)
                }
                return S + h.slice(w)
            }]
        })
    }, {
        115: 115,
        117: 117,
        118: 118,
        14: 14,
        16: 16,
        43: 43,
        95: 95
    }],
    228: [function(t, n, r) {
        "use strict";
        var e = t(16),
            i = t(97),
            o = t(95);
        t(43)("search", 1, function(t, n, r, u) {
            return [function(r) {
                var e = t(this),
                    i = null == r ? void 0 : r[n];
                return void 0 !== i ? i.call(r, e) : new RegExp(r)[n](String(e))
            }, function(t) {
                var n = u(r, t, this);
                if (n.done) return n.value;
                var c = e(t),
                    f = String(this),
                    a = c.lastIndex;
                i(a, 0) || (c.lastIndex = 0);
                var s = o(c, f);
                return i(c.lastIndex, a) || (c.lastIndex = a), null === s ? -1 : s.index
            }]
        })
    }, {
        16: 16,
        43: 43,
        95: 95,
        97: 97
    }],
    229: [function(t, n, r) {
        "use strict";
        var e = t(58),
            i = t(16),
            o = t(103),
            u = t(14),
            c = t(117),
            f = t(95),
            a = t(96),
            s = Math.min,
            l = [].push,
            h = "length",
            v = !! function() {
                try {
                    return new RegExp("x", "y")
                } catch (t) {}
            }();
        t(43)("split", 2, function(t, n, r, p) {
            var g;
            return g = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1)[h] || 2 != "ab".split(/(?:ab)*/)[h] || 4 != ".".split(/(.?)(.?)/)[h] || ".".split(/()()/)[h] > 1 || "".split(/.?/)[h] ? function(t, n) {
                var i = String(this);
                if (void 0 === t && 0 === n) return [];
                if (!e(t)) return r.call(i, t, n);
                for (var o, u, c, f = [], s = (t.ignoreCase ? "i" : "") + (t.multiline ? "m" : "") + (t.unicode ? "u" : "") + (t.sticky ? "y" : ""), v = 0, p = void 0 === n ? 4294967295 : n >>> 0, g = new RegExp(t.source, s + "g");
                    (o = a.call(g, i)) && !((u = g.lastIndex) > v && (f.push(i.slice(v, o.index)), o[h] > 1 && o.index < i[h] && l.apply(f, o.slice(1)), c = o[0][h], v = u, f[h] >= p));) g.lastIndex === o.index && g.lastIndex++;
                return v === i[h] ? !c && g.test("") || f.push("") : f.push(i.slice(v)), f[h] > p ? f.slice(0, p) : f
            } : "0".split(void 0, 0)[h] ? function(t, n) {
                return void 0 === t && 0 === n ? [] : r.call(this, t, n)
            } : r, [function(r, e) {
                var i = t(this),
                    o = null == r ? void 0 : r[n];
                return void 0 !== o ? o.call(r, i, e) : g.call(String(i), r, e)
            }, function(t, n) {
                var e = p(g, t, this, n, g !== r);
                if (e.done) return e.value;
                var a = i(t),
                    l = String(this),
                    h = o(a, RegExp),
                    y = a.unicode,
                    d = (a.ignoreCase ? "i" : "") + (a.multiline ? "m" : "") + (a.unicode ? "u" : "") + (v ? "y" : "g"),
                    x = new h(v ? a : "^(?:" + a.source + ")", d),
                    m = void 0 === n ? 4294967295 : n >>> 0;
                if (0 === m) return [];
                if (0 === l.length) return null === f(x, l) ? [l] : [];
                for (var b = 0, S = 0, w = []; S < l.length;) {
                    x.lastIndex = v ? S : 0;
                    var _, E = f(x, v ? l : l.slice(S));
                    if (null === E || (_ = s(c(x.lastIndex + (v ? 0 : S)), l.length)) === b) S = u(l, S, y);
                    else {
                        if (w.push(l.slice(b, S)), w.length === m) return w;
                        for (var O = 1; O <= E.length - 1; O++)
                            if (w.push(E[O]), w.length === m) return w;
                        S = b = _
                    }
                }
                return w.push(l.slice(b)), w
            }]
        })
    }, {
        103: 103,
        117: 117,
        14: 14,
        16: 16,
        43: 43,
        58: 58,
        95: 95,
        96: 96
    }],
    230: [function(t, n, r) {
        "use strict";
        t(225);
        var e = t(16),
            i = t(44),
            o = t(36),
            u = /./.toString,
            c = function(n) {
                t(94)(RegExp.prototype, "toString", n, !0)
            };
        t(42)(function() {
            return "/a/b" != u.call({
                source: "a",
                flags: "b"
            })
        }) ? c(function() {
            var t = e(this);
            return "/".concat(t.source, "/", "flags" in t ? t.flags : !o && t instanceof RegExp ? i.call(t) : void 0)
        }) : "toString" != u.name && c(function() {
            return u.call(this)
        })
    }, {
        16: 16,
        225: 225,
        36: 36,
        42: 42,
        44: 44,
        94: 94
    }],
    231: [function(t, n, r) {
        "use strict";
        var e = t(27),
            i = t(125);
        n.exports = t(29)("Set", function(t) {
            return function() {
                return t(this, arguments.length > 0 ? arguments[0] : void 0)
            }
        }, {
            add: function(t) {
                return e.def(i(this, "Set"), t = 0 === t ? 0 : t, t)
            }
        }, e)
    }, {
        125: 125,
        27: 27,
        29: 29
    }],
    232: [function(t, n, r) {
        "use strict";
        t(107)("anchor", function(t) {
            return function(n) {
                return t(this, "a", "name", n)
            }
        })
    }, {
        107: 107
    }],
    233: [function(t, n, r) {
        "use strict";
        t(107)("big", function(t) {
            return function() {
                return t(this, "big", "", "")
            }
        })
    }, {
        107: 107
    }],
    234: [function(t, n, r) {
        "use strict";
        t(107)("blink", function(t) {
            return function() {
                return t(this, "blink", "", "")
            }
        })
    }, {
        107: 107
    }],
    235: [function(t, n, r) {
        "use strict";
        t(107)("bold", function(t) {
            return function() {
                return t(this, "b", "", "")
            }
        })
    }, {
        107: 107
    }],
    236: [function(t, n, r) {
        "use strict";
        var e = t(40),
            i = t(105)(!1);
        e(e.P, "String", {
            codePointAt: function(t) {
                return i(this, t)
            }
        })
    }, {
        105: 105,
        40: 40
    }],
    237: [function(t, n, r) {
        "use strict";
        var e = t(40),
            i = t(117),
            o = t(106),
            u = "".endsWith;
        e(e.P + e.F * t(41)("endsWith"), "String", {
            endsWith: function(t) {
                var n = o(this, t, "endsWith"),
                    r = arguments.length > 1 ? arguments[1] : void 0,
                    e = i(n.length),
                    c = void 0 === r ? e : Math.min(i(r), e),
                    f = String(t);
                return u ? u.call(n, f, c) : n.slice(c - f.length, c) === f
            }
        })
    }, {
        106: 106,
        117: 117,
        40: 40,
        41: 41
    }],
    238: [function(t, n, r) {
        "use strict";
        t(107)("fixed", function(t) {
            return function() {
                return t(this, "tt", "", "")
            }
        })
    }, {
        107: 107
    }],
    239: [function(t, n, r) {
        "use strict";
        t(107)("fontcolor", function(t) {
            return function(n) {
                return t(this, "font", "color", n)
            }
        })
    }, {
        107: 107
    }],
    240: [function(t, n, r) {
        "use strict";
        t(107)("fontsize", function(t) {
            return function(n) {
                return t(this, "font", "size", n)
            }
        })
    }, {
        107: 107
    }],
    241: [function(t, n, r) {
        var e = t(40),
            i = t(113),
            o = String.fromCharCode,
            u = String.fromCodePoint;
        e(e.S + e.F * (!!u && 1 != u.length), "String", {
            fromCodePoint: function(t) {
                for (var n, r = [], e = arguments.length, u = 0; e > u;) {
                    if (n = +arguments[u++], i(n, 1114111) !== n) throw RangeError(n + " is not a valid code point");
                    r.push(n < 65536 ? o(n) : o(55296 + ((n -= 65536) >> 10), n % 1024 + 56320))
                }
                return r.join("")
            }
        })
    }, {
        113: 113,
        40: 40
    }],
    242: [function(t, n, r) {
        "use strict";
        var e = t(40),
            i = t(106);
        e(e.P + e.F * t(41)("includes"), "String", {
            includes: function(t) {
                return !!~i(this, t, "includes").indexOf(t, arguments.length > 1 ? arguments[1] : void 0)
            }
        })
    }, {
        106: 106,
        40: 40,
        41: 41
    }],
    243: [function(t, n, r) {
        "use strict";
        t(107)("italics", function(t) {
            return function() {
                return t(this, "i", "", "")
            }
        })
    }, {
        107: 107
    }],
    244: [function(t, n, r) {
        "use strict";
        var e = t(105)(!0);
        t(61)(String, "String", function(t) {
            this._t = String(t), this._i = 0
        }, function() {
            var t, n = this._t,
                r = this._i;
            return r >= n.length ? {
                value: void 0,
                done: !0
            } : (t = e(n, r), this._i += t.length, {
                value: t,
                done: !1
            })
        })
    }, {
        105: 105,
        61: 61
    }],
    245: [function(t, n, r) {
        "use strict";
        t(107)("link", function(t) {
            return function(n) {
                return t(this, "a", "href", n)
            }
        })
    }, {
        107: 107
    }],
    246: [function(t, n, r) {
        var e = t(40),
            i = t(116),
            o = t(117);
        e(e.S, "String", {
            raw: function(t) {
                for (var n = i(t.raw), r = o(n.length), e = arguments.length, u = [], c = 0; r > c;) u.push(String(n[c++])), c < e && u.push(String(arguments[c]));
                return u.join("")
            }
        })
    }, {
        116: 116,
        117: 117,
        40: 40
    }],
    247: [function(t, n, r) {
        var e = t(40);
        e(e.P, "String", {
            repeat: t(109)
        })
    }, {
        109: 109,
        40: 40
    }],
    248: [function(t, n, r) {
        "use strict";
        t(107)("small", function(t) {
            return function() {
                return t(this, "small", "", "")
            }
        })
    }, {
        107: 107
    }],
    249: [function(t, n, r) {
        "use strict";
        var e = t(40),
            i = t(117),
            o = t(106),
            u = "".startsWith;
        e(e.P + e.F * t(41)("startsWith"), "String", {
            startsWith: function(t) {
                var n = o(this, t, "startsWith"),
                    r = i(Math.min(arguments.length > 1 ? arguments[1] : void 0, n.length)),
                    e = String(t);
                return u ? u.call(n, e, r) : n.slice(r, r + e.length) === e
            }
        })
    }, {
        106: 106,
        117: 117,
        40: 40,
        41: 41
    }],
    250: [function(t, n, r) {
        "use strict";
        t(107)("strike", function(t) {
            return function() {
                return t(this, "strike", "", "")
            }
        })
    }, {
        107: 107
    }],
    251: [function(t, n, r) {
        "use strict";
        t(107)("sub", function(t) {
            return function() {
                return t(this, "sub", "", "")
            }
        })
    }, {
        107: 107
    }],
    252: [function(t, n, r) {
        "use strict";
        t(107)("sup", function(t) {
            return function() {
                return t(this, "sup", "", "")
            }
        })
    }, {
        107: 107
    }],
    253: [function(t, n, r) {
        "use strict";
        t(110)("trim", function(t) {
            return function() {
                return t(this, 3)
            }
        })
    }, {
        110: 110
    }],
    254: [function(t, n, r) {
        "use strict";
        var e = t(46),
            i = t(47),
            o = t(36),
            u = t(40),
            c = t(94),
            f = t(70).KEY,
            a = t(42),
            s = t(102),
            l = t(100),
            h = t(123),
            v = t(128),
            p = t(127),
            g = t(126),
            y = t(39),
            d = t(55),
            x = t(16),
            m = t(57),
            b = t(116),
            S = t(119),
            w = t(92),
            _ = t(74),
            E = t(78),
            O = t(77),
            F = t(75),
            P = t(83),
            M = O.f,
            A = F.f,
            I = E.f,
            j = e.Symbol,
            N = e.JSON,
            T = N && N.stringify,
            L = v("_hidden"),
            R = v("toPrimitive"),
            k = {}.propertyIsEnumerable,
            D = s("symbol-registry"),
            C = s("symbols"),
            W = s("op-symbols"),
            U = Object.prototype,
            V = "function" == typeof j,
            B = e.QObject,
            G = !B || !B.prototype || !B.prototype.findChild,
            z = o && a(function() {
                return 7 != _(A({}, "a", {
                    get: function() {
                        return A(this, "a", {
                            value: 7
                        }).a
                    }
                })).a
            }) ? function(t, n, r) {
                var e = M(U, n);
                e && delete U[n], A(t, n, r), e && t !== U && A(U, n, e)
            } : A,
            q = function(t) {
                var n = C[t] = _(j.prototype);
                return n._k = t, n
            },
            Y = V && "symbol" == typeof j.iterator ? function(t) {
                return "symbol" == typeof t
            } : function(t) {
                return t instanceof j
            },
            $ = function(t, n, r) {
                return t === U && $(W, n, r), x(t), n = S(n, !0), x(r), i(C, n) ? (r.enumerable ? (i(t, L) && t[L][n] && (t[L][n] = !1), r = _(r, {
                    enumerable: w(0, !1)
                })) : (i(t, L) || A(t, L, w(1, {})), t[L][n] = !0), z(t, n, r)) : A(t, n, r)
            },
            K = function(t, n) {
                x(t);
                for (var r, e = y(n = b(n)), i = 0, o = e.length; o > i;) $(t, r = e[i++], n[r]);
                return t
            },
            J = function(t) {
                var n = k.call(this, t = S(t, !0));
                return !(this === U && i(C, t) && !i(W, t)) && (!(n || !i(this, t) || !i(C, t) || i(this, L) && this[L][t]) || n)
            },
            H = function(t, n) {
                if (t = b(t), n = S(n, !0), t !== U || !i(C, n) || i(W, n)) {
                    var r = M(t, n);
                    return !r || !i(C, n) || i(t, L) && t[L][n] || (r.enumerable = !0), r
                }
            },
            X = function(t) {
                for (var n, r = I(b(t)), e = [], o = 0; r.length > o;) i(C, n = r[o++]) || n == L || n == f || e.push(n);
                return e
            },
            Z = function(t) {
                for (var n, r = t === U, e = I(r ? W : b(t)), o = [], u = 0; e.length > u;) !i(C, n = e[u++]) || r && !i(U, n) || o.push(C[n]);
                return o
            };
        V || (c((j = function() {
            if (this instanceof j) throw TypeError("Symbol is not a constructor!");
            var t = h(arguments.length > 0 ? arguments[0] : void 0),
                n = function(r) {
                    this === U && n.call(W, r), i(this, L) && i(this[L], t) && (this[L][t] = !1), z(this, t, w(1, r))
                };
            return o && G && z(U, t, {
                configurable: !0,
                set: n
            }), q(t)
        }).prototype, "toString", function() {
            return this._k
        }), O.f = H, F.f = $, t(79).f = E.f = X, t(84).f = J, t(80).f = Z, o && !t(65) && c(U, "propertyIsEnumerable", J, !0), p.f = function(t) {
            return q(v(t))
        }), u(u.G + u.W + u.F * !V, {
            Symbol: j
        });
        for (var Q = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), tt = 0; Q.length > tt;) v(Q[tt++]);
        for (var nt = P(v.store), rt = 0; nt.length > rt;) g(nt[rt++]);
        u(u.S + u.F * !V, "Symbol", {
            for: function(t) {
                return i(D, t += "") ? D[t] : D[t] = j(t)
            },
            keyFor: function(t) {
                if (!Y(t)) throw TypeError(t + " is not a symbol!");
                for (var n in D)
                    if (D[n] === t) return n
            },
            useSetter: function() {
                G = !0
            },
            useSimple: function() {
                G = !1
            }
        }), u(u.S + u.F * !V, "Object", {
            create: function(t, n) {
                return void 0 === n ? _(t) : K(_(t), n)
            },
            defineProperty: $,
            defineProperties: K,
            getOwnPropertyDescriptor: H,
            getOwnPropertyNames: X,
            getOwnPropertySymbols: Z
        }), N && u(u.S + u.F * (!V || a(function() {
            var t = j();
            return "[null]" != T([t]) || "{}" != T({
                a: t
            }) || "{}" != T(Object(t))
        })), "JSON", {
            stringify: function(t) {
                for (var n, r, e = [t], i = 1; arguments.length > i;) e.push(arguments[i++]);
                if (r = n = e[1], (m(n) || void 0 !== t) && !Y(t)) return d(n) || (n = function(t, n) {
                    if ("function" == typeof r && (n = r.call(this, t, n)), !Y(n)) return n
                }), e[1] = n, T.apply(N, e)
            }
        }), j.prototype[R] || t(48)(j.prototype, R, j.prototype.valueOf), l(j, "Symbol"), l(Math, "Math", !0), l(e.JSON, "JSON", !0)
    }, {
        100: 100,
        102: 102,
        116: 116,
        119: 119,
        123: 123,
        126: 126,
        127: 127,
        128: 128,
        16: 16,
        36: 36,
        39: 39,
        40: 40,
        42: 42,
        46: 46,
        47: 47,
        48: 48,
        55: 55,
        57: 57,
        65: 65,
        70: 70,
        74: 74,
        75: 75,
        77: 77,
        78: 78,
        79: 79,
        80: 80,
        83: 83,
        84: 84,
        92: 92,
        94: 94
    }],
    255: [function(t, n, r) {
        "use strict";
        var e = t(40),
            i = t(122),
            o = t(121),
            u = t(16),
            c = t(113),
            f = t(117),
            a = t(57),
            s = t(46).ArrayBuffer,
            l = t(103),
            h = o.ArrayBuffer,
            v = o.DataView,
            p = i.ABV && s.isView,
            g = h.prototype.slice,
            y = i.VIEW;
        e(e.G + e.W + e.F * (s !== h), {
            ArrayBuffer: h
        }), e(e.S + e.F * !i.CONSTR, "ArrayBuffer", {
            isView: function(t) {
                return p && p(t) || a(t) && y in t
            }
        }), e(e.P + e.U + e.F * t(42)(function() {
            return !new h(2).slice(1, void 0).byteLength
        }), "ArrayBuffer", {
            slice: function(t, n) {
                if (void 0 !== g && void 0 === n) return g.call(u(this), t);
                for (var r = u(this).byteLength, e = c(t, r), i = c(void 0 === n ? r : n, r), o = new(l(this, h))(f(i - e)), a = new v(this), s = new v(o), p = 0; e < i;) s.setUint8(p++, a.getUint8(e++));
                return o
            }
        }), t(99)("ArrayBuffer")
    }, {
        103: 103,
        113: 113,
        117: 117,
        121: 121,
        122: 122,
        16: 16,
        40: 40,
        42: 42,
        46: 46,
        57: 57,
        99: 99
    }],
    256: [function(t, n, r) {
        var e = t(40);
        e(e.G + e.W + e.F * !t(122).ABV, {
            DataView: t(121).DataView
        })
    }, {
        121: 121,
        122: 122,
        40: 40
    }],
    257: [function(t, n, r) {
        t(120)("Float32", 4, function(t) {
            return function(n, r, e) {
                return t(this, n, r, e)
            }
        })
    }, {
        120: 120
    }],
    258: [function(t, n, r) {
        t(120)("Float64", 8, function(t) {
            return function(n, r, e) {
                return t(this, n, r, e)
            }
        })
    }, {
        120: 120
    }],
    259: [function(t, n, r) {
        t(120)("Int16", 2, function(t) {
            return function(n, r, e) {
                return t(this, n, r, e)
            }
        })
    }, {
        120: 120
    }],
    260: [function(t, n, r) {
        t(120)("Int32", 4, function(t) {
            return function(n, r, e) {
                return t(this, n, r, e)
            }
        })
    }, {
        120: 120
    }],
    261: [function(t, n, r) {
        t(120)("Int8", 1, function(t) {
            return function(n, r, e) {
                return t(this, n, r, e)
            }
        })
    }, {
        120: 120
    }],
    262: [function(t, n, r) {
        t(120)("Uint16", 2, function(t) {
            return function(n, r, e) {
                return t(this, n, r, e)
            }
        })
    }, {
        120: 120
    }],
    263: [function(t, n, r) {
        t(120)("Uint32", 4, function(t) {
            return function(n, r, e) {
                return t(this, n, r, e)
            }
        })
    }, {
        120: 120
    }],
    264: [function(t, n, r) {
        t(120)("Uint8", 1, function(t) {
            return function(n, r, e) {
                return t(this, n, r, e)
            }
        })
    }, {
        120: 120
    }],
    265: [function(t, n, r) {
        t(120)("Uint8", 1, function(t) {
            return function(n, r, e) {
                return t(this, n, r, e)
            }
        }, !0)
    }, {
        120: 120
    }],
    266: [function(t, n, r) {
        "use strict";
        var e, i = t(20)(0),
            o = t(94),
            u = t(70),
            c = t(73),
            f = t(28),
            a = t(57),
            s = t(42),
            l = t(125),
            h = u.getWeak,
            v = Object.isExtensible,
            p = f.ufstore,
            g = {},
            y = function(t) {
                return function() {
                    return t(this, arguments.length > 0 ? arguments[0] : void 0)
                }
            },
            d = {
                get: function(t) {
                    if (a(t)) {
                        var n = h(t);
                        return !0 === n ? p(l(this, "WeakMap")).get(t) : n ? n[this._i] : void 0
                    }
                },
                set: function(t, n) {
                    return f.def(l(this, "WeakMap"), t, n)
                }
            },
            x = n.exports = t(29)("WeakMap", y, d, f, !0, !0);
        s(function() {
            return 7 != (new x).set((Object.freeze || Object)(g), 7).get(g)
        }) && (c((e = f.getConstructor(y, "WeakMap")).prototype, d), u.NEED = !0, i(["delete", "has", "get", "set"], function(t) {
            var n = x.prototype,
                r = n[t];
            o(n, t, function(n, i) {
                if (a(n) && !v(n)) {
                    this._f || (this._f = new e);
                    var o = this._f[t](n, i);
                    return "set" == t ? this : o
                }
                return r.call(this, n, i)
            })
        }))
    }, {
        125: 125,
        20: 20,
        28: 28,
        29: 29,
        42: 42,
        57: 57,
        70: 70,
        73: 73,
        94: 94
    }],
    267: [function(t, n, r) {
        "use strict";
        var e = t(28),
            i = t(125);
        t(29)("WeakSet", function(t) {
            return function() {
                return t(this, arguments.length > 0 ? arguments[0] : void 0)
            }
        }, {
            add: function(t) {
                return e.def(i(this, "WeakSet"), t, !0)
            }
        }, e, !1, !0)
    }, {
        125: 125,
        28: 28,
        29: 29
    }],
    268: [function(t, n, r) {
        "use strict";
        var e = t(40),
            i = t(19)(!0);
        e(e.P, "Array", {
            includes: function(t) {
                return i(this, t, arguments.length > 1 ? arguments[1] : void 0)
            }
        }), t(13)("includes")
    }, {
        13: 13,
        19: 19,
        40: 40
    }],
    269: [function(t, n, r) {
        var e = t(40),
            i = t(86)(!0);
        e(e.S, "Object", {
            entries: function(t) {
                return i(t)
            }
        })
    }, {
        40: 40,
        86: 86
    }],
    270: [function(t, n, r) {
        var e = t(40),
            i = t(87),
            o = t(116),
            u = t(77),
            c = t(31);
        e(e.S, "Object", {
            getOwnPropertyDescriptors: function(t) {
                for (var n, r, e = o(t), f = u.f, a = i(e), s = {}, l = 0; a.length > l;) void 0 !== (r = f(e, n = a[l++])) && c(s, n, r);
                return s
            }
        })
    }, {
        116: 116,
        31: 31,
        40: 40,
        77: 77,
        87: 87
    }],
    271: [function(t, n, r) {
        var e = t(40),
            i = t(86)(!1);
        e(e.S, "Object", {
            values: function(t) {
                return i(t)
            }
        })
    }, {
        40: 40,
        86: 86
    }],
    272: [function(t, n, r) {
        "use strict";
        var e = t(40),
            i = t(30),
            o = t(46),
            u = t(103),
            c = t(91);
        e(e.P + e.R, "Promise", {
            finally: function(t) {
                var n = u(this, i.Promise || o.Promise),
                    r = "function" == typeof t;
                return this.then(r ? function(r) {
                    return c(n, t()).then(function() {
                        return r
                    })
                } : t, r ? function(r) {
                    return c(n, t()).then(function() {
                        throw r
                    })
                } : t)
            }
        })
    }, {
        103: 103,
        30: 30,
        40: 40,
        46: 46,
        91: 91
    }],
    273: [function(t, n, r) {
        "use strict";
        var e = t(40),
            i = t(108),
            o = t(124);
        e(e.P + e.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(o), "String", {
            padEnd: function(t) {
                return i(this, t, arguments.length > 1 ? arguments[1] : void 0, !1)
            }
        })
    }, {
        108: 108,
        124: 124,
        40: 40
    }],
    274: [function(t, n, r) {
        "use strict";
        var e = t(40),
            i = t(108),
            o = t(124);
        e(e.P + e.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(o), "String", {
            padStart: function(t) {
                return i(this, t, arguments.length > 1 ? arguments[1] : void 0, !0)
            }
        })
    }, {
        108: 108,
        124: 124,
        40: 40
    }],
    275: [function(t, n, r) {
        t(126)("asyncIterator")
    }, {
        126: 126
    }],
    276: [function(t, n, r) {
        for (var e = t(140), i = t(83), o = t(94), u = t(46), c = t(48), f = t(64), a = t(128), s = a("iterator"), l = a("toStringTag"), h = f.Array, v = {
                CSSRuleList: !0,
                CSSStyleDeclaration: !1,
                CSSValueList: !1,
                ClientRectList: !1,
                DOMRectList: !1,
                DOMStringList: !1,
                DOMTokenList: !0,
                DataTransferItemList: !1,
                FileList: !1,
                HTMLAllCollection: !1,
                HTMLCollection: !1,
                HTMLFormElement: !1,
                HTMLSelectElement: !1,
                MediaList: !0,
                MimeTypeArray: !1,
                NamedNodeMap: !1,
                NodeList: !0,
                PaintRequestList: !1,
                Plugin: !1,
                PluginArray: !1,
                SVGLengthList: !1,
                SVGNumberList: !1,
                SVGPathSegList: !1,
                SVGPointList: !1,
                SVGStringList: !1,
                SVGTransformList: !1,
                SourceBufferList: !1,
                StyleSheetList: !0,
                TextTrackCueList: !1,
                TextTrackList: !1,
                TouchList: !1
            }, p = i(v), g = 0; g < p.length; g++) {
            var y, d = p[g],
                x = v[d],
                m = u[d],
                b = m && m.prototype;
            if (b && (b[s] || c(b, s, h), b[l] || c(b, l, d), f[d] = h, x))
                for (y in e) b[y] || o(b, y, e[y], !0)
        }
    }, {
        128: 128,
        140: 140,
        46: 46,
        48: 48,
        64: 64,
        83: 83,
        94: 94
    }],
    277: [function(t, n, r) {
        var e = t(40),
            i = t(112);
        e(e.G + e.B, {
            setImmediate: i.set,
            clearImmediate: i.clear
        })
    }, {
        112: 112,
        40: 40
    }],
    278: [function(t, n, r) {
        var e = t(46),
            i = t(40),
            o = t(124),
            u = [].slice,
            c = /MSIE .\./.test(o),
            f = function(t) {
                return function(n, r) {
                    var e = arguments.length > 2,
                        i = !!e && u.call(arguments, 2);
                    return t(e ? function() {
                        ("function" == typeof n ? n : Function(n)).apply(this, i)
                    } : n, r)
                }
            };
        i(i.G + i.B + i.F * c, {
            setTimeout: f(e.setTimeout),
            setInterval: f(e.setInterval)
        })
    }, {
        124: 124,
        40: 40,
        46: 46
    }],
    279: [function(t, n, r) {
        t(278), t(277), t(276), n.exports = t(30)
    }, {
        276: 276,
        277: 277,
        278: 278,
        30: 30
    }],
    280: [function(t, n, r) {
        ! function(t) {
            "use strict";

            function r(t, n, r, o) {
                var u = n && n.prototype instanceof i ? n : i,
                    c = Object.create(u.prototype),
                    f = new h(o || []);
                return c._invoke = function(t, n, r) {
                    var i = E;
                    return function(o, u) {
                        if (i === F) throw new Error("Generator is already running");
                        if (i === P) {
                            if ("throw" === o) throw u;
                            return p()
                        }
                        for (r.method = o, r.arg = u;;) {
                            var c = r.delegate;
                            if (c) {
                                var f = a(c, r);
                                if (f) {
                                    if (f === M) continue;
                                    return f
                                }
                            }
                            if ("next" === r.method) r.sent = r._sent = r.arg;
                            else if ("throw" === r.method) {
                                if (i === E) throw i = P, r.arg;
                                r.dispatchException(r.arg)
                            } else "return" === r.method && r.abrupt("return", r.arg);
                            i = F;
                            var s = e(t, n, r);
                            if ("normal" === s.type) {
                                if (i = r.done ? P : O, s.arg === M) continue;
                                return {
                                    value: s.arg,
                                    done: r.done
                                }
                            }
                            "throw" === s.type && (i = P, r.method = "throw", r.arg = s.arg)
                        }
                    }
                }(t, r, f), c
            }

            function e(t, n, r) {
                try {
                    return {
                        type: "normal",
                        arg: t.call(n, r)
                    }
                } catch (t) {
                    return {
                        type: "throw",
                        arg: t
                    }
                }
            }

            function i() {}

            function o() {}

            function u() {}

            function c(t) {
                ["next", "throw", "return"].forEach(function(n) {
                    t[n] = function(t) {
                        return this._invoke(n, t)
                    }
                })
            }

            function f(t) {
                function n(r, i, o, u) {
                    var c = e(t[r], t, i);
                    if ("throw" !== c.type) {
                        var f = c.arg,
                            a = f.value;
                        return a && "object" == typeof a && d.call(a, "__await") ? Promise.resolve(a.__await).then(function(t) {
                            n("next", t, o, u)
                        }, function(t) {
                            n("throw", t, o, u)
                        }) : Promise.resolve(a).then(function(t) {
                            f.value = t, o(f)
                        }, function(t) {
                            return n("throw", t, o, u)
                        })
                    }
                    u(c.arg)
                }
                var r;
                this._invoke = function(t, e) {
                    function i() {
                        return new Promise(function(r, i) {
                            n(t, e, r, i)
                        })
                    }
                    return r = r ? r.then(i, i) : i()
                }
            }

            function a(t, n) {
                var r = t.iterator[n.method];
                if (r === g) {
                    if (n.delegate = null, "throw" === n.method) {
                        if (t.iterator.return && (n.method = "return", n.arg = g, a(t, n), "throw" === n.method)) return M;
                        n.method = "throw", n.arg = new TypeError("The iterator does not provide a 'throw' method")
                    }
                    return M
                }
                var i = e(r, t.iterator, n.arg);
                if ("throw" === i.type) return n.method = "throw", n.arg = i.arg, n.delegate = null, M;
                var o = i.arg;
                return o ? o.done ? (n[t.resultName] = o.value, n.next = t.nextLoc, "return" !== n.method && (n.method = "next", n.arg = g), n.delegate = null, M) : o : (n.method = "throw", n.arg = new TypeError("iterator result is not an object"), n.delegate = null, M)
            }

            function s(t) {
                var n = {
                    tryLoc: t[0]
                };
                1 in t && (n.catchLoc = t[1]), 2 in t && (n.finallyLoc = t[2], n.afterLoc = t[3]), this.tryEntries.push(n)
            }

            function l(t) {
                var n = t.completion || {};
                n.type = "normal", delete n.arg, t.completion = n
            }

            function h(t) {
                this.tryEntries = [{
                    tryLoc: "root"
                }], t.forEach(s, this), this.reset(!0)
            }

            function v(t) {
                if (t) {
                    var n = t[m];
                    if (n) return n.call(t);
                    if ("function" == typeof t.next) return t;
                    if (!isNaN(t.length)) {
                        var r = -1,
                            e = function n() {
                                for (; ++r < t.length;)
                                    if (d.call(t, r)) return n.value = t[r], n.done = !1, n;
                                return n.value = g, n.done = !0, n
                            };
                        return e.next = e
                    }
                }
                return {
                    next: p
                }
            }

            function p() {
                return {
                    value: g,
                    done: !0
                }
            }
            var g, y = Object.prototype,
                d = y.hasOwnProperty,
                x = "function" == typeof Symbol ? Symbol : {},
                m = x.iterator || "@@iterator",
                b = x.asyncIterator || "@@asyncIterator",
                S = x.toStringTag || "@@toStringTag",
                w = "object" == typeof n,
                _ = t.regeneratorRuntime;
            if (_) w && (n.exports = _);
            else {
                (_ = t.regeneratorRuntime = w ? n.exports : {}).wrap = r;
                var E = "suspendedStart",
                    O = "suspendedYield",
                    F = "executing",
                    P = "completed",
                    M = {},
                    A = {};
                A[m] = function() {
                    return this
                };
                var I = Object.getPrototypeOf,
                    j = I && I(I(v([])));
                j && j !== y && d.call(j, m) && (A = j);
                var N = u.prototype = i.prototype = Object.create(A);
                o.prototype = N.constructor = u, u.constructor = o, u[S] = o.displayName = "GeneratorFunction", _.isGeneratorFunction = function(t) {
                    var n = "function" == typeof t && t.constructor;
                    return !!n && (n === o || "GeneratorFunction" === (n.displayName || n.name))
                }, _.mark = function(t) {
                    return Object.setPrototypeOf ? Object.setPrototypeOf(t, u) : (t.__proto__ = u, S in t || (t[S] = "GeneratorFunction")), t.prototype = Object.create(N), t
                }, _.awrap = function(t) {
                    return {
                        __await: t
                    }
                }, c(f.prototype), f.prototype[b] = function() {
                    return this
                }, _.AsyncIterator = f, _.async = function(t, n, e, i) {
                    var o = new f(r(t, n, e, i));
                    return _.isGeneratorFunction(n) ? o : o.next().then(function(t) {
                        return t.done ? t.value : o.next()
                    })
                }, c(N), N[S] = "Generator", N[m] = function() {
                    return this
                }, N.toString = function() {
                    return "[object Generator]"
                }, _.keys = function(t) {
                    var n = [];
                    for (var r in t) n.push(r);
                    return n.reverse(),
                        function r() {
                            for (; n.length;) {
                                var e = n.pop();
                                if (e in t) return r.value = e, r.done = !1, r
                            }
                            return r.done = !0, r
                        }
                }, _.values = v, h.prototype = {
                    constructor: h,
                    reset: function(t) {
                        if (this.prev = 0, this.next = 0, this.sent = this._sent = g, this.done = !1, this.delegate = null, this.method = "next", this.arg = g, this.tryEntries.forEach(l), !t)
                            for (var n in this) "t" === n.charAt(0) && d.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = g)
                    },
                    stop: function() {
                        this.done = !0;
                        var t = this.tryEntries[0].completion;
                        if ("throw" === t.type) throw t.arg;
                        return this.rval
                    },
                    dispatchException: function(t) {
                        function n(n, e) {
                            return o.type = "throw", o.arg = t, r.next = n, e && (r.method = "next", r.arg = g), !!e
                        }
                        if (this.done) throw t;
                        for (var r = this, e = this.tryEntries.length - 1; e >= 0; --e) {
                            var i = this.tryEntries[e],
                                o = i.completion;
                            if ("root" === i.tryLoc) return n("end");
                            if (i.tryLoc <= this.prev) {
                                var u = d.call(i, "catchLoc"),
                                    c = d.call(i, "finallyLoc");
                                if (u && c) {
                                    if (this.prev < i.catchLoc) return n(i.catchLoc, !0);
                                    if (this.prev < i.finallyLoc) return n(i.finallyLoc)
                                } else if (u) {
                                    if (this.prev < i.catchLoc) return n(i.catchLoc, !0)
                                } else {
                                    if (!c) throw new Error("try statement without catch or finally");
                                    if (this.prev < i.finallyLoc) return n(i.finallyLoc)
                                }
                            }
                        }
                    },
                    abrupt: function(t, n) {
                        for (var r = this.tryEntries.length - 1; r >= 0; --r) {
                            var e = this.tryEntries[r];
                            if (e.tryLoc <= this.prev && d.call(e, "finallyLoc") && this.prev < e.finallyLoc) {
                                var i = e;
                                break
                            }
                        }
                        i && ("break" === t || "continue" === t) && i.tryLoc <= n && n <= i.finallyLoc && (i = null);
                        var o = i ? i.completion : {};
                        return o.type = t, o.arg = n, i ? (this.method = "next", this.next = i.finallyLoc, M) : this.complete(o)
                    },
                    complete: function(t, n) {
                        if ("throw" === t.type) throw t.arg;
                        return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && n && (this.next = n), M
                    },
                    finish: function(t) {
                        for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                            var r = this.tryEntries[n];
                            if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), l(r), M
                        }
                    },
                    catch: function(t) {
                        for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                            var r = this.tryEntries[n];
                            if (r.tryLoc === t) {
                                var e = r.completion;
                                if ("throw" === e.type) {
                                    var i = e.arg;
                                    l(r)
                                }
                                return i
                            }
                        }
                        throw new Error("illegal catch attempt")
                    },
                    delegateYield: function(t, n, r) {
                        return this.delegate = {
                            iterator: v(t),
                            resultName: n,
                            nextLoc: r
                        }, "next" === this.method && (this.arg = g), M
                    }
                }
            }
        }(function() {
            return this || "object" == typeof self && self
        }() || Function("return this")())
    }, {}]
}, {}, [1]);
! function(t) {
    var e;
    "object" == typeof exports ? module.exports = t() : ("undefined" != typeof window ? e = window : "undefined" != typeof global ? e = global : "undefined" != typeof self && (e = self), e.p2 = t())
}(function() {
    return function t(e, i, s) {
        function n(o, a) {
            if (!i[o]) {
                if (!e[o]) {
                    var h = "function" == typeof require && require;
                    if (!a && h) return h(o, !0);
                    if (r) return r(o, !0);
                    throw new Error("Cannot find module '" + o + "'")
                }
                var l = i[o] = {
                    exports: {}
                };
                e[o][0].call(l.exports, function(t) {
                    return n(e[o][1][t] || t)
                }, l, l.exports, t, e, i, s)
            }
            return i[o].exports
        }
        for (var r = "function" == typeof require && require, o = 0; o < s.length; o++) n(s[o]);
        return n
    }({
        1: [function(t, e, i) {
            function s() {}
            var n = t("./Scalar");
            e.exports = s, s.lineInt = function(t, e, i) {
                i = i || 0;
                var s, r, o, a, h, l, c, u = [0, 0];
                return s = t[1][1] - t[0][1], r = t[0][0] - t[1][0], o = s * t[0][0] + r * t[0][1], a = e[1][1] - e[0][1], h = e[0][0] - e[1][0], l = a * e[0][0] + h * e[0][1], c = s * h - a * r, n.eq(c, 0, i) || (u[0] = (h * o - r * l) / c, u[1] = (s * l - a * o) / c), u
            }, s.segmentsIntersect = function(t, e, i, s) {
                var n = e[0] - t[0],
                    r = e[1] - t[1],
                    o = s[0] - i[0],
                    a = s[1] - i[1];
                if (o * r - a * n == 0) return !1;
                var h = (n * (i[1] - t[1]) + r * (t[0] - i[0])) / (o * r - a * n),
                    l = (o * (t[1] - i[1]) + a * (i[0] - t[0])) / (a * n - o * r);
                return h >= 0 && h <= 1 && l >= 0 && l <= 1
            }
        }, {
            "./Scalar": 4
        }],
        2: [function(t, e, i) {
            function s() {}
            e.exports = s, s.area = function(t, e, i) {
                return (e[0] - t[0]) * (i[1] - t[1]) - (i[0] - t[0]) * (e[1] - t[1])
            }, s.left = function(t, e, i) {
                return s.area(t, e, i) > 0
            }, s.leftOn = function(t, e, i) {
                return s.area(t, e, i) >= 0
            }, s.right = function(t, e, i) {
                return s.area(t, e, i) < 0
            }, s.rightOn = function(t, e, i) {
                return s.area(t, e, i) <= 0
            };
            var n = [],
                r = [];
            s.collinear = function(t, e, i, o) {
                if (o) {
                    var a = n,
                        h = r;
                    a[0] = e[0] - t[0], a[1] = e[1] - t[1], h[0] = i[0] - e[0], h[1] = i[1] - e[1];
                    var l = a[0] * h[0] + a[1] * h[1],
                        c = Math.sqrt(a[0] * a[0] + a[1] * a[1]),
                        u = Math.sqrt(h[0] * h[0] + h[1] * h[1]);
                    return Math.acos(l / (c * u)) < o
                }
                return 0 == s.area(t, e, i)
            }, s.sqdist = function(t, e) {
                var i = e[0] - t[0],
                    s = e[1] - t[1];
                return i * i + s * s
            }
        }, {}],
        3: [function(t, e, i) {
            function s() {
                this.vertices = []
            }

            function n(t, e, i, s, n) {
                n = n || 0;
                var r = e[1] - t[1],
                    o = t[0] - e[0],
                    h = r * t[0] + o * t[1],
                    l = s[1] - i[1],
                    c = i[0] - s[0],
                    u = l * i[0] + c * i[1],
                    d = r * c - l * o;
                return a.eq(d, 0, n) ? [0, 0] : [(c * h - o * u) / d, (r * u - l * h) / d]
            }
            var r = t("./Line"),
                o = t("./Point"),
                a = t("./Scalar");
            e.exports = s, s.prototype.at = function(t) {
                var e = this.vertices,
                    i = e.length;
                return e[t < 0 ? t % i + i : t % i]
            }, s.prototype.first = function() {
                return this.vertices[0]
            }, s.prototype.last = function() {
                return this.vertices[this.vertices.length - 1]
            }, s.prototype.clear = function() {
                this.vertices.length = 0
            }, s.prototype.append = function(t, e, i) {
                if (void 0 === e) throw new Error("From is not given!");
                if (void 0 === i) throw new Error("To is not given!");
                if (i - 1 < e) throw new Error("lol1");
                if (i > t.vertices.length) throw new Error("lol2");
                if (e < 0) throw new Error("lol3");
                for (var s = e; s < i; s++) this.vertices.push(t.vertices[s])
            }, s.prototype.makeCCW = function() {
                for (var t = 0, e = this.vertices, i = 1; i < this.vertices.length; ++i)(e[i][1] < e[t][1] || e[i][1] == e[t][1] && e[i][0] > e[t][0]) && (t = i);
                o.left(this.at(t - 1), this.at(t), this.at(t + 1)) || this.reverse()
            }, s.prototype.reverse = function() {
                for (var t = [], e = 0, i = this.vertices.length; e !== i; e++) t.push(this.vertices.pop());
                this.vertices = t
            }, s.prototype.isReflex = function(t) {
                return o.right(this.at(t - 1), this.at(t), this.at(t + 1))
            };
            var h = [],
                l = [];
            s.prototype.canSee = function(t, e) {
                var i, s, n = h,
                    a = l;
                if (o.leftOn(this.at(t + 1), this.at(t), this.at(e)) && o.rightOn(this.at(t - 1), this.at(t), this.at(e))) return !1;
                s = o.sqdist(this.at(t), this.at(e));
                for (var c = 0; c !== this.vertices.length; ++c)
                    if ((c + 1) % this.vertices.length !== t && c !== t && o.leftOn(this.at(t), this.at(e), this.at(c + 1)) && o.rightOn(this.at(t), this.at(e), this.at(c)) && (n[0] = this.at(t), n[1] = this.at(e), a[0] = this.at(c), a[1] = this.at(c + 1), i = r.lineInt(n, a), o.sqdist(this.at(t), i) < s)) return !1;
                return !0
            }, s.prototype.copy = function(t, e, i) {
                var n = i || new s;
                if (n.clear(), t < e)
                    for (r = t; r <= e; r++) n.vertices.push(this.vertices[r]);
                else {
                    for (r = 0; r <= e; r++) n.vertices.push(this.vertices[r]);
                    for (var r = t; r < this.vertices.length; r++) n.vertices.push(this.vertices[r])
                }
                return n
            }, s.prototype.getCutEdges = function() {
                for (var t = [], e = [], i = [], n = new s, r = Number.MAX_VALUE, o = 0; o < this.vertices.length; ++o)
                    if (this.isReflex(o))
                        for (var a = 0; a < this.vertices.length; ++a)
                            if (this.canSee(o, a)) {
                                e = this.copy(o, a, n).getCutEdges(), i = this.copy(a, o, n).getCutEdges();
                                for (var h = 0; h < i.length; h++) e.push(i[h]);
                                e.length < r && (t = e, r = e.length, t.push([this.at(o), this.at(a)]))
                            }
                return t
            }, s.prototype.decomp = function() {
                var t = this.getCutEdges();
                return t.length > 0 ? this.slice(t) : [this]
            }, s.prototype.slice = function(t) {
                if (0 == t.length) return [this];
                if (t instanceof Array && t.length && t[0] instanceof Array && 2 == t[0].length && t[0][0] instanceof Array) {
                    for (var e = [this], i = 0; i < t.length; i++)
                        for (var s = t[i], n = 0; n < e.length; n++) {
                            var r = e[n].slice(s);
                            if (r) {
                                e.splice(n, 1), e.push(r[0], r[1]);
                                break
                            }
                        }
                    return e
                }
                s = t, i = this.vertices.indexOf(s[0]), n = this.vertices.indexOf(s[1]);
                return -1 != i && -1 != n && [this.copy(i, n), this.copy(n, i)]
            }, s.prototype.isSimple = function() {
                for (var t = this.vertices, e = 0; e < t.length - 1; e++)
                    for (var i = 0; i < e - 1; i++)
                        if (r.segmentsIntersect(t[e], t[e + 1], t[i], t[i + 1])) return !1;
                for (e = 1; e < t.length - 2; e++)
                    if (r.segmentsIntersect(t[0], t[t.length - 1], t[e], t[e + 1])) return !1;
                return !0
            }, s.prototype.quickDecomp = function(t, e, i, r, a, h) {
                a = a || 100, h = h || 0, r = r || 25, t = void 0 !== t ? t : [], e = e || [], i = i || [];
                var l = [0, 0],
                    c = [0, 0],
                    u = [0, 0],
                    d = 0,
                    p = 0,
                    f = 0,
                    g = 0,
                    m = 0,
                    y = 0,
                    v = 0,
                    x = new s,
                    b = new s,
                    _ = this,
                    w = this.vertices;
                if (w.length < 3) return t;
                if (++h > a) return console.warn("quickDecomp: max level (" + a + ") reached."), t;
                for (var T = 0; T < this.vertices.length; ++T)
                    if (_.isReflex(T)) {
                        for (e.push(_.vertices[T]), d = p = Number.MAX_VALUE, P = 0; P < this.vertices.length; ++P) o.left(_.at(T - 1), _.at(T), _.at(P)) && o.rightOn(_.at(T - 1), _.at(T), _.at(P - 1)) && (u = n(_.at(T - 1), _.at(T), _.at(P), _.at(P - 1)), o.right(_.at(T + 1), _.at(T), u) && (f = o.sqdist(_.vertices[T], u)) < p && (p = f, c = u, y = P)), o.left(_.at(T + 1), _.at(T), _.at(P + 1)) && o.rightOn(_.at(T + 1), _.at(T), _.at(P)) && (u = n(_.at(T + 1), _.at(T), _.at(P), _.at(P + 1)), o.left(_.at(T - 1), _.at(T), u) && (f = o.sqdist(_.vertices[T], u)) < d && (d = f, l = u, m = P));
                        if (y == (m + 1) % this.vertices.length) u[0] = (c[0] + l[0]) / 2, u[1] = (c[1] + l[1]) / 2, i.push(u), T < m ? (x.append(_, T, m + 1), x.vertices.push(u), b.vertices.push(u), 0 != y && b.append(_, y, _.vertices.length), b.append(_, 0, T + 1)) : (0 != T && x.append(_, T, _.vertices.length), x.append(_, 0, m + 1), x.vertices.push(u), b.vertices.push(u), b.append(_, y, T + 1));
                        else {
                            if (y > m && (m += this.vertices.length), g = Number.MAX_VALUE, m < y) return t;
                            for (var P = y; P <= m; ++P) o.leftOn(_.at(T - 1), _.at(T), _.at(P)) && o.rightOn(_.at(T + 1), _.at(T), _.at(P)) && (f = o.sqdist(_.at(T), _.at(P))) < g && (g = f, v = P % this.vertices.length);
                            T < v ? (x.append(_, T, v + 1), 0 != v && b.append(_, v, w.length), b.append(_, 0, T + 1)) : (0 != T && x.append(_, T, w.length), x.append(_, 0, v + 1), b.append(_, v, T + 1))
                        }
                        return x.vertices.length < b.vertices.length ? (x.quickDecomp(t, e, i, r, a, h), b.quickDecomp(t, e, i, r, a, h)) : (b.quickDecomp(t, e, i, r, a, h), x.quickDecomp(t, e, i, r, a, h)), t
                    }
                return t.push(this), t
            }, s.prototype.removeCollinearPoints = function(t) {
                for (var e = 0, i = this.vertices.length - 1; this.vertices.length > 3 && i >= 0; --i) o.collinear(this.at(i - 1), this.at(i), this.at(i + 1), t) && (this.vertices.splice(i % this.vertices.length, 1), i--, e++);
                return e
            }
        }, {
            "./Line": 1,
            "./Point": 2,
            "./Scalar": 4
        }],
        4: [function(t, e, i) {
            function s() {}
            e.exports = s, s.eq = function(t, e, i) {
                return i = i || 0, Math.abs(t - e) < i
            }
        }, {}],
        5: [function(t, e, i) {
            e.exports = {
                Polygon: t("./Polygon"),
                Point: t("./Point")
            }
        }, {
            "./Point": 2,
            "./Polygon": 3
        }],
        6: [function(t, e, i) {
            e.exports = {
                name: "p2",
                version: "0.7.1",
                description: "A JavaScript 2D physics engine.",
                author: "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
                keywords: ["p2.js", "p2", "physics", "engine", "2d"],
                main: "./src/p2.js",
                engines: {
                    node: "*"
                },
                repository: {
                    type: "git",
                    url: "https://github.com/schteppe/p2.js.git"
                },
                bugs: {
                    url: "https://github.com/schteppe/p2.js/issues"
                },
                licenses: [{
                    type: "MIT"
                }],
                devDependencies: {
                    grunt: "^0.4.5",
                    "grunt-contrib-jshint": "^0.11.2",
                    "grunt-contrib-nodeunit": "^0.4.1",
                    "grunt-contrib-uglify": "~0.4.0",
                    "grunt-contrib-watch": "~0.5.0",
                    "grunt-browserify": "~2.0.1",
                    "grunt-contrib-concat": "^0.4.0"
                },
                dependencies: {
                    "poly-decomp": "0.1.1"
                }
            }
        }, {}],
        7: [function(t, e, i) {
            function s(t) {
                this.lowerBound = n.create(), t && t.lowerBound && n.copy(this.lowerBound, t.lowerBound), this.upperBound = n.create(), t && t.upperBound && n.copy(this.upperBound, t.upperBound)
            }
            var n = t("../math/vec2");
            t("../utils/Utils"), e.exports = s;
            var r = n.create();
            s.prototype.setFromPoints = function(t, e, i, s) {
                var o = this.lowerBound,
                    a = this.upperBound;
                "number" != typeof i && (i = 0), 0 !== i ? n.rotate(o, t[0], i) : n.copy(o, t[0]), n.copy(a, o);
                for (var h = Math.cos(i), l = Math.sin(i), c = 1; c < t.length; c++) {
                    var u = t[c];
                    if (0 !== i) {
                        var d = u[0],
                            p = u[1];
                        r[0] = h * d - l * p, r[1] = l * d + h * p, u = r
                    }
                    for (var f = 0; f < 2; f++) u[f] > a[f] && (a[f] = u[f]), u[f] < o[f] && (o[f] = u[f])
                }
                e && (n.add(this.lowerBound, this.lowerBound, e), n.add(this.upperBound, this.upperBound, e)), s && (this.lowerBound[0] -= s, this.lowerBound[1] -= s, this.upperBound[0] += s, this.upperBound[1] += s)
            }, s.prototype.copy = function(t) {
                n.copy(this.lowerBound, t.lowerBound), n.copy(this.upperBound, t.upperBound)
            }, s.prototype.extend = function(t) {
                for (var e = 2; e--;) {
                    var i = t.lowerBound[e];
                    this.lowerBound[e] > i && (this.lowerBound[e] = i);
                    var s = t.upperBound[e];
                    this.upperBound[e] < s && (this.upperBound[e] = s)
                }
            }, s.prototype.overlaps = function(t) {
                var e = this.lowerBound,
                    i = this.upperBound,
                    s = t.lowerBound,
                    n = t.upperBound;
                return (s[0] <= i[0] && i[0] <= n[0] || e[0] <= n[0] && n[0] <= i[0]) && (s[1] <= i[1] && i[1] <= n[1] || e[1] <= n[1] && n[1] <= i[1])
            }, s.prototype.containsPoint = function(t) {
                var e = this.lowerBound,
                    i = this.upperBound;
                return e[0] <= t[0] && t[0] <= i[0] && e[1] <= t[1] && t[1] <= i[1]
            }, s.prototype.overlapsRay = function(t) {
                var e = 1 / t.direction[0],
                    i = 1 / t.direction[1],
                    s = (this.lowerBound[0] - t.from[0]) * e,
                    n = (this.upperBound[0] - t.from[0]) * e,
                    r = (this.lowerBound[1] - t.from[1]) * i,
                    o = (this.upperBound[1] - t.from[1]) * i,
                    a = Math.max(Math.max(Math.min(s, n), Math.min(r, o))),
                    h = Math.min(Math.min(Math.max(s, n), Math.max(r, o)));
                return h < 0 ? -1 : a > h ? -1 : a
            }
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57
        }],
        8: [function(t, e, i) {
            function s(t) {
                this.type = t, this.result = [], this.world = null, this.boundingVolumeType = s.AABB
            }
            var n = t("../math/vec2"),
                r = t("../objects/Body");
            e.exports = s, s.AABB = 1, s.BOUNDING_CIRCLE = 2, s.prototype.setWorld = function(t) {
                this.world = t
            }, s.prototype.getCollisionPairs = function(t) {};
            var o = n.create();
            s.boundingRadiusCheck = function(t, e) {
                n.sub(o, t.position, e.position);
                var i = n.squaredLength(o),
                    s = t.boundingRadius + e.boundingRadius;
                return i <= s * s
            }, s.aabbCheck = function(t, e) {
                return t.getAABB().overlaps(e.getAABB())
            }, s.prototype.boundingVolumeCheck = function(t, e) {
                var i;
                switch (this.boundingVolumeType) {
                    case s.BOUNDING_CIRCLE:
                        i = s.boundingRadiusCheck(t, e);
                        break;
                    case s.AABB:
                        i = s.aabbCheck(t, e);
                        break;
                    default:
                        throw new Error("Bounding volume type not recognized: " + this.boundingVolumeType)
                }
                return i
            }, s.canCollide = function(t, e) {
                var i = r.KINEMATIC,
                    s = r.STATIC;
                return !(t.type === s && e.type === s || t.type === i && e.type === s || t.type === s && e.type === i || t.type === i && e.type === i || t.sleepState === r.SLEEPING && e.sleepState === r.SLEEPING || t.sleepState === r.SLEEPING && e.type === s || e.sleepState === r.SLEEPING && t.type === s)
            }, s.NAIVE = 1, s.SAP = 2
        }, {
            "../math/vec2": 30,
            "../objects/Body": 31
        }],
        9: [function(t, e, i) {
            function s() {
                n.call(this, n.NAIVE)
            }
            t("../shapes/Circle"), t("../shapes/Plane"), t("../shapes/Shape"), t("../shapes/Particle");
            var n = t("../collision/Broadphase");
            t("../math/vec2"), e.exports = s, (s.prototype = new n).constructor = s, s.prototype.getCollisionPairs = function(t) {
                var e = t.bodies,
                    i = this.result;
                i.length = 0;
                for (var s = 0, r = e.length; s !== r; s++)
                    for (var o = e[s], a = 0; a < s; a++) {
                        var h = e[a];
                        n.canCollide(o, h) && this.boundingVolumeCheck(o, h) && i.push(o, h)
                    }
                return i
            }, s.prototype.aabbQuery = function(t, e, i) {
                i = i || [];
                for (var s = t.bodies, n = 0; n < s.length; n++) {
                    var r = s[n];
                    r.aabbNeedsUpdate && r.updateAABB(), r.aabb.overlaps(e) && i.push(r)
                }
                return i
            }
        }, {
            "../collision/Broadphase": 8,
            "../math/vec2": 30,
            "../shapes/Circle": 39,
            "../shapes/Particle": 43,
            "../shapes/Plane": 44,
            "../shapes/Shape": 45
        }],
        10: [function(t, e, i) {
            function s() {
                this.contactEquations = [], this.frictionEquations = [], this.enableFriction = !0, this.enabledEquations = !0, this.slipForce = 10, this.frictionCoefficient = .3, this.surfaceVelocity = 0, this.contactEquationPool = new c({
                    size: 32
                }), this.frictionEquationPool = new u({
                    size: 64
                }), this.restitution = 0, this.stiffness = p.DEFAULT_STIFFNESS, this.relaxation = p.DEFAULT_RELAXATION, this.frictionStiffness = p.DEFAULT_STIFFNESS, this.frictionRelaxation = p.DEFAULT_RELAXATION, this.enableFrictionReduction = !0, this.collidingBodiesLastStep = new d, this.contactSkinSize = .01
            }

            function n(t, e) {
                o.set(t.vertices[0], .5 * -e.length, -e.radius), o.set(t.vertices[1], .5 * e.length, -e.radius), o.set(t.vertices[2], .5 * e.length, e.radius), o.set(t.vertices[3], .5 * -e.length, e.radius)
            }

            function r(t, e, i, s) {
                for (var n = H, r = q, l = Y, c = z, u = t, d = e.vertices, p = null, f = 0; f !== d.length + 1; f++) {
                    var g = d[f % d.length],
                        m = d[(f + 1) % d.length];
                    o.rotate(n, g, s), o.rotate(r, m, s), h(n, n, i), h(r, r, i), a(l, n, u), a(c, r, u);
                    var y = o.crossLength(l, c);
                    if (null === p && (p = y), y * p <= 0) return !1;
                    p = y
                }
                return !0
            }
            var o = t("../math/vec2"),
                a = o.sub,
                h = o.add,
                l = o.dot,
                c = (t("../utils/Utils"), t("../utils/ContactEquationPool")),
                u = t("../utils/FrictionEquationPool"),
                d = t("../utils/TupleDictionary"),
                p = t("../equations/Equation"),
                f = (t("../equations/ContactEquation"), t("../equations/FrictionEquation"), t("../shapes/Circle")),
                g = t("../shapes/Convex"),
                m = t("../shapes/Shape"),
                y = (t("../objects/Body"), t("../shapes/Box"));
            e.exports = s;
            var v = o.fromValues(0, 1),
                x = o.fromValues(0, 0),
                b = o.fromValues(0, 0),
                _ = o.fromValues(0, 0),
                w = o.fromValues(0, 0),
                T = o.fromValues(0, 0),
                P = o.fromValues(0, 0),
                C = o.fromValues(0, 0),
                S = o.fromValues(0, 0),
                A = o.fromValues(0, 0),
                E = o.fromValues(0, 0),
                M = o.fromValues(0, 0),
                R = o.fromValues(0, 0),
                L = o.fromValues(0, 0),
                B = o.fromValues(0, 0),
                I = o.fromValues(0, 0),
                O = o.fromValues(0, 0),
                k = o.fromValues(0, 0),
                F = o.fromValues(0, 0),
                D = [],
                U = o.create(),
                G = o.create();
            s.prototype.bodiesOverlap = function(t, e) {
                for (var i = U, s = G, n = 0, r = t.shapes.length; n !== r; n++) {
                    var o = t.shapes[n];
                    t.toWorldFrame(i, o.position);
                    for (var a = 0, h = e.shapes.length; a !== h; a++) {
                        var l = e.shapes[a];
                        if (e.toWorldFrame(s, l.position), this[o.type | l.type](t, o, i, o.angle + t.angle, e, l, s, l.angle + e.angle, !0)) return !0
                    }
                }
                return !1
            }, s.prototype.collidedLastStep = function(t, e) {
                var i = 0 | t.id,
                    s = 0 | e.id;
                return !!this.collidingBodiesLastStep.get(i, s)
            }, s.prototype.reset = function() {
                this.collidingBodiesLastStep.reset();
                for (var t = this.contactEquations, e = t.length; e--;) {
                    var i = t[e],
                        s = i.bodyA.id,
                        n = i.bodyB.id;
                    this.collidingBodiesLastStep.set(s, n, !0)
                }
                for (var r = this.contactEquations, o = this.frictionEquations, a = 0; a < r.length; a++) this.contactEquationPool.release(r[a]);
                for (a = 0; a < o.length; a++) this.frictionEquationPool.release(o[a]);
                this.contactEquations.length = this.frictionEquations.length = 0
            }, s.prototype.createContactEquation = function(t, e, i, s) {
                var n = this.contactEquationPool.get();
                return n.bodyA = t, n.bodyB = e, n.shapeA = i, n.shapeB = s, n.restitution = this.restitution, n.firstImpact = !this.collidedLastStep(t, e), n.stiffness = this.stiffness, n.relaxation = this.relaxation, n.needsUpdate = !0, n.enabled = this.enabledEquations, n.offset = this.contactSkinSize, n
            }, s.prototype.createFrictionEquation = function(t, e, i, s) {
                var n = this.frictionEquationPool.get();
                return n.bodyA = t, n.bodyB = e, n.shapeA = i, n.shapeB = s, n.setSlipForce(this.slipForce), n.frictionCoefficient = this.frictionCoefficient, n.relativeVelocity = this.surfaceVelocity, n.enabled = this.enabledEquations, n.needsUpdate = !0, n.stiffness = this.frictionStiffness, n.relaxation = this.frictionRelaxation, n.contactEquations.length = 0, n
            }, s.prototype.createFrictionFromContact = function(t) {
                var e = this.createFrictionEquation(t.bodyA, t.bodyB, t.shapeA, t.shapeB);
                return o.copy(e.contactPointA, t.contactPointA), o.copy(e.contactPointB, t.contactPointB), o.rotate90cw(e.t, t.normalA), e.contactEquations.push(t), e
            }, s.prototype.createFrictionFromAverage = function(t) {
                var e = this.contactEquations[this.contactEquations.length - 1],
                    i = this.createFrictionEquation(e.bodyA, e.bodyB, e.shapeA, e.shapeB),
                    s = e.bodyA;
                e.bodyB, o.set(i.contactPointA, 0, 0), o.set(i.contactPointB, 0, 0), o.set(i.t, 0, 0);
                for (var n = 0; n !== t; n++)(e = this.contactEquations[this.contactEquations.length - 1 - n]).bodyA === s ? (o.add(i.t, i.t, e.normalA), o.add(i.contactPointA, i.contactPointA, e.contactPointA), o.add(i.contactPointB, i.contactPointB, e.contactPointB)) : (o.sub(i.t, i.t, e.normalA), o.add(i.contactPointA, i.contactPointA, e.contactPointB), o.add(i.contactPointB, i.contactPointB, e.contactPointA)), i.contactEquations.push(e);
                var r = 1 / t;
                return o.scale(i.contactPointA, i.contactPointA, r), o.scale(i.contactPointB, i.contactPointB, r), o.normalize(i.t, i.t), o.rotate90cw(i.t, i.t), i
            }, s.prototype[m.LINE | m.CONVEX] = s.prototype.convexLine = function(t, e, i, s, n, r, o, a, h) {
                return !h && 0
            }, s.prototype[m.LINE | m.BOX] = s.prototype.lineBox = function(t, e, i, s, n, r, o, a, h) {
                return !h && 0
            };
            var N = new y({
                    width: 1,
                    height: 1
                }),
                X = o.create();
            s.prototype[m.CAPSULE | m.CONVEX] = s.prototype[m.CAPSULE | m.BOX] = s.prototype.convexCapsule = function(t, e, i, s, r, a, h, l, c) {
                var u = X;
                o.set(u, a.length / 2, 0), o.rotate(u, u, l), o.add(u, u, h);
                var d = this.circleConvex(r, a, u, l, t, e, i, s, c, a.radius);
                o.set(u, -a.length / 2, 0), o.rotate(u, u, l), o.add(u, u, h);
                var p = this.circleConvex(r, a, u, l, t, e, i, s, c, a.radius);
                if (c && (d || p)) return !0;
                var f = N;
                return n(f, a), this.convexConvex(t, e, i, s, r, f, h, l, c) + d + p
            }, s.prototype[m.CAPSULE | m.LINE] = s.prototype.lineCapsule = function(t, e, i, s, n, r, o, a, h) {
                return !h && 0
            };
            var W = o.create(),
                j = o.create(),
                V = new y({
                    width: 1,
                    height: 1
                });
            s.prototype[m.CAPSULE | m.CAPSULE] = s.prototype.capsuleCapsule = function(t, e, i, s, r, a, h, l, c) {
                for (var u = W, d = j, p = 0, f = 0; f < 2; f++) {
                    o.set(u, (0 === f ? -1 : 1) * e.length / 2, 0), o.rotate(u, u, s), o.add(u, u, i);
                    for (var g = 0; g < 2; g++) {
                        o.set(d, (0 === g ? -1 : 1) * a.length / 2, 0), o.rotate(d, d, l), o.add(d, d, h), this.enableFrictionReduction && (x = this.enableFriction, this.enableFriction = !1);
                        var m = this.circleCircle(t, e, u, s, r, a, d, l, c, e.radius, a.radius);
                        if (this.enableFrictionReduction && (this.enableFriction = x), c && m) return !0;
                        p += m
                    }
                }
                this.enableFrictionReduction && (x = this.enableFriction, this.enableFriction = !1);
                var y = V;
                n(y, e);
                var v = this.convexCapsule(t, y, i, s, r, a, h, l, c);
                if (this.enableFrictionReduction && (this.enableFriction = x), c && v) return !0;
                if (p += v, this.enableFrictionReduction) {
                    var x = this.enableFriction;
                    this.enableFriction = !1
                }
                n(y, a);
                var b = this.convexCapsule(r, y, h, l, t, e, i, s, c);
                return this.enableFrictionReduction && (this.enableFriction = x), !(!c || !b) || (p += b, this.enableFrictionReduction && p && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(p)), p)
            }, s.prototype[m.LINE | m.LINE] = s.prototype.lineLine = function(t, e, i, s, n, r, o, a, h) {
                return !h && 0
            }, s.prototype[m.PLANE | m.LINE] = s.prototype.planeLine = function(t, e, i, s, n, r, c, u, d) {
                var p = x,
                    f = b,
                    g = _,
                    m = w,
                    y = T,
                    E = P,
                    M = C,
                    R = S,
                    L = A,
                    B = D,
                    I = 0;
                o.set(p, -r.length / 2, 0), o.set(f, r.length / 2, 0), o.rotate(g, p, u), o.rotate(m, f, u), h(g, g, c), h(m, m, c), o.copy(p, g), o.copy(f, m), a(y, f, p), o.normalize(E, y), o.rotate90cw(L, E), o.rotate(R, v, s), B[0] = p, B[1] = f;
                for (var O = 0; O < B.length; O++) {
                    var k = B[O];
                    a(M, k, i);
                    var F = l(M, R);
                    if (F < 0) {
                        if (d) return !0;
                        var U = this.createContactEquation(t, n, e, r);
                        I++, o.copy(U.normalA, R), o.normalize(U.normalA, U.normalA), o.scale(M, R, F), a(U.contactPointA, k, M), a(U.contactPointA, U.contactPointA, t.position), a(U.contactPointB, k, c), h(U.contactPointB, U.contactPointB, c), a(U.contactPointB, U.contactPointB, n.position), this.contactEquations.push(U), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(U))
                    }
                }
                return !d && (this.enableFrictionReduction || I && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(I)), I)
            }, s.prototype[m.PARTICLE | m.CAPSULE] = s.prototype.particleCapsule = function(t, e, i, s, n, r, o, a, h) {
                return this.circleLine(t, e, i, s, n, r, o, a, h, r.radius, 0)
            }, s.prototype[m.CIRCLE | m.LINE] = s.prototype.circleLine = function(t, e, i, s, n, r, c, u, d, p, f) {
                p = p || 0, f = void 0 !== f ? f : e.radius;
                var g = x,
                    m = b,
                    y = _,
                    v = w,
                    I = T,
                    O = P,
                    k = C,
                    F = S,
                    U = A,
                    G = E,
                    N = M,
                    X = R,
                    W = L,
                    j = B,
                    V = D;
                o.set(F, -r.length / 2, 0), o.set(U, r.length / 2, 0), o.rotate(G, F, u), o.rotate(N, U, u), h(G, G, c), h(N, N, c), o.copy(F, G), o.copy(U, N), a(O, U, F), o.normalize(k, O), o.rotate90cw(I, k), a(X, i, F);
                var H = l(X, I);
                a(v, F, c), a(W, i, c);
                var q = f + p;
                if (Math.abs(H) < q) {
                    o.scale(g, I, H), a(y, i, g), o.scale(m, I, l(I, W)), o.normalize(m, m), o.scale(m, m, p), h(y, y, m);
                    var Y = l(k, y),
                        z = l(k, F),
                        K = l(k, U);
                    if (Y > z && Y < K) return !!d || (Z = this.createContactEquation(t, n, e, r), o.scale(Z.normalA, g, -1), o.normalize(Z.normalA, Z.normalA), o.scale(Z.contactPointA, Z.normalA, f), h(Z.contactPointA, Z.contactPointA, i), a(Z.contactPointA, Z.contactPointA, t.position), a(Z.contactPointB, y, c), h(Z.contactPointB, Z.contactPointB, c), a(Z.contactPointB, Z.contactPointB, n.position), this.contactEquations.push(Z), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(Z)), 1)
                }
                V[0] = F, V[1] = U;
                for (var J = 0; J < V.length; J++) {
                    var Q = V[J];
                    if (a(X, Q, i), o.squaredLength(X) < Math.pow(q, 2)) {
                        if (d) return !0;
                        var Z = this.createContactEquation(t, n, e, r);
                        return o.copy(Z.normalA, X), o.normalize(Z.normalA, Z.normalA), o.scale(Z.contactPointA, Z.normalA, f), h(Z.contactPointA, Z.contactPointA, i), a(Z.contactPointA, Z.contactPointA, t.position), a(Z.contactPointB, Q, c), o.scale(j, Z.normalA, -p), h(Z.contactPointB, Z.contactPointB, j), h(Z.contactPointB, Z.contactPointB, c), a(Z.contactPointB, Z.contactPointB, n.position), this.contactEquations.push(Z), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(Z)), 1
                    }
                }
                return 0
            }, s.prototype[m.CIRCLE | m.CAPSULE] = s.prototype.circleCapsule = function(t, e, i, s, n, r, o, a, h) {
                return this.circleLine(t, e, i, s, n, r, o, a, h, r.radius)
            }, s.prototype[m.CIRCLE | m.CONVEX] = s.prototype[m.CIRCLE | m.BOX] = s.prototype.circleConvex = function(t, e, i, s, n, l, c, u, d, p) {
                p = "number" == typeof p ? p : e.radius;
                for (var f = x, g = b, m = _, y = w, v = T, P = E, C = M, S = L, A = B, R = I, k = O, F = !1, D = Number.MAX_VALUE, U = l.vertices, G = 0; G !== U.length + 1; G++) {
                    var N = U[G % U.length],
                        X = U[(G + 1) % U.length];
                    if (o.rotate(f, N, u), o.rotate(g, X, u), h(f, f, c), h(g, g, c), a(m, g, f), o.normalize(y, m), o.rotate90cw(v, y), o.scale(A, v, -e.radius), h(A, A, i), r(A, l, c, u)) {
                        o.sub(R, f, A);
                        var W = Math.abs(o.dot(R, v));
                        W < D && (o.copy(k, A), D = W, o.scale(S, v, W), o.add(S, S, A), F = !0)
                    }
                }
                if (F) return !!d || (V = this.createContactEquation(t, n, e, l), o.sub(V.normalA, k, i), o.normalize(V.normalA, V.normalA), o.scale(V.contactPointA, V.normalA, p), h(V.contactPointA, V.contactPointA, i), a(V.contactPointA, V.contactPointA, t.position), a(V.contactPointB, S, c), h(V.contactPointB, V.contactPointB, c), a(V.contactPointB, V.contactPointB, n.position), this.contactEquations.push(V), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(V)), 1);
                if (p > 0)
                    for (G = 0; G < U.length; G++) {
                        var j = U[G];
                        if (o.rotate(C, j, u), h(C, C, c), a(P, C, i), o.squaredLength(P) < Math.pow(p, 2)) {
                            if (d) return !0;
                            var V = this.createContactEquation(t, n, e, l);
                            return o.copy(V.normalA, P), o.normalize(V.normalA, V.normalA), o.scale(V.contactPointA, V.normalA, p), h(V.contactPointA, V.contactPointA, i), a(V.contactPointA, V.contactPointA, t.position), a(V.contactPointB, C, c), h(V.contactPointB, V.contactPointB, c), a(V.contactPointB, V.contactPointB, n.position), this.contactEquations.push(V), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(V)), 1
                        }
                    }
                return 0
            };
            var H = o.create(),
                q = o.create(),
                Y = o.create(),
                z = o.create();
            s.prototype[m.PARTICLE | m.CONVEX] = s.prototype[m.PARTICLE | m.BOX] = s.prototype.particleConvex = function(t, e, i, s, n, c, u, d, p) {
                var f = x,
                    g = b,
                    m = _,
                    y = w,
                    v = T,
                    S = P,
                    A = C,
                    M = E,
                    R = L,
                    B = k,
                    I = F,
                    O = Number.MAX_VALUE,
                    D = !1,
                    U = c.vertices;
                if (!r(i, c, u, d)) return 0;
                if (p) return !0;
                for (var G = 0; G !== U.length + 1; G++) {
                    var N = U[G % U.length],
                        X = U[(G + 1) % U.length];
                    o.rotate(f, N, d), o.rotate(g, X, d), h(f, f, u), h(g, g, u), a(m, g, f), o.normalize(y, m), o.rotate90cw(v, y), a(M, i, f), l(M, v), a(S, f, u), a(A, i, u), o.sub(B, f, i);
                    var W = Math.abs(o.dot(B, v));
                    W < O && (O = W, o.scale(R, v, W), o.add(R, R, i), o.copy(I, v), D = !0)
                }
                if (D) {
                    var j = this.createContactEquation(t, n, e, c);
                    return o.scale(j.normalA, I, -1), o.normalize(j.normalA, j.normalA), o.set(j.contactPointA, 0, 0), h(j.contactPointA, j.contactPointA, i), a(j.contactPointA, j.contactPointA, t.position), a(j.contactPointB, R, u), h(j.contactPointB, j.contactPointB, u), a(j.contactPointB, j.contactPointB, n.position), this.contactEquations.push(j), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(j)), 1
                }
                return 0
            }, s.prototype[m.CIRCLE] = s.prototype.circleCircle = function(t, e, i, s, n, r, l, c, u, d, p) {
                var f = x;
                d = d || e.radius, p = p || r.radius;
                a(f, i, l);
                var g = d + p;
                if (o.squaredLength(f) > Math.pow(g, 2)) return 0;
                if (u) return !0;
                var m = this.createContactEquation(t, n, e, r);
                return a(m.normalA, l, i), o.normalize(m.normalA, m.normalA), o.scale(m.contactPointA, m.normalA, d), o.scale(m.contactPointB, m.normalA, -p), h(m.contactPointA, m.contactPointA, i), a(m.contactPointA, m.contactPointA, t.position), h(m.contactPointB, m.contactPointB, l), a(m.contactPointB, m.contactPointB, n.position), this.contactEquations.push(m), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(m)), 1
            }, s.prototype[m.PLANE | m.CONVEX] = s.prototype[m.PLANE | m.BOX] = s.prototype.planeConvex = function(t, e, i, s, n, r, c, u, d) {
                var p = x,
                    f = b,
                    g = _,
                    m = 0;
                o.rotate(f, v, s);
                for (var y = 0; y !== r.vertices.length; y++) {
                    var w = r.vertices[y];
                    if (o.rotate(p, w, u), h(p, p, c), a(g, p, i), l(g, f) <= 0) {
                        if (d) return !0;
                        m++;
                        var T = this.createContactEquation(t, n, e, r);
                        a(g, p, i), o.copy(T.normalA, f);
                        var P = l(g, T.normalA);
                        o.scale(g, T.normalA, P), a(T.contactPointB, p, n.position), a(T.contactPointA, p, g), a(T.contactPointA, T.contactPointA, t.position), this.contactEquations.push(T), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(T))
                    }
                }
                return this.enableFrictionReduction && this.enableFriction && m && this.frictionEquations.push(this.createFrictionFromAverage(m)), m
            }, s.prototype[m.PARTICLE | m.PLANE] = s.prototype.particlePlane = function(t, e, i, s, n, r, h, c, u) {
                var d = x,
                    p = b;
                c = c || 0, a(d, i, h), o.rotate(p, v, c);
                var f = l(d, p);
                if (f > 0) return 0;
                if (u) return !0;
                var g = this.createContactEquation(n, t, r, e);
                return o.copy(g.normalA, p), o.scale(d, g.normalA, f), a(g.contactPointA, i, d), a(g.contactPointA, g.contactPointA, n.position), a(g.contactPointB, i, t.position), this.contactEquations.push(g), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(g)), 1
            }, s.prototype[m.CIRCLE | m.PARTICLE] = s.prototype.circleParticle = function(t, e, i, s, n, r, l, c, u) {
                var d = x;
                if (a(d, l, i), o.squaredLength(d) > Math.pow(e.radius, 2)) return 0;
                if (u) return !0;
                var p = this.createContactEquation(t, n, e, r);
                return o.copy(p.normalA, d), o.normalize(p.normalA, p.normalA), o.scale(p.contactPointA, p.normalA, e.radius), h(p.contactPointA, p.contactPointA, i), a(p.contactPointA, p.contactPointA, t.position), a(p.contactPointB, l, n.position), this.contactEquations.push(p), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(p)), 1
            };
            var K = new f({
                    radius: 1
                }),
                J = o.create(),
                Q = o.create();
            o.create(), s.prototype[m.PLANE | m.CAPSULE] = s.prototype.planeCapsule = function(t, e, i, s, n, r, a, l, c) {
                var u, d = J,
                    p = Q,
                    f = K;
                o.set(d, -r.length / 2, 0), o.rotate(d, d, l), h(d, d, a), o.set(p, r.length / 2, 0), o.rotate(p, p, l), h(p, p, a), f.radius = r.radius, this.enableFrictionReduction && (u = this.enableFriction, this.enableFriction = !1);
                var g = this.circlePlane(n, f, d, 0, t, e, i, s, c),
                    m = this.circlePlane(n, f, p, 0, t, e, i, s, c);
                if (this.enableFrictionReduction && (this.enableFriction = u), c) return g || m;
                var y = g + m;
                return this.enableFrictionReduction && y && this.frictionEquations.push(this.createFrictionFromAverage(y)), y
            }, s.prototype[m.CIRCLE | m.PLANE] = s.prototype.circlePlane = function(t, e, i, s, n, r, c, u, d) {
                var p = t,
                    f = e,
                    g = i,
                    m = n,
                    y = c,
                    w = u;
                w = w || 0;
                var T = x,
                    P = b,
                    C = _;
                a(T, g, y), o.rotate(P, v, w);
                var S = l(P, T);
                if (S > f.radius) return 0;
                if (d) return !0;
                var A = this.createContactEquation(m, p, r, e);
                return o.copy(A.normalA, P), o.scale(A.contactPointB, A.normalA, -f.radius), h(A.contactPointB, A.contactPointB, g), a(A.contactPointB, A.contactPointB, p.position), o.scale(C, A.normalA, S), a(A.contactPointA, T, C), h(A.contactPointA, A.contactPointA, y), a(A.contactPointA, A.contactPointA, m.position), this.contactEquations.push(A), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(A)), 1
            }, s.prototype[m.CONVEX] = s.prototype[m.CONVEX | m.BOX] = s.prototype[m.BOX] = s.prototype.convexConvex = function(t, e, i, n, r, c, u, d, p, f) {
                var g = x,
                    m = b,
                    y = _,
                    v = w,
                    P = T,
                    E = C,
                    M = S,
                    R = A,
                    L = 0;
                f = "number" == typeof f ? f : 0;
                if (!s.findSeparatingAxis(e, i, n, c, u, d, g)) return 0;
                a(M, u, i), l(g, M) > 0 && o.scale(g, g, -1);
                var B = s.getClosestEdge(e, n, g, !0),
                    I = s.getClosestEdge(c, d, g);
                if (-1 === B || -1 === I) return 0;
                for (var O = 0; O < 2; O++) {
                    var k, F = B,
                        D = I,
                        U = e,
                        G = c,
                        N = i,
                        X = u,
                        W = n,
                        j = d,
                        V = t,
                        H = r;
                    if (0 === O) k = F, F = D, D = k, k = U, U = G, G = k, k = N, N = X, X = k, k = W, W = j, j = k, k = V, V = H, H = k;
                    for (var q = D; q < D + 2; q++) {
                        var Y = G.vertices[(q + G.vertices.length) % G.vertices.length];
                        o.rotate(m, Y, j), h(m, m, X);
                        for (var z = 0, K = F - 1; K < F + 2; K++) {
                            var J = U.vertices[(K + U.vertices.length) % U.vertices.length],
                                Q = U.vertices[(K + 1 + U.vertices.length) % U.vertices.length];
                            o.rotate(y, J, W), o.rotate(v, Q, W), h(y, y, N), h(v, v, N), a(P, v, y), o.rotate90cw(R, P), o.normalize(R, R), a(M, m, y), $ = l(R, M), (K === F && $ <= f || K !== F && $ <= 0) && z++
                        }
                        if (z >= 3) {
                            if (p) return !0;
                            var Z = this.createContactEquation(V, H, U, G);
                            L++;
                            J = U.vertices[F % U.vertices.length], Q = U.vertices[(F + 1) % U.vertices.length];
                            o.rotate(y, J, W), o.rotate(v, Q, W), h(y, y, N), h(v, v, N), a(P, v, y), o.rotate90cw(Z.normalA, P), o.normalize(Z.normalA, Z.normalA), a(M, m, y);
                            var $ = l(Z.normalA, M);
                            o.scale(E, Z.normalA, $), a(Z.contactPointA, m, N), a(Z.contactPointA, Z.contactPointA, E), h(Z.contactPointA, Z.contactPointA, N), a(Z.contactPointA, Z.contactPointA, V.position), a(Z.contactPointB, m, X), h(Z.contactPointB, Z.contactPointB, X), a(Z.contactPointB, Z.contactPointB, H.position), this.contactEquations.push(Z), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(Z))
                        }
                    }
                }
                return this.enableFrictionReduction && this.enableFriction && L && this.frictionEquations.push(this.createFrictionFromAverage(L)), L
            };
            var Z = o.fromValues(0, 0);
            s.projectConvexOntoAxis = function(t, e, i, s, n) {
                var r, a, h = null,
                    c = null,
                    u = Z;
                o.rotate(u, s, -i);
                for (var d = 0; d < t.vertices.length; d++) r = t.vertices[d], a = l(r, u), (null === h || a > h) && (h = a), (null === c || a < c) && (c = a);
                if (c > h) {
                    var p = c;
                    c = h, h = p
                }
                var f = l(e, s);
                o.set(n, c + f, h + f)
            };
            var $ = o.fromValues(0, 0),
                tt = o.fromValues(0, 0),
                et = o.fromValues(0, 0),
                it = o.fromValues(0, 0),
                st = o.fromValues(0, 0),
                nt = o.fromValues(0, 0);
            s.findSeparatingAxis = function(t, e, i, n, r, h, l) {
                var c = null,
                    u = !1,
                    d = !1,
                    p = $,
                    f = tt,
                    g = et,
                    m = it,
                    v = st,
                    x = nt;
                if (t instanceof y && n instanceof y)
                    for (P = 0; 2 !== P; P++) {
                        var b = t,
                            _ = i;
                        for (1 === P && (b = n, _ = h), C = 0; 2 !== C; C++) {
                            0 === C ? o.set(m, 0, 1) : 1 === C && o.set(m, 1, 0), 0 !== _ && o.rotate(m, m, _), s.projectConvexOntoAxis(t, e, i, m, v), s.projectConvexOntoAxis(n, r, h, m, x);
                            var w = v,
                                T = x;
                            v[0] > x[0] && (T = v, w = x), u = (S = T[0] - w[1]) <= 0, (null === c || S > c) && (o.copy(l, m), c = S, d = u)
                        }
                    } else
                        for (var P = 0; 2 !== P; P++) {
                            b = t, _ = i;
                            1 === P && (b = n, _ = h);
                            for (var C = 0; C !== b.vertices.length; C++) {
                                o.rotate(f, b.vertices[C], _), o.rotate(g, b.vertices[(C + 1) % b.vertices.length], _), a(p, g, f), o.rotate90cw(m, p), o.normalize(m, m), s.projectConvexOntoAxis(t, e, i, m, v), s.projectConvexOntoAxis(n, r, h, m, x);
                                w = v, T = x;
                                v[0] > x[0] && (T = v, w = x);
                                var S = T[0] - w[1];
                                u = S <= 0, (null === c || S > c) && (o.copy(l, m), c = S, d = u)
                            }
                        }
                return d
            };
            var rt = o.fromValues(0, 0),
                ot = o.fromValues(0, 0),
                at = o.fromValues(0, 0);
            s.getClosestEdge = function(t, e, i, s) {
                var n = rt,
                    r = ot,
                    h = at;
                o.rotate(n, i, -e), s && o.scale(n, n, -1);
                for (var c = -1, u = t.vertices.length, d = -1, p = 0; p !== u; p++) {
                    a(r, t.vertices[(p + 1) % u], t.vertices[p % u]), o.rotate90cw(h, r), o.normalize(h, h);
                    var f = l(h, n);
                    (-1 === c || f > d) && (c = p % u, d = f)
                }
                return c
            };
            var ht = o.create(),
                lt = o.create(),
                ct = o.create(),
                ut = o.create(),
                dt = o.create(),
                pt = o.create(),
                ft = o.create();
            s.prototype[m.CIRCLE | m.HEIGHTFIELD] = s.prototype.circleHeightfield = function(t, e, i, s, n, r, l, c, u, d) {
                var p = r.heights,
                    f = (d = d || e.radius, r.elementWidth),
                    g = lt,
                    m = ht,
                    y = dt,
                    v = ft,
                    x = pt,
                    b = ct,
                    _ = ut,
                    w = Math.floor((i[0] - d - l[0]) / f),
                    T = Math.ceil((i[0] + d - l[0]) / f);
                w < 0 && (w = 0), T >= p.length && (T = p.length - 1);
                for (var P = p[w], C = p[T], S = w; S < T; S++) p[S] < C && (C = p[S]), p[S] > P && (P = p[S]);
                if (i[1] - d > P) return !u && 0;
                var A = !1;
                for (S = w; S < T; S++) {
                    o.set(b, S * f, p[S]), o.set(_, (S + 1) * f, p[S + 1]), o.add(b, b, l), o.add(_, _, l), o.sub(x, _, b), o.rotate(x, x, Math.PI / 2), o.normalize(x, x), o.scale(m, x, -d), o.add(m, m, i), o.sub(g, m, b);
                    var E = o.dot(g, x);
                    if (m[0] >= b[0] && m[0] < _[0] && E <= 0) {
                        if (u) return !0;
                        A = !0, o.scale(g, x, -E), o.add(y, m, g), o.copy(v, x), M = this.createContactEquation(n, t, r, e), o.copy(M.normalA, v), o.scale(M.contactPointB, M.normalA, -d), h(M.contactPointB, M.contactPointB, i), a(M.contactPointB, M.contactPointB, t.position), o.copy(M.contactPointA, y), o.sub(M.contactPointA, M.contactPointA, n.position), this.contactEquations.push(M), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(M))
                    }
                }
                if (A = !1, d > 0)
                    for (S = w; S <= T; S++)
                        if (o.set(b, S * f, p[S]), o.add(b, b, l), o.sub(g, i, b), o.squaredLength(g) < Math.pow(d, 2)) {
                            if (u) return !0;
                            A = !0;
                            var M = this.createContactEquation(n, t, r, e);
                            o.copy(M.normalA, g), o.normalize(M.normalA, M.normalA), o.scale(M.contactPointB, M.normalA, -d), h(M.contactPointB, M.contactPointB, i), a(M.contactPointB, M.contactPointB, t.position), a(M.contactPointA, b, l), h(M.contactPointA, M.contactPointA, l), a(M.contactPointA, M.contactPointA, n.position), this.contactEquations.push(M), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(M))
                        }
                return A ? 1 : 0
            };
            var gt = o.create(),
                mt = o.create(),
                yt = o.create(),
                vt = new g({
                    vertices: [o.create(), o.create(), o.create(), o.create()]
                });
            s.prototype[m.BOX | m.HEIGHTFIELD] = s.prototype[m.CONVEX | m.HEIGHTFIELD] = s.prototype.convexHeightfield = function(t, e, i, s, n, r, a, h, l) {
                var c = r.heights,
                    u = r.elementWidth,
                    d = gt,
                    p = mt,
                    f = yt,
                    g = vt,
                    m = Math.floor((t.aabb.lowerBound[0] - a[0]) / u),
                    y = Math.ceil((t.aabb.upperBound[0] - a[0]) / u);
                m < 0 && (m = 0), y >= c.length && (y = c.length - 1);
                for (var v = c[m], x = c[y], b = m; b < y; b++) c[b] < x && (x = c[b]), c[b] > v && (v = c[b]);
                if (t.aabb.lowerBound[1] > v) return !l && 0;
                var _ = 0;
                for (b = m; b < y; b++) o.set(d, b * u, c[b]), o.set(p, (b + 1) * u, c[b + 1]), o.add(d, d, a), o.add(p, p, a), o.set(f, .5 * (p[0] + d[0]), .5 * (p[1] + d[1] - 100)), o.sub(g.vertices[0], p, f), o.sub(g.vertices[1], d, f), o.copy(g.vertices[2], g.vertices[1]), o.copy(g.vertices[3], g.vertices[0]), g.vertices[2][1] -= 100, g.vertices[3][1] -= 100, _ += this.convexConvex(t, e, i, s, n, g, f, 0, l);
                return _
            }
        }, {
            "../equations/ContactEquation": 21,
            "../equations/Equation": 22,
            "../equations/FrictionEquation": 23,
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../shapes/Box": 37,
            "../shapes/Circle": 39,
            "../shapes/Convex": 40,
            "../shapes/Shape": 45,
            "../utils/ContactEquationPool": 48,
            "../utils/FrictionEquationPool": 49,
            "../utils/TupleDictionary": 56,
            "../utils/Utils": 57
        }],
        11: [function(t, e, i) {
            function s(t) {
                t = t || {}, this.from = t.from ? r.fromValues(t.from[0], t.from[1]) : r.create(), this.to = t.to ? r.fromValues(t.to[0], t.to[1]) : r.create(), this.checkCollisionResponse = void 0 === t.checkCollisionResponse || t.checkCollisionResponse, this.skipBackfaces = !!t.skipBackfaces, this.collisionMask = void 0 !== t.collisionMask ? t.collisionMask : -1, this.collisionGroup = void 0 !== t.collisionGroup ? t.collisionGroup : -1, this.mode = void 0 !== t.mode ? t.mode : s.ANY, this.callback = t.callback || function(t) {}, this.direction = r.create(), this.length = 1, this.update()
            }

            function n(t, e, i) {
                r.sub(a, i, t);
                var s = r.dot(a, e);
                return r.scale(h, e, s), r.add(h, h, t), r.squaredDistance(i, h)
            }
            e.exports = s;
            var r = t("../math/vec2");
            t("../collision/RaycastResult"), t("../shapes/Shape"), t("../collision/AABB"), s.prototype.constructor = s, s.CLOSEST = 1, s.ANY = 2, s.ALL = 4, s.prototype.update = function() {
                var t = this.direction;
                r.sub(t, this.to, this.from), this.length = r.length(t), r.normalize(t, t)
            }, s.prototype.intersectBodies = function(t, e) {
                for (var i = 0, s = e.length; !t.shouldStop(this) && i < s; i++) {
                    var n = e[i],
                        r = n.getAABB();
                    (r.overlapsRay(this) >= 0 || r.containsPoint(this.from)) && this.intersectBody(t, n)
                }
            };
            var o = r.create();
            s.prototype.intersectBody = function(t, e) {
                var i = this.checkCollisionResponse;
                if (!i || e.collisionResponse)
                    for (var s = o, n = 0, a = e.shapes.length; n < a; n++) {
                        var h = e.shapes[n];
                        if ((!i || h.collisionResponse) && 0 != (this.collisionGroup & h.collisionMask) && 0 != (h.collisionGroup & this.collisionMask)) {
                            r.rotate(s, h.position, e.angle), r.add(s, s, e.position);
                            var l = h.angle + e.angle;
                            if (this.intersectShape(t, h, l, s, e), t.shouldStop(this)) break
                        }
                    }
            }, s.prototype.intersectShape = function(t, e, i, s, r) {
                n(this.from, this.direction, s) > e.boundingRadius * e.boundingRadius || (this._currentBody = r, this._currentShape = e, e.raycast(t, this, s, i), this._currentBody = this._currentShape = null)
            }, s.prototype.getAABB = function(t) {
                var e = this.to,
                    i = this.from;
                r.set(t.lowerBound, Math.min(e[0], i[0]), Math.min(e[1], i[1])), r.set(t.upperBound, Math.max(e[0], i[0]), Math.max(e[1], i[1]))
            }, r.create(), s.prototype.reportIntersection = function(t, e, i, n) {
                this.from, this.to;
                var o = this._currentShape,
                    a = this._currentBody;
                if (!(this.skipBackfaces && r.dot(i, this.direction) > 0)) switch (this.mode) {
                    case s.ALL:
                        t.set(i, o, a, e, n), this.callback(t);
                        break;
                    case s.CLOSEST:
                        (e < t.fraction || !t.hasHit()) && t.set(i, o, a, e, n);
                        break;
                    case s.ANY:
                        t.set(i, o, a, e, n)
                }
            };
            var a = r.create(),
                h = r.create()
        }, {
            "../collision/AABB": 7,
            "../collision/RaycastResult": 12,
            "../math/vec2": 30,
            "../shapes/Shape": 45
        }],
        12: [function(t, e, i) {
            function s() {
                this.normal = n.create(), this.shape = null, this.body = null, this.faceIndex = -1, this.fraction = -1, this.isStopped = !1
            }
            var n = t("../math/vec2"),
                r = t("../collision/Ray");
            e.exports = s, s.prototype.reset = function() {
                n.set(this.normal, 0, 0), this.shape = null, this.body = null, this.faceIndex = -1, this.fraction = -1, this.isStopped = !1
            }, s.prototype.getHitDistance = function(t) {
                return n.distance(t.from, t.to) * this.fraction
            }, s.prototype.hasHit = function() {
                return -1 !== this.fraction
            }, s.prototype.getHitPoint = function(t, e) {
                n.lerp(t, e.from, e.to, this.fraction)
            }, s.prototype.stop = function() {
                this.isStopped = !0
            }, s.prototype.shouldStop = function(t) {
                return this.isStopped || -1 !== this.fraction && t.mode === r.ANY
            }, s.prototype.set = function(t, e, i, s, r) {
                n.copy(this.normal, t), this.shape = e, this.body = i, this.fraction = s, this.faceIndex = r
            }
        }, {
            "../collision/Ray": 11,
            "../math/vec2": 30
        }],
        13: [function(t, e, i) {
            function s() {
                r.call(this, r.SAP), this.axisList = [], this.axisIndex = 0;
                var t = this;
                this._addBodyHandler = function(e) {
                    t.axisList.push(e.body)
                }, this._removeBodyHandler = function(e) {
                    var i = t.axisList.indexOf(e.body); - 1 !== i && t.axisList.splice(i, 1)
                }
            }
            var n = t("../utils/Utils"),
                r = t("../collision/Broadphase");
            e.exports = s, (s.prototype = new r).constructor = s, s.prototype.setWorld = function(t) {
                this.axisList.length = 0, n.appendArray(this.axisList, t.bodies), t.off("addBody", this._addBodyHandler).off("removeBody", this._removeBodyHandler), t.on("addBody", this._addBodyHandler).on("removeBody", this._removeBodyHandler), this.world = t
            }, s.sortAxisList = function(t, e) {
                e |= 0;
                for (var i = 1, s = t.length; i < s; i++) {
                    for (var n = t[i], r = i - 1; r >= 0 && !(t[r].aabb.lowerBound[e] <= n.aabb.lowerBound[e]); r--) t[r + 1] = t[r];
                    t[r + 1] = n
                }
                return t
            }, s.prototype.sortList = function() {
                var t = this.axisList,
                    e = this.axisIndex;
                s.sortAxisList(t, e)
            }, s.prototype.getCollisionPairs = function(t) {
                var e = this.axisList,
                    i = this.result,
                    s = this.axisIndex;
                i.length = 0;
                for (var n = e.length; n--;) {
                    var o = e[n];
                    o.aabbNeedsUpdate && o.updateAABB()
                }
                this.sortList();
                for (var a = 0, h = 0 | e.length; a !== h; a++)
                    for (var l = e[a], c = a + 1; c < h; c++) {
                        var u = e[c];
                        if (!(u.aabb.lowerBound[s] <= l.aabb.upperBound[s])) break;
                        r.canCollide(l, u) && this.boundingVolumeCheck(l, u) && i.push(l, u)
                    }
                return i
            }, s.prototype.aabbQuery = function(t, e, i) {
                i = i || [], this.sortList();
                var s = this.axisIndex,
                    n = "x";
                1 === s && (n = "y"), 2 === s && (n = "z");
                for (var r = this.axisList, o = (e.lowerBound[n], e.upperBound[n], 0); o < r.length; o++) {
                    var a = r[o];
                    a.aabbNeedsUpdate && a.updateAABB(), a.aabb.overlaps(e) && i.push(a)
                }
                return i
            }
        }, {
            "../collision/Broadphase": 8,
            "../utils/Utils": 57
        }],
        14: [function(t, e, i) {
            function s(t, e, i, s) {
                this.type = i, s = n.defaults(s, {
                    collideConnected: !0,
                    wakeUpBodies: !0
                }), this.equations = [], this.bodyA = t, this.bodyB = e, this.collideConnected = s.collideConnected, s.wakeUpBodies && (t && t.wakeUp(), e && e.wakeUp())
            }
            e.exports = s;
            var n = t("../utils/Utils");
            s.prototype.update = function() {
                throw new Error("method update() not implmemented in this Constraint subclass!")
            }, s.DISTANCE = 1, s.GEAR = 2, s.LOCK = 3, s.PRISMATIC = 4, s.REVOLUTE = 5, s.prototype.setStiffness = function(t) {
                for (var e = this.equations, i = 0; i !== e.length; i++) {
                    var s = e[i];
                    s.stiffness = t, s.needsUpdate = !0
                }
            }, s.prototype.setRelaxation = function(t) {
                for (var e = this.equations, i = 0; i !== e.length; i++) {
                    var s = e[i];
                    s.relaxation = t, s.needsUpdate = !0
                }
            }
        }, {
            "../utils/Utils": 57
        }],
        15: [function(t, e, i) {
            function s(t, e, i) {
                i = a.defaults(i, {
                    localAnchorA: [0, 0],
                    localAnchorB: [0, 0]
                }), n.call(this, t, e, n.DISTANCE, i), this.localAnchorA = o.fromValues(i.localAnchorA[0], i.localAnchorA[1]), this.localAnchorB = o.fromValues(i.localAnchorB[0], i.localAnchorB[1]);
                var s, h = this.localAnchorA,
                    l = this.localAnchorB;
                if (this.distance = 0, "number" == typeof i.distance) this.distance = i.distance;
                else {
                    var c = o.create(),
                        u = o.create(),
                        d = o.create();
                    o.rotate(c, h, t.angle), o.rotate(u, l, e.angle), o.add(d, e.position, u), o.sub(d, d, c), o.sub(d, d, t.position), this.distance = o.length(d)
                }
                s = void 0 === i.maxForce ? Number.MAX_VALUE : i.maxForce;
                var p = new r(t, e, -s, s);
                this.equations = [p], this.maxForce = s;
                d = o.create();
                var f = o.create(),
                    g = o.create(),
                    m = this;
                p.computeGq = function() {
                    var t = this.bodyA,
                        e = this.bodyB,
                        i = t.position,
                        s = e.position;
                    return o.rotate(f, h, t.angle), o.rotate(g, l, e.angle), o.add(d, s, g), o.sub(d, d, f), o.sub(d, d, i), o.length(d) - m.distance
                }, this.setMaxForce(s), this.upperLimitEnabled = !1, this.upperLimit = 1, this.lowerLimitEnabled = !1, this.lowerLimit = 0, this.position = 0
            }
            var n = t("./Constraint"),
                r = t("../equations/Equation"),
                o = t("../math/vec2"),
                a = t("../utils/Utils");
            e.exports = s, (s.prototype = new n).constructor = s;
            var h = o.create(),
                l = o.create(),
                c = o.create();
            s.prototype.update = function() {
                var t = this.equations[0],
                    e = this.bodyA,
                    i = this.bodyB,
                    s = (this.distance, e.position),
                    n = i.position,
                    r = this.equations[0],
                    a = t.G;
                o.rotate(l, this.localAnchorA, e.angle), o.rotate(c, this.localAnchorB, i.angle), o.add(h, n, c), o.sub(h, h, l), o.sub(h, h, s), this.position = o.length(h);
                var u = !1;
                if (this.upperLimitEnabled && this.position > this.upperLimit && (r.maxForce = 0, r.minForce = -this.maxForce, this.distance = this.upperLimit, u = !0), this.lowerLimitEnabled && this.position < this.lowerLimit && (r.maxForce = this.maxForce, r.minForce = 0, this.distance = this.lowerLimit, u = !0), !this.lowerLimitEnabled && !this.upperLimitEnabled || u) {
                    r.enabled = !0, o.normalize(h, h);
                    var d = o.crossLength(l, h),
                        p = o.crossLength(c, h);
                    a[0] = -h[0], a[1] = -h[1], a[2] = -d, a[3] = h[0], a[4] = h[1], a[5] = p
                } else r.enabled = !1
            }, s.prototype.setMaxForce = function(t) {
                var e = this.equations[0];
                e.minForce = -t, e.maxForce = t
            }, s.prototype.getMaxForce = function() {
                return this.equations[0].maxForce
            }
        }, {
            "../equations/Equation": 22,
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Constraint": 14
        }],
        16: [function(t, e, i) {
            function s(t, e, i) {
                i = i || {}, n.call(this, t, e, n.GEAR, i), this.ratio = void 0 !== i.ratio ? i.ratio : 1, this.angle = void 0 !== i.angle ? i.angle : e.angle - this.ratio * t.angle, i.angle = this.angle, i.ratio = this.ratio, this.equations = [new r(t, e, i)], void 0 !== i.maxTorque && this.setMaxTorque(i.maxTorque)
            }
            var n = t("./Constraint"),
                r = (t("../equations/Equation"), t("../equations/AngleLockEquation"));
            t("../math/vec2"), e.exports = s, (s.prototype = new n).constructor = s, s.prototype.update = function() {
                var t = this.equations[0];
                t.ratio !== this.ratio && t.setRatio(this.ratio), t.angle = this.angle
            }, s.prototype.setMaxTorque = function(t) {
                this.equations[0].setMaxTorque(t)
            }, s.prototype.getMaxTorque = function(t) {
                return this.equations[0].maxForce
            }
        }, {
            "../equations/AngleLockEquation": 20,
            "../equations/Equation": 22,
            "../math/vec2": 30,
            "./Constraint": 14
        }],
        17: [function(t, e, i) {
            function s(t, e, i) {
                i = i || {}, n.call(this, t, e, n.LOCK, i);
                var s = void 0 === i.maxForce ? Number.MAX_VALUE : i.maxForce,
                    a = (i.localAngleB, new o(t, e, -s, s)),
                    h = new o(t, e, -s, s),
                    l = new o(t, e, -s, s),
                    c = r.create(),
                    u = r.create(),
                    d = this;
                a.computeGq = function() {
                    return r.rotate(c, d.localOffsetB, t.angle), r.sub(u, e.position, t.position), r.sub(u, u, c), u[0]
                }, h.computeGq = function() {
                    return r.rotate(c, d.localOffsetB, t.angle), r.sub(u, e.position, t.position), r.sub(u, u, c), u[1]
                };
                var p = r.create(),
                    f = r.create();
                l.computeGq = function() {
                    return r.rotate(p, d.localOffsetB, e.angle - d.localAngleB), r.scale(p, p, -1), r.sub(u, t.position, e.position), r.add(u, u, p), r.rotate(f, p, -Math.PI / 2), r.normalize(f, f), r.dot(u, f)
                }, this.localOffsetB = r.create(), i.localOffsetB ? r.copy(this.localOffsetB, i.localOffsetB) : (r.sub(this.localOffsetB, e.position, t.position), r.rotate(this.localOffsetB, this.localOffsetB, -t.angle)), this.localAngleB = 0, "number" == typeof i.localAngleB ? this.localAngleB = i.localAngleB : this.localAngleB = e.angle - t.angle, this.equations.push(a, h, l), this.setMaxForce(s)
            }
            var n = t("./Constraint"),
                r = t("../math/vec2"),
                o = t("../equations/Equation");
            e.exports = s, (s.prototype = new n).constructor = s, s.prototype.setMaxForce = function(t) {
                for (var e = this.equations, i = 0; i < this.equations.length; i++) e[i].maxForce = t, e[i].minForce = -t
            }, s.prototype.getMaxForce = function() {
                return this.equations[0].maxForce
            };
            var a = r.create(),
                h = r.create(),
                l = r.create(),
                c = r.fromValues(1, 0),
                u = r.fromValues(0, 1);
            s.prototype.update = function() {
                var t = this.equations[0],
                    e = this.equations[1],
                    i = this.equations[2],
                    s = this.bodyA,
                    n = this.bodyB;
                r.rotate(a, this.localOffsetB, s.angle), r.rotate(h, this.localOffsetB, n.angle - this.localAngleB), r.scale(h, h, -1), r.rotate(l, h, Math.PI / 2), r.normalize(l, l), t.G[0] = -1, t.G[1] = 0, t.G[2] = -r.crossLength(a, c), t.G[3] = 1, e.G[0] = 0, e.G[1] = -1, e.G[2] = -r.crossLength(a, u), e.G[4] = 1, i.G[0] = -l[0], i.G[1] = -l[1], i.G[3] = l[0], i.G[4] = l[1], i.G[5] = r.crossLength(h, l)
            }
        }, {
            "../equations/Equation": 22,
            "../math/vec2": 30,
            "./Constraint": 14
        }],
        18: [function(t, e, i) {
            function s(t, e, i) {
                i = i || {}, n.call(this, t, e, n.PRISMATIC, i);
                var s = a.fromValues(0, 0),
                    l = a.fromValues(1, 0),
                    c = a.fromValues(0, 0);
                i.localAnchorA && a.copy(s, i.localAnchorA), i.localAxisA && a.copy(l, i.localAxisA), i.localAnchorB && a.copy(c, i.localAnchorB), this.localAnchorA = s, this.localAnchorB = c, this.localAxisA = l;
                var u = this.maxForce = void 0 !== i.maxForce ? i.maxForce : Number.MAX_VALUE,
                    d = new o(t, e, -u, u),
                    p = new a.create,
                    f = new a.create,
                    g = new a.create,
                    m = new a.create;
                if (d.computeGq = function() {
                        return a.dot(g, m)
                    }, d.updateJacobian = function() {
                        var i = this.G,
                            n = t.position,
                            r = e.position;
                        a.rotate(p, s, t.angle), a.rotate(f, c, e.angle), a.add(g, r, f), a.sub(g, g, n), a.sub(g, g, p), a.rotate(m, l, t.angle + Math.PI / 2), i[0] = -m[0], i[1] = -m[1], i[2] = -a.crossLength(p, m) + a.crossLength(m, g), i[3] = m[0], i[4] = m[1], i[5] = a.crossLength(f, m)
                    }, this.equations.push(d), !i.disableRotationalLock) {
                    var y = new h(t, e, -u, u);
                    this.equations.push(y)
                }
                this.position = 0, this.velocity = 0, this.lowerLimitEnabled = void 0 !== i.lowerLimit, this.upperLimitEnabled = void 0 !== i.upperLimit, this.lowerLimit = void 0 !== i.lowerLimit ? i.lowerLimit : 0, this.upperLimit = void 0 !== i.upperLimit ? i.upperLimit : 1, this.upperLimitEquation = new r(t, e), this.lowerLimitEquation = new r(t, e), this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0, this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = u, this.motorEquation = new o(t, e), this.motorEnabled = !1, this.motorSpeed = 0;
                var v = this,
                    x = this.motorEquation;
                x.computeGW, x.computeGq = function() {
                    return 0
                }, x.computeGW = function() {
                    var t = this.G,
                        e = this.bodyA,
                        i = this.bodyB,
                        s = e.velocity,
                        n = i.velocity,
                        r = e.angularVelocity,
                        o = i.angularVelocity;
                    return this.gmult(t, s, r, n, o) + v.motorSpeed
                }
            }
            var n = t("./Constraint"),
                r = t("../equations/ContactEquation"),
                o = t("../equations/Equation"),
                a = t("../math/vec2"),
                h = t("../equations/RotationalLockEquation");
            e.exports = s, (s.prototype = new n).constructor = s;
            var l = a.create(),
                c = a.create(),
                u = a.create(),
                d = a.create(),
                p = a.create(),
                f = a.create();
            s.prototype.update = function() {
                var t = this.equations,
                    e = t[0],
                    i = this.upperLimit,
                    s = this.lowerLimit,
                    n = this.upperLimitEquation,
                    r = this.lowerLimitEquation,
                    o = this.bodyA,
                    h = this.bodyB,
                    g = this.localAxisA,
                    m = this.localAnchorA,
                    y = this.localAnchorB;
                e.updateJacobian(), a.rotate(l, g, o.angle), a.rotate(d, m, o.angle), a.add(c, d, o.position), a.rotate(p, y, h.angle), a.add(u, p, h.position);
                var v = this.position = a.dot(u, l) - a.dot(c, l);
                if (this.motorEnabled) {
                    var x = this.motorEquation.G;
                    x[0] = l[0], x[1] = l[1], x[2] = a.crossLength(l, p), x[3] = -l[0], x[4] = -l[1], x[5] = -a.crossLength(l, d)
                }
                if (this.upperLimitEnabled && v > i ? (a.scale(n.normalA, l, -1), a.sub(n.contactPointA, c, o.position), a.sub(n.contactPointB, u, h.position), a.scale(f, l, i), a.add(n.contactPointA, n.contactPointA, f), -1 === t.indexOf(n) && t.push(n)) : -1 !== (b = t.indexOf(n)) && t.splice(b, 1), this.lowerLimitEnabled && v < s) a.scale(r.normalA, l, 1), a.sub(r.contactPointA, c, o.position), a.sub(r.contactPointB, u, h.position), a.scale(f, l, s), a.sub(r.contactPointB, r.contactPointB, f), -1 === t.indexOf(r) && t.push(r);
                else {
                    var b = t.indexOf(r); - 1 !== b && t.splice(b, 1)
                }
            }, s.prototype.enableMotor = function() {
                this.motorEnabled || (this.equations.push(this.motorEquation), this.motorEnabled = !0)
            }, s.prototype.disableMotor = function() {
                if (this.motorEnabled) {
                    var t = this.equations.indexOf(this.motorEquation);
                    this.equations.splice(t, 1), this.motorEnabled = !1
                }
            }, s.prototype.setLimits = function(t, e) {
                "number" == typeof t ? (this.lowerLimit = t, this.lowerLimitEnabled = !0) : (this.lowerLimit = t, this.lowerLimitEnabled = !1), "number" == typeof e ? (this.upperLimit = e, this.upperLimitEnabled = !0) : (this.upperLimit = e, this.upperLimitEnabled = !1)
            }
        }, {
            "../equations/ContactEquation": 21,
            "../equations/Equation": 22,
            "../equations/RotationalLockEquation": 24,
            "../math/vec2": 30,
            "./Constraint": 14
        }],
        19: [function(t, e, i) {
            function s(t, e, i) {
                i = i || {}, n.call(this, t, e, n.REVOLUTE, i);
                var s = this.maxForce = void 0 !== i.maxForce ? i.maxForce : Number.MAX_VALUE;
                this.pivotA = h.create(), this.pivotB = h.create(), i.worldPivot ? (h.sub(this.pivotA, i.worldPivot, t.position), h.sub(this.pivotB, i.worldPivot, e.position), h.rotate(this.pivotA, this.pivotA, -t.angle), h.rotate(this.pivotB, this.pivotB, -e.angle)) : (h.copy(this.pivotA, i.localPivotA), h.copy(this.pivotB, i.localPivotB));
                var f = this.equations = [new r(t, e, -s, s), new r(t, e, -s, s)],
                    g = f[0],
                    m = f[1],
                    y = this;
                g.computeGq = function() {
                    return h.rotate(l, y.pivotA, t.angle), h.rotate(c, y.pivotB, e.angle), h.add(p, e.position, c), h.sub(p, p, t.position), h.sub(p, p, l), h.dot(p, u)
                }, m.computeGq = function() {
                    return h.rotate(l, y.pivotA, t.angle), h.rotate(c, y.pivotB, e.angle), h.add(p, e.position, c), h.sub(p, p, t.position), h.sub(p, p, l), h.dot(p, d)
                }, m.minForce = g.minForce = -s, m.maxForce = g.maxForce = s, this.motorEquation = new o(t, e), this.motorEnabled = !1, this.angle = 0, this.lowerLimitEnabled = !1, this.upperLimitEnabled = !1, this.lowerLimit = 0, this.upperLimit = 0, this.upperLimitEquation = new a(t, e), this.lowerLimitEquation = new a(t, e), this.upperLimitEquation.minForce = 0, this.lowerLimitEquation.maxForce = 0
            }
            var n = t("./Constraint"),
                r = t("../equations/Equation"),
                o = t("../equations/RotationalVelocityEquation"),
                a = t("../equations/RotationalLockEquation"),
                h = t("../math/vec2");
            e.exports = s;
            var l = h.create(),
                c = h.create(),
                u = h.fromValues(1, 0),
                d = h.fromValues(0, 1),
                p = h.create();
            (s.prototype = new n).constructor = s, s.prototype.setLimits = function(t, e) {
                "number" == typeof t ? (this.lowerLimit = t, this.lowerLimitEnabled = !0) : (this.lowerLimit = t, this.lowerLimitEnabled = !1), "number" == typeof e ? (this.upperLimit = e, this.upperLimitEnabled = !0) : (this.upperLimit = e, this.upperLimitEnabled = !1)
            }, s.prototype.update = function() {
                var t = this.bodyA,
                    e = this.bodyB,
                    i = this.pivotA,
                    s = this.pivotB,
                    n = this.equations,
                    r = (n[0], n[1], n[0]),
                    o = n[1],
                    a = this.upperLimit,
                    p = this.lowerLimit,
                    f = this.upperLimitEquation,
                    g = this.lowerLimitEquation,
                    m = this.angle = e.angle - t.angle;
                if (this.upperLimitEnabled && m > a ? (f.angle = a, -1 === n.indexOf(f) && n.push(f)) : -1 !== (y = n.indexOf(f)) && n.splice(y, 1), this.lowerLimitEnabled && m < p) g.angle = p, -1 === n.indexOf(g) && n.push(g);
                else {
                    var y = n.indexOf(g); - 1 !== y && n.splice(y, 1)
                }
                h.rotate(l, i, t.angle), h.rotate(c, s, e.angle), r.G[0] = -1, r.G[1] = 0, r.G[2] = -h.crossLength(l, u), r.G[3] = 1, r.G[4] = 0, r.G[5] = h.crossLength(c, u), o.G[0] = 0, o.G[1] = -1, o.G[2] = -h.crossLength(l, d), o.G[3] = 0, o.G[4] = 1, o.G[5] = h.crossLength(c, d)
            }, s.prototype.enableMotor = function() {
                this.motorEnabled || (this.equations.push(this.motorEquation), this.motorEnabled = !0)
            }, s.prototype.disableMotor = function() {
                if (this.motorEnabled) {
                    var t = this.equations.indexOf(this.motorEquation);
                    this.equations.splice(t, 1), this.motorEnabled = !1
                }
            }, s.prototype.setMotorSpeed = function(t) {
                if (this.motorEnabled) {
                    var e = this.equations.indexOf(this.motorEquation);
                    this.equations[e].relativeVelocity = t
                }
            }, s.prototype.getMotorSpeed = function() {
                return !!this.motorEnabled && this.motorEquation.relativeVelocity
            }
        }, {
            "../equations/Equation": 22,
            "../equations/RotationalLockEquation": 24,
            "../equations/RotationalVelocityEquation": 25,
            "../math/vec2": 30,
            "./Constraint": 14
        }],
        20: [function(t, e, i) {
            function s(t, e, i) {
                i = i || {}, n.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE), this.angle = i.angle || 0, this.ratio = "number" == typeof i.ratio ? i.ratio : 1, this.setRatio(this.ratio)
            }
            var n = t("./Equation");
            t("../math/vec2"), e.exports = s, (s.prototype = new n).constructor = s, s.prototype.computeGq = function() {
                return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle
            }, s.prototype.setRatio = function(t) {
                var e = this.G;
                e[2] = t, e[5] = -1, this.ratio = t
            }, s.prototype.setMaxTorque = function(t) {
                this.maxForce = t, this.minForce = -t
            }
        }, {
            "../math/vec2": 30,
            "./Equation": 22
        }],
        21: [function(t, e, i) {
            function s(t, e) {
                n.call(this, t, e, 0, Number.MAX_VALUE), this.contactPointA = r.create(), this.penetrationVec = r.create(), this.contactPointB = r.create(), this.normalA = r.create(), this.restitution = 0, this.firstImpact = !1, this.shapeA = null, this.shapeB = null
            }
            var n = t("./Equation"),
                r = t("../math/vec2");
            e.exports = s, (s.prototype = new n).constructor = s, s.prototype.computeB = function(t, e, i) {
                var s, n, o = this.bodyA,
                    a = this.bodyB,
                    h = this.contactPointA,
                    l = this.contactPointB,
                    c = o.position,
                    u = a.position,
                    d = this.penetrationVec,
                    p = this.normalA,
                    f = this.G,
                    g = r.crossLength(h, p),
                    m = r.crossLength(l, p);
                return f[0] = -p[0], f[1] = -p[1], f[2] = -g, f[3] = p[0], f[4] = p[1], f[5] = m, r.add(d, u, l), r.sub(d, d, c), r.sub(d, d, h), this.firstImpact && 0 !== this.restitution ? (n = 0, s = 1 / e * (1 + this.restitution) * this.computeGW()) : (n = r.dot(p, d) + this.offset, s = this.computeGW()), -n * t - s * e - i * this.computeGiMf()
            };
            var o = r.create(),
                a = r.create(),
                h = r.create();
            s.prototype.getVelocityAlongNormal = function() {
                return this.bodyA.getVelocityAtPoint(o, this.contactPointA), this.bodyB.getVelocityAtPoint(a, this.contactPointB), r.subtract(h, o, a), r.dot(this.normalA, h)
            }
        }, {
            "../math/vec2": 30,
            "./Equation": 22
        }],
        22: [function(t, e, i) {
            function s(t, e, i, n) {
                this.minForce = void 0 === i ? -Number.MAX_VALUE : i, this.maxForce = void 0 === n ? Number.MAX_VALUE : n, this.bodyA = t, this.bodyB = e, this.stiffness = s.DEFAULT_STIFFNESS, this.relaxation = s.DEFAULT_RELAXATION, this.G = new r.ARRAY_TYPE(6);
                for (var o = 0; o < 6; o++) this.G[o] = 0;
                this.offset = 0, this.a = 0, this.b = 0, this.epsilon = 0, this.timeStep = 1 / 60, this.needsUpdate = !0, this.multiplier = 0, this.relativeVelocity = 0, this.enabled = !0
            }
            e.exports = s;
            var n = t("../math/vec2"),
                r = t("../utils/Utils");
            t("../objects/Body"), s.prototype.constructor = s, s.DEFAULT_STIFFNESS = 1e6, s.DEFAULT_RELAXATION = 4, s.prototype.update = function() {
                var t = this.stiffness,
                    e = this.relaxation,
                    i = this.timeStep;
                this.a = 4 / (i * (1 + 4 * e)), this.b = 4 * e / (1 + 4 * e), this.epsilon = 4 / (i * i * t * (1 + 4 * e)), this.needsUpdate = !1
            }, s.prototype.gmult = function(t, e, i, s, n) {
                return t[0] * e[0] + t[1] * e[1] + t[2] * i + t[3] * s[0] + t[4] * s[1] + t[5] * n
            }, s.prototype.computeB = function(t, e, i) {
                var s = this.computeGW();
                return -this.computeGq() * t - s * e - this.computeGiMf() * i
            };
            var o = n.create(),
                a = n.create();
            s.prototype.computeGq = function() {
                var t = this.G,
                    e = this.bodyA,
                    i = this.bodyB,
                    s = (e.position, i.position, e.angle),
                    n = i.angle;
                return this.gmult(t, o, s, a, n) + this.offset
            }, s.prototype.computeGW = function() {
                var t = this.G,
                    e = this.bodyA,
                    i = this.bodyB,
                    s = e.velocity,
                    n = i.velocity,
                    r = e.angularVelocity,
                    o = i.angularVelocity;
                return this.gmult(t, s, r, n, o) + this.relativeVelocity
            }, s.prototype.computeGWlambda = function() {
                var t = this.G,
                    e = this.bodyA,
                    i = this.bodyB,
                    s = e.vlambda,
                    n = i.vlambda,
                    r = e.wlambda,
                    o = i.wlambda;
                return this.gmult(t, s, r, n, o)
            };
            var h = n.create(),
                l = n.create();
            s.prototype.computeGiMf = function() {
                var t = this.bodyA,
                    e = this.bodyB,
                    i = t.force,
                    s = t.angularForce,
                    r = e.force,
                    o = e.angularForce,
                    a = t.invMassSolve,
                    c = e.invMassSolve,
                    u = t.invInertiaSolve,
                    d = e.invInertiaSolve,
                    p = this.G;
                return n.scale(h, i, a), n.multiply(h, t.massMultiplier, h), n.scale(l, r, c), n.multiply(l, e.massMultiplier, l), this.gmult(p, h, s * u, l, o * d)
            }, s.prototype.computeGiMGt = function() {
                var t = this.bodyA,
                    e = this.bodyB,
                    i = t.invMassSolve,
                    s = e.invMassSolve,
                    n = t.invInertiaSolve,
                    r = e.invInertiaSolve,
                    o = this.G;
                return o[0] * o[0] * i * t.massMultiplier[0] + o[1] * o[1] * i * t.massMultiplier[1] + o[2] * o[2] * n + o[3] * o[3] * s * e.massMultiplier[0] + o[4] * o[4] * s * e.massMultiplier[1] + o[5] * o[5] * r
            };
            var c = n.create(),
                u = n.create(),
                d = n.create();
            n.create(), n.create(), n.create(), s.prototype.addToWlambda = function(t) {
                var e = this.bodyA,
                    i = this.bodyB,
                    s = c,
                    r = u,
                    o = d,
                    a = e.invMassSolve,
                    h = i.invMassSolve,
                    l = e.invInertiaSolve,
                    p = i.invInertiaSolve,
                    f = this.G;
                r[0] = f[0], r[1] = f[1], o[0] = f[3], o[1] = f[4], n.scale(s, r, a * t), n.multiply(s, s, e.massMultiplier), n.add(e.vlambda, e.vlambda, s), e.wlambda += l * f[2] * t, n.scale(s, o, h * t), n.multiply(s, s, i.massMultiplier), n.add(i.vlambda, i.vlambda, s), i.wlambda += p * f[5] * t
            }, s.prototype.computeInvC = function(t) {
                return 1 / (this.computeGiMGt() + t)
            }
        }, {
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../utils/Utils": 57
        }],
        23: [function(t, e, i) {
            function s(t, e, i) {
                r.call(this, t, e, -i, i), this.contactPointA = n.create(), this.contactPointB = n.create(), this.t = n.create(), this.contactEquations = [], this.shapeA = null, this.shapeB = null, this.frictionCoefficient = .3
            }
            var n = t("../math/vec2"),
                r = t("./Equation");
            t("../utils/Utils"), e.exports = s, (s.prototype = new r).constructor = s, s.prototype.setSlipForce = function(t) {
                this.maxForce = t, this.minForce = -t
            }, s.prototype.getSlipForce = function() {
                return this.maxForce
            }, s.prototype.computeB = function(t, e, i) {
                this.bodyA, this.bodyB;
                var s = this.contactPointA,
                    r = this.contactPointB,
                    o = this.t,
                    a = this.G;
                return a[0] = -o[0], a[1] = -o[1], a[2] = -n.crossLength(s, o), a[3] = o[0], a[4] = o[1], a[5] = n.crossLength(r, o), -this.computeGW() * e - i * this.computeGiMf()
            }
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Equation": 22
        }],
        24: [function(t, e, i) {
            function s(t, e, i) {
                i = i || {}, n.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE), this.angle = i.angle || 0;
                var s = this.G;
                s[2] = 1, s[5] = -1
            }
            var n = t("./Equation"),
                r = t("../math/vec2");
            e.exports = s, (s.prototype = new n).constructor = s;
            var o = r.create(),
                a = r.create(),
                h = r.fromValues(1, 0),
                l = r.fromValues(0, 1);
            s.prototype.computeGq = function() {
                return r.rotate(o, h, this.bodyA.angle + this.angle), r.rotate(a, l, this.bodyB.angle), r.dot(o, a)
            }
        }, {
            "../math/vec2": 30,
            "./Equation": 22
        }],
        25: [function(t, e, i) {
            function s(t, e) {
                n.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE), this.relativeVelocity = 1, this.ratio = 1
            }
            var n = t("./Equation");
            t("../math/vec2"), e.exports = s, (s.prototype = new n).constructor = s, s.prototype.computeB = function(t, e, i) {
                var s = this.G;
                s[2] = -1, s[5] = this.ratio;
                var n = this.computeGiMf();
                return -this.computeGW() * e - i * n
            }
        }, {
            "../math/vec2": 30,
            "./Equation": 22
        }],
        26: [function(t, e, i) {
            var s = function() {};
            e.exports = s, s.prototype = {
                constructor: s,
                on: function(t, e, i) {
                    e.context = i || this, void 0 === this._listeners && (this._listeners = {});
                    var s = this._listeners;
                    return void 0 === s[t] && (s[t] = []), -1 === s[t].indexOf(e) && s[t].push(e), this
                },
                has: function(t, e) {
                    if (void 0 === this._listeners) return !1;
                    var i = this._listeners;
                    if (e) {
                        if (void 0 !== i[t] && -1 !== i[t].indexOf(e)) return !0
                    } else if (void 0 !== i[t]) return !0;
                    return !1
                },
                off: function(t, e) {
                    if (void 0 === this._listeners) return this;
                    var i = this._listeners,
                        s = i[t].indexOf(e);
                    return -1 !== s && i[t].splice(s, 1), this
                },
                emit: function(t) {
                    if (void 0 === this._listeners) return this;
                    var e = this._listeners[t.type];
                    if (void 0 !== e) {
                        t.target = this;
                        for (var i = 0, s = e.length; i < s; i++) {
                            var n = e[i];
                            n.call(n.context, t)
                        }
                    }
                    return this
                }
            }
        }, {}],
        27: [function(t, e, i) {
            function s(t, e, i) {
                if (i = i || {}, !(t instanceof n && e instanceof n)) throw new Error("First two arguments must be Material instances.");
                this.id = s.idCounter++, this.materialA = t, this.materialB = e, this.friction = void 0 !== i.friction ? Number(i.friction) : .3, this.restitution = void 0 !== i.restitution ? Number(i.restitution) : 0, this.stiffness = void 0 !== i.stiffness ? Number(i.stiffness) : r.DEFAULT_STIFFNESS, this.relaxation = void 0 !== i.relaxation ? Number(i.relaxation) : r.DEFAULT_RELAXATION, this.frictionStiffness = void 0 !== i.frictionStiffness ? Number(i.frictionStiffness) : r.DEFAULT_STIFFNESS, this.frictionRelaxation = void 0 !== i.frictionRelaxation ? Number(i.frictionRelaxation) : r.DEFAULT_RELAXATION, this.surfaceVelocity = void 0 !== i.surfaceVelocity ? Number(i.surfaceVelocity) : 0, this.contactSkinSize = .005
            }
            var n = t("./Material"),
                r = t("../equations/Equation");
            e.exports = s, s.idCounter = 0
        }, {
            "../equations/Equation": 22,
            "./Material": 28
        }],
        28: [function(t, e, i) {
            function s(t) {
                this.id = t || s.idCounter++
            }
            e.exports = s, s.idCounter = 0
        }, {}],
        29: [function(t, e, i) {
            var s = {
                GetArea: function(t) {
                    if (t.length < 6) return 0;
                    for (var e = t.length - 2, i = 0, s = 0; s < e; s += 2) i += (t[s + 2] - t[s]) * (t[s + 1] + t[s + 3]);
                    return .5 * -(i += (t[0] - t[e]) * (t[e + 1] + t[1]))
                },
                Triangulate: function(t) {
                    var e = t.length >> 1;
                    if (e < 3) return [];
                    for (var i = [], n = [], r = 0; r < e; r++) n.push(r);
                    r = 0;
                    for (var o = e; o > 3;) {
                        var a = n[(r + 0) % o],
                            h = n[(r + 1) % o],
                            l = n[(r + 2) % o],
                            c = t[2 * a],
                            u = t[2 * a + 1],
                            d = t[2 * h],
                            p = t[2 * h + 1],
                            f = t[2 * l],
                            g = t[2 * l + 1],
                            m = !1;
                        if (s._convex(c, u, d, p, f, g)) {
                            m = !0;
                            for (var y = 0; y < o; y++) {
                                var v = n[y];
                                if (v != a && v != h && v != l && s._PointInTriangle(t[2 * v], t[2 * v + 1], c, u, d, p, f, g)) {
                                    m = !1;
                                    break
                                }
                            }
                        }
                        if (m) i.push(a, h, l), n.splice((r + 1) % o, 1), o--, r = 0;
                        else if (r++ > 3 * o) break
                    }
                    return i.push(n[0], n[1], n[2]), i
                },
                _PointInTriangle: function(t, e, i, s, n, r, o, a) {
                    var h = o - i,
                        l = a - s,
                        c = n - i,
                        u = r - s,
                        d = t - i,
                        p = e - s,
                        f = h * h + l * l,
                        g = h * c + l * u,
                        m = h * d + l * p,
                        y = c * c + u * u,
                        v = c * d + u * p,
                        x = 1 / (f * y - g * g),
                        b = (y * m - g * v) * x,
                        _ = (f * v - g * m) * x;
                    return b >= 0 && _ >= 0 && b + _ < 1
                },
                _convex: function(t, e, i, s, n, r) {
                    return (e - s) * (n - i) + (i - t) * (r - s) >= 0
                }
            };
            e.exports = s
        }, {}],
        30: [function(t, e, i) {
            var s = e.exports = {},
                n = t("../utils/Utils");
            s.crossLength = function(t, e) {
                return t[0] * e[1] - t[1] * e[0]
            }, s.crossVZ = function(t, e, i) {
                return s.rotate(t, e, -Math.PI / 2), s.scale(t, t, i), t
            }, s.crossZV = function(t, e, i) {
                return s.rotate(t, i, Math.PI / 2), s.scale(t, t, e), t
            }, s.rotate = function(t, e, i) {
                if (0 !== i) {
                    var s = Math.cos(i),
                        n = Math.sin(i),
                        r = e[0],
                        o = e[1];
                    t[0] = s * r - n * o, t[1] = n * r + s * o
                } else t[0] = e[0], t[1] = e[1]
            }, s.rotate90cw = function(t, e) {
                var i = e[0],
                    s = e[1];
                t[0] = s, t[1] = -i
            }, s.toLocalFrame = function(t, e, i, n) {
                s.copy(t, e), s.sub(t, t, i), s.rotate(t, t, -n)
            }, s.toGlobalFrame = function(t, e, i, n) {
                s.copy(t, e), s.rotate(t, t, n), s.add(t, t, i)
            }, s.vectorToLocalFrame = function(t, e, i) {
                s.rotate(t, e, -i)
            }, s.vectorToGlobalFrame = function(t, e, i) {
                s.rotate(t, e, i)
            }, s.centroid = function(t, e, i, n) {
                return s.add(t, e, i), s.add(t, t, n), s.scale(t, t, 1 / 3), t
            }, s.create = function() {
                var t = new n.ARRAY_TYPE(2);
                return t[0] = 0, t[1] = 0, t
            }, s.clone = function(t) {
                var e = new n.ARRAY_TYPE(2);
                return e[0] = t[0], e[1] = t[1], e
            }, s.fromValues = function(t, e) {
                var i = new n.ARRAY_TYPE(2);
                return i[0] = t, i[1] = e, i
            }, s.copy = function(t, e) {
                return t[0] = e[0], t[1] = e[1], t
            }, s.set = function(t, e, i) {
                return t[0] = e, t[1] = i, t
            }, s.add = function(t, e, i) {
                return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t
            }, s.subtract = function(t, e, i) {
                return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t
            }, s.sub = s.subtract, s.multiply = function(t, e, i) {
                return t[0] = e[0] * i[0], t[1] = e[1] * i[1], t
            }, s.mul = s.multiply, s.divide = function(t, e, i) {
                return t[0] = e[0] / i[0], t[1] = e[1] / i[1], t
            }, s.div = s.divide, s.scale = function(t, e, i) {
                return t[0] = e[0] * i, t[1] = e[1] * i, t
            }, s.distance = function(t, e) {
                var i = e[0] - t[0],
                    s = e[1] - t[1];
                return Math.sqrt(i * i + s * s)
            }, s.dist = s.distance, s.squaredDistance = function(t, e) {
                var i = e[0] - t[0],
                    s = e[1] - t[1];
                return i * i + s * s
            }, s.sqrDist = s.squaredDistance, s.length = function(t) {
                var e = t[0],
                    i = t[1];
                return Math.sqrt(e * e + i * i)
            }, s.len = s.length, s.squaredLength = function(t) {
                var e = t[0],
                    i = t[1];
                return e * e + i * i
            }, s.sqrLen = s.squaredLength, s.negate = function(t, e) {
                return t[0] = -e[0], t[1] = -e[1], t
            }, s.normalize = function(t, e) {
                var i = e[0],
                    s = e[1],
                    n = i * i + s * s;
                return n > 0 && (n = 1 / Math.sqrt(n), t[0] = e[0] * n, t[1] = e[1] * n), t
            }, s.dot = function(t, e) {
                return t[0] * e[0] + t[1] * e[1]
            }, s.str = function(t) {
                return "vec2(" + t[0] + ", " + t[1] + ")"
            }, s.lerp = function(t, e, i, s) {
                var n = e[0],
                    r = e[1];
                return t[0] = n + s * (i[0] - n), t[1] = r + s * (i[1] - r), t
            }, s.reflect = function(t, e, i) {
                var s = e[0] * i[0] + e[1] * i[1];
                t[0] = e[0] - 2 * i[0] * s, t[1] = e[1] - 2 * i[1] * s
            }, s.getLineSegmentsIntersection = function(t, e, i, n, r) {
                var o = s.getLineSegmentsIntersectionFraction(e, i, n, r);
                return !(o < 0 || (t[0] = e[0] + o * (i[0] - e[0]), t[1] = e[1] + o * (i[1] - e[1]), 0))
            }, s.getLineSegmentsIntersectionFraction = function(t, e, i, s) {
                var n, r, o = e[0] - t[0],
                    a = e[1] - t[1],
                    h = s[0] - i[0],
                    l = s[1] - i[1];
                return n = (-a * (t[0] - i[0]) + o * (t[1] - i[1])) / (-h * a + o * l), r = (h * (t[1] - i[1]) - l * (t[0] - i[0])) / (-h * a + o * l), n >= 0 && n <= 1 && r >= 0 && r <= 1 ? r : -1
            }
        }, {
            "../utils/Utils": 57
        }],
        31: [function(t, e, i) {
            function s(t) {
                t = t || {}, c.call(this), this.id = t.id || ++s._idCounter, this.world = null, this.shapes = [], this.mass = t.mass || 0, this.invMass = 0, this.inertia = 0, this.invInertia = 0, this.invMassSolve = 0, this.invInertiaSolve = 0, this.fixedRotation = !!t.fixedRotation, this.fixedX = !!t.fixedX, this.fixedY = !!t.fixedY, this.massMultiplier = n.create(), this.position = n.fromValues(0, 0), t.position && n.copy(this.position, t.position), this.interpolatedPosition = n.fromValues(0, 0), this.interpolatedAngle = 0, this.previousPosition = n.fromValues(0, 0), this.previousAngle = 0, this.velocity = n.fromValues(0, 0), t.velocity && n.copy(this.velocity, t.velocity), this.vlambda = n.fromValues(0, 0), this.wlambda = 0, this.angle = t.angle || 0, this.angularVelocity = t.angularVelocity || 0, this.force = n.create(), t.force && n.copy(this.force, t.force), this.angularForce = t.angularForce || 0, this.damping = "number" == typeof t.damping ? t.damping : .1, this.angularDamping = "number" == typeof t.angularDamping ? t.angularDamping : .1, this.type = s.STATIC, void 0 !== t.type ? this.type = t.type : t.mass ? this.type = s.DYNAMIC : this.type = s.STATIC, this.boundingRadius = 0, this.aabb = new l, this.aabbNeedsUpdate = !0, this.allowSleep = void 0 === t.allowSleep || t.allowSleep, this.wantsToSleep = !1, this.sleepState = s.AWAKE, this.sleepSpeedLimit = void 0 !== t.sleepSpeedLimit ? t.sleepSpeedLimit : .2, this.sleepTimeLimit = void 0 !== t.sleepTimeLimit ? t.sleepTimeLimit : 1, this.gravityScale = void 0 !== t.gravityScale ? t.gravityScale : 1, this.collisionResponse = void 0 === t.collisionResponse || t.collisionResponse, this.idleTime = 0, this.timeLastSleepy = 0, this.ccdSpeedThreshold = void 0 !== t.ccdSpeedThreshold ? t.ccdSpeedThreshold : -1, this.ccdIterations = void 0 !== t.ccdIterations ? t.ccdIterations : 10, this.concavePath = null, this._wakeUpAfterNarrowphase = !1, this.updateMassProperties()
            }
            var n = t("../math/vec2"),
                r = t("poly-decomp"),
                o = t("../shapes/Convex"),
                a = t("../collision/RaycastResult"),
                h = t("../collision/Ray"),
                l = t("../collision/AABB"),
                c = t("../events/EventEmitter");
            e.exports = s, s.prototype = new c, s.prototype.constructor = s, s._idCounter = 0, s.prototype.updateSolveMassProperties = function() {
                this.sleepState === s.SLEEPING || this.type === s.KINEMATIC ? (this.invMassSolve = 0, this.invInertiaSolve = 0) : (this.invMassSolve = this.invMass, this.invInertiaSolve = this.invInertia)
            }, s.prototype.setDensity = function(t) {
                var e = this.getArea();
                this.mass = e * t, this.updateMassProperties()
            }, s.prototype.getArea = function() {
                for (var t = 0, e = 0; e < this.shapes.length; e++) t += this.shapes[e].area;
                return t
            }, s.prototype.getAABB = function() {
                return this.aabbNeedsUpdate && this.updateAABB(), this.aabb
            };
            var u = new l,
                d = n.create();
            s.prototype.updateAABB = function() {
                for (var t = this.shapes, e = t.length, i = d, s = this.angle, r = 0; r !== e; r++) {
                    var o = t[r],
                        a = o.angle + s;
                    n.rotate(i, o.position, s), n.add(i, i, this.position), o.computeAABB(u, i, a), 0 === r ? this.aabb.copy(u) : this.aabb.extend(u)
                }
                this.aabbNeedsUpdate = !1
            }, s.prototype.updateBoundingRadius = function() {
                for (var t = this.shapes, e = t.length, i = 0, s = 0; s !== e; s++) {
                    var r = t[s],
                        o = n.length(r.position),
                        a = r.boundingRadius;
                    o + a > i && (i = o + a)
                }
                this.boundingRadius = i
            }, s.prototype.addShape = function(t, e, i) {
                if (t.body) throw new Error("A shape can only be added to one body.");
                t.body = this, e ? n.copy(t.position, e) : n.set(t.position, 0, 0), t.angle = i || 0, this.shapes.push(t), this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = !0
            }, s.prototype.removeShape = function(t) {
                var e = this.shapes.indexOf(t);
                return -1 !== e && (this.shapes.splice(e, 1), this.aabbNeedsUpdate = !0, t.body = null, !0)
            }, s.prototype.updateMassProperties = function() {
                if (this.type === s.STATIC || this.type === s.KINEMATIC) this.mass = Number.MAX_VALUE, this.invMass = 0, this.inertia = Number.MAX_VALUE, this.invInertia = 0;
                else {
                    var t = this.shapes,
                        e = t.length,
                        i = this.mass / e,
                        r = 0;
                    if (this.fixedRotation) this.inertia = Number.MAX_VALUE, this.invInertia = 0;
                    else {
                        for (var o = 0; o < e; o++) {
                            var a = t[o],
                                h = n.squaredLength(a.position);
                            r += a.computeMomentOfInertia(i) + i * h
                        }
                        this.inertia = r, this.invInertia = r > 0 ? 1 / r : 0
                    }
                    this.invMass = 1 / this.mass, n.set(this.massMultiplier, this.fixedX ? 0 : 1, this.fixedY ? 0 : 1)
                }
            }, n.create(), s.prototype.applyForce = function(t, e) {
                if (n.add(this.force, this.force, t), e) {
                    var i = n.crossLength(e, t);
                    this.angularForce += i
                }
            };
            var p = n.create(),
                f = n.create(),
                g = n.create();
            s.prototype.applyForceLocal = function(t, e) {
                e = e || g;
                var i = p,
                    s = f;
                this.vectorToWorldFrame(i, t), this.vectorToWorldFrame(s, e), this.applyForce(i, s)
            };
            var m = n.create();
            s.prototype.applyImpulse = function(t, e) {
                if (this.type === s.DYNAMIC) {
                    var i = m;
                    if (n.scale(i, t, this.invMass), n.multiply(i, this.massMultiplier, i), n.add(this.velocity, i, this.velocity), e) {
                        var r = n.crossLength(e, t);
                        r *= this.invInertia, this.angularVelocity += r
                    }
                }
            };
            var y = n.create(),
                v = n.create(),
                x = n.create();
            s.prototype.applyImpulseLocal = function(t, e) {
                e = e || x;
                var i = y,
                    s = v;
                this.vectorToWorldFrame(i, t), this.vectorToWorldFrame(s, e), this.applyImpulse(i, s)
            }, s.prototype.toLocalFrame = function(t, e) {
                n.toLocalFrame(t, e, this.position, this.angle)
            }, s.prototype.toWorldFrame = function(t, e) {
                n.toGlobalFrame(t, e, this.position, this.angle)
            }, s.prototype.vectorToLocalFrame = function(t, e) {
                n.vectorToLocalFrame(t, e, this.angle)
            }, s.prototype.vectorToWorldFrame = function(t, e) {
                n.vectorToGlobalFrame(t, e, this.angle)
            }, s.prototype.fromPolygon = function(t, e) {
                for (e = e || {}, h = this.shapes.length; h >= 0; --h) this.removeShape(this.shapes[h]);
                var i, s = new r.Polygon;
                if (s.vertices = t, s.makeCCW(), "number" == typeof e.removeCollinearPoints && s.removeCollinearPoints(e.removeCollinearPoints), void 0 === e.skipSimpleCheck && !s.isSimple()) return !1;
                for (this.concavePath = s.vertices.slice(0), h = 0; h < this.concavePath.length; h++) u = [0, 0], n.copy(u, this.concavePath[h]), this.concavePath[h] = u;
                i = e.optimalDecomp ? s.decomp() : s.quickDecomp();
                for (var a = n.create(), h = 0; h !== i.length; h++) {
                    for (var l = new o({
                            vertices: i[h].vertices
                        }), c = 0; c !== l.vertices.length; c++) {
                        var u = l.vertices[c];
                        n.sub(u, u, l.centerOfMass)
                    }
                    n.scale(a, l.centerOfMass, 1), l.updateTriangles(), l.updateCenterOfMass(), l.updateBoundingRadius(), this.addShape(l, a)
                }
                return this.adjustCenterOfMass(), this.aabbNeedsUpdate = !0, !0
            }, n.fromValues(0, 0);
            var b = n.fromValues(0, 0),
                _ = n.fromValues(0, 0),
                w = n.fromValues(0, 0);
            s.prototype.adjustCenterOfMass = function() {
                var t = b,
                    e = _,
                    i = w,
                    s = 0;
                for (n.set(e, 0, 0), o = 0; o !== this.shapes.length; o++) r = this.shapes[o], n.scale(t, r.position, r.area), n.add(e, e, t), s += r.area;
                for (n.scale(i, e, 1 / s), o = 0; o !== this.shapes.length; o++) {
                    var r = this.shapes[o];
                    n.sub(r.position, r.position, i)
                }
                n.add(this.position, this.position, i);
                for (var o = 0; this.concavePath && o < this.concavePath.length; o++) n.sub(this.concavePath[o], this.concavePath[o], i);
                this.updateMassProperties(), this.updateBoundingRadius()
            }, s.prototype.setZeroForce = function() {
                n.set(this.force, 0, 0), this.angularForce = 0
            }, s.prototype.resetConstraintVelocity = function() {
                var t = this.vlambda;
                n.set(t, 0, 0), this.wlambda = 0
            }, s.prototype.addConstraintVelocity = function() {
                var t = this,
                    e = t.velocity;
                n.add(e, e, t.vlambda), t.angularVelocity += t.wlambda
            }, s.prototype.applyDamping = function(t) {
                if (this.type === s.DYNAMIC) {
                    var e = this.velocity;
                    n.scale(e, e, Math.pow(1 - this.damping, t)), this.angularVelocity *= Math.pow(1 - this.angularDamping, t)
                }
            }, s.prototype.wakeUp = function() {
                var t = this.sleepState;
                this.sleepState = s.AWAKE, this.idleTime = 0, t !== s.AWAKE && this.emit(s.wakeUpEvent)
            }, s.prototype.sleep = function() {
                this.sleepState = s.SLEEPING, this.angularVelocity = 0, this.angularForce = 0, n.set(this.velocity, 0, 0), n.set(this.force, 0, 0), this.emit(s.sleepEvent)
            }, s.prototype.sleepTick = function(t, e, i) {
                this.allowSleep && this.type !== s.SLEEPING && (this.wantsToSleep = !1, this.sleepState, n.squaredLength(this.velocity) + Math.pow(this.angularVelocity, 2) >= Math.pow(this.sleepSpeedLimit, 2) ? (this.idleTime = 0, this.sleepState = s.AWAKE) : (this.idleTime += i, this.sleepState = s.SLEEPY), this.idleTime > this.sleepTimeLimit && (e ? this.wantsToSleep = !0 : this.sleep()))
            }, s.prototype.overlaps = function(t) {
                return this.world.overlapKeeper.bodiesAreOverlapping(this, t)
            };
            var T = n.create(),
                P = n.create();
            s.prototype.integrate = function(t) {
                var e = this.invMass,
                    i = this.force,
                    s = this.position,
                    r = this.velocity;
                n.copy(this.previousPosition, this.position), this.previousAngle = this.angle, this.fixedRotation || (this.angularVelocity += this.angularForce * this.invInertia * t), n.scale(T, i, t * e), n.multiply(T, this.massMultiplier, T), n.add(r, T, r), this.integrateToTimeOfImpact(t) || (n.scale(P, r, t), n.add(s, s, P), this.fixedRotation || (this.angle += this.angularVelocity * t)), this.aabbNeedsUpdate = !0
            };
            var C = new a,
                S = new h({
                    mode: h.ALL
                }),
                A = n.create(),
                E = n.create(),
                M = n.create(),
                R = n.create();
            s.prototype.integrateToTimeOfImpact = function(t) {
                if (this.ccdSpeedThreshold < 0 || n.squaredLength(this.velocity) < Math.pow(this.ccdSpeedThreshold, 2)) return !1;
                n.normalize(A, this.velocity), n.scale(E, this.velocity, t), n.add(E, E, this.position), n.sub(M, E, this.position);
                var e, i = this.angularVelocity * t,
                    s = n.length(M),
                    r = 1,
                    o = this;
                if (C.reset(), S.callback = function(t) {
                        t.body !== o && (e = t.body, t.getHitPoint(E, S), n.sub(M, E, o.position), r = n.length(M) / s, t.stop())
                    }, n.copy(S.from, this.position), n.copy(S.to, E), S.update(), this.world.raycast(C, S), !e) return !1;
                var a = this.angle;
                n.copy(R, this.position);
                for (var h = 0, l = 0, c = 0, u = r; u >= l && h < this.ccdIterations;) h++, c = (u - l) / 2, n.scale(P, M, r), n.add(this.position, R, P), this.angle = a + i * r, this.updateAABB(), this.aabb.overlaps(e.aabb) && this.world.narrowphase.bodiesOverlap(this, e) ? l = c : u = c;
                return r = c, n.copy(this.position, R), this.angle = a, n.scale(P, M, r), n.add(this.position, this.position, P), this.fixedRotation || (this.angle += i * r), !0
            }, s.prototype.getVelocityAtPoint = function(t, e) {
                return n.crossVZ(t, e, this.angularVelocity), n.subtract(t, this.velocity, t), t
            }, s.sleepyEvent = {
                type: "sleepy"
            }, s.sleepEvent = {
                type: "sleep"
            }, s.wakeUpEvent = {
                type: "wakeup"
            }, s.DYNAMIC = 1, s.STATIC = 2, s.KINEMATIC = 4, s.AWAKE = 0, s.SLEEPY = 1, s.SLEEPING = 2
        }, {
            "../collision/AABB": 7,
            "../collision/Ray": 11,
            "../collision/RaycastResult": 12,
            "../events/EventEmitter": 26,
            "../math/vec2": 30,
            "../shapes/Convex": 40,
            "poly-decomp": 5
        }],
        32: [function(t, e, i) {
            function s(t, e, i) {
                i = i || {}, r.call(this, t, e, i), this.localAnchorA = n.fromValues(0, 0), this.localAnchorB = n.fromValues(0, 0), i.localAnchorA && n.copy(this.localAnchorA, i.localAnchorA), i.localAnchorB && n.copy(this.localAnchorB, i.localAnchorB), i.worldAnchorA && this.setWorldAnchorA(i.worldAnchorA), i.worldAnchorB && this.setWorldAnchorB(i.worldAnchorB);
                var s = n.create(),
                    o = n.create();
                this.getWorldAnchorA(s), this.getWorldAnchorB(o);
                var a = n.distance(s, o);
                this.restLength = "number" == typeof i.restLength ? i.restLength : a
            }
            var n = t("../math/vec2"),
                r = t("./Spring");
            t("../utils/Utils"), e.exports = s, (s.prototype = new r).constructor = s, s.prototype.setWorldAnchorA = function(t) {
                this.bodyA.toLocalFrame(this.localAnchorA, t)
            }, s.prototype.setWorldAnchorB = function(t) {
                this.bodyB.toLocalFrame(this.localAnchorB, t)
            }, s.prototype.getWorldAnchorA = function(t) {
                this.bodyA.toWorldFrame(t, this.localAnchorA)
            }, s.prototype.getWorldAnchorB = function(t) {
                this.bodyB.toWorldFrame(t, this.localAnchorB)
            };
            var o = n.create(),
                a = n.create(),
                h = n.create(),
                l = n.create(),
                c = n.create(),
                u = n.create(),
                d = n.create(),
                p = n.create(),
                f = n.create();
            s.prototype.applyForce = function() {
                var t = this.stiffness,
                    e = this.damping,
                    i = this.restLength,
                    s = this.bodyA,
                    r = this.bodyB,
                    g = o,
                    m = a,
                    y = h,
                    v = l,
                    x = f,
                    b = c,
                    _ = u,
                    w = d,
                    T = p;
                this.getWorldAnchorA(b), this.getWorldAnchorB(_), n.sub(w, b, s.position), n.sub(T, _, r.position), n.sub(g, _, b);
                var P = n.len(g);
                n.normalize(m, g), n.sub(y, r.velocity, s.velocity), n.crossZV(x, r.angularVelocity, T), n.add(y, y, x), n.crossZV(x, s.angularVelocity, w), n.sub(y, y, x), n.scale(v, m, -t * (P - i) - e * n.dot(y, m)), n.sub(s.force, s.force, v), n.add(r.force, r.force, v);
                var C = n.crossLength(w, v),
                    S = n.crossLength(T, v);
                s.angularForce -= C, r.angularForce += S
            }
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Spring": 34
        }],
        33: [function(t, e, i) {
            function s(t, e, i) {
                i = i || {}, n.call(this, t, e, i), this.restAngle = "number" == typeof i.restAngle ? i.restAngle : e.angle - t.angle
            }
            t("../math/vec2");
            var n = t("./Spring");
            e.exports = s, (s.prototype = new n).constructor = s, s.prototype.applyForce = function() {
                var t = this.stiffness,
                    e = this.damping,
                    i = this.restAngle,
                    s = this.bodyA,
                    n = this.bodyB,
                    r = -t * (n.angle - s.angle - i) - e * (n.angularVelocity - s.angularVelocity) * 0;
                s.angularForce -= r, n.angularForce += r
            }
        }, {
            "../math/vec2": 30,
            "./Spring": 34
        }],
        34: [function(t, e, i) {
            function s(t, e, i) {
                i = n.defaults(i, {
                    stiffness: 100,
                    damping: 1
                }), this.stiffness = i.stiffness, this.damping = i.damping, this.bodyA = t, this.bodyB = e
            }
            t("../math/vec2");
            var n = t("../utils/Utils");
            e.exports = s, s.prototype.applyForce = function() {}
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57
        }],
        35: [function(t, e, i) {
            function s(t, e) {
                e = e || {}, this.chassisBody = t, this.wheels = [], this.groundBody = new h({
                    mass: 0
                }), this.world = null;
                var i = this;
                this.preStepCallback = function() {
                    i.update()
                }
            }

            function n(t, e) {
                e = e || {}, this.vehicle = t, this.forwardEquation = new a(t.chassisBody, t.groundBody), this.sideEquation = new a(t.chassisBody, t.groundBody), this.steerValue = 0, this.engineForce = 0, this.setSideFriction(void 0 !== e.sideFriction ? e.sideFriction : 5), this.localForwardVector = r.fromValues(0, 1), e.localForwardVector && r.copy(this.localForwardVector, e.localForwardVector), this.localPosition = r.fromValues(0, 0), e.localPosition && r.copy(this.localPosition, e.localPosition), o.apply(this, t.chassisBody, t.groundBody), this.equations.push(this.forwardEquation, this.sideEquation), this.setBrakeForce(0)
            }
            var r = t("../math/vec2"),
                o = (t("../utils/Utils"), t("../constraints/Constraint")),
                a = t("../equations/FrictionEquation"),
                h = t("../objects/Body");
            e.exports = s, s.prototype.addToWorld = function(t) {
                this.world = t, t.addBody(this.groundBody), t.on("preStep", this.preStepCallback);
                for (var e = 0; e < this.wheels.length; e++) {
                    var i = this.wheels[e];
                    t.addConstraint(i)
                }
            }, s.prototype.removeFromWorld = function() {
                var t = this.world;
                t.removeBody(this.groundBody), t.off("preStep", this.preStepCallback);
                for (var e = 0; e < this.wheels.length; e++) {
                    var i = this.wheels[e];
                    t.removeConstraint(i)
                }
                this.world = null
            }, s.prototype.addWheel = function(t) {
                var e = new n(this, t);
                return this.wheels.push(e), e
            }, s.prototype.update = function() {
                for (var t = 0; t < this.wheels.length; t++) this.wheels[t].update()
            }, (n.prototype = new o).setBrakeForce = function(t) {
                this.forwardEquation.setSlipForce(t)
            }, n.prototype.setSideFriction = function(t) {
                this.sideEquation.setSlipForce(t)
            };
            var l = r.create(),
                c = r.create();
            n.prototype.getSpeed = function() {
                return this.vehicle.chassisBody.vectorToWorldFrame(c, this.localForwardVector), this.vehicle.chassisBody.getVelocityAtPoint(l, c), r.dot(l, c)
            };
            var u = r.create();
            n.prototype.update = function() {
                this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.t, this.localForwardVector), r.rotate(this.sideEquation.t, this.localForwardVector, Math.PI / 2), this.vehicle.chassisBody.vectorToWorldFrame(this.sideEquation.t, this.sideEquation.t), r.rotate(this.forwardEquation.t, this.forwardEquation.t, this.steerValue), r.rotate(this.sideEquation.t, this.sideEquation.t, this.steerValue), this.vehicle.chassisBody.toWorldFrame(this.forwardEquation.contactPointB, this.localPosition), r.copy(this.sideEquation.contactPointB, this.forwardEquation.contactPointB), this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.contactPointA, this.localPosition), r.copy(this.sideEquation.contactPointA, this.forwardEquation.contactPointA), r.normalize(u, this.forwardEquation.t), r.scale(u, u, this.engineForce), this.vehicle.chassisBody.applyForce(u, this.forwardEquation.contactPointA)
            }
        }, {
            "../constraints/Constraint": 14,
            "../equations/FrictionEquation": 23,
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../utils/Utils": 57
        }],
        36: [function(t, e, i) {
            var s = e.exports = {
                AABB: t("./collision/AABB"),
                AngleLockEquation: t("./equations/AngleLockEquation"),
                Body: t("./objects/Body"),
                Broadphase: t("./collision/Broadphase"),
                Capsule: t("./shapes/Capsule"),
                Circle: t("./shapes/Circle"),
                Constraint: t("./constraints/Constraint"),
                ContactEquation: t("./equations/ContactEquation"),
                ContactEquationPool: t("./utils/ContactEquationPool"),
                ContactMaterial: t("./material/ContactMaterial"),
                Convex: t("./shapes/Convex"),
                DistanceConstraint: t("./constraints/DistanceConstraint"),
                Equation: t("./equations/Equation"),
                EventEmitter: t("./events/EventEmitter"),
                FrictionEquation: t("./equations/FrictionEquation"),
                FrictionEquationPool: t("./utils/FrictionEquationPool"),
                GearConstraint: t("./constraints/GearConstraint"),
                GSSolver: t("./solver/GSSolver"),
                Heightfield: t("./shapes/Heightfield"),
                Line: t("./shapes/Line"),
                LockConstraint: t("./constraints/LockConstraint"),
                Material: t("./material/Material"),
                Narrowphase: t("./collision/Narrowphase"),
                NaiveBroadphase: t("./collision/NaiveBroadphase"),
                Particle: t("./shapes/Particle"),
                Plane: t("./shapes/Plane"),
                Pool: t("./utils/Pool"),
                RevoluteConstraint: t("./constraints/RevoluteConstraint"),
                PrismaticConstraint: t("./constraints/PrismaticConstraint"),
                Ray: t("./collision/Ray"),
                RaycastResult: t("./collision/RaycastResult"),
                Box: t("./shapes/Box"),
                RotationalVelocityEquation: t("./equations/RotationalVelocityEquation"),
                SAPBroadphase: t("./collision/SAPBroadphase"),
                Shape: t("./shapes/Shape"),
                Solver: t("./solver/Solver"),
                Spring: t("./objects/Spring"),
                TopDownVehicle: t("./objects/TopDownVehicle"),
                LinearSpring: t("./objects/LinearSpring"),
                RotationalSpring: t("./objects/RotationalSpring"),
                Utils: t("./utils/Utils"),
                World: t("./world/World"),
                vec2: t("./math/vec2"),
                version: t("../package.json").version
            };
            Object.defineProperty(s, "Rectangle", {
                get: function() {
                    return console.warn("The Rectangle class has been renamed to Box."), this.Box
                }
            })
        }, {
            "../package.json": 6,
            "./collision/AABB": 7,
            "./collision/Broadphase": 8,
            "./collision/NaiveBroadphase": 9,
            "./collision/Narrowphase": 10,
            "./collision/Ray": 11,
            "./collision/RaycastResult": 12,
            "./collision/SAPBroadphase": 13,
            "./constraints/Constraint": 14,
            "./constraints/DistanceConstraint": 15,
            "./constraints/GearConstraint": 16,
            "./constraints/LockConstraint": 17,
            "./constraints/PrismaticConstraint": 18,
            "./constraints/RevoluteConstraint": 19,
            "./equations/AngleLockEquation": 20,
            "./equations/ContactEquation": 21,
            "./equations/Equation": 22,
            "./equations/FrictionEquation": 23,
            "./equations/RotationalVelocityEquation": 25,
            "./events/EventEmitter": 26,
            "./material/ContactMaterial": 27,
            "./material/Material": 28,
            "./math/vec2": 30,
            "./objects/Body": 31,
            "./objects/LinearSpring": 32,
            "./objects/RotationalSpring": 33,
            "./objects/Spring": 34,
            "./objects/TopDownVehicle": 35,
            "./shapes/Box": 37,
            "./shapes/Capsule": 38,
            "./shapes/Circle": 39,
            "./shapes/Convex": 40,
            "./shapes/Heightfield": 41,
            "./shapes/Line": 42,
            "./shapes/Particle": 43,
            "./shapes/Plane": 44,
            "./shapes/Shape": 45,
            "./solver/GSSolver": 46,
            "./solver/Solver": 47,
            "./utils/ContactEquationPool": 48,
            "./utils/FrictionEquationPool": 49,
            "./utils/Pool": 55,
            "./utils/Utils": 57,
            "./world/World": 61
        }],
        37: [function(t, e, i) {
            function s(t) {
                "number" == typeof arguments[0] && "number" == typeof arguments[1] && (t = {
                    width: arguments[0],
                    height: arguments[1]
                }, console.warn("The Rectangle has been renamed to Box and its constructor signature has changed. Please use the following format: new Box({ width: 1, height: 1, ... })")), t = t || {};
                var e = this.width = t.width || 1,
                    i = this.height = t.height || 1,
                    s = [n.fromValues(-e / 2, -i / 2), n.fromValues(e / 2, -i / 2), n.fromValues(e / 2, i / 2), n.fromValues(-e / 2, i / 2)],
                    a = [n.fromValues(1, 0), n.fromValues(0, 1)];
                t.vertices = s, t.axes = a, t.type = r.BOX, o.call(this, t)
            }
            var n = t("../math/vec2"),
                r = t("./Shape"),
                o = t("./Convex");
            e.exports = s, (s.prototype = new o).constructor = s, s.prototype.computeMomentOfInertia = function(t) {
                var e = this.width,
                    i = this.height;
                return t * (i * i + e * e) / 12
            }, s.prototype.updateBoundingRadius = function() {
                var t = this.width,
                    e = this.height;
                this.boundingRadius = Math.sqrt(t * t + e * e) / 2
            }, n.create(), n.create(), n.create(), n.create(), s.prototype.computeAABB = function(t, e, i) {
                t.setFromPoints(this.vertices, e, i, 0)
            }, s.prototype.updateArea = function() {
                this.area = this.width * this.height
            }
        }, {
            "../math/vec2": 30,
            "./Convex": 40,
            "./Shape": 45
        }],
        38: [function(t, e, i) {
            function s(t) {
                "number" == typeof arguments[0] && "number" == typeof arguments[1] && (t = {
                    length: arguments[0],
                    radius: arguments[1]
                }, console.warn("The Capsule constructor signature has changed. Please use the following format: new Capsule({ radius: 1, length: 1 })")), t = t || {}, this.length = t.length || 1, this.radius = t.radius || 1, t.type = n.CAPSULE, n.call(this, t)
            }
            var n = t("./Shape"),
                r = t("../math/vec2");
            e.exports = s, (s.prototype = new n).constructor = s, s.prototype.computeMomentOfInertia = function(t) {
                var e = this.radius,
                    i = this.length + e,
                    s = 2 * e;
                return t * (s * s + i * i) / 12
            }, s.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.radius + this.length / 2
            }, s.prototype.updateArea = function() {
                this.area = Math.PI * this.radius * this.radius + 2 * this.radius * this.length
            };
            var o = r.create();
            s.prototype.computeAABB = function(t, e, i) {
                var s = this.radius;
                r.set(o, this.length / 2, 0), 0 !== i && r.rotate(o, o, i), r.set(t.upperBound, Math.max(o[0] + s, -o[0] + s), Math.max(o[1] + s, -o[1] + s)), r.set(t.lowerBound, Math.min(o[0] - s, -o[0] - s), Math.min(o[1] - s, -o[1] - s)), r.add(t.lowerBound, t.lowerBound, e), r.add(t.upperBound, t.upperBound, e)
            };
            var a = r.create(),
                h = r.create(),
                l = r.create(),
                c = r.create(),
                u = r.fromValues(0, 1);
            s.prototype.raycast = function(t, e, i, s) {
                for (var n = e.from, o = e.to, d = (e.direction, a), p = h, f = l, g = c, m = this.length / 2, y = 0; y < 2; y++) {
                    var v = this.radius * (2 * y - 1);
                    if (r.set(f, -m, v), r.set(g, m, v), r.toGlobalFrame(f, f, i, s), r.toGlobalFrame(g, g, i, s), (T = r.getLineSegmentsIntersectionFraction(n, o, f, g)) >= 0 && (r.rotate(p, u, s), r.scale(p, p, 2 * y - 1), e.reportIntersection(t, T, p, -1), t.shouldStop(e))) return
                }
                var x = Math.pow(this.radius, 2) + Math.pow(m, 2);
                for (y = 0; y < 2; y++) {
                    r.set(f, m * (2 * y - 1), 0), r.toGlobalFrame(f, f, i, s);
                    var b = Math.pow(o[0] - n[0], 2) + Math.pow(o[1] - n[1], 2),
                        _ = 2 * ((o[0] - n[0]) * (n[0] - f[0]) + (o[1] - n[1]) * (n[1] - f[1])),
                        w = Math.pow(n[0] - f[0], 2) + Math.pow(n[1] - f[1], 2) - Math.pow(this.radius, 2),
                        T = Math.pow(_, 2) - 4 * b * w;
                    if (!(T < 0))
                        if (0 === T) {
                            if (r.lerp(d, n, o, T), r.squaredDistance(d, i) > x && (r.sub(p, d, f), r.normalize(p, p), e.reportIntersection(t, T, p, -1), t.shouldStop(e))) return
                        } else {
                            var P = Math.sqrt(T),
                                C = 1 / (2 * b),
                                S = (-_ - P) * C,
                                A = (-_ + P) * C;
                            if (S >= 0 && S <= 1 && (r.lerp(d, n, o, S), r.squaredDistance(d, i) > x && (r.sub(p, d, f), r.normalize(p, p), e.reportIntersection(t, S, p, -1), t.shouldStop(e)))) return;
                            if (A >= 0 && A <= 1 && (r.lerp(d, n, o, A), r.squaredDistance(d, i) > x && (r.sub(p, d, f), r.normalize(p, p), e.reportIntersection(t, A, p, -1), t.shouldStop(e)))) return
                        }
                }
            }
        }, {
            "../math/vec2": 30,
            "./Shape": 45
        }],
        39: [function(t, e, i) {
            function s(t) {
                "number" == typeof arguments[0] && (t = {
                    radius: arguments[0]
                }, console.warn("The Circle constructor signature has changed. Please use the following format: new Circle({ radius: 1 })")), t = t || {}, this.radius = t.radius || 1, t.type = n.CIRCLE, n.call(this, t)
            }
            var n = t("./Shape"),
                r = t("../math/vec2");
            e.exports = s, (s.prototype = new n).constructor = s, s.prototype.computeMomentOfInertia = function(t) {
                var e = this.radius;
                return t * e * e / 2
            }, s.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.radius
            }, s.prototype.updateArea = function() {
                this.area = Math.PI * this.radius * this.radius
            }, s.prototype.computeAABB = function(t, e, i) {
                var s = this.radius;
                r.set(t.upperBound, s, s), r.set(t.lowerBound, -s, -s), e && (r.add(t.lowerBound, t.lowerBound, e), r.add(t.upperBound, t.upperBound, e))
            };
            var o = r.create(),
                a = r.create();
            s.prototype.raycast = function(t, e, i, s) {
                var n = e.from,
                    h = e.to,
                    l = this.radius,
                    c = Math.pow(h[0] - n[0], 2) + Math.pow(h[1] - n[1], 2),
                    u = 2 * ((h[0] - n[0]) * (n[0] - i[0]) + (h[1] - n[1]) * (n[1] - i[1])),
                    d = Math.pow(n[0] - i[0], 2) + Math.pow(n[1] - i[1], 2) - Math.pow(l, 2),
                    p = Math.pow(u, 2) - 4 * c * d,
                    f = o,
                    g = a;
                if (!(p < 0))
                    if (0 === p) r.lerp(f, n, h, p), r.sub(g, f, i), r.normalize(g, g), e.reportIntersection(t, p, g, -1);
                    else {
                        var m = Math.sqrt(p),
                            y = 1 / (2 * c),
                            v = (-u - m) * y,
                            x = (-u + m) * y;
                        if (v >= 0 && v <= 1 && (r.lerp(f, n, h, v), r.sub(g, f, i), r.normalize(g, g), e.reportIntersection(t, v, g, -1), t.shouldStop(e))) return;
                        x >= 0 && x <= 1 && (r.lerp(f, n, h, x), r.sub(g, f, i), r.normalize(g, g), e.reportIntersection(t, x, g, -1))
                    }
            }
        }, {
            "../math/vec2": 30,
            "./Shape": 45
        }],
        40: [function(t, e, i) {
            function s(t) {
                Array.isArray(arguments[0]) && (t = {
                    vertices: arguments[0],
                    axes: arguments[1]
                }, console.warn("The Convex constructor signature has changed. Please use the following format: new Convex({ vertices: [...], ... })")), t = t || {}, this.vertices = [];
                for (var e = void 0 !== t.vertices ? t.vertices : [], i = 0; i < e.length; i++) {
                    var s = r.create();
                    r.copy(s, e[i]), this.vertices.push(s)
                }
                if (this.axes = [], t.axes)
                    for (i = 0; i < t.axes.length; i++) {
                        var o = r.create();
                        r.copy(o, t.axes[i]), this.axes.push(o)
                    } else
                        for (i = 0; i < this.vertices.length; i++) {
                            var a = this.vertices[i],
                                h = this.vertices[(i + 1) % this.vertices.length],
                                l = r.create();
                            r.sub(l, h, a), r.rotate90cw(l, l), r.normalize(l, l), this.axes.push(l)
                        }
                if (this.centerOfMass = r.fromValues(0, 0), this.triangles = [], this.vertices.length && (this.updateTriangles(), this.updateCenterOfMass()), this.boundingRadius = 0, t.type = n.CONVEX, n.call(this, t), this.updateBoundingRadius(), this.updateArea(), this.area < 0) throw new Error("Convex vertices must be given in conter-clockwise winding.")
            }
            var n = t("./Shape"),
                r = t("../math/vec2"),
                o = t("../math/polyk");
            t("poly-decomp"), e.exports = s, (s.prototype = new n).constructor = s;
            var a = r.create(),
                h = r.create();
            s.prototype.projectOntoLocalAxis = function(t, e) {
                for (var i, s, n = null, o = null, h = (t = a, 0); h < this.vertices.length; h++) i = this.vertices[h], s = r.dot(i, t), (null === n || s > n) && (n = s), (null === o || s < o) && (o = s);
                if (o > n) {
                    var l = o;
                    o = n, n = l
                }
                r.set(e, o, n)
            }, s.prototype.projectOntoWorldAxis = function(t, e, i, s) {
                var n = h;
                this.projectOntoLocalAxis(t, s), 0 !== i ? r.rotate(n, t, i) : n = t;
                var o = r.dot(e, n);
                r.set(s, s[0] + o, s[1] + o)
            }, s.prototype.updateTriangles = function() {
                this.triangles.length = 0;
                for (var t = [], e = 0; e < this.vertices.length; e++) {
                    var i = this.vertices[e];
                    t.push(i[0], i[1])
                }
                var s = o.Triangulate(t);
                for (e = 0; e < s.length; e += 3) {
                    var n = s[e],
                        r = s[e + 1],
                        a = s[e + 2];
                    this.triangles.push([n, r, a])
                }
            };
            var l = r.create(),
                c = r.create(),
                u = r.create(),
                d = r.create(),
                p = r.create();
            r.create(), r.create(), r.create(), r.create(), s.prototype.updateCenterOfMass = function() {
                var t = this.triangles,
                    e = this.vertices,
                    i = this.centerOfMass,
                    n = l,
                    o = u,
                    a = d,
                    h = p,
                    f = c;
                r.set(i, 0, 0);
                for (var g = 0, m = 0; m !== t.length; m++) {
                    var y = t[m];
                    o = e[y[0]], a = e[y[1]], h = e[y[2]];
                    r.centroid(n, o, a, h);
                    var v = s.triangleArea(o, a, h);
                    g += v, r.scale(f, n, v), r.add(i, i, f)
                }
                r.scale(i, i, 1 / g)
            }, s.prototype.computeMomentOfInertia = function(t) {
                for (var e = 0, i = 0, s = this.vertices.length, n = s - 1, o = 0; o < s; n = o, o++) {
                    var a = this.vertices[n],
                        h = this.vertices[o],
                        l = Math.abs(r.crossLength(a, h));
                    e += l * (r.dot(h, h) + r.dot(h, a) + r.dot(a, a)), i += l
                }
                return t / 6 * (e / i)
            }, s.prototype.updateBoundingRadius = function() {
                for (var t = this.vertices, e = 0, i = 0; i !== t.length; i++) {
                    var s = r.squaredLength(t[i]);
                    s > e && (e = s)
                }
                this.boundingRadius = Math.sqrt(e)
            }, s.triangleArea = function(t, e, i) {
                return .5 * ((e[0] - t[0]) * (i[1] - t[1]) - (i[0] - t[0]) * (e[1] - t[1]))
            }, s.prototype.updateArea = function() {
                this.updateTriangles(), this.area = 0;
                for (var t = this.triangles, e = this.vertices, i = 0; i !== t.length; i++) {
                    var n = t[i],
                        r = e[n[0]],
                        o = e[n[1]],
                        a = e[n[2]],
                        h = s.triangleArea(r, o, a);
                    this.area += h
                }
            }, s.prototype.computeAABB = function(t, e, i) {
                t.setFromPoints(this.vertices, e, i, 0)
            };
            var f = r.create(),
                g = r.create(),
                m = r.create();
            s.prototype.raycast = function(t, e, i, s) {
                var n = f,
                    o = g,
                    a = m,
                    h = this.vertices;
                r.toLocalFrame(n, e.from, i, s), r.toLocalFrame(o, e.to, i, s);
                for (var l = h.length, c = 0; c < l && !t.shouldStop(e); c++) {
                    var u = h[c],
                        d = h[(c + 1) % l],
                        p = r.getLineSegmentsIntersectionFraction(n, o, u, d);
                    p >= 0 && (r.sub(a, d, u), r.rotate(a, a, -Math.PI / 2 + s), r.normalize(a, a), e.reportIntersection(t, p, a, c))
                }
            }
        }, {
            "../math/polyk": 29,
            "../math/vec2": 30,
            "./Shape": 45,
            "poly-decomp": 5
        }],
        41: [function(t, e, i) {
            function s(t) {
                if (Array.isArray(arguments[0])) {
                    if (t = {
                            heights: arguments[0]
                        }, "object" == typeof arguments[1])
                        for (var e in arguments[1]) t[e] = arguments[1][e];
                    console.warn("The Heightfield constructor signature has changed. Please use the following format: new Heightfield({ heights: [...], ... })")
                }
                t = t || {}, this.heights = t.heights ? t.heights.slice(0) : [], this.maxValue = t.maxValue || null, this.minValue = t.minValue || null, this.elementWidth = t.elementWidth || .1, void 0 !== t.maxValue && void 0 !== t.minValue || this.updateMaxMinValues(), t.type = n.HEIGHTFIELD, n.call(this, t)
            }
            var n = t("./Shape"),
                r = t("../math/vec2");
            t("../utils/Utils"), e.exports = s, (s.prototype = new n).constructor = s, s.prototype.updateMaxMinValues = function() {
                for (var t = this.heights, e = t[0], i = t[0], s = 0; s !== t.length; s++) {
                    var n = t[s];
                    n > e && (e = n), n < i && (i = n)
                }
                this.maxValue = e, this.minValue = i
            }, s.prototype.computeMomentOfInertia = function(t) {
                return Number.MAX_VALUE
            }, s.prototype.updateBoundingRadius = function() {
                this.boundingRadius = Number.MAX_VALUE
            }, s.prototype.updateArea = function() {
                for (var t = this.heights, e = 0, i = 0; i < t.length - 1; i++) e += (t[i] + t[i + 1]) / 2 * this.elementWidth;
                this.area = e
            };
            var o = [r.create(), r.create(), r.create(), r.create()];
            s.prototype.computeAABB = function(t, e, i) {
                r.set(o[0], 0, this.maxValue), r.set(o[1], this.elementWidth * this.heights.length, this.maxValue), r.set(o[2], this.elementWidth * this.heights.length, this.minValue), r.set(o[3], 0, this.minValue), t.setFromPoints(o, e, i)
            }, s.prototype.getLineSegment = function(t, e, i) {
                var s = this.heights,
                    n = this.elementWidth;
                r.set(t, i * n, s[i]), r.set(e, (i + 1) * n, s[i + 1])
            }, s.prototype.getSegmentIndex = function(t) {
                return Math.floor(t[0] / this.elementWidth)
            }, s.prototype.getClampedSegmentIndex = function(t) {
                var e = this.getSegmentIndex(t);
                return Math.min(this.heights.length, Math.max(e, 0))
            }, r.create();
            var a = r.create(),
                h = r.create(),
                l = r.create(),
                c = r.create(),
                u = r.create();
            r.fromValues(0, 1), s.prototype.raycast = function(t, e, i, s) {
                var n = e.from,
                    o = e.to,
                    d = (e.direction, a),
                    p = h,
                    f = l,
                    g = c,
                    m = u;
                r.toLocalFrame(g, n, i, s), r.toLocalFrame(m, o, i, s);
                var y = this.getClampedSegmentIndex(g),
                    v = this.getClampedSegmentIndex(m);
                if (y > v) {
                    var x = y;
                    y = v, v = x
                }
                for (var b = 0; b < this.heights.length - 1; b++) {
                    this.getLineSegment(p, f, b);
                    var _ = r.getLineSegmentsIntersectionFraction(g, m, p, f);
                    if (_ >= 0 && (r.sub(d, f, p), r.rotate(d, d, s + Math.PI / 2), r.normalize(d, d), e.reportIntersection(t, _, d, -1), t.shouldStop(e))) return
                }
            }
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Shape": 45
        }],
        42: [function(t, e, i) {
            function s(t) {
                "number" == typeof arguments[0] && (t = {
                    length: arguments[0]
                }, console.warn("The Line constructor signature has changed. Please use the following format: new Line({ length: 1, ... })")), t = t || {}, this.length = t.length || 1, t.type = n.LINE, n.call(this, t)
            }
            var n = t("./Shape"),
                r = t("../math/vec2");
            e.exports = s, (s.prototype = new n).constructor = s, s.prototype.computeMomentOfInertia = function(t) {
                return t * Math.pow(this.length, 2) / 12
            }, s.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.length / 2
            };
            var o = [r.create(), r.create()];
            s.prototype.computeAABB = function(t, e, i) {
                var s = this.length / 2;
                r.set(o[0], -s, 0), r.set(o[1], s, 0), t.setFromPoints(o, e, i, 0)
            }, r.create();
            var a = r.create(),
                h = r.create(),
                l = r.create(),
                c = r.fromValues(0, 1);
            s.prototype.raycast = function(t, e, i, s) {
                var n = e.from,
                    o = e.to,
                    u = h,
                    d = l,
                    p = this.length / 2;
                r.set(u, -p, 0), r.set(d, p, 0), r.toGlobalFrame(u, u, i, s), r.toGlobalFrame(d, d, i, s);
                var f = r.getLineSegmentsIntersectionFraction(u, d, n, o);
                if (f >= 0) {
                    var g = a;
                    r.rotate(g, c, s), e.reportIntersection(t, f, g, -1)
                }
            }
        }, {
            "../math/vec2": 30,
            "./Shape": 45
        }],
        43: [function(t, e, i) {
            function s(t) {
                (t = t || {}).type = n.PARTICLE, n.call(this, t)
            }
            var n = t("./Shape"),
                r = t("../math/vec2");
            e.exports = s, (s.prototype = new n).constructor = s, s.prototype.computeMomentOfInertia = function(t) {
                return 0
            }, s.prototype.updateBoundingRadius = function() {
                this.boundingRadius = 0
            }, s.prototype.computeAABB = function(t, e, i) {
                r.copy(t.lowerBound, e), r.copy(t.upperBound, e)
            }
        }, {
            "../math/vec2": 30,
            "./Shape": 45
        }],
        44: [function(t, e, i) {
            function s(t) {
                (t = t || {}).type = n.PLANE, n.call(this, t)
            }
            var n = t("./Shape"),
                r = t("../math/vec2");
            t("../utils/Utils"), e.exports = s, (s.prototype = new n).constructor = s, s.prototype.computeMomentOfInertia = function(t) {
                return 0
            }, s.prototype.updateBoundingRadius = function() {
                this.boundingRadius = Number.MAX_VALUE
            }, s.prototype.computeAABB = function(t, e, i) {
                var s = i % (2 * Math.PI),
                    n = r.set,
                    o = t.lowerBound,
                    a = t.upperBound;
                n(o, -1e7, -1e7), n(a, 1e7, 1e7), 0 === s ? a[1] = 0 : s === Math.PI / 2 ? o[0] = 0 : s === Math.PI ? o[1] = 0 : s === 3 * Math.PI / 2 && (a[0] = 0)
            }, s.prototype.updateArea = function() {
                this.area = Number.MAX_VALUE
            };
            var o = r.create(),
                a = (r.create(), r.create(), r.create()),
                h = r.create();
            s.prototype.raycast = function(t, e, i, s) {
                var n = e.from,
                    l = e.to,
                    c = e.direction,
                    u = o,
                    d = a,
                    p = h;
                r.set(d, 0, 1), r.rotate(d, d, s), r.sub(p, n, i);
                var f = r.dot(p, d);
                if (r.sub(p, l, i), !(f * r.dot(p, d) > 0 || r.squaredDistance(n, l) < f * f)) {
                    var g = r.dot(d, c);
                    r.sub(u, n, i);
                    var m = -r.dot(d, u) / g / e.length;
                    e.reportIntersection(t, m, d, -1)
                }
            }
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Shape": 45
        }],
        45: [function(t, e, i) {
            function s(t) {
                t = t || {}, this.body = null, this.position = n.fromValues(0, 0), t.position && n.copy(this.position, t.position), this.angle = t.angle || 0, this.type = t.type || 0, this.id = s.idCounter++, this.boundingRadius = 0, this.collisionGroup = void 0 !== t.collisionGroup ? t.collisionGroup : 1, this.collisionResponse = void 0 === t.collisionResponse || t.collisionResponse, this.collisionMask = void 0 !== t.collisionMask ? t.collisionMask : 1, this.material = t.material || null, this.area = 0, this.sensor = void 0 !== t.sensor && t.sensor, this.type && this.updateBoundingRadius(), this.updateArea()
            }
            e.exports = s;
            var n = t("../math/vec2");
            s.idCounter = 0, s.CIRCLE = 1, s.PARTICLE = 2, s.PLANE = 4, s.CONVEX = 8, s.LINE = 16, s.BOX = 32, s.CAPSULE = 64, s.HEIGHTFIELD = 128, s.prototype.computeMomentOfInertia = function(t) {}, s.prototype.updateBoundingRadius = function() {}, s.prototype.updateArea = function() {}, s.prototype.computeAABB = function(t, e, i) {}, s.prototype.raycast = function(t, e, i, s) {}
        }, {
            "../math/vec2": 30
        }],
        46: [function(t, e, i) {
            function s(t) {
                r.call(this, t, r.GS), t = t || {}, this.iterations = t.iterations || 10, this.tolerance = t.tolerance || 1e-7, this.arrayStep = 30, this.lambda = new o.ARRAY_TYPE(this.arrayStep), this.Bs = new o.ARRAY_TYPE(this.arrayStep), this.invCs = new o.ARRAY_TYPE(this.arrayStep), this.useZeroRHS = !1, this.frictionIterations = void 0 !== t.frictionIterations ? 0 : t.frictionIterations, this.usedIterations = 0
            }
            var n = t("../math/vec2"),
                r = t("./Solver"),
                o = t("../utils/Utils"),
                a = t("../equations/FrictionEquation");
            e.exports = s, (s.prototype = new r).constructor = s, s.prototype.solve = function(t, e) {
                this.sortEquations();
                var i, r, h, l = 0,
                    c = this.iterations,
                    u = this.frictionIterations,
                    d = this.equations,
                    p = d.length,
                    f = Math.pow(this.tolerance * p, 2),
                    g = e.bodies,
                    m = e.bodies.length,
                    y = (n.add, n.set, this.useZeroRHS),
                    v = this.lambda;
                if (this.usedIterations = 0, p)
                    for (_ = 0; _ !== m; _++)(w = g[_]).updateSolveMassProperties();
                v.length < p && (v = this.lambda = new o.ARRAY_TYPE(p + this.arrayStep), this.Bs = new o.ARRAY_TYPE(p + this.arrayStep), this.invCs = new o.ARRAY_TYPE(p + this.arrayStep)),
                    function(t) {
                        for (var e = t.length; e--;) t[e] = 0
                    }(v);
                for (var x = this.invCs, b = this.Bs, _ = (v = this.lambda, 0); _ !== d.length; _++)((i = d[_]).timeStep !== t || i.needsUpdate) && (i.timeStep = t, i.update()), b[_] = i.computeB(i.a, i.b, t), x[_] = i.computeInvC(i.epsilon);
                if (0 !== p) {
                    for (_ = 0; _ !== m; _++) {
                        var w = g[_];
                        w.resetConstraintVelocity()
                    }
                    if (u) {
                        for (l = 0; l !== u; l++) {
                            for (r = 0, h = 0; h !== p; h++) i = d[h], S = s.iterateEquation(h, i, i.epsilon, b, x, v, y, t, l), r += Math.abs(S);
                            if (this.usedIterations++, r * r <= f) break
                        }
                        for (s.updateMultipliers(d, v, 1 / t), h = 0; h !== p; h++) {
                            var T = d[h];
                            if (T instanceof a) {
                                for (var P = 0, C = 0; C !== T.contactEquations.length; C++) P += T.contactEquations[C].multiplier;
                                P *= T.frictionCoefficient / T.contactEquations.length, T.maxForce = P, T.minForce = -P
                            }
                        }
                    }
                    for (l = 0; l !== c; l++) {
                        for (r = 0, h = 0; h !== p; h++) {
                            i = d[h];
                            var S = s.iterateEquation(h, i, i.epsilon, b, x, v, y, t, l);
                            r += Math.abs(S)
                        }
                        if (this.usedIterations++, r * r <= f) break
                    }
                    for (_ = 0; _ !== m; _++) g[_].addConstraintVelocity();
                    s.updateMultipliers(d, v, 1 / t)
                }
            }, s.updateMultipliers = function(t, e, i) {
                for (var s = t.length; s--;) t[s].multiplier = e[s] * i
            }, s.iterateEquation = function(t, e, i, s, n, r, o, a, h) {
                var l = s[t],
                    c = n[t],
                    u = r[t],
                    d = e.computeGWlambda(),
                    p = e.maxForce,
                    f = e.minForce;
                o && (l = 0);
                var g = c * (l - d - i * u),
                    m = u + g;
                return m < f * a ? g = f * a - u : m > p * a && (g = p * a - u), r[t] += g, e.addToWlambda(g), g
            }
        }, {
            "../equations/FrictionEquation": 23,
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Solver": 47
        }],
        47: [function(t, e, i) {
            function s(t, e) {
                t = t || {}, n.call(this), this.type = e, this.equations = [], this.equationSortFunction = t.equationSortFunction || !1
            }
            t("../utils/Utils");
            var n = t("../events/EventEmitter");
            e.exports = s, (s.prototype = new n).constructor = s, s.prototype.solve = function(t, e) {
                throw new Error("Solver.solve should be implemented by subclasses!")
            };
            var r = {
                bodies: []
            };
            s.prototype.solveIsland = function(t, e) {
                this.removeAllEquations(), e.equations.length && (this.addEquations(e.equations), r.bodies.length = 0, e.getBodies(r.bodies), r.bodies.length && this.solve(t, r))
            }, s.prototype.sortEquations = function() {
                this.equationSortFunction && this.equations.sort(this.equationSortFunction)
            }, s.prototype.addEquation = function(t) {
                t.enabled && this.equations.push(t)
            }, s.prototype.addEquations = function(t) {
                for (var e = 0, i = t.length; e !== i; e++) {
                    var s = t[e];
                    s.enabled && this.equations.push(s)
                }
            }, s.prototype.removeEquation = function(t) {
                var e = this.equations.indexOf(t); - 1 !== e && this.equations.splice(e, 1)
            }, s.prototype.removeAllEquations = function() {
                this.equations.length = 0
            }, s.GS = 1, s.ISLAND = 2
        }, {
            "../events/EventEmitter": 26,
            "../utils/Utils": 57
        }],
        48: [function(t, e, i) {
            function s() {
                r.apply(this, arguments)
            }
            var n = t("../equations/ContactEquation"),
                r = t("./Pool");
            e.exports = s, (s.prototype = new r).constructor = s, s.prototype.create = function() {
                return new n
            }, s.prototype.destroy = function(t) {
                return t.bodyA = t.bodyB = null, this
            }
        }, {
            "../equations/ContactEquation": 21,
            "./Pool": 55
        }],
        49: [function(t, e, i) {
            function s() {
                r.apply(this, arguments)
            }
            var n = t("../equations/FrictionEquation"),
                r = t("./Pool");
            e.exports = s, (s.prototype = new r).constructor = s, s.prototype.create = function() {
                return new n
            }, s.prototype.destroy = function(t) {
                return t.bodyA = t.bodyB = null, this
            }
        }, {
            "../equations/FrictionEquation": 23,
            "./Pool": 55
        }],
        50: [function(t, e, i) {
            function s() {
                r.apply(this, arguments)
            }
            var n = t("../world/IslandNode"),
                r = t("./Pool");
            e.exports = s, (s.prototype = new r).constructor = s, s.prototype.create = function() {
                return new n
            }, s.prototype.destroy = function(t) {
                return t.reset(), this
            }
        }, {
            "../world/IslandNode": 60,
            "./Pool": 55
        }],
        51: [function(t, e, i) {
            function s() {
                r.apply(this, arguments)
            }
            var n = t("../world/Island"),
                r = t("./Pool");
            e.exports = s, (s.prototype = new r).constructor = s, s.prototype.create = function() {
                return new n
            }, s.prototype.destroy = function(t) {
                return t.reset(), this
            }
        }, {
            "../world/Island": 58,
            "./Pool": 55
        }],
        52: [function(t, e, i) {
            function s() {
                this.overlappingShapesLastState = new n, this.overlappingShapesCurrentState = new n, this.recordPool = new r({
                    size: 16
                }), this.tmpDict = new n, this.tmpArray1 = []
            }
            var n = t("./TupleDictionary"),
                r = (t("./OverlapKeeperRecord"), t("./OverlapKeeperRecordPool"));
            t("./Utils"), e.exports = s, s.prototype.tick = function() {
                for (var t = this.overlappingShapesLastState, e = this.overlappingShapesCurrentState, i = t.keys.length; i--;) {
                    var s = t.keys[i],
                        n = t.getByKey(s);
                    e.getByKey(s), n && this.recordPool.release(n)
                }
                t.reset(), t.copy(e), e.reset()
            }, s.prototype.setOverlapping = function(t, e, i, s) {
                this.overlappingShapesLastState;
                var n = this.overlappingShapesCurrentState;
                if (!n.get(e.id, s.id)) {
                    var r = this.recordPool.get();
                    r.set(t, e, i, s), n.set(e.id, s.id, r)
                }
            }, s.prototype.getNewOverlaps = function(t) {
                return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, t)
            }, s.prototype.getEndOverlaps = function(t) {
                return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, t)
            }, s.prototype.bodiesAreOverlapping = function(t, e) {
                for (var i = this.overlappingShapesCurrentState, s = i.keys.length; s--;) {
                    var n = i.keys[s],
                        r = i.data[n];
                    if (r.bodyA === t && r.bodyB === e || r.bodyA === e && r.bodyB === t) return !0
                }
                return !1
            }, s.prototype.getDiff = function(t, e, i) {
                var s = t,
                    n = e;
                (i = i || []).length = 0;
                for (var r = n.keys.length; r--;) {
                    var o = n.keys[r],
                        a = n.data[o];
                    if (!a) throw new Error("Key " + o + " had no data!");
                    s.data[o] || i.push(a)
                }
                return i
            }, s.prototype.isNewOverlap = function(t, e) {
                var i = 0 | t.id,
                    s = 0 | e.id,
                    n = this.overlappingShapesLastState,
                    r = this.overlappingShapesCurrentState;
                return !n.get(i, s) && !!r.get(i, s)
            }, s.prototype.getNewBodyOverlaps = function(t) {
                this.tmpArray1.length = 0;
                var e = this.getNewOverlaps(this.tmpArray1);
                return this.getBodyDiff(e, t)
            }, s.prototype.getEndBodyOverlaps = function(t) {
                this.tmpArray1.length = 0;
                var e = this.getEndOverlaps(this.tmpArray1);
                return this.getBodyDiff(e, t)
            }, s.prototype.getBodyDiff = function(t, e) {
                e = e || [];
                for (var i = this.tmpDict, s = t.length; s--;) {
                    var n = t[s];
                    i.set(0 | n.bodyA.id, 0 | n.bodyB.id, n)
                }
                for (s = i.keys.length; s--;)(n = i.getByKey(i.keys[s])) && e.push(n.bodyA, n.bodyB);
                return i.reset(), e
            }
        }, {
            "./OverlapKeeperRecord": 53,
            "./OverlapKeeperRecordPool": 54,
            "./TupleDictionary": 56,
            "./Utils": 57
        }],
        53: [function(t, e, i) {
            function s(t, e, i, s) {
                this.shapeA = e, this.shapeB = s, this.bodyA = t, this.bodyB = i
            }
            e.exports = s, s.prototype.set = function(t, e, i, n) {
                s.call(this, t, e, i, n)
            }
        }, {}],
        54: [function(t, e, i) {
            function s() {
                r.apply(this, arguments)
            }
            var n = t("./OverlapKeeperRecord"),
                r = t("./Pool");
            e.exports = s, (s.prototype = new r).constructor = s, s.prototype.create = function() {
                return new n
            }, s.prototype.destroy = function(t) {
                return t.bodyA = t.bodyB = t.shapeA = t.shapeB = null, this
            }
        }, {
            "./OverlapKeeperRecord": 53,
            "./Pool": 55
        }],
        55: [function(t, e, i) {
            function s(t) {
                t = t || {}, this.objects = [], void 0 !== t.size && this.resize(t.size)
            }
            e.exports = s, s.prototype.resize = function(t) {
                for (var e = this.objects; e.length > t;) e.pop();
                for (; e.length < t;) e.push(this.create());
                return this
            }, s.prototype.get = function() {
                var t = this.objects;
                return t.length ? t.pop() : this.create()
            }, s.prototype.release = function(t) {
                return this.destroy(t), this.objects.push(t), this
            }
        }, {}],
        56: [function(t, e, i) {
            function s() {
                this.data = {}, this.keys = []
            }
            var n = t("./Utils");
            e.exports = s, s.prototype.getKey = function(t, e) {
                return (0 | (t |= 0)) == (0 | (e |= 0)) ? -1 : 0 | ((0 | t) > (0 | e) ? t << 16 | 65535 & e : e << 16 | 65535 & t)
            }, s.prototype.getByKey = function(t) {
                return t |= 0, this.data[t]
            }, s.prototype.get = function(t, e) {
                return this.data[this.getKey(t, e)]
            }, s.prototype.set = function(t, e, i) {
                if (!i) throw new Error("No data!");
                var s = this.getKey(t, e);
                return this.data[s] || this.keys.push(s), this.data[s] = i, s
            }, s.prototype.reset = function() {
                for (var t = this.data, e = this.keys, i = e.length; i--;) delete t[e[i]];
                e.length = 0
            }, s.prototype.copy = function(t) {
                this.reset(), n.appendArray(this.keys, t.keys);
                for (var e = t.keys.length; e--;) {
                    var i = t.keys[e];
                    this.data[i] = t.data[i]
                }
            }
        }, {
            "./Utils": 57
        }],
        57: [function(t, e, i) {
            function s() {}
            e.exports = s, s.appendArray = function(t, e) {
                if (e.length < 15e4) t.push.apply(t, e);
                else
                    for (var i = 0, s = e.length; i !== s; ++i) t.push(e[i])
            }, s.splice = function(t, e, i) {
                i = i || 1;
                for (var s = e, n = t.length - i; s < n; s++) t[s] = t[s + i];
                t.length = n
            }, s.ARRAY_TYPE = "undefined" != typeof P2_ARRAY_TYPE ? P2_ARRAY_TYPE : "undefined" != typeof Float32Array ? Float32Array : Array, s.extend = function(t, e) {
                for (var i in e) t[i] = e[i]
            }, s.defaults = function(t, e) {
                for (var i in t = t || {}, e) i in t || (t[i] = e[i]);
                return t
            }
        }, {}],
        58: [function(t, e, i) {
            function s() {
                this.equations = [], this.bodies = []
            }
            var n = t("../objects/Body");
            e.exports = s, s.prototype.reset = function() {
                this.equations.length = this.bodies.length = 0
            };
            var r = [];
            s.prototype.getBodies = function(t) {
                var e = t || [],
                    i = this.equations;
                r.length = 0;
                for (var s = 0; s !== i.length; s++) {
                    var n = i[s]; - 1 === r.indexOf(n.bodyA.id) && (e.push(n.bodyA), r.push(n.bodyA.id)), -1 === r.indexOf(n.bodyB.id) && (e.push(n.bodyB), r.push(n.bodyB.id))
                }
                return e
            }, s.prototype.wantsToSleep = function() {
                for (var t = 0; t < this.bodies.length; t++) {
                    var e = this.bodies[t];
                    if (e.type === n.DYNAMIC && !e.wantsToSleep) return !1
                }
                return !0
            }, s.prototype.sleep = function() {
                for (var t = 0; t < this.bodies.length; t++) this.bodies[t].sleep();
                return !0
            }
        }, {
            "../objects/Body": 31
        }],
        59: [function(t, e, i) {
            function s(t) {
                this.nodePool = new n({
                    size: 16
                }), this.islandPool = new r({
                    size: 8
                }), this.equations = [], this.islands = [], this.nodes = [], this.queue = []
            }
            t("../math/vec2"), t("./Island"), t("./IslandNode");
            var n = t("./../utils/IslandNodePool"),
                r = t("./../utils/IslandPool"),
                o = t("../objects/Body");
            e.exports = s, s.getUnvisitedNode = function(t) {
                for (var e = t.length, i = 0; i !== e; i++) {
                    var s = t[i];
                    if (!s.visited && s.body.type === o.DYNAMIC) return s
                }
                return !1
            }, s.prototype.visit = function(t, e, i) {
                e.push(t.body);
                for (var s = t.equations.length, n = 0; n !== s; n++) {
                    var r = t.equations[n]; - 1 === i.indexOf(r) && i.push(r)
                }
            }, s.prototype.bfs = function(t, e, i) {
                var n = this.queue;
                for (n.length = 0, n.push(t), t.visited = !0, this.visit(t, e, i); n.length;)
                    for (var r, a = n.pop(); r = s.getUnvisitedNode(a.neighbors);) r.visited = !0, this.visit(r, e, i), r.body.type === o.DYNAMIC && n.push(r)
            }, s.prototype.split = function(t) {
                for (var e = t.bodies, i = this.nodes, n = this.equations; i.length;) this.nodePool.release(i.pop());
                for (h = 0; h !== e.length; h++) {
                    var r = this.nodePool.get();
                    r.body = e[h], i.push(r)
                }
                for (var o = 0; o !== n.length; o++) {
                    var a = n[o],
                        h = e.indexOf(a.bodyA),
                        l = e.indexOf(a.bodyB),
                        c = i[h],
                        u = i[l];
                    c.neighbors.push(u), u.neighbors.push(c), c.equations.push(a), u.equations.push(a)
                }
                var d = this.islands;
                for (h = 0; h < d.length; h++) this.islandPool.release(d[h]);
                d.length = 0;
                for (var p; p = s.getUnvisitedNode(i);) {
                    var f = this.islandPool.get();
                    this.bfs(p, f.bodies, f.equations), d.push(f)
                }
                return d
            }
        }, {
            "../math/vec2": 30,
            "../objects/Body": 31,
            "./../utils/IslandNodePool": 50,
            "./../utils/IslandPool": 51,
            "./Island": 58,
            "./IslandNode": 60
        }],
        60: [function(t, e, i) {
            function s(t) {
                this.body = t, this.neighbors = [], this.equations = [], this.visited = !1
            }
            e.exports = s, s.prototype.reset = function() {
                this.equations.length = 0, this.neighbors.length = 0, this.visited = !1, this.body = null
            }
        }, {}],
        61: [function(t, e, i) {
            function s(t) {
                u.apply(this), t = t || {}, this.springs = [], this.bodies = [], this.disabledBodyCollisionPairs = [], this.solver = t.solver || new n, this.narrowphase = new y(this), this.islandManager = new b, this.gravity = r.fromValues(0, -9.78), t.gravity && r.copy(this.gravity, t.gravity), this.frictionGravity = r.length(this.gravity) || 10, this.useWorldGravityAsFrictionGravity = !0, this.useFrictionGravityOnZeroGravity = !0, this.broadphase = t.broadphase || new m, this.broadphase.setWorld(this), this.constraints = [], this.defaultMaterial = new p, this.defaultContactMaterial = new f(this.defaultMaterial, this.defaultMaterial), this.lastTimeStep = 1 / 60, this.applySpringForces = !0, this.applyDamping = !0, this.applyGravity = !0, this.solveConstraints = !0, this.contactMaterials = [], this.time = 0, this.accumulator = 0, this.stepping = !1, this.bodiesToBeRemoved = [], this.islandSplit = void 0 === t.islandSplit || !!t.islandSplit, this.emitImpactEvent = !0, this._constraintIdCounter = 0, this._bodyIdCounter = 0, this.postStepEvent = {
                    type: "postStep"
                }, this.addBodyEvent = {
                    type: "addBody",
                    body: null
                }, this.removeBodyEvent = {
                    type: "removeBody",
                    body: null
                }, this.addSpringEvent = {
                    type: "addSpring",
                    spring: null
                }, this.impactEvent = {
                    type: "impact",
                    bodyA: null,
                    bodyB: null,
                    shapeA: null,
                    shapeB: null,
                    contactEquation: null
                }, this.postBroadphaseEvent = {
                    type: "postBroadphase",
                    pairs: null
                }, this.sleepMode = s.NO_SLEEPING, this.beginContactEvent = {
                    type: "beginContact",
                    shapeA: null,
                    shapeB: null,
                    bodyA: null,
                    bodyB: null,
                    contactEquations: []
                }, this.endContactEvent = {
                    type: "endContact",
                    shapeA: null,
                    shapeB: null,
                    bodyA: null,
                    bodyB: null
                }, this.preSolveEvent = {
                    type: "preSolve",
                    contactEquations: null,
                    frictionEquations: null
                }, this.overlappingShapesLastState = {
                    keys: []
                }, this.overlappingShapesCurrentState = {
                    keys: []
                }, this.overlapKeeper = new x
            }
            var n = t("../solver/GSSolver"),
                r = (t("../solver/Solver"), t("../collision/Ray"), t("../math/vec2")),
                o = t("../shapes/Circle"),
                a = t("../shapes/Convex"),
                h = (t("../shapes/Line"), t("../shapes/Plane")),
                l = t("../shapes/Capsule"),
                c = t("../shapes/Particle"),
                u = t("../events/EventEmitter"),
                d = t("../objects/Body"),
                p = (t("../shapes/Shape"), t("../objects/LinearSpring"), t("../material/Material")),
                f = t("../material/ContactMaterial"),
                g = (t("../constraints/DistanceConstraint"), t("../constraints/Constraint"), t("../constraints/LockConstraint"), t("../constraints/RevoluteConstraint"), t("../constraints/PrismaticConstraint"), t("../constraints/GearConstraint"), t("../../package.json"), t("../collision/Broadphase"), t("../collision/AABB")),
                m = t("../collision/SAPBroadphase"),
                y = t("../collision/Narrowphase"),
                v = t("../utils/Utils"),
                x = t("../utils/OverlapKeeper"),
                b = t("./IslandManager");
            t("../objects/RotationalSpring"), e.exports = s, s.prototype = new Object(u.prototype), s.prototype.constructor = s, s.NO_SLEEPING = 1, s.BODY_SLEEPING = 2, s.ISLAND_SLEEPING = 4, s.prototype.addConstraint = function(t) {
                this.constraints.push(t)
            }, s.prototype.addContactMaterial = function(t) {
                this.contactMaterials.push(t)
            }, s.prototype.removeContactMaterial = function(t) {
                var e = this.contactMaterials.indexOf(t); - 1 !== e && v.splice(this.contactMaterials, e, 1)
            }, s.prototype.getContactMaterial = function(t, e) {
                for (var i = this.contactMaterials, s = 0, n = i.length; s !== n; s++) {
                    var r = i[s];
                    if (r.materialA.id === t.id && r.materialB.id === e.id || r.materialA.id === e.id && r.materialB.id === t.id) return r
                }
                return !1
            }, s.prototype.removeConstraint = function(t) {
                var e = this.constraints.indexOf(t); - 1 !== e && v.splice(this.constraints, e, 1)
            }, r.create(), r.create(), r.create(), r.create(), r.create(), r.create();
            var _ = r.create(),
                w = r.fromValues(0, 0),
                T = r.fromValues(0, 0);
            r.fromValues(0, 0), r.fromValues(0, 0), s.prototype.step = function(t, e, i) {
                if (i = i || 10, 0 === (e = e || 0)) this.internalStep(t), this.time += t;
                else {
                    this.accumulator += e;
                    for (var s = 0; this.accumulator >= t && s < i;) this.internalStep(t), this.time += t, this.accumulator -= t, s++;
                    for (var n = this.accumulator % t / t, o = 0; o !== this.bodies.length; o++) {
                        var a = this.bodies[o];
                        r.lerp(a.interpolatedPosition, a.previousPosition, a.position, n), a.interpolatedAngle = a.previousAngle + n * (a.angle - a.previousAngle)
                    }
                }
            };
            var P = [];
            s.prototype.internalStep = function(t) {
                this.stepping = !0;
                var e = this.springs.length,
                    i = this.springs,
                    n = this.bodies,
                    o = this.gravity,
                    a = this.solver,
                    h = this.bodies.length,
                    l = this.broadphase,
                    c = this.narrowphase,
                    u = this.constraints,
                    p = _,
                    f = (r.scale, r.add),
                    g = (r.rotate, this.islandManager);
                if (this.overlapKeeper.tick(), this.lastTimeStep = t, this.useWorldGravityAsFrictionGravity) {
                    var m = r.length(this.gravity);
                    0 === m && this.useFrictionGravityOnZeroGravity || (this.frictionGravity = m)
                }
                if (this.applyGravity)
                    for (T = 0; T !== h; T++) {
                        var y = (x = n[T]).force;
                        x.type === d.DYNAMIC && x.sleepState !== d.SLEEPING && (r.scale(p, o, x.mass * x.gravityScale), f(y, y, p))
                    }
                if (this.applySpringForces)
                    for (T = 0; T !== e; T++) i[T].applyForce();
                if (this.applyDamping)
                    for (T = 0; T !== h; T++) {
                        var x = n[T];
                        x.type === d.DYNAMIC && x.applyDamping(t)
                    }
                for (var b = l.getCollisionPairs(this), w = this.disabledBodyCollisionPairs, T = w.length - 2; T >= 0; T -= 2)
                    for (S = b.length - 2; S >= 0; S -= 2)(w[T] === b[S] && w[T + 1] === b[S + 1] || w[T + 1] === b[S] && w[T] === b[S + 1]) && b.splice(S, 2);
                for (H = u.length, T = 0; T !== H; T++) {
                    var C = u[T];
                    if (!C.collideConnected)
                        for (var S = b.length - 2; S >= 0; S -= 2)(C.bodyA === b[S] && C.bodyB === b[S + 1] || C.bodyB === b[S] && C.bodyA === b[S + 1]) && b.splice(S, 2)
                }
                this.postBroadphaseEvent.pairs = b, this.emit(this.postBroadphaseEvent), this.postBroadphaseEvent.pairs = null, c.reset(this);
                T = 0;
                for (var A = b.length; T !== A; T += 2)
                    for (var E = b[T], M = b[T + 1], R = 0, L = E.shapes.length; R !== L; R++)
                        for (var B = E.shapes[R], I = B.position, O = B.angle, k = 0, F = M.shapes.length; k !== F; k++) {
                            var D = M.shapes[k],
                                U = D.position,
                                G = D.angle,
                                N = this.defaultContactMaterial;
                            if (B.material && D.material) {
                                var X = this.getContactMaterial(B.material, D.material);
                                X && (N = X)
                            }
                            this.runNarrowphase(c, E, B, I, O, M, D, U, G, N, this.frictionGravity)
                        }
                for (T = 0; T !== h; T++)(q = n[T])._wakeUpAfterNarrowphase && (q.wakeUp(), q._wakeUpAfterNarrowphase = !1);
                if (this.has("endContact")) {
                    this.overlapKeeper.getEndOverlaps(P);
                    var W = this.endContactEvent;
                    for (k = P.length; k--;) {
                        var j = P[k];
                        W.shapeA = j.shapeA, W.shapeB = j.shapeB, W.bodyA = j.bodyA, W.bodyB = j.bodyB, this.emit(W)
                    }
                    P.length = 0
                }
                var V = this.preSolveEvent;
                V.contactEquations = c.contactEquations, V.frictionEquations = c.frictionEquations, this.emit(V), V.contactEquations = V.frictionEquations = null;
                var H = u.length;
                for (T = 0; T !== H; T++) u[T].update();
                if (c.contactEquations.length || c.frictionEquations.length || H)
                    if (this.islandSplit) {
                        for (g.equations.length = 0, v.appendArray(g.equations, c.contactEquations), v.appendArray(g.equations, c.frictionEquations), T = 0; T !== H; T++) v.appendArray(g.equations, u[T].equations);
                        for (g.split(this), T = 0; T !== g.islands.length; T++)(K = g.islands[T]).equations.length && a.solveIsland(t, K)
                    } else {
                        for (a.addEquations(c.contactEquations), a.addEquations(c.frictionEquations), T = 0; T !== H; T++) a.addEquations(u[T].equations);
                        this.solveConstraints && a.solve(t, this), a.removeAllEquations()
                    }
                for (T = 0; T !== h; T++) {
                    var q = n[T];
                    q.integrate(t)
                }
                for (T = 0; T !== h; T++) n[T].setZeroForce();
                if (this.emitImpactEvent && this.has("impact")) {
                    var Y = this.impactEvent;
                    for (T = 0; T !== c.contactEquations.length; T++) {
                        var z = c.contactEquations[T];
                        z.firstImpact && (Y.bodyA = z.bodyA, Y.bodyB = z.bodyB, Y.shapeA = z.shapeA, Y.shapeB = z.shapeB, Y.contactEquation = z, this.emit(Y))
                    }
                }
                if (this.sleepMode === s.BODY_SLEEPING)
                    for (T = 0; T !== h; T++) n[T].sleepTick(this.time, !1, t);
                else if (this.sleepMode === s.ISLAND_SLEEPING && this.islandSplit) {
                    for (T = 0; T !== h; T++) n[T].sleepTick(this.time, !0, t);
                    for (T = 0; T < this.islandManager.islands.length; T++) {
                        var K = this.islandManager.islands[T];
                        K.wantsToSleep() && K.sleep()
                    }
                }
                this.stepping = !1;
                var J = this.bodiesToBeRemoved;
                for (T = 0; T !== J.length; T++) this.removeBody(J[T]);
                J.length = 0, this.emit(this.postStepEvent)
            }, s.prototype.runNarrowphase = function(t, e, i, s, n, o, a, h, l, c, u) {
                if (0 != (i.collisionGroup & a.collisionMask) && 0 != (a.collisionGroup & i.collisionMask)) {
                    r.rotate(w, s, e.angle), r.rotate(T, h, o.angle), r.add(w, w, e.position), r.add(T, T, o.position);
                    var p, f = n + e.angle,
                        g = l + o.angle;
                    t.enableFriction = c.friction > 0, t.frictionCoefficient = c.friction, p = e.type === d.STATIC || e.type === d.KINEMATIC ? o.mass : o.type === d.STATIC || o.type === d.KINEMATIC ? e.mass : e.mass * o.mass / (e.mass + o.mass), t.slipForce = c.friction * u * p, t.restitution = c.restitution, t.surfaceVelocity = c.surfaceVelocity, t.frictionStiffness = c.frictionStiffness, t.frictionRelaxation = c.frictionRelaxation, t.stiffness = c.stiffness, t.relaxation = c.relaxation, t.contactSkinSize = c.contactSkinSize, t.enabledEquations = e.collisionResponse && o.collisionResponse && i.collisionResponse && a.collisionResponse;
                    var m = t[i.type | a.type],
                        y = 0;
                    if (m) {
                        var v = i.sensor || a.sensor,
                            x = t.frictionEquations.length;
                        y = i.type < a.type ? m.call(t, e, i, w, f, o, a, T, g, v) : m.call(t, o, a, T, g, e, i, w, f, v);
                        var b = t.frictionEquations.length - x;
                        if (y) {
                            if (e.allowSleep && e.type === d.DYNAMIC && e.sleepState === d.SLEEPING && o.sleepState === d.AWAKE && o.type !== d.STATIC && r.squaredLength(o.velocity) + Math.pow(o.angularVelocity, 2) >= 2 * Math.pow(o.sleepSpeedLimit, 2) && (e._wakeUpAfterNarrowphase = !0), o.allowSleep && o.type === d.DYNAMIC && o.sleepState === d.SLEEPING && e.sleepState === d.AWAKE && e.type !== d.STATIC && r.squaredLength(e.velocity) + Math.pow(e.angularVelocity, 2) >= 2 * Math.pow(e.sleepSpeedLimit, 2) && (o._wakeUpAfterNarrowphase = !0), this.overlapKeeper.setOverlapping(e, i, o, a), this.has("beginContact") && this.overlapKeeper.isNewOverlap(i, a)) {
                                var _ = this.beginContactEvent;
                                if (_.shapeA = i, _.shapeB = a, _.bodyA = e, _.bodyB = o, _.contactEquations.length = 0, "number" == typeof y)
                                    for (P = t.contactEquations.length - y; P < t.contactEquations.length; P++) _.contactEquations.push(t.contactEquations[P]);
                                this.emit(_)
                            }
                            if ("number" == typeof y && b > 1)
                                for (var P = t.frictionEquations.length - b; P < t.frictionEquations.length; P++) {
                                    var C = t.frictionEquations[P];
                                    C.setSlipForce(C.getSlipForce() / b)
                                }
                        }
                    }
                }
            }, s.prototype.addSpring = function(t) {
                this.springs.push(t);
                var e = this.addSpringEvent;
                e.spring = t, this.emit(e), e.spring = null
            }, s.prototype.removeSpring = function(t) {
                var e = this.springs.indexOf(t); - 1 !== e && v.splice(this.springs, e, 1)
            }, s.prototype.addBody = function(t) {
                if (-1 === this.bodies.indexOf(t)) {
                    this.bodies.push(t), t.world = this;
                    var e = this.addBodyEvent;
                    e.body = t, this.emit(e), e.body = null
                }
            }, s.prototype.removeBody = function(t) {
                if (this.stepping) this.bodiesToBeRemoved.push(t);
                else {
                    t.world = null;
                    var e = this.bodies.indexOf(t); - 1 !== e && (v.splice(this.bodies, e, 1), this.removeBodyEvent.body = t, t.resetConstraintVelocity(), this.emit(this.removeBodyEvent), this.removeBodyEvent.body = null)
                }
            }, s.prototype.getBodyById = function(t) {
                for (var e = this.bodies, i = 0; i < e.length; i++) {
                    var s = e[i];
                    if (s.id === t) return s
                }
                return !1
            }, s.prototype.disableBodyCollision = function(t, e) {
                this.disabledBodyCollisionPairs.push(t, e)
            }, s.prototype.enableBodyCollision = function(t, e) {
                for (var i = this.disabledBodyCollisionPairs, s = 0; s < i.length; s += 2)
                    if (i[s] === t && i[s + 1] === e || i[s + 1] === t && i[s] === e) return void i.splice(s, 2)
            }, s.prototype.clear = function() {
                this.time = 0, this.solver && this.solver.equations.length && this.solver.removeAllEquations();
                for (var t = this.constraints, e = t.length - 1; e >= 0; e--) this.removeConstraint(t[e]);
                var i = this.bodies;
                for (e = i.length - 1; e >= 0; e--) this.removeBody(i[e]);
                var n = this.springs;
                for (e = n.length - 1; e >= 0; e--) this.removeSpring(n[e]);
                var r = this.contactMaterials;
                for (e = r.length - 1; e >= 0; e--) this.removeContactMaterial(r[e]);
                s.apply(this)
            };
            var C = r.create(),
                S = (r.fromValues(0, 0), r.fromValues(0, 0));
            s.prototype.hitTest = function(t, e, i) {
                i = i || 0;
                var s = new d({
                        position: t
                    }),
                    n = new c,
                    u = t,
                    p = C,
                    f = S;
                s.addShape(n);
                for (var g = this.narrowphase, m = [], y = 0, v = e.length; y !== v; y++)
                    for (var x = e[y], b = 0, _ = x.shapes.length; b !== _; b++) {
                        var w = x.shapes[b];
                        r.rotate(p, w.position, x.angle), r.add(p, p, x.position);
                        var T = w.angle + x.angle;
                        (w instanceof o && g.circleParticle(x, w, p, T, s, n, u, 0, !0) || w instanceof a && g.particleConvex(s, n, u, 0, x, w, p, T, !0) || w instanceof h && g.particlePlane(s, n, u, 0, x, w, p, T, !0) || w instanceof l && g.particleCapsule(s, n, u, 0, x, w, p, T, !0) || w instanceof c && r.squaredLength(r.sub(f, p, t)) < i * i) && m.push(x)
                    }
                return m
            }, s.prototype.setGlobalStiffness = function(t) {
                for (var e = this.constraints, i = 0; i !== e.length; i++)
                    for (var s = e[i], n = 0; n !== s.equations.length; n++) {
                        var r = s.equations[n];
                        r.stiffness = t, r.needsUpdate = !0
                    }
                var o = this.contactMaterials;
                for (i = 0; i !== o.length; i++)(s = o[i]).stiffness = s.frictionStiffness = t;
                (s = this.defaultContactMaterial).stiffness = s.frictionStiffness = t
            }, s.prototype.setGlobalRelaxation = function(t) {
                for (n = 0; n !== this.constraints.length; n++)
                    for (var e = this.constraints[n], i = 0; i !== e.equations.length; i++) {
                        var s = e.equations[i];
                        s.relaxation = t, s.needsUpdate = !0
                    }
                for (var n = 0; n !== this.contactMaterials.length; n++)(e = this.contactMaterials[n]).relaxation = e.frictionRelaxation = t;
                (e = this.defaultContactMaterial).relaxation = e.frictionRelaxation = t
            };
            var A = new g,
                E = [];
            s.prototype.raycast = function(t, e) {
                return e.getAABB(A), this.broadphase.aabbQuery(this, A, E), e.intersectBodies(t, E), E.length = 0, t.hasHit()
            }
        }, {
            "../../package.json": 6,
            "../collision/AABB": 7,
            "../collision/Broadphase": 8,
            "../collision/Narrowphase": 10,
            "../collision/Ray": 11,
            "../collision/SAPBroadphase": 13,
            "../constraints/Constraint": 14,
            "../constraints/DistanceConstraint": 15,
            "../constraints/GearConstraint": 16,
            "../constraints/LockConstraint": 17,
            "../constraints/PrismaticConstraint": 18,
            "../constraints/RevoluteConstraint": 19,
            "../events/EventEmitter": 26,
            "../material/ContactMaterial": 27,
            "../material/Material": 28,
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../objects/LinearSpring": 32,
            "../objects/RotationalSpring": 33,
            "../shapes/Capsule": 38,
            "../shapes/Circle": 39,
            "../shapes/Convex": 40,
            "../shapes/Line": 42,
            "../shapes/Particle": 43,
            "../shapes/Plane": 44,
            "../shapes/Shape": 45,
            "../solver/GSSolver": 46,
            "../solver/Solver": 47,
            "../utils/OverlapKeeper": 52,
            "../utils/Utils": 57,
            "./IslandManager": 59
        }]
    }, {}, [36])(36)
}),
function() {
    function t(t, e, s, n) {
        var r = t.createTexture();
        return t.bindTexture(t.TEXTURE_2D, r), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, n === i.scaleModes.LINEAR ? t.LINEAR : t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, n === i.scaleModes.LINEAR ? t.LINEAR : t.NEAREST), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, e, s, 0, t.RGBA, t.UNSIGNED_BYTE, null), r
    }

    function e(e, i, n, r, o) {
        var a, h, l = e.createFramebuffer(),
            c = e.createRenderbuffer();
        return e.activeTexture(e.TEXTURE0 + o), e.bindFramebuffer(e.FRAMEBUFFER, l), e.bindRenderbuffer(e.RENDERBUFFER, c), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, this.renderBuffer), a = t(e, i, n, r), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, a, 0), (h = e.checkFramebufferStatus(e.FRAMEBUFFER)) !== e.FRAMEBUFFER_COMPLETE && console.error("Incomplete GL framebuffer. ", s[h]), l.width = i, l.height = n, l.targetTexture = a, l.renderBuffer = c, l
    }
    var i = i || {};
    i.DisplayObject = function() {
        this.position = new i.Point(0, 0), this.scale = new i.Point(1, 1), this.pivot = new i.Point(0, 0), this.rotation = 0, this.alpha = 1, this.visible = !0, this.hitArea = null, this.renderable = !1, this.parent = null, this.worldAlpha = 1, this.worldTransform = new Phaser.Matrix, this.worldPosition = new i.Point(0, 0), this.worldScale = new i.Point(1, 1), this.worldRotation = 0, this.filterArea = null, this._sr = 0, this._cr = 1, this._bounds = new i.Rectangle(0, 0, 0, 0), this._currentBounds = null, this._mask = null, this._cacheAsBitmap = !1, this._cacheIsDirty = !1
    }, i.DisplayObject.prototype = {
        constructor: i.DisplayObject,
        destroy: function() {
            if (this.children) {
                for (var t = this.children.length; t--;) this.children[t].destroy();
                this.children = []
            }
            this.hitArea = null, this.parent = null, this.worldTransform = null, this.filterArea = null, this.renderable = !1, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite()
        },
        updateTransform: function(t) {
            if (!t && !this.parent && !this.game) return this;
            var e = this.parent;
            t ? e = t : this.parent || (e = this.game.world);
            var i, s, n, r, o, a, h = e.worldTransform,
                l = this.worldTransform;
            this.rotation % Phaser.Math.PI2 ? (this.rotation !== this.rotationCache && (this.rotationCache = this.rotation, this._sr = Math.sin(this.rotation), this._cr = Math.cos(this.rotation)), i = this._cr * this.scale.x, s = this._sr * this.scale.x, n = -this._sr * this.scale.y, r = this._cr * this.scale.y, o = this.position.x, a = this.position.y, (this.pivot.x || this.pivot.y) && (o -= this.pivot.x * i + this.pivot.y * n, a -= this.pivot.x * s + this.pivot.y * r), l.a = i * h.a + s * h.c, l.b = i * h.b + s * h.d, l.c = n * h.a + r * h.c, l.d = n * h.b + r * h.d, l.tx = o * h.a + a * h.c + h.tx, l.ty = o * h.b + a * h.d + h.ty) : (i = this.scale.x, s = 0, n = 0, r = this.scale.y, o = this.position.x - this.pivot.x * i, a = this.position.y - this.pivot.y * r, l.a = i * h.a, l.b = i * h.b, l.c = r * h.c, l.d = r * h.d, l.tx = o * h.a + a * h.c + h.tx, l.ty = o * h.b + a * h.d + h.ty), i = l.a, s = l.b, n = l.c;
            var c = i * (r = l.d) - s * n;
            if (i || s) {
                var u = Math.sqrt(i * i + s * s);
                this.worldRotation = s > 0 ? Math.acos(i / u) : -Math.acos(i / u), this.worldScale.x = u, this.worldScale.y = c / u
            } else if (n || r) {
                var d = Math.sqrt(n * n + r * r);
                this.worldRotation = Phaser.Math.HALF_PI - (r > 0 ? Math.acos(-n / d) : -Math.acos(n / d)), this.worldScale.x = c / d, this.worldScale.y = d
            } else this.worldScale.x = 0, this.worldScale.y = 0;
            return this.worldAlpha = this.alpha * e.worldAlpha, this.worldPosition.x = l.tx, this.worldPosition.y = l.ty, this._currentBounds = null, this.transformCallback && this.transformCallback.call(this.transformCallbackContext, l, h), this
        },
        preUpdate: function() {},
        generateTexture: function(t, e, s) {
            var n = this.getLocalBounds(),
                r = new Phaser.RenderTexture(this.game, 0 | n.width, 0 | n.height, s, e, t);
            return i.DisplayObject._tempMatrix.tx = -n.x, i.DisplayObject._tempMatrix.ty = -n.y, r.render(this, i.DisplayObject._tempMatrix), r
        },
        updateCache: function() {
            return this._generateCachedSprite(), this
        },
        toGlobal: function(t) {
            return this.updateTransform(), this.worldTransform.apply(t)
        },
        toLocal: function(t, e) {
            return e && (t = e.toGlobal(t)), this.updateTransform(), this.worldTransform.applyInverse(t)
        },
        _renderCachedSprite: function(t) {
            this._cachedSprite.worldAlpha = this.worldAlpha, t.gl ? i.Sprite.prototype._renderWebGL.call(this._cachedSprite, t) : i.Sprite.prototype._renderCanvas.call(this._cachedSprite, t)
        },
        _generateCachedSprite: function() {
            this._cacheAsBitmap = !1;
            var t = this.getLocalBounds();
            if (t.width = Math.max(1, Math.ceil(t.width)), t.height = Math.max(1, Math.ceil(t.height)), this.updateTransform(), this._cachedSprite) this._cachedSprite.texture.resize(t.width, t.height);
            else {
                var e = 0;
                this.texture && this.texture.baseTexture && i._enableMultiTextureToggle && (e = this.texture.baseTexture.textureIndex);
                var s = new Phaser.RenderTexture(this.game, t.width, t.height, void 0, void 0, void 0, void 0, e);
                this._cachedSprite = new i.Sprite(s), this._cachedSprite.worldTransform = this.worldTransform
            }
            var n = this._filters;
            this._filters = null, this._cachedSprite.filters = n, i.DisplayObject._tempMatrix.tx = -t.x, i.DisplayObject._tempMatrix.ty = -t.y, this._cachedSprite.texture.render(this, i.DisplayObject._tempMatrix, !0), this._cachedSprite.anchor.x = -t.x / t.width, this._cachedSprite.anchor.y = -t.y / t.height, this._filters = n, this._cacheAsBitmap = !0
        },
        _destroyCachedSprite: function() {
            this._cachedSprite && (this._cachedSprite.texture.destroy(!0), this._cachedSprite = null)
        }
    }, i.DisplayObject.prototype.displayObjectUpdateTransform = i.DisplayObject.prototype.updateTransform, Object.defineProperties(i.DisplayObject.prototype, {
        x: {
            get: function() {
                return this.position.x
            },
            set: function(t) {
                this.position.x = t
            }
        },
        y: {
            get: function() {
                return this.position.y
            },
            set: function(t) {
                this.position.y = t
            }
        },
        worldVisible: {
            get: function() {
                if (this.visible) {
                    var t = this.parent;
                    if (!t) return this.visible;
                    do {
                        if (!t.visible) return !1;
                        t = t.parent
                    } while (t);
                    return !0
                }
                return !1
            }
        },
        mask: {
            get: function() {
                return this._mask
            },
            set: function(t) {
                this._mask && (this._mask.isMask = !1), this._mask = t, t && (this._mask.isMask = !0)
            }
        },
        filters: {
            get: function() {
                return this._filters
            },
            set: function(t) {
                if (Array.isArray(t)) {
                    for (var e = [], s = 0; s < t.length; s++)
                        for (var n = t[s].passes, r = 0; r < n.length; r++) e.push(n[r]);
                    this._filterBlock = {
                        target: this,
                        filterPasses: e
                    }
                }
                this._filters = t, this.blendMode && this.blendMode === i.blendModes.MULTIPLY && (this.blendMode = i.blendModes.NORMAL)
            }
        },
        cacheAsBitmap: {
            get: function() {
                return this._cacheAsBitmap
            },
            set: function(t) {
                this._cacheAsBitmap !== t && (t ? this._generateCachedSprite() : this._destroyCachedSprite(), this._cacheAsBitmap = t)
            }
        }
    }), i.DisplayObjectContainer = function() {
        i.DisplayObject.call(this), this.children = [], this.ignoreChildInput = !1
    }, i.DisplayObjectContainer.prototype = Object.create(i.DisplayObject.prototype), i.DisplayObjectContainer.prototype.constructor = i.DisplayObjectContainer, i.DisplayObjectContainer.prototype.addChild = function(t) {
        return this.addChildAt(t, this.children.length)
    }, i.DisplayObjectContainer.prototype.addChildAt = function(t, e) {
        if (e >= 0 && e <= this.children.length) return t.parent && t.parent.removeChild(t), t.parent = this, this.children.splice(e, 0, t), t;
        throw new Error(t + "addChildAt: The index " + e + " supplied is out of bounds " + this.children.length)
    }, i.DisplayObjectContainer.prototype.swapChildren = function(t, e) {
        if (t !== e) {
            var i = this.getChildIndex(t),
                s = this.getChildIndex(e);
            if (i < 0 || s < 0) throw new Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller.");
            this.children[i] = e, this.children[s] = t
        }
    }, i.DisplayObjectContainer.prototype.getChildIndex = function(t) {
        var e = this.children.indexOf(t);
        if (-1 === e) throw new Error("The supplied DisplayObject must be a child of the caller");
        return e
    }, i.DisplayObjectContainer.prototype.setChildIndex = function(t, e) {
        if (e < 0 || e >= this.children.length) throw new Error("The supplied index is out of bounds");
        var i = this.getChildIndex(t);
        this.children.splice(i, 1), this.children.splice(e, 0, t)
    }, i.DisplayObjectContainer.prototype.getChildAt = function(t) {
        if (t < 0 || t >= this.children.length) throw new Error("getChildAt: Supplied index " + t + " does not exist in the child list, or the supplied DisplayObject must be a child of the caller");
        return this.children[t]
    }, i.DisplayObjectContainer.prototype.removeChild = function(t) {
        var e = this.children.indexOf(t);
        if (-1 !== e) return this.removeChildAt(e)
    }, i.DisplayObjectContainer.prototype.removeChildAt = function(t) {
        var e = this.getChildAt(t);
        return e && (e.parent = void 0, this.children.splice(t, 1)), e
    }, i.DisplayObjectContainer.prototype.bringChildToTop = function(t) {
        if (t.parent === this) return this.setChildIndex(t, this.children.length - 1)
    }, i.DisplayObjectContainer.prototype.sendChildToBack = function(t) {
        if (t.parent === this) return this.setChildIndex(t, 0)
    }, i.DisplayObjectContainer.prototype.removeChildren = function(t, e) {
        void 0 === t && (t = 0), void 0 === e && (e = this.children.length);
        var i = e - t;
        if (i > 0 && i <= e) {
            for (var s = this.children.splice(t, i), n = 0; n < s.length; n++) s[n].parent = void 0;
            return s
        }
        if (0 === i && 0 === this.children.length) return [];
        throw new Error("removeChildren: Range Error, numeric values are outside the acceptable range")
    }, i.DisplayObjectContainer.prototype.updateTransform = function() {
        if (this.visible && (this.displayObjectUpdateTransform(), !this._cacheAsBitmap))
            for (var t = 0; t < this.children.length; t++) this.children[t].updateTransform()
    }, i.DisplayObjectContainer.prototype.displayObjectContainerUpdateTransform = i.DisplayObjectContainer.prototype.updateTransform, i.DisplayObjectContainer.prototype.getBounds = function(t) {
        var e, s = t && t instanceof i.DisplayObject,
            n = !0;
        if (s ? n = t instanceof i.DisplayObjectContainer && t.contains(this) : t = this, s) {
            var r = t.worldTransform;
            for (t.worldTransform = Phaser.identityMatrix, e = 0; e < t.children.length; e++) t.children[e].updateTransform()
        }
        var o, a, h, l = 1 / 0,
            c = 1 / 0,
            u = -1 / 0,
            d = -1 / 0,
            p = !1;
        for (e = 0; e < this.children.length; e++) this.children[e].visible && (p = !0, l = l < (o = this.children[e].getBounds()).x ? l : o.x, c = c < o.y ? c : o.y, u = u > (a = o.width + o.x) ? u : a, d = d > (h = o.height + o.y) ? d : h);
        var f = this._bounds;
        if (!p) {
            var g = (f = new i.Rectangle).x,
                m = f.width + f.x,
                y = f.y,
                v = f.height + f.y,
                x = this.worldTransform,
                b = x.a,
                _ = x.b,
                w = x.c,
                T = x.d,
                P = x.tx,
                C = x.ty,
                S = b * m + w * v + P,
                A = T * v + _ * m + C,
                E = b * g + w * v + P,
                M = T * v + _ * g + C,
                R = b * g + w * y + P,
                L = T * y + _ * g + C,
                B = b * m + w * y + P,
                I = T * y + _ * m + C;
            l = B < (l = R < (l = E < (l = S) ? E : l) ? R : l) ? B : l, c = I < (c = L < (c = M < (c = A) ? M : c) ? L : c) ? I : c, u = B > (u = R > (u = E > (u = S) ? E : u) ? R : u) ? B : u, d = I > (d = L > (d = M > (d = A) ? M : d) ? L : d) ? I : d
        }
        if (f.x = l, f.y = c, f.width = u - l, f.height = d - c, s)
            for (t.worldTransform = r, e = 0; e < t.children.length; e++) t.children[e].updateTransform();
        if (!n) {
            var O = t.getBounds();
            f.x -= O.x, f.y -= O.y
        }
        return f
    }, i.DisplayObjectContainer.prototype.getLocalBounds = function() {
        return this.getBounds(this)
    }, i.DisplayObjectContainer.prototype.contains = function(t) {
        return !!t && (t === this || this.contains(t.parent))
    }, i.DisplayObjectContainer.prototype._renderWebGL = function(t) {
        if (this.visible && !(this.alpha <= 0))
            if (this._cacheAsBitmap) this._renderCachedSprite(t);
            else {
                var e;
                if (this._mask || this._filters) {
                    for (this._filters && (t.spriteBatch.flush(), t.filterManager.pushFilter(this._filterBlock)), this._mask && (t.spriteBatch.stop(), t.maskManager.pushMask(this.mask, t), t.spriteBatch.start()), e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t);
                    t.spriteBatch.stop(), this._mask && t.maskManager.popMask(this._mask, t), this._filters && t.filterManager.popFilter(), t.spriteBatch.start()
                } else
                    for (e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t)
            }
    }, i.DisplayObjectContainer.prototype._renderCanvas = function(t) {
        if (!1 !== this.visible && 0 !== this.alpha)
            if (this._cacheAsBitmap) this._renderCachedSprite(t);
            else {
                this._mask && t.maskManager.pushMask(this._mask, t);
                for (var e = 0; e < this.children.length; e++) this.children[e]._renderCanvas(t);
                this._mask && t.maskManager.popMask(t)
            }
    }, Object.defineProperty(i.DisplayObjectContainer.prototype, "width", {
        get: function() {
            return this.getLocalBounds().width * this.scale.x
        },
        set: function(t) {
            var e = this.getLocalBounds().width;
            this.scale.x = 0 !== e ? t / e : 1, this._width = t
        }
    }), Object.defineProperty(i.DisplayObjectContainer.prototype, "height", {
        get: function() {
            return this.getLocalBounds().height * this.scale.y
        },
        set: function(t) {
            var e = this.getLocalBounds().height;
            this.scale.y = 0 !== e ? t / e : 1, this._height = t
        }
    }), i.Sprite = function(t) {
        i.DisplayObjectContainer.call(this), this.anchor = new i.Point(i.Sprite.defaultAnchor.x, i.Sprite.defaultAnchor.y), this.texture = t || i.Texture.emptyTexture, this._width = 0, this._height = 0, this.tint = 16777215, this.cachedTint = -1, this.tintedTexture = null, this.blendMode = i.blendModes.NORMAL, this.shader = null, this.exists = !0, this.texture.baseTexture.hasLoaded && this.onTextureUpdate(), this.renderable = !0
    }, i.Sprite.defaultAnchor = {
        x: 0,
        y: 0
    }, i.Sprite.prototype = Object.create(i.DisplayObjectContainer.prototype), i.Sprite.prototype.constructor = i.Sprite, Object.defineProperty(i.Sprite.prototype, "width", {
        get: function() {
            return this.scale.x * this.texture.frame.width
        },
        set: function(t) {
            this.scale.x = t / this.texture.frame.width, this._width = t
        }
    }), Object.defineProperty(i.Sprite.prototype, "height", {
        get: function() {
            return this.scale.y * this.texture.frame.height
        },
        set: function(t) {
            this.scale.y = t / this.texture.frame.height, this._height = t
        }
    }), i.Sprite.prototype.setTexture = function(t, e) {
        e && this.texture.baseTexture.destroy(), this.texture.baseTexture.skipRender = !1, this.texture = t, this.texture.valid = !0, this.cachedTint = -1
    }, i.Sprite.prototype.onTextureUpdate = function() {
        this._width && (this.scale.x = this._width / this.texture.frame.width), this._height && (this.scale.y = this._height / this.texture.frame.height)
    }, i.Sprite.prototype.getBounds = function(t) {
        var e = this.texture.frame.width,
            i = this.texture.frame.height,
            s = e * (1 - this.anchor.x),
            n = e * -this.anchor.x,
            r = i * (1 - this.anchor.y),
            o = i * -this.anchor.y,
            a = t || this.worldTransform,
            h = a.a,
            l = a.b,
            c = a.c,
            u = a.d,
            d = a.tx,
            p = a.ty,
            f = -1 / 0,
            g = -1 / 0,
            m = 1 / 0,
            y = 1 / 0;
        if (0 === l && 0 === c) {
            if (h < 0 && (h *= -1, v = s, s = -n, n = -v), u < 0) {
                u *= -1;
                var v = r;
                r = -o, o = -v
            }
            m = h * n + d, f = h * s + d, y = u * o + p, g = u * r + p
        } else {
            var x = h * n + c * o + d,
                b = u * o + l * n + p,
                _ = h * s + c * o + d,
                w = u * o + l * s + p,
                T = h * s + c * r + d,
                P = u * r + l * s + p,
                C = h * n + c * r + d,
                S = u * r + l * n + p;
            m = C < (m = T < (m = _ < (m = x < m ? x : m) ? _ : m) ? T : m) ? C : m, y = S < (y = P < (y = w < (y = b < y ? b : y) ? w : y) ? P : y) ? S : y, f = C > (f = T > (f = _ > (f = x > f ? x : f) ? _ : f) ? T : f) ? C : f, g = S > (g = P > (g = w > (g = b > g ? b : g) ? w : g) ? P : g) ? S : g
        }
        var A = this._bounds;
        return A.x = m, A.width = f - m, A.y = y, A.height = g - y, this._currentBounds = A, A
    }, i.Sprite.prototype.getLocalBounds = function() {
        var t = this.worldTransform;
        this.worldTransform = Phaser.identityMatrix;
        for (var e = 0; e < this.children.length; e++) this.children[e].updateTransform();
        var i = this.getBounds();
        for (this.worldTransform = t, e = 0; e < this.children.length; e++) this.children[e].updateTransform();
        return i
    }, i.Sprite.prototype._renderWebGL = function(t, e) {
        if (this.visible && !(this.alpha <= 0) && this.renderable) {
            var i = this.worldTransform;
            if (e && (i = e), this._mask || this._filters) {
                var s = t.spriteBatch;
                for (this._filters && (s.flush(), t.filterManager.pushFilter(this._filterBlock)), this._mask && (s.stop(), t.maskManager.pushMask(this.mask, t), s.start()), s.render(this), n = 0; n < this.children.length; n++) this.children[n]._renderWebGL(t);
                s.stop(), this._mask && t.maskManager.popMask(this._mask, t), this._filters && t.filterManager.popFilter(), s.start()
            } else {
                t.spriteBatch.render(this);
                for (var n = 0; n < this.children.length; n++) this.children[n]._renderWebGL(t, i)
            }
        }
    }, i.Sprite.prototype._renderCanvas = function(t, e) {
        if (!(!this.visible || 0 === this.alpha || !this.renderable || this.texture.crop.width < 1 || this.texture.crop.height < 1)) {
            var s = this.worldTransform;
            if (e && (s = e), this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, t.context.globalCompositeOperation = i.blendModesCanvas[t.currentBlendMode]), this._mask && t.maskManager.pushMask(this._mask, t), this.texture.valid) {
                var n = this.texture.baseTexture.resolution / t.resolution;
                t.context.globalAlpha = this.worldAlpha, t.smoothProperty && t.scaleMode !== this.texture.baseTexture.scaleMode && (t.scaleMode = this.texture.baseTexture.scaleMode, t.context[t.smoothProperty] = t.scaleMode === i.scaleModes.LINEAR);
                var r = this.texture.trim ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width,
                    o = this.texture.trim ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height,
                    a = s.tx * t.resolution + t.shakeX,
                    h = s.ty * t.resolution + t.shakeY,
                    l = this.texture.crop.width,
                    c = this.texture.crop.height;
                if (this.texture.rotated) {
                    var u = s.a,
                        d = s.b,
                        p = s.c,
                        f = s.d,
                        g = l;
                    a = s.c * c + a, h = s.d * c + h, s.a = 6.123233995736766e-17 * u - p, s.b = 6.123233995736766e-17 * d - f, s.c = u + 6.123233995736766e-17 * p, s.d = d + 6.123233995736766e-17 * f, l = c, c = g
                }
                if (t.roundPixels ? (t.context.setTransform(s.a, s.b, s.c, s.d, 0 | a, 0 | h), r |= 0, o |= 0) : t.context.setTransform(s.a, s.b, s.c, s.d, a, h), r /= n, o /= n, c |= 0, (l |= 0) && c) {
                    if (16777215 !== this.tint)(this.texture.requiresReTint || this.cachedTint !== this.tint) && (this.tintedTexture = i.CanvasTinter.getTintedTexture(this, this.tint), this.cachedTint = this.tint, this.texture.requiresReTint = !1), t.context.drawImage(this.tintedTexture, 0, 0, l, c, r, o, l / n, c / n);
                    else {
                        var m = this.texture.crop.x,
                            y = this.texture.crop.y;
                        t.context.drawImage(this.texture.baseTexture.source, m, y, l, c, r, o, l / n, c / n)
                    }
                    for (v = 0; v < this.children.length; v++) this.children[v]._renderCanvas(t);
                    this._mask && t.maskManager.popMask(t)
                }
            } else {
                for (var v = 0; v < this.children.length; v++) this.children[v]._renderCanvas(t);
                this._mask && t.maskManager.popMask(t)
            }
        }
    }, i.initDefaultShaders = function() {}, i.CompileVertexShader = function(t, e) {
        return i._CompileShader(t, e, t.VERTEX_SHADER)
    }, i.CompileFragmentShader = function(t, e) {
        return i._CompileShader(t, e, t.FRAGMENT_SHADER)
    }, i._CompileShader = function(t, e, i) {
        var s = e;
        Array.isArray(e) && (s = e.join("\n"));
        var n = t.createShader(i);
        return t.shaderSource(n, s), t.compileShader(n), t.getShaderParameter(n, t.COMPILE_STATUS) ? n : (window.gradle.event(t.getShaderInfoLog(n)), null)
    }, i.compileProgram = function(t, e, s) {
        var n = i.CompileFragmentShader(t, s),
            r = i.CompileVertexShader(t, e),
            o = t.createProgram();
        return t.attachShader(o, r), t.attachShader(o, n), t.linkProgram(o), t.getProgramParameter(o, t.LINK_STATUS) || (window.gradle.event(t.getProgramInfoLog(o)), window.gradle.event("Could not initialise shaders")), o
    }, i.PixiShader = function(t) {
        this._UID = Phaser._UID++, this.gl = t, this.program = null, this.fragmentSrc = null, this.textureCount = 0, this.firstRun = !0, this.dirty = !0, this.attributes = [], this.init()
    }, i.PixiShader.prototype.constructor = i.PixiShader, i.PixiShader.prototype.initMultitexShader = function() {
        var t = this.gl;
        this.MAX_TEXTURES = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
        for (var e = "\tif (vTextureIndex == 0.0) { gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;return;}\n", s = 1; s < this.MAX_TEXTURES; ++s) e += "\tif (vTextureIndex == " + s + ".0) {gl_FragColor = texture2D(uSamplerArray[" + s + "], vTextureCoord) * vColor;return;}\n";
        this.fragmentSrc = ["// PixiShader Fragment Shader.", "precision lowp float;", "bool isnan( float val ) {  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true; }", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "uniform sampler2D uSamplerArray[" + this.MAX_TEXTURES + "];", "const vec4 BLUE = vec4(1.0, 0.0, 1.0, 1.0);", "const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);", "void main(void) {", e, "   if(vTextureIndex >= " + this.MAX_TEXTURES + ".0) { gl_FragColor = BLUE;return;}", "   if(isnan(vTextureIndex)) { gl_FragColor = RED;return;}", "}"];
        var n = i.compileProgram(t, this.vertexSrc || i.PixiShader.defaultVertexSrc, this.fragmentSrc);
        t.useProgram(n), this.uSamplerArray = t.getUniformLocation(n, "uSamplerArray[0]"), this.projectionVector = t.getUniformLocation(n, "projectionVector"), this.offsetVector = t.getUniformLocation(n, "offsetVector"), this.dimensions = t.getUniformLocation(n, "dimensions"), this.aVertexPosition = t.getAttribLocation(n, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(n, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(n, "aColor"), this.aTextureIndex = t.getAttribLocation(n, "aTextureIndex");
        var r = [],
            o = t.createTexture();
        t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, o), t.texImage2D(t.TEXTURE_2D, 0, t.RGB, 1, 1, 0, t.RGB, t.UNSIGNED_BYTE, null);
        for (var a = 0; a < this.MAX_TEXTURES; ++a) t.activeTexture(t.TEXTURE0 + a), t.bindTexture(t.TEXTURE_2D, o), r.push(a);
        for (var h in t.activeTexture(t.TEXTURE0), t.uniform1iv(this.uSamplerArray, r), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute, this.aTextureIndex], this.uniforms) this.uniforms[h].uniformLocation = t.getUniformLocation(n, h);
        this.initUniforms(), this.program = n
    }, i.PixiShader.prototype.initDefaultShader = function() {
        null === this.fragmentSrc && (this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"]);
        var t = this.gl,
            e = i.compileProgram(t, this.vertexSrc || i.PixiShader.defaultVertexSrc, this.fragmentSrc);
        for (var s in t.useProgram(e), this.uSampler = t.getUniformLocation(e, "uSampler"), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.dimensions = t.getUniformLocation(e, "dimensions"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(e, "aColor"), this.aTextureIndex = t.getAttribLocation(e, "aTextureIndex"), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute, this.aTextureIndex], this.uniforms) this.uniforms[s].uniformLocation = t.getUniformLocation(e, s);
        this.initUniforms(), this.program = e
    }, i.PixiShader.prototype.init = function(t) {
        i._enableMultiTextureToggle && !t ? this.initMultitexShader() : this.initDefaultShader()
    }, i.PixiShader.prototype.initUniforms = function() {
        this.textureCount = 1;
        var t, e = this.gl;
        for (var i in this.uniforms) {
            var s = (t = this.uniforms[i]).type;
            "sampler2D" === s ? (t._init = !1, null !== t.value && this.initSampler2D(t)) : "mat2" === s || "mat3" === s || "mat4" === s ? (t.glMatrix = !0, t.glValueLength = 1, "mat2" === s ? t.glFunc = e.uniformMatrix2fv : "mat3" === s ? t.glFunc = e.uniformMatrix3fv : "mat4" === s && (t.glFunc = e.uniformMatrix4fv)) : (t.glFunc = e["uniform" + s], t.glValueLength = "2f" === s || "2i" === s ? 2 : "3f" === s || "3i" === s ? 3 : "4f" === s || "4i" === s ? 4 : 1)
        }
    }, i.PixiShader.prototype.initSampler2D = function(t) {
        if (t.value && t.value.baseTexture && t.value.baseTexture.hasLoaded) {
            var e = this.gl;
            if (e.activeTexture(e.TEXTURE0 + this.textureCount), e.bindTexture(e.TEXTURE_2D, t.value.baseTexture._glTextures[e.id]), t.textureData) {
                var i = t.textureData,
                    s = i.magFilter ? i.magFilter : e.LINEAR,
                    n = i.minFilter ? i.minFilter : e.LINEAR,
                    r = i.wrapS ? i.wrapS : e.CLAMP_TO_EDGE,
                    o = i.wrapT ? i.wrapT : e.CLAMP_TO_EDGE,
                    a = i.luminance ? e.LUMINANCE : e.RGBA;
                if (i.repeat && (r = e.REPEAT, o = e.REPEAT), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !!i.flipY), i.width) {
                    var h = i.width ? i.width : 512,
                        l = i.height ? i.height : 2,
                        c = i.border ? i.border : 0;
                    e.texImage2D(e.TEXTURE_2D, 0, a, h, l, c, a, e.UNSIGNED_BYTE, null)
                } else e.texImage2D(e.TEXTURE_2D, 0, a, e.RGBA, e.UNSIGNED_BYTE, t.value.baseTexture.source);
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, s), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, n), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, r), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, o)
            }
            e.uniform1i(t.uniformLocation, this.textureCount), t._init = !0, this.textureCount++
        }
    }, i.PixiShader.prototype.syncUniforms = function() {
        this.textureCount = 1;
        var t, e = this.gl;
        for (var s in this.uniforms) 1 === (t = this.uniforms[s]).glValueLength ? !0 === t.glMatrix ? t.glFunc.call(e, t.uniformLocation, t.transpose, t.value) : t.glFunc.call(e, t.uniformLocation, t.value) : 2 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y) : 3 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y, t.value.z) : 4 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y, t.value.z, t.value.w) : "sampler2D" === t.type && (t._init ? (e.activeTexture(e["TEXTURE" + this.textureCount]), t.value.baseTexture._dirty[e.id] ? i.instances[e.id].updateTexture(t.value.baseTexture) : e.bindTexture(e.TEXTURE_2D, t.value.baseTexture._glTextures[e.id]), e.uniform1i(t.uniformLocation, this.textureCount), this.textureCount++) : this.initSampler2D(t))
    }, i.PixiShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
    }, i.PixiShader.defaultVertexSrc = ["// PixiShader Vertex Shader", "// With multi-texture rendering", "attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec4 aColor;", "attribute float aTextureIndex;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   if (aTextureIndex > 0.0) gl_Position = vec4(0.0);", "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = vec4(aColor.rgb * aColor.a, aColor.a);", "   vTextureIndex = aTextureIndex;", "}"], i.PixiFastShader = function(t) {
        if (this._UID = Phaser._UID++, this.gl = t, this.program = null, i._enableMultiTextureToggle) {
            t = this.gl;
            this.MAX_TEXTURES = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
            for (var e = "\tif (vTextureIndex == 0.0) { gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;return;}\n", s = 1; s < this.MAX_TEXTURES; ++s) e += "\tif (vTextureIndex == " + s + ".0) { gl_FragColor = texture2D(uSamplerArray[" + s + "], vTextureCoord) * vColor;return;}\n";
            this.fragmentSrc = ["// PixiFastShader Fragment Shader.", "precision lowp float;", "bool isnan( float val ) {  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true; }", "varying vec2 vTextureCoord;", "varying float vColor;", "varying float vTextureIndex;", "uniform sampler2D uSamplerArray[" + this.MAX_TEXTURES + "];", "const vec4 BLUE = vec4(1.0, 0.0, 1.0, 1.0);", "const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);", "void main(void) {", e, "   if(vTextureIndex >= " + this.MAX_TEXTURES + ".0) { gl_FragColor = BLUE;return;}", "   if(isnan(vTextureIndex)) {gl_FragColor = RED;return;}", "}"]
        } else this.fragmentSrc = ["// PixiFastShader Fragment Shader.", "precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "varying float vTextureIndex;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;", "}"];
        this.vertexSrc = ["// PixiFastShader Vertex Shader.", "attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "attribute float aTextureIndex;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "varying float vTextureIndex;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vTextureIndex = aTextureIndex;", "   vColor = aColor;", "}"], this.textureCount = 0, this.init()
    }, i.PixiFastShader.prototype.constructor = i.PixiFastShader, i.PixiFastShader.prototype.init = function() {
        var t = this.gl,
            e = i.compileProgram(t, this.vertexSrc, this.fragmentSrc);
        if (t.useProgram(e), this.uSampler = i._enableMultiTextureToggle ? t.getUniformLocation(e, "uSamplerArray[0]") : t.getUniformLocation(e, "uSampler"), i._enableMultiTextureToggle) {
            var s = [],
                n = t.createTexture();
            t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, n), t.texImage2D(t.TEXTURE_2D, 0, t.RGB, 1, 1, 0, t.RGB, t.UNSIGNED_BYTE, null);
            for (var r = 0; r < this.MAX_TEXTURES; ++r) t.activeTexture(t.TEXTURE0 + r), t.bindTexture(t.TEXTURE_2D, n), s.push(r);
            t.activeTexture(t.TEXTURE0), t.uniform1iv(this.uSampler, s)
        }
        this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.dimensions = t.getUniformLocation(e, "dimensions"), this.uMatrix = t.getUniformLocation(e, "uMatrix"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.aPositionCoord = t.getAttribLocation(e, "aPositionCoord"), this.aScale = t.getAttribLocation(e, "aScale"), this.aRotation = t.getAttribLocation(e, "aRotation"), this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(e, "aColor"), this.aTextureIndex = t.getAttribLocation(e, "aTextureIndex"), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aPositionCoord, this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute, this.aTextureIndex], this.program = e
    }, i.PixiFastShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
    }, i.StripShader = function(t) {
        if (this._UID = Phaser._UID++, this.gl = t, this.program = null, i._enableMultiTextureToggle) {
            t = this.gl;
            this.MAX_TEXTURES = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
            for (var e = "\tif (vTextureIndex == 0.0) { gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord);return;}\n", s = 1; s < this.MAX_TEXTURES; ++s) e += "\tif (vTextureIndex == " + s + ".0) { gl_FragColor = texture2D(uSamplerArray[" + s + "], vTextureCoord) ;return;}\n";
            this.fragmentSrc = ["//StripShader Fragment Shader.", "precision mediump float;", "bool isnan( float val ) {  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true; }", "varying vec2 vTextureCoord;", "varying float vTextureIndex;", "uniform float alpha;", "uniform sampler2D uSamplerArray[" + this.MAX_TEXTURES + "];", "const vec4 BLUE = vec4(1.0, 0.0, 1.0, 1.0);", "const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);", "void main(void) {", e, "   if(vTextureIndex >= " + this.MAX_TEXTURES + ".0) { gl_FragColor = BLUE;return;}", "   if(isnan(vTextureIndex)) {gl_FragColor = RED;return;}", "}"]
        } else this.fragmentSrc = ["//StripShader Fragment Shader.", "precision mediump float;", "varying vec2 vTextureCoord;", "varying float vTextureIndex;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord);", "}"];
        this.vertexSrc = ["//StripShader Vertex Shader.", "attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute float aTextureIndex;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying float vTextureIndex;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vTextureIndex = aTextureIndex;", "}"], this.init()
    }, i.StripShader.prototype.constructor = i.StripShader, i.StripShader.prototype.init = function() {
        var t = this.gl,
            e = i.compileProgram(t, this.vertexSrc, this.fragmentSrc);
        if (t.useProgram(e), this.uSampler = i._enableMultiTextureToggle ? t.getUniformLocation(e, "uSamplerArray[0]") : t.getUniformLocation(e, "uSampler"), i._enableMultiTextureToggle) {
            var s = [],
                n = t.createTexture();
            t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, n), t.texImage2D(t.TEXTURE_2D, 0, t.RGB, 1, 1, 0, t.RGB, t.UNSIGNED_BYTE, null);
            for (var r = 0; r < this.MAX_TEXTURES; ++r) t.activeTexture(t.TEXTURE0 + r), t.bindTexture(t.TEXTURE_2D, n), s.push(r);
            t.activeTexture(t.TEXTURE0), t.uniform1iv(this.uSampler, s)
        }
        this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.colorAttribute = t.getAttribLocation(e, "aColor"), this.aTextureIndex = t.getAttribLocation(e, "aTextureIndex"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"), this.attributes = [this.aVertexPosition, this.aTextureCoord, this.aTextureIndex], this.translationMatrix = t.getUniformLocation(e, "translationMatrix"), this.alpha = t.getUniformLocation(e, "alpha"), this.program = e
    }, i.StripShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null
    }, i.PrimitiveShader = function(t) {
        this._UID = Phaser._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform float flipY;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}"], this.init()
    }, i.PrimitiveShader.prototype.constructor = i.PrimitiveShader, i.PrimitiveShader.prototype.init = function() {
        var t = this.gl,
            e = i.compileProgram(t, this.vertexSrc, this.fragmentSrc);
        t.useProgram(e), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.tintColor = t.getUniformLocation(e, "tint"), this.flipY = t.getUniformLocation(e, "flipY"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.colorAttribute = t.getAttribLocation(e, "aColor"), this.attributes = [this.aVertexPosition, this.colorAttribute], this.translationMatrix = t.getUniformLocation(e, "translationMatrix"), this.alpha = t.getUniformLocation(e, "alpha"), this.program = e
    }, i.PrimitiveShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
    }, i.ComplexPrimitiveShader = function(t) {
        this._UID = Phaser._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform vec3 tint;", "uniform float alpha;", "uniform vec3 color;", "uniform float flipY;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = vec4(color * alpha * tint, alpha);", "}"], this.init()
    }, i.ComplexPrimitiveShader.prototype.constructor = i.ComplexPrimitiveShader, i.ComplexPrimitiveShader.prototype.init = function() {
        var t = this.gl,
            e = i.compileProgram(t, this.vertexSrc, this.fragmentSrc);
        t.useProgram(e), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.tintColor = t.getUniformLocation(e, "tint"), this.color = t.getUniformLocation(e, "color"), this.flipY = t.getUniformLocation(e, "flipY"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.attributes = [this.aVertexPosition, this.colorAttribute], this.translationMatrix = t.getUniformLocation(e, "translationMatrix"), this.alpha = t.getUniformLocation(e, "alpha"), this.program = e
    }, i.ComplexPrimitiveShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null
    }, i.glContexts = [], i.instances = [], i._enableMultiTextureToggle = !1, i.WebGLRenderer = function(t, e) {
        this.game = t, i.defaultRenderer || (i.defaultRenderer = this), this.extensions = {}, this.type = Phaser.WEBGL, this.resolution = t.resolution, this.transparent = t.transparent, this.autoResize = !1, this.preserveDrawingBuffer = t.preserveDrawingBuffer, this.clearBeforeRender = t.clearBeforeRender, this.width = t.width, this.height = t.height, this.view = t.canvas, this._contextOptions = {
            alpha: this.transparent,
            antialias: t.antialias,
            failIfMajorPerformanceCaveat: e.failIfMajorPerformanceCaveat,
            premultipliedAlpha: this.transparent && "notMultiplied" !== this.transparent,
            stencil: !0,
            preserveDrawingBuffer: this.preserveDrawingBuffer
        }, this.projection = new i.Point, this.offset = new i.Point, this.shaderManager = new i.WebGLShaderManager, this.spriteBatch = new i.WebGLSpriteBatch(t), this.maskManager = new i.WebGLMaskManager, this.filterManager = new i.WebGLFilterManager, this.stencilManager = new i.WebGLStencilManager, this.blendModeManager = new i.WebGLBlendModeManager, this.renderSession = {}, this.currentBatchedTextures = [], this.renderSession.game = this.game, this.renderSession.gl = this.gl, this.renderSession.drawCount = 0, this.renderSession.shaderManager = this.shaderManager, this.renderSession.maskManager = this.maskManager, this.renderSession.filterManager = this.filterManager, this.renderSession.blendModeManager = this.blendModeManager, this.renderSession.spriteBatch = this.spriteBatch, this.renderSession.stencilManager = this.stencilManager, this.renderSession.renderer = this, this.renderSession.resolution = this.resolution, this.renderSession.roundPixels = e.roundPixels || !1, this.renderSession.maxTextureAvailableSpace = null, this.initContext(), this.mapBlendModes()
    }, i.WebGLRenderer.prototype.constructor = i.WebGLRenderer, i.WebGLRenderer.prototype.initContext = function() {
        var t = this.view.getContext("webgl", this._contextOptions) || this.view.getContext("experimental-webgl", this._contextOptions);
        if (this.gl = t, !t) throw new Error("This browser does not support webGL. Try using the canvas renderer");
        this.maxTextures = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), this.maxTextureSize = this.gl.getParameter(t.MAX_TEXTURE_SIZE), this.glContextId = t.id = i.WebGLRenderer.glContextId++, i.glContexts[this.glContextId] = t, i.instances[this.glContextId] = this, t.disable(t.DEPTH_TEST), t.disable(t.CULL_FACE), t.enable(t.BLEND), this.shaderManager.setContext(t), this.spriteBatch.setContext(t), this.maskManager.setContext(t), this.filterManager.setContext(t), this.blendModeManager.setContext(t), this.stencilManager.setContext(t), this.renderSession.gl = this.gl, this.resize(this.width, this.height), this.extensions.compression = {};
        var e = t.getExtension("WEBGL_compressed_texture_etc1") || t.getExtension("WEBKIT_WEBGL_compressed_texture_etc1"),
            s = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
            n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        e && (this.extensions.compression.ETC1 = e), s && (this.extensions.compression.PVRTC = s), n && (this.extensions.compression.S3TC = n)
    }, i.WebGLRenderer.prototype.setTexturePriority = function(t) {
        if (i._enableMultiTextureToggle) {
            for (var e = function(t) {
                    return --t, t |= t >> 1, t |= t >> 2, t |= t >> 4, t |= t >> 8, t |= t >> 16, ++t
                }, s = this.gl, n = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS), r = s.getParameter(s.MAX_TEXTURE_SIZE), o = this.game.cache._cache.image, a = null, h = 0; h < this.currentBatchedTextures.length; h++)(a = this.currentBatchedTextures[h]) in o ? o[a].base.textureIndex = 0 : console.warn('setTexturePriority: There is no image "%s" in the image cache.', a);
            var l = r - e(Math.max(this.width, this.height));
            this.currentBatchedTextures.length = 0;
            for (var c = 0; c < t.length; ++c)
                if ((a = t[c]) in o) {
                    var u = o[a].base;
                    (l -= e(Math.max(u.width, u.height))) <= 0 ? (u.textureIndex = 0, console.warn('setTexturePriority: Image "%s" was given textureIndex=0 because there is no available texture space (%s).', a, l)) : u.textureIndex = 1 + c % (n - 1), this.currentBatchedTextures.push(a)
                } else console.warn('setTexturePriority: There is no image "%s" in the image cache.', a);
            return this.renderSession.maxTextureAvailableSpace = l, this.currentBatchedTextures
        }
        console.warn("setTexturePriority error: Multi Texture support hasn't been enabled in the Phaser Game Config.")
    }, i.WebGLRenderer.prototype.render = function(t) {
        if (!this.contextLost) {
            var e = this.gl;
            e.viewport(0, 0, this.width, this.height), e.bindFramebuffer(e.FRAMEBUFFER, null), this.game.clearBeforeRender && (e.clearColor(t._bgColor.r, t._bgColor.g, t._bgColor.b, t._bgColor.a), e.clear(e.COLOR_BUFFER_BIT)), this.offset.x = this.game.camera._shake.x, this.offset.y = this.game.camera._shake.y, this.renderDisplayObject(t, this.projection)
        }
    }, i.WebGLRenderer.prototype.renderDisplayObject = function(t, e, s, n) {
        this.renderSession.blendModeManager.setBlendMode(i.blendModes.NORMAL), this.renderSession.drawCount = 0, this.renderSession.flipY = s ? -1 : 1, this.renderSession.projection = e, this.renderSession.offset = this.offset, this.spriteBatch.begin(this.renderSession), this.filterManager.begin(this.renderSession, s), t._renderWebGL(this.renderSession, n), this.spriteBatch.end()
    }, i.WebGLRenderer.prototype.resize = function(t, e) {
        this.width = t * this.resolution, this.height = e * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.gl.viewport(0, 0, this.width, this.height), this.projection.x = this.width / 2 / this.resolution, this.projection.y = -this.height / 2 / this.resolution
    }, i.WebGLRenderer.prototype.updateCompressedTexture = function(t) {
        if (!t.hasLoaded) return !1;
        var e = this.gl,
            s = t.source;
        return t._glTextures[e.id] || (t._glTextures[e.id] = e.createTexture()), e.activeTexture(e.TEXTURE0 + t.textureIndex), e.bindTexture(e.TEXTURE_2D, t._glTextures[e.id]), e.compressedTexImage2D(e.TEXTURE_2D, 0, s.glExtensionFormat, s.width, s.height, 0, s.textureData), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, t.scaleMode === i.scaleModes.LINEAR ? e.LINEAR : e.NEAREST), t.mipmap && Phaser.Math.isPowerOfTwo(t.width, t.height) ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === i.scaleModes.LINEAR ? e.LINEAR_MIPMAP_LINEAR : e.NEAREST_MIPMAP_NEAREST), e.generateMipmap(e.TEXTURE_2D)) : e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === i.scaleModes.LINEAR ? e.LINEAR : e.NEAREST), t._powerOf2 ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT)) : (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE)), t._dirty[e.id] = !1, !0
    }, i.WebGLRenderer.prototype.updateTexture = function(t) {
        if (!t.hasLoaded) return !1;
        if (t.source.compressionAlgorithm) return this.updateCompressedTexture(t);
        var e = this.gl;
        return t._glTextures[e.id] || (t._glTextures[e.id] = e.createTexture()), e.activeTexture(e.TEXTURE0 + t.textureIndex), e.bindTexture(e.TEXTURE_2D, t._glTextures[e.id]), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultipliedAlpha), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t.source), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, t.scaleMode === i.scaleModes.LINEAR ? e.LINEAR : e.NEAREST), t.mipmap && Phaser.Math.isPowerOfTwo(t.width, t.height) ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === i.scaleModes.LINEAR ? e.LINEAR_MIPMAP_LINEAR : e.NEAREST_MIPMAP_NEAREST), e.generateMipmap(e.TEXTURE_2D)) : e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === i.scaleModes.LINEAR ? e.LINEAR : e.NEAREST), t._powerOf2 ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT)) : (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE)), t._dirty[e.id] = !1, !0
    }, i.WebGLRenderer.prototype.destroy = function() {
        i.glContexts[this.glContextId] = null, this.projection = null, this.offset = null, this.shaderManager.destroy(), this.spriteBatch.destroy(), this.maskManager.destroy(), this.filterManager.destroy(), this.shaderManager = null, this.spriteBatch = null, this.maskManager = null, this.filterManager = null, this.gl = null, this.renderSession = null, Phaser.CanvasPool.remove(this), i.instances[this.glContextId] = null, i.WebGLRenderer.glContextId--
    }, i.WebGLRenderer.prototype.mapBlendModes = function() {
        var t = this.gl;
        if (!i.blendModesWebGL) {
            var e = [],
                s = i.blendModes;
            e[s.NORMAL] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.ADD] = [t.SRC_ALPHA, t.DST_ALPHA], e[s.MULTIPLY] = [t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA], e[s.SCREEN] = [t.SRC_ALPHA, t.ONE], e[s.OVERLAY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.DARKEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.LIGHTEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.COLOR_DODGE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.COLOR_BURN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.HARD_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.SOFT_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.DIFFERENCE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.EXCLUSION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.HUE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.SATURATION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.COLOR] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[s.LUMINOSITY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i.blendModesWebGL = e
        }
    }, i.WebGLRenderer.prototype.getMaxTextureUnit = function() {
        var t = this.gl;
        return t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)
    }, i.enableMultiTexture = function() {
        i._enableMultiTextureToggle = !0
    }, i.WebGLRenderer.glContextId = 0, i.WebGLRenderer.textureArray = [], i.WebGLBlendModeManager = function() {
        this.currentBlendMode = 99999
    }, i.WebGLBlendModeManager.prototype.constructor = i.WebGLBlendModeManager, i.WebGLBlendModeManager.prototype.setContext = function(t) {
        this.gl = t
    }, i.WebGLBlendModeManager.prototype.setBlendMode = function(t) {
        if (this.currentBlendMode === t) return !1;
        this.currentBlendMode = t;
        var e = i.blendModesWebGL[this.currentBlendMode];
        return e && this.gl.blendFunc(e[0], e[1]), !0
    }, i.WebGLBlendModeManager.prototype.destroy = function() {
        this.gl = null
    }, i.WebGLMaskManager = function() {}, i.WebGLMaskManager.prototype.constructor = i.WebGLMaskManager, i.WebGLMaskManager.prototype.setContext = function(t) {
        this.gl = t
    }, i.WebGLMaskManager.prototype.pushMask = function(t, e) {
        var s = e.gl;
        t.dirty && i.WebGLGraphics.updateGraphics(t, s), void 0 !== t._webGL[s.id] && void 0 !== t._webGL[s.id].data && 0 !== t._webGL[s.id].data.length && e.stencilManager.pushStencil(t, t._webGL[s.id].data[0], e)
    }, i.WebGLMaskManager.prototype.popMask = function(t, e) {
        var i = this.gl;
        void 0 !== t._webGL[i.id] && void 0 !== t._webGL[i.id].data && 0 !== t._webGL[i.id].data.length && e.stencilManager.popStencil(t, t._webGL[i.id].data[0], e)
    }, i.WebGLMaskManager.prototype.destroy = function() {
        this.gl = null
    }, i.WebGLStencilManager = function() {
        this.stencilStack = [], this.reverse = !0, this.count = 0
    }, i.WebGLStencilManager.prototype.setContext = function(t) {
        this.gl = t
    }, i.WebGLStencilManager.prototype.pushStencil = function(t, e, i) {
        var s = this.gl;
        this.bindGraphics(t, e, i), 0 === this.stencilStack.length && (s.enable(s.STENCIL_TEST), s.clear(s.STENCIL_BUFFER_BIT), this.reverse = !0, this.count = 0), this.stencilStack.push(e);
        var n = this.count;
        s.colorMask(!1, !1, !1, !1), s.stencilFunc(s.ALWAYS, 0, 255), s.stencilOp(s.KEEP, s.KEEP, s.INVERT), 1 === e.mode ? (s.drawElements(s.TRIANGLE_FAN, e.indices.length - 4, s.UNSIGNED_SHORT, 0), this.reverse ? (s.stencilFunc(s.EQUAL, 255 - n, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)) : (s.stencilFunc(s.EQUAL, n, 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)), s.drawElements(s.TRIANGLE_FAN, 4, s.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), this.reverse ? s.stencilFunc(s.EQUAL, 255 - (n + 1), 255) : s.stencilFunc(s.EQUAL, n + 1, 255), this.reverse = !this.reverse) : (this.reverse ? (s.stencilFunc(s.EQUAL, n, 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)) : (s.stencilFunc(s.EQUAL, 255 - n, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)), s.drawElements(s.TRIANGLE_STRIP, e.indices.length, s.UNSIGNED_SHORT, 0), this.reverse ? s.stencilFunc(s.EQUAL, n + 1, 255) : s.stencilFunc(s.EQUAL, 255 - (n + 1), 255)), s.colorMask(!0, !0, !0, !0), s.stencilOp(s.KEEP, s.KEEP, s.KEEP), this.count++
    }, i.WebGLStencilManager.prototype.bindGraphics = function(t, e, i) {
        this._currentGraphics = t;
        var s, n = this.gl,
            r = i.projection,
            o = i.offset;
        1 === e.mode ? (s = i.shaderManager.complexPrimitiveShader, i.shaderManager.setShader(s), n.uniform1f(s.flipY, i.flipY), n.uniformMatrix3fv(s.translationMatrix, !1, t.worldTransform.toArray(!0)), n.uniform2f(s.projectionVector, r.x, -r.y), n.uniform2f(s.offsetVector, -o.x, -o.y), n.uniform3fv(s.tintColor, Phaser.Color.hexToRGBArray(t.tint)), n.uniform3fv(s.color, e.color), n.uniform1f(s.alpha, t.worldAlpha * e.alpha), n.bindBuffer(n.ARRAY_BUFFER, e.buffer), n.vertexAttribPointer(s.aVertexPosition, 2, n.FLOAT, !1, 8, 0), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.indexBuffer)) : (s = i.shaderManager.primitiveShader, i.shaderManager.setShader(s), n.uniformMatrix3fv(s.translationMatrix, !1, t.worldTransform.toArray(!0)), n.uniform1f(s.flipY, i.flipY), n.uniform2f(s.projectionVector, r.x, -r.y), n.uniform2f(s.offsetVector, -o.x, -o.y), n.uniform3fv(s.tintColor, Phaser.Color.hexToRGBArray(t.tint)), n.uniform1f(s.alpha, t.worldAlpha), n.bindBuffer(n.ARRAY_BUFFER, e.buffer), n.vertexAttribPointer(s.aVertexPosition, 2, n.FLOAT, !1, 24, 0), n.vertexAttribPointer(s.colorAttribute, 4, n.FLOAT, !1, 24, 8), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.indexBuffer))
    }, i.WebGLStencilManager.prototype.popStencil = function(t, e, i) {
        var s = this.gl;
        if (this.stencilStack.pop(), this.count--, 0 === this.stencilStack.length) s.disable(s.STENCIL_TEST);
        else {
            var n = this.count;
            this.bindGraphics(t, e, i), s.colorMask(!1, !1, !1, !1), 1 === e.mode ? (this.reverse = !this.reverse, this.reverse ? (s.stencilFunc(s.EQUAL, 255 - (n + 1), 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)) : (s.stencilFunc(s.EQUAL, n + 1, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)), s.drawElements(s.TRIANGLE_FAN, 4, s.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), s.stencilFunc(s.ALWAYS, 0, 255), s.stencilOp(s.KEEP, s.KEEP, s.INVERT), s.drawElements(s.TRIANGLE_FAN, e.indices.length - 4, s.UNSIGNED_SHORT, 0), this.reverse ? s.stencilFunc(s.EQUAL, n, 255) : s.stencilFunc(s.EQUAL, 255 - n, 255)) : (this.reverse ? (s.stencilFunc(s.EQUAL, n + 1, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)) : (s.stencilFunc(s.EQUAL, 255 - (n + 1), 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)), s.drawElements(s.TRIANGLE_STRIP, e.indices.length, s.UNSIGNED_SHORT, 0), this.reverse ? s.stencilFunc(s.EQUAL, n, 255) : s.stencilFunc(s.EQUAL, 255 - n, 255)), s.colorMask(!0, !0, !0, !0), s.stencilOp(s.KEEP, s.KEEP, s.KEEP)
        }
    }, i.WebGLStencilManager.prototype.destroy = function() {
        this.stencilStack = null, this.gl = null
    }, i.WebGLShaderManager = function() {
        this.maxAttibs = 10, this.attribState = [], this.tempAttribState = [];
        for (var t = 0; t < this.maxAttibs; t++) this.attribState[t] = !1;
        this.stack = []
    }, i.WebGLShaderManager.prototype.constructor = i.WebGLShaderManager, i.WebGLShaderManager.prototype.setContext = function(t) {
        this.gl = t, this.primitiveShader = new i.PrimitiveShader(t), this.complexPrimitiveShader = new i.ComplexPrimitiveShader(t), this.defaultShader = new i.PixiShader(t), this.fastShader = new i.PixiFastShader(t), this.stripShader = new i.StripShader(t), this.creatureShader = i.CreatureShader ? new i.CreatureShader(t) : null, this.setShader(this.defaultShader)
    }, i.WebGLShaderManager.prototype.setAttribs = function(t) {
        var e;
        for (e = 0; e < this.tempAttribState.length; e++) this.tempAttribState[e] = !1;
        for (e = 0; e < t.length; e++) {
            var i = t[e];
            this.tempAttribState[i] = !0
        }
        var s = this.gl;
        for (e = 0; e < this.attribState.length; e++) this.attribState[e] !== this.tempAttribState[e] && (this.attribState[e] = this.tempAttribState[e], this.tempAttribState[e] ? s.enableVertexAttribArray(e) : s.disableVertexAttribArray(e))
    }, i.WebGLShaderManager.prototype.setShader = function(t) {
        return this._currentId !== t._UID && (this._currentId = t._UID, this.currentShader = t, this.gl.useProgram(t.program), this.setAttribs(t.attributes), !0)
    }, i.WebGLShaderManager.prototype.destroy = function() {
        this.attribState = null, this.tempAttribState = null, this.primitiveShader.destroy(), this.complexPrimitiveShader.destroy(), this.defaultShader.destroy(), this.fastShader.destroy(), this.stripShader.destroy(), this.creatureShader && this.creatureShader.destroy(), this.gl = null
    }, i.WebGLSpriteBatch = function(t) {
        this.game = t, this.vertSize = 5, this.size = 2e3, this.vertexSize = 24;
        var e = this.vertexSize * this.size * 4,
            i = 6 * this.size;
        this.vertices = new ArrayBuffer(e), this.positions = new Float32Array(this.vertices), this.colors = new Uint32Array(this.vertices), this.indices = new Uint16Array(i), this.lastIndexCount = 0;
        for (var s = 0, n = 0; s < i; s += 6, n += 4) this.indices[s + 0] = n + 0, this.indices[s + 1] = n + 1, this.indices[s + 2] = n + 2, this.indices[s + 3] = n + 0, this.indices[s + 4] = n + 2, this.indices[s + 5] = n + 3;
        this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.dirty = !0, this.textures = [], this.blendModes = [], this.shaders = [], this.sprites = [], this.defaultShader = null
    }, i.WebGLSpriteBatch.prototype.setContext = function(t) {
        if (this.MAX_TEXTURES = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), this.gl = t, i._enableMultiTextureToggle) {
            for (var e = "\tif (vTextureIndex == 0.0) {gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;return;}\n", s = 1; s < this.MAX_TEXTURES; ++s) e += "\tif (vTextureIndex == " + s + ".0) {gl_FragColor = texture2D(uSamplerArray[" + s + "], vTextureCoord) * vColor;return;}\n";
            this.defaultShader = new Phaser.Filter(this.game, void 0, ["//WebGLSpriteBatch Fragment Shader.", "precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "uniform sampler2D uSamplerArray[" + this.MAX_TEXTURES + "];", "void main(void) {", e, "\tgl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;", "}"])
        } else this.defaultShader = new Phaser.Filter(this.game, void 0, ["//WebGLSpriteBatch Fragment Shader.", "precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;", "}"]);
        this.vertexBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW), this.currentBlendMode = 99999;
        var n = new i.PixiShader(t);
        n.fragmentSrc = this.defaultShader.fragmentSrc, n.uniforms = {}, n.init(), this.defaultShader.shaders[t.id] = n
    }, i.WebGLSpriteBatch.prototype.begin = function(t) {
        this.renderSession = t, this.shader = this.renderSession.shaderManager.defaultShader, this.start()
    }, i.WebGLSpriteBatch.prototype.end = function() {
        this.flush()
    }, i.WebGLSpriteBatch.prototype.render = function(t, e) {
        var s = t.texture,
            n = s.baseTexture,
            r = this.gl;
        i.WebGLRenderer.textureArray[n.textureIndex] != n && (this.flush(), r.activeTexture(r.TEXTURE0 + n.textureIndex), r.bindTexture(r.TEXTURE_2D, n._glTextures[r.id]), i.WebGLRenderer.textureArray[n.textureIndex] = n);
        var o = t.worldTransform;
        e && (o = e), this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = s.baseTexture);
        var a = s._uvs;
        if (a) {
            var h, l, c, u, d = t.anchor.x,
                p = t.anchor.y;
            if (s.trim) {
                var f = s.trim;
                h = (l = f.x - d * f.width) + s.crop.width, c = (u = f.y - p * f.height) + s.crop.height
            } else h = s.frame.width * (1 - d), l = s.frame.width * -d, c = s.frame.height * (1 - p), u = s.frame.height * -p;
            var g = this.currentBatchSize * this.vertexSize,
                m = s.baseTexture.resolution,
                y = s.baseTexture.textureIndex,
                v = o.a / m,
                x = o.b / m,
                b = o.c / m,
                _ = o.d / m,
                w = o.tx,
                T = o.ty,
                P = s.crop.height;
            if (s.rotated) {
                var C = o.a,
                    S = o.b,
                    A = o.c,
                    E = o.d,
                    M = l,
                    R = h;
                w = o.c * P + w, T = o.d * P + T, v = 6.123233995736766e-17 * C - A, x = 6.123233995736766e-17 * S - E, b = C + 6.123233995736766e-17 * A, _ = S + 6.123233995736766e-17 * E, s._updateUvsInverted(), h = c, l = u, c = R, u = M
            }
            var L = this.colors,
                B = this.positions,
                I = t.tint,
                O = (I >> 16) + (65280 & I) + ((255 & I) << 16) + (255 * t.worldAlpha << 24);
            this.renderSession.roundPixels ? (B[g++] = v * l + b * u + w | 0, B[g++] = _ * u + x * l + T | 0, B[g++] = a.x0, B[g++] = a.y0, L[g++] = O, B[g++] = y, B[g++] = v * h + b * u + w | 0, B[g++] = _ * u + x * h + T | 0, B[g++] = a.x1, B[g++] = a.y1, L[g++] = O, B[g++] = y, B[g++] = v * h + b * c + w | 0, B[g++] = _ * c + x * h + T | 0, B[g++] = a.x2, B[g++] = a.y2, L[g++] = O, B[g++] = y, B[g++] = v * l + b * c + w | 0, B[g++] = _ * c + x * l + T | 0, B[g++] = a.x3, B[g++] = a.y3, L[g++] = O, B[g++] = y) : (B[g++] = v * l + b * u + w, B[g++] = _ * u + x * l + T, B[g++] = a.x0, B[g++] = a.y0, L[g++] = O, B[g++] = y, B[g++] = v * h + b * u + w, B[g++] = _ * u + x * h + T, B[g++] = a.x1, B[g++] = a.y1, L[g++] = O, B[g++] = y, B[g++] = v * h + b * c + w, B[g++] = _ * c + x * h + T, B[g++] = a.x2, B[g++] = a.y2, L[g++] = O, B[g++] = y, B[g++] = v * l + b * c + w, B[g++] = _ * c + x * l + T, B[g++] = a.x3, B[g++] = a.y3, L[g++] = O, B[g++] = y), this.sprites[this.currentBatchSize++] = t
        }
    }, i.WebGLSpriteBatch.prototype.renderTilingSprite = function(t) {
        var e = t.tilingTexture,
            s = e.baseTexture,
            n = this.gl,
            r = t.texture.baseTexture.textureIndex;
        i.WebGLRenderer.textureArray[r] != s && (this.flush(), n.activeTexture(n.TEXTURE0 + r), n.bindTexture(n.TEXTURE_2D, s._glTextures[n.id]), i.WebGLRenderer.textureArray[r] = s), this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = e.baseTexture), t._uvs || (t._uvs = new i.TextureUvs);
        var o = t._uvs,
            a = e.baseTexture.width,
            h = e.baseTexture.height;
        t.tilePosition.x %= a * t.tileScaleOffset.x, t.tilePosition.y %= h * t.tileScaleOffset.y;
        var l = t.tilePosition.x / (a * t.tileScaleOffset.x),
            c = t.tilePosition.y / (h * t.tileScaleOffset.y),
            u = t.width / a / (t.tileScale.x * t.tileScaleOffset.x),
            d = t.height / h / (t.tileScale.y * t.tileScaleOffset.y);
        o.x0 = 0 - l, o.y0 = 0 - c, o.x1 = 1 * u - l, o.y1 = 0 - c, o.x2 = 1 * u - l, o.y2 = 1 * d - c, o.x3 = 0 - l, o.y3 = 1 * d - c;
        var p = t.tint,
            f = (p >> 16) + (65280 & p) + ((255 & p) << 16) + (255 * t.worldAlpha << 24),
            g = this.positions,
            m = this.colors,
            y = t.width,
            v = t.height,
            x = t.anchor.x,
            b = t.anchor.y,
            _ = y * (1 - x),
            w = y * -x,
            T = v * (1 - b),
            P = v * -b,
            C = this.currentBatchSize * this.vertexSize,
            S = e.baseTexture.resolution,
            A = t.worldTransform,
            E = A.a / S,
            M = A.b / S,
            R = A.c / S,
            L = A.d / S,
            B = A.tx,
            I = A.ty;
        g[C++] = E * w + R * P + B, g[C++] = L * P + M * w + I, g[C++] = o.x0, g[C++] = o.y0, m[C++] = f, g[C++] = r, g[C++] = E * _ + R * P + B, g[C++] = L * P + M * _ + I, g[C++] = o.x1, g[C++] = o.y1, m[C++] = f, g[C++] = r, g[C++] = E * _ + R * T + B, g[C++] = L * T + M * _ + I, g[C++] = o.x2, g[C++] = o.y2, m[C++] = f, g[C++] = r, g[C++] = E * w + R * T + B, g[C++] = L * T + M * w + I, g[C++] = o.x3, g[C++] = o.y3, m[C++] = f, g[C++] = r, this.sprites[this.currentBatchSize++] = t
    }, i.WebGLSpriteBatch.prototype.flush = function() {
        if (0 !== this.currentBatchSize) {
            var t, e = this.gl;
            if (this.dirty) {
                this.dirty = !1, t = this.defaultShader.shaders[e.id], e.activeTexture(e.TEXTURE0), e.bindBuffer(e.ARRAY_BUFFER, this.vertexBuffer), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                var s = this.vertexSize;
                e.vertexAttribPointer(t.aVertexPosition, 2, e.FLOAT, !1, s, 0), e.vertexAttribPointer(t.aTextureCoord, 2, e.FLOAT, !1, s, 8), e.vertexAttribPointer(t.colorAttribute, 4, e.UNSIGNED_BYTE, !0, s, 16), e.vertexAttribPointer(t.aTextureIndex, 1, e.FLOAT, !1, s, 20)
            }
            if (this.currentBatchSize > .5 * this.size) e.bufferSubData(e.ARRAY_BUFFER, 0, this.vertices);
            else {
                e.bindBuffer(e.ARRAY_BUFFER, this.vertexBuffer);
                var n = this.positions.subarray(0, this.currentBatchSize * this.vertexSize);
                e.bufferSubData(e.ARRAY_BUFFER, 0, n)
            }
            for (var r, o, a, h, l = 0, c = 0, u = null, d = this.renderSession.blendModeManager.currentBlendMode, p = null, f = !1, g = !1, m = 0, y = this.currentBatchSize; m < y; m++) {
                r = (h = this.sprites[m]).tilingTexture ? h.tilingTexture.baseTexture : h.texture.baseTexture, f = d !== (o = h.blendMode), g = p !== (a = h.shader || this.defaultShader);
                var v = r.skipRender;
                if (v && h.children.length > 0 && (v = !1), (f || g) && (this.renderBatch(u, l, c), c = m, l = 0, u = r, f && (d = o, this.renderSession.blendModeManager.setBlendMode(d)), g)) {
                    (t = (p = a).shaders[e.id]) || ((t = new i.PixiShader(e)).fragmentSrc = p.fragmentSrc, t.uniforms = p.uniforms, t.init(), p.shaders[e.id] = t), this.renderSession.shaderManager.setShader(t), t.dirty && t.syncUniforms();
                    var x = this.renderSession.projection;
                    e.uniform2f(t.projectionVector, x.x, x.y);
                    var b = this.renderSession.offset;
                    e.uniform2f(t.offsetVector, b.x, b.y)
                }
                l++
            }
            this.renderBatch(u, l, c), this.currentBatchSize = 0
        }
    }, i.WebGLSpriteBatch.prototype.renderBatch = function(t, e, i) {
        if (0 !== e) {
            var s = this.gl;
            if (t._dirty[s.id]) {
                if (!this.renderSession.renderer.updateTexture(t)) return
            } else s.bindTexture(s.TEXTURE_2D, t._glTextures[s.id]);
            s.drawElements(s.TRIANGLES, 6 * e, s.UNSIGNED_SHORT, 6 * i * 2), this.renderSession.drawCount++
        }
    }, i.WebGLSpriteBatch.prototype.stop = function() {
        this.flush(), this.dirty = !0
    }, i.WebGLSpriteBatch.prototype.start = function() {
        this.dirty = !0
    }, i.WebGLSpriteBatch.prototype.destroy = function() {
        this.vertices = null, this.indices = null, this.gl.deleteBuffer(this.vertexBuffer), this.gl.deleteBuffer(this.indexBuffer), this.currentBaseTexture = null, this.gl = null
    }, i.WebGLFastSpriteBatch = function(t) {
        this.vertSize = 11, this.maxSize = 6e3, this.size = this.maxSize;
        var e = 4 * this.size * this.vertSize,
            i = 6 * this.maxSize;
        this.vertices = new Float32Array(e), this.indices = new Uint16Array(i), this.vertexBuffer = null, this.indexBuffer = null, this.lastIndexCount = 0;
        for (var s = 0, n = 0; s < i; s += 6, n += 4) this.indices[s + 0] = n + 0, this.indices[s + 1] = n + 1, this.indices[s + 2] = n + 2, this.indices[s + 3] = n + 0, this.indices[s + 4] = n + 2, this.indices[s + 5] = n + 3;
        this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.currentBlendMode = 0, this.renderSession = null, this.shader = null, this.matrix = null, this.setContext(t)
    }, i.WebGLFastSpriteBatch.prototype.constructor = i.WebGLFastSpriteBatch, i.WebGLFastSpriteBatch.prototype.setContext = function(t) {
        this.gl = t, this.vertexBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW)
    }, i.WebGLFastSpriteBatch.prototype.begin = function(t, e) {
        this.renderSession = e, this.shader = this.renderSession.shaderManager.fastShader, this.matrix = t.worldTransform.toArray(!0), this.start()
    }, i.WebGLFastSpriteBatch.prototype.end = function() {
        this.flush()
    }, i.WebGLFastSpriteBatch.prototype.render = function(t) {
        var e = t.children,
            i = e[0];
        if (i.texture._uvs) {
            this.currentBaseTexture = i.texture.baseTexture, i.blendMode !== this.renderSession.blendModeManager.currentBlendMode && (this.flush(), this.renderSession.blendModeManager.setBlendMode(i.blendMode));
            for (var s = 0, n = e.length; s < n; s++) this.renderSprite(e[s]);
            this.flush()
        }
    }, i.WebGLFastSpriteBatch.prototype.renderSprite = function(t) {
        var e = t.texture.baseTexture,
            s = this.gl,
            n = t.texture.baseTexture.textureIndex;
        if ((i.WebGLRenderer.textureArray[n] == e || !e._glTextures[s.id] || t.texture.baseTexture.skipRender || (this.flush(), s.activeTexture(s.TEXTURE0 + n), s.bindTexture(s.TEXTURE_2D, e._glTextures[s.id]), i.WebGLRenderer.textureArray[n] = e, t.texture._uvs)) && t.visible) {
            var r, o, a, h, l, c, u, d, p = this.vertices;
            if (r = t.texture._uvs, o = t.texture.frame.width, a = t.texture.frame.height, t.texture.trim) {
                var f = t.texture.trim;
                h = (l = f.x - t.anchor.x * f.width) + t.texture.crop.width, c = (u = f.y - t.anchor.y * f.height) + t.texture.crop.height
            } else h = o * (1 - t.anchor.x), l = o * -t.anchor.x, c = a * (1 - t.anchor.y), u = a * -t.anchor.y;
            d = 4 * this.currentBatchSize * this.vertSize, p[d++] = l, p[d++] = u, p[d++] = t.position.x, p[d++] = t.position.y, p[d++] = t.scale.x, p[d++] = t.scale.y, p[d++] = t.rotation, p[d++] = r.x0, p[d++] = r.y1, p[d++] = t.alpha, p[d++] = n, p[d++] = h, p[d++] = u, p[d++] = t.position.x, p[d++] = t.position.y, p[d++] = t.scale.x, p[d++] = t.scale.y, p[d++] = t.rotation, p[d++] = r.x1, p[d++] = r.y1, p[d++] = t.alpha, p[d++] = n, p[d++] = h, p[d++] = c, p[d++] = t.position.x, p[d++] = t.position.y, p[d++] = t.scale.x, p[d++] = t.scale.y, p[d++] = t.rotation, p[d++] = r.x2, p[d++] = r.y2, p[d++] = t.alpha, p[d++] = n, p[d++] = l, p[d++] = c, p[d++] = t.position.x, p[d++] = t.position.y, p[d++] = t.scale.x, p[d++] = t.scale.y, p[d++] = t.rotation, p[d++] = r.x3, p[d++] = r.y3, p[d++] = t.alpha, p[d++] = n, ++this.currentBatchSize >= this.size && this.flush()
        }
    }, i.WebGLFastSpriteBatch.prototype.flush = function() {
        if (0 !== this.currentBatchSize) {
            var t = this.gl;
            if (this.currentBaseTexture._glTextures[t.id]) {
                if (this.currentBatchSize > .5 * this.size) t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertices);
                else {
                    var e = this.vertices.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                    t.bufferSubData(t.ARRAY_BUFFER, 0, e)
                }
                t.drawElements(t.TRIANGLES, 6 * this.currentBatchSize, t.UNSIGNED_SHORT, 0), this.currentBatchSize = 0, this.renderSession.drawCount++
            } else this.renderSession.renderer.updateTexture(this.currentBaseTexture, t)
        }
    }, i.WebGLFastSpriteBatch.prototype.stop = function() {
        this.flush()
    }, i.WebGLFastSpriteBatch.prototype.start = function() {
        var t = this.gl;
        t.activeTexture(t.TEXTURE0), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        var e = this.renderSession.projection;
        t.uniform2f(this.shader.projectionVector, e.x, e.y), t.uniformMatrix3fv(this.shader.uMatrix, !1, this.matrix);
        var i = 4 * this.vertSize;
        t.vertexAttribPointer(this.shader.aVertexPosition, 2, t.FLOAT, !1, i, 0), t.vertexAttribPointer(this.shader.aPositionCoord, 2, t.FLOAT, !1, i, 8), t.vertexAttribPointer(this.shader.aScale, 2, t.FLOAT, !1, i, 16), t.vertexAttribPointer(this.shader.aRotation, 1, t.FLOAT, !1, i, 24), t.vertexAttribPointer(this.shader.aTextureCoord, 2, t.FLOAT, !1, i, 28), t.vertexAttribPointer(this.shader.colorAttribute, 1, t.FLOAT, !1, i, 36), t.vertexAttribPointer(this.shader.aTextureIndex, 1, t.FLOAT, !1, i, 40)
    }, i.WebGLFilterManager = function() {
        this.filterStack = [], this.offsetX = 0, this.offsetY = 0
    }, i.WebGLFilterManager.prototype.constructor = i.WebGLFilterManager, i.WebGLFilterManager.prototype.setContext = function(t) {
        this.gl = t, this.texturePool = [], this.initShaderBuffers()
    }, i.WebGLFilterManager.prototype.begin = function(t, e) {
        this.renderSession = t, this.defaultShader = t.shaderManager.defaultShader;
        var i = this.renderSession.projection;
        this.width = 2 * i.x, this.height = 2 * -i.y, this.buffer = e
    }, i.WebGLFilterManager.prototype.pushFilter = function(t) {
        var e = this.gl,
            s = this.renderSession.projection,
            n = this.renderSession.offset;
        t._filterArea = t.target.filterArea || t.target.getBounds(), t._previous_stencil_mgr = this.renderSession.stencilManager, this.renderSession.stencilManager = new i.WebGLStencilManager, this.renderSession.stencilManager.setContext(e), e.disable(e.STENCIL_TEST), this.filterStack.push(t);
        var r = t.filterPasses[0];
        this.offsetX += t._filterArea.x, this.offsetY += t._filterArea.y;
        var o = this.texturePool.pop();
        o ? o.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution) : o = new i.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution), e.bindTexture(e.TEXTURE_2D, o.texture);
        var a = t._filterArea,
            h = r.padding;
        a.x -= h, a.y -= h, a.width += 2 * h, a.height += 2 * h, a.x < 0 && (a.x = 0), a.width > this.width && (a.width = this.width), a.y < 0 && (a.y = 0), a.height > this.height && (a.height = this.height), e.bindFramebuffer(e.FRAMEBUFFER, o.frameBuffer), e.viewport(0, 0, a.width * this.renderSession.resolution, a.height * this.renderSession.resolution), s.x = a.width / 2, s.y = -a.height / 2, n.x = -a.x, n.y = -a.y, e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.clear(e.COLOR_BUFFER_BIT), t._glFilterTexture = o
    }, i.WebGLFilterManager.prototype.popFilter = function() {
        var t = this.gl,
            e = this.filterStack.pop(),
            s = e._filterArea,
            n = e._glFilterTexture,
            r = this.renderSession.projection,
            o = this.renderSession.offset;
        if (e.filterPasses.length > 1) {
            t.viewport(0, 0, s.width * this.renderSession.resolution, s.height * this.renderSession.resolution), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = 0, this.vertexArray[1] = s.height, this.vertexArray[2] = s.width, this.vertexArray[3] = s.height, this.vertexArray[4] = 0, this.vertexArray[5] = 0, this.vertexArray[6] = s.width, this.vertexArray[7] = 0, t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = s.width / this.width, this.uvArray[5] = s.height / this.height, this.uvArray[6] = s.width / this.width, this.uvArray[7] = s.height / this.height, t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray);
            var a = n,
                h = this.texturePool.pop();
            h || (h = new i.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution)), h.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution), t.bindFramebuffer(t.FRAMEBUFFER, h.frameBuffer), t.clear(t.COLOR_BUFFER_BIT), t.disable(t.BLEND);
            for (var l = 0; l < e.filterPasses.length - 1; l++) {
                var c = e.filterPasses[l];
                t.bindFramebuffer(t.FRAMEBUFFER, h.frameBuffer), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, a.texture), this.applyFilterPass(c, s, s.width, s.height);
                var u = a;
                a = h, h = u
            }
            t.enable(t.BLEND), n = a, this.texturePool.push(h)
        }
        var d = e.filterPasses[e.filterPasses.length - 1];
        this.offsetX -= s.x, this.offsetY -= s.y;
        var p = this.width,
            f = this.height,
            g = 0,
            m = 0,
            y = this.buffer;
        if (0 === this.filterStack.length) t.colorMask(!0, !0, !0, !0);
        else {
            var v = this.filterStack[this.filterStack.length - 1];
            p = (s = v._filterArea).width, f = s.height, g = s.x, m = s.y, y = v._glFilterTexture.frameBuffer
        }
        r.x = p / 2, r.y = -f / 2, o.x = g, o.y = m;
        var x = (s = e._filterArea).x - g,
            b = s.y - m;
        t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = x, this.vertexArray[1] = b + s.height, this.vertexArray[2] = x + s.width, this.vertexArray[3] = b + s.height, this.vertexArray[4] = x, this.vertexArray[5] = b, this.vertexArray[6] = x + s.width, this.vertexArray[7] = b, t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = s.width / this.width, this.uvArray[5] = s.height / this.height, this.uvArray[6] = s.width / this.width, this.uvArray[7] = s.height / this.height, t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray), t.viewport(0, 0, p * this.renderSession.resolution, f * this.renderSession.resolution), t.bindFramebuffer(t.FRAMEBUFFER, y), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, n.texture), this.renderSession.stencilManager && this.renderSession.stencilManager.destroy(), this.renderSession.stencilManager = e._previous_stencil_mgr, e._previous_stencil_mgr = null, this.renderSession.stencilManager.count > 0 ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST), this.applyFilterPass(d, s, p, f), this.texturePool.push(n), e._glFilterTexture = null
    }, i.WebGLFilterManager.prototype.applyFilterPass = function(t, e, s, n) {
        var r = this.gl,
            o = t.shaders[r.id];
        o || ((o = new i.PixiShader(r)).fragmentSrc = t.fragmentSrc, o.uniforms = t.uniforms, o.init(!0), t.shaders[r.id] = o), this.renderSession.shaderManager.setShader(o), r.uniform2f(o.projectionVector, s / 2, -n / 2), r.uniform2f(o.offsetVector, 0, 0), t.uniforms.dimensions && (t.uniforms.dimensions.value[0] = this.width, t.uniforms.dimensions.value[1] = this.height, t.uniforms.dimensions.value[2] = this.vertexArray[0], t.uniforms.dimensions.value[3] = this.vertexArray[5]), o.syncUniforms(), r.bindBuffer(r.ARRAY_BUFFER, this.vertexBuffer), r.vertexAttribPointer(o.aVertexPosition, 2, r.FLOAT, !1, 0, 0), r.bindBuffer(r.ARRAY_BUFFER, this.uvBuffer), r.vertexAttribPointer(o.aTextureCoord, 2, r.FLOAT, !1, 0, 0), r.bindBuffer(r.ARRAY_BUFFER, this.colorBuffer), r.vertexAttribPointer(o.colorAttribute, 2, r.FLOAT, !1, 0, 0), r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, this.indexBuffer), r.drawElements(r.TRIANGLES, 6, r.UNSIGNED_SHORT, 0), this.renderSession.drawCount++
    }, i.WebGLFilterManager.prototype.initShaderBuffers = function() {
        var t = this.gl;
        this.vertexBuffer = t.createBuffer(), this.uvBuffer = t.createBuffer(), this.colorBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), this.vertexArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertexArray, t.STATIC_DRAW), this.uvArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), t.bufferData(t.ARRAY_BUFFER, this.uvArray, t.STATIC_DRAW), this.colorArray = new Float32Array([1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215]), t.bindBuffer(t.ARRAY_BUFFER, this.colorBuffer), t.bufferData(t.ARRAY_BUFFER, this.colorArray, t.STATIC_DRAW), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 1, 3, 2]), t.STATIC_DRAW)
    }, i.WebGLFilterManager.prototype.destroy = function() {
        var t = this.gl;
        this.filterStack = null, this.offsetX = 0, this.offsetY = 0;
        for (var e = 0; e < this.texturePool.length; e++) this.texturePool[e].destroy();
        this.texturePool = null, t.deleteBuffer(this.vertexBuffer), t.deleteBuffer(this.uvBuffer), t.deleteBuffer(this.colorBuffer), t.deleteBuffer(this.indexBuffer)
    };
    var s = {
        36054: "Incomplete attachment",
        36055: "Missing attachment",
        36057: "Incomplete dimensions",
        36061: "Framebuffer unsupported"
    };
    return i.FilterTexture = function(t, s, n, r, o) {
        o = "number" == typeof o ? o : 0, this.gl = t, this.frameBuffer = e(t, s, n, r || i.scaleModes.DEFAULT, o), this.texture = this.frameBuffer.targetTexture, this.width = s, this.height = n, this.renderBuffer = this.frameBuffer.renderBuffer
    }, i.FilterTexture.prototype.constructor = i.FilterTexture, i.FilterTexture.prototype.clear = function() {
        var t = this.gl;
        t.clearColor(0, 0, 0, 0), t.clear(t.COLOR_BUFFER_BIT)
    }, i.FilterTexture.prototype.resize = function(t, e) {
        if (this.width !== t || this.height !== e) {
            this.width = t, this.height = e;
            var i = this.gl;
            i.bindTexture(i.TEXTURE_2D, this.texture), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, t, e, 0, i.RGBA, i.UNSIGNED_BYTE, null), i.bindRenderbuffer(i.RENDERBUFFER, this.renderBuffer), i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, t, e)
        }
    }, i.FilterTexture.prototype.destroy = function() {
        var t = this.gl;
        t.deleteFramebuffer(this.frameBuffer), t.deleteTexture(this.texture), this.frameBuffer = null, this.texture = null
    }, i.CanvasBuffer = function(t, e) {
        this.width = t, this.height = e, this.canvas = Phaser.CanvasPool.create(this, this.width, this.height), this.context = this.canvas.getContext("2d"), this.canvas.width = t, this.canvas.height = e
    }, i.CanvasBuffer.prototype.constructor = i.CanvasBuffer, i.CanvasBuffer.prototype.clear = function() {
        this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.width, this.height)
    }, i.CanvasBuffer.prototype.resize = function(t, e) {
        this.width = this.canvas.width = t, this.height = this.canvas.height = e
    }, i.CanvasBuffer.prototype.destroy = function() {
        Phaser.CanvasPool.remove(this)
    }, i.CanvasMaskManager = function() {}, i.CanvasMaskManager.prototype.constructor = i.CanvasMaskManager, i.CanvasMaskManager.prototype.pushMask = function(t, e) {
        var s = e.context;
        s.save();
        var n = t.alpha,
            r = t.worldTransform,
            o = e.resolution;
        s.setTransform(r.a * o, r.b * o, r.c * o, r.d * o, r.tx * o, r.ty * o), i.CanvasGraphics.renderGraphicsMask(t, s), s.clip(), t.worldAlpha = n
    }, i.CanvasMaskManager.prototype.popMask = function(t) {
        t.context.restore()
    }, i.CanvasTinter = function() {}, i.CanvasTinter.getTintedTexture = function(t, e) {
        var s = t.tintedTexture || Phaser.CanvasPool.create(this);
        return i.CanvasTinter.tintMethod(t.texture, e, s), s
    }, i.CanvasTinter.tintWithMultiply = function(t, e, i) {
        var s = i.getContext("2d"),
            n = t.crop,
            r = n.width,
            o = n.height;
        t.rotated && (r = o, o = n.width), i.width === r && i.height === o || (i.width = r, i.height = o), s.clearRect(0, 0, r, o), s.fillStyle = "#" + ("00000" + (0 | e).toString(16)).substr(-6), s.fillRect(0, 0, r, o), s.globalCompositeOperation = "multiply", s.drawImage(t.baseTexture.source, n.x, n.y, r, o, 0, 0, r, o), s.globalCompositeOperation = "destination-atop", s.drawImage(t.baseTexture.source, n.x, n.y, r, o, 0, 0, r, o)
    }, i.CanvasTinter.tintWithPerPixel = function(t, e, s) {
        var n = s.getContext("2d"),
            r = t.crop,
            o = r.width,
            a = r.height;
        t.rotated && (o = a, a = r.width), s.width === o && s.height === a || (s.width = o, s.height = a), n.globalCompositeOperation = "copy", n.drawImage(t.baseTexture.source, r.x, r.y, o, a, 0, 0, o, a);
        for (var h = Phaser.Color.hexToRGBArray(e), l = h[0], c = h[1], u = h[2], d = n.getImageData(0, 0, o, a), p = d.data, f = 0; f < p.length; f += 4)
            if (p[f + 0] *= l, p[f + 1] *= c, p[f + 2] *= u, !i.CanvasTinter.canHandleAlpha) {
                var g = p[f + 3];
                p[f + 0] /= 255 / g, p[f + 1] /= 255 / g, p[f + 2] /= 255 / g
            }
        n.putImageData(d, 0, 0)
    }, i.CanvasRenderer = function(t, e) {
        if (this.game = t, i.defaultRenderer || (i.defaultRenderer = this), this.type = Phaser.CANVAS, this.resolution = t.resolution, this.clearBeforeRender = t.clearBeforeRender, this.transparent = t.transparent, this.autoResize = !1, this.width = t.width * this.resolution, this.height = t.height * this.resolution, this.view = t.canvas, this.context = this.view.getContext("2d", {
                alpha: this.transparent
            }), !this.context) throw new Error("Failed to create a Canvas 2d context.");
        this.refresh = !0, this.count = 0, this.maskManager = new i.CanvasMaskManager, this.renderSession = {
            context: this.context,
            maskManager: this.maskManager,
            scaleMode: null,
            smoothProperty: Phaser.Canvas.getSmoothingPrefix(this.context),
            roundPixels: e.roundPixels || !1
        }, this.mapBlendModes(), this.resize(this.width, this.height)
    }, i.CanvasRenderer.prototype.constructor = i.CanvasRenderer, i.CanvasRenderer.prototype.render = function(t) {
        this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.globalAlpha = 1, this.renderSession.currentBlendMode = 0, this.renderSession.shakeX = this.game.camera._shake.x, this.renderSession.shakeY = this.game.camera._shake.y, this.context.globalCompositeOperation = "source-over", navigator.isCocoonJS && this.view.screencanvas && (this.context.fillStyle = "black", this.context.clear()), this.clearBeforeRender && (this.transparent ? this.context.clearRect(0, 0, this.width, this.height) : t._bgColor && (this.context.fillStyle = t._bgColor.rgba, this.context.fillRect(0, 0, this.width, this.height))), this.renderDisplayObject(t)
    }, i.CanvasRenderer.prototype.setTexturePriority = function() {}, i.CanvasRenderer.prototype.destroy = function(t) {
        void 0 === t && (t = !0), t && this.view.parent && this.view.parent.removeChild(this.view), this.view = null, this.context = null, this.maskManager = null, this.renderSession = null
    }, i.CanvasRenderer.prototype.resize = function(t, e) {
        this.width = t * this.resolution, this.height = e * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.renderSession.smoothProperty && (this.context[this.renderSession.smoothProperty] = this.renderSession.scaleMode === i.scaleModes.LINEAR)
    }, i.CanvasRenderer.prototype.renderDisplayObject = function(t, e, i) {
        this.renderSession.context = e || this.context, this.renderSession.resolution = this.resolution, t._renderCanvas(this.renderSession, i)
    }, i.CanvasRenderer.prototype.mapBlendModes = function() {
        if (!i.blendModesCanvas) {
            var t = [],
                e = i.blendModes,
                s = this.game.device.canUseMultiply;
            t[e.NORMAL] = "source-over", t[e.ADD] = "lighter", t[e.MULTIPLY] = s ? "multiply" : "source-over", t[e.SCREEN] = s ? "screen" : "source-over", t[e.OVERLAY] = s ? "overlay" : "source-over", t[e.DARKEN] = s ? "darken" : "source-over", t[e.LIGHTEN] = s ? "lighten" : "source-over", t[e.COLOR_DODGE] = s ? "color-dodge" : "source-over", t[e.COLOR_BURN] = s ? "color-burn" : "source-over", t[e.HARD_LIGHT] = s ? "hard-light" : "source-over", t[e.SOFT_LIGHT] = s ? "soft-light" : "source-over", t[e.DIFFERENCE] = s ? "difference" : "source-over", t[e.EXCLUSION] = s ? "exclusion" : "source-over", t[e.HUE] = s ? "hue" : "source-over", t[e.SATURATION] = s ? "saturation" : "source-over", t[e.COLOR] = s ? "color" : "source-over", t[e.LUMINOSITY] = s ? "luminosity" : "source-over", i.blendModesCanvas = t
        }
    }, i.BaseTexture = function(t, e, s) {
        this.resolution = s || 1, this.width = 100, this.height = 100, this.scaleMode = e || i.scaleModes.DEFAULT, this.hasLoaded = !1, this.source = t, this.premultipliedAlpha = !0, this._glTextures = [], this.mipmap = !1, this.textureIndex = 0, this._dirty = [!0, !0, !0, !0], t && ((this.source.complete || this.source.getContext) && this.source.width && this.source.height && (this.hasLoaded = !0, this.width = this.source.naturalWidth || this.source.width, this.height = this.source.naturalHeight || this.source.height, this.dirty()), this.skipRender = !1, this._powerOf2 = !1)
    }, i.BaseTexture.prototype.constructor = i.BaseTexture, i.BaseTexture.prototype.forceLoaded = function(t, e) {
        this.hasLoaded = !0, this.width = t, this.height = e, this.dirty()
    }, i.BaseTexture.prototype.destroy = function() {
        this.source && Phaser.CanvasPool.removeByCanvas(this.source), this.source = null, this.unloadFromGPU()
    }, i.BaseTexture.prototype.dirty = function() {
        for (var t = 0; t < this._glTextures.length; t++) this._dirty[t] = !0
    }, i.BaseTexture.prototype.unloadFromGPU = function() {
        this.dirty();
        for (var t = this._glTextures.length - 1; t >= 0; t--) {
            var e = this._glTextures[t],
                s = i.glContexts[t];
            s && e && s.deleteTexture(e)
        }
        this._glTextures.length = 0, this.dirty()
    }, i.BaseTexture.fromCanvas = function(t, e, s) {
        return 0 === t.width && (t.width = 1), 0 === t.height && (t.height = 1), s = s || 1, new i.BaseTexture(t, e, s)
    }, i.TextureSilentFail = !1, i.Texture = function(t, e, s, n) {
        this.noFrame = !1, e || (this.noFrame = !0, e = new i.Rectangle(0, 0, 1, 1)), t instanceof i.Texture && (t = t.baseTexture), this.baseTexture = t, this.frame = e, this.trim = n, this.valid = !1, this.isTiling = !1, this.requiresUpdate = !1, this.requiresReTint = !1, this._uvs = null, this.width = 0, this.height = 0, this.crop = s || new i.Rectangle(0, 0, 1, 1), this.rotated = !1, t.hasLoaded && (this.noFrame && (e = new i.Rectangle(0, 0, t.width, t.height)), this.setFrame(e))
    }, i.Texture.prototype.constructor = i.Texture, i.Texture.prototype.onBaseTextureLoaded = function() {
        var t = this.baseTexture;
        this.noFrame && (this.frame = new i.Rectangle(0, 0, t.width, t.height)), this.setFrame(this.frame)
    }, i.Texture.prototype.destroy = function(t) {
        t && this.baseTexture.destroy(), this.valid = !1
    }, i.Texture.prototype.setFrame = function(t) {
        if (this.noFrame = !1, this.frame = t, this.width = t.width, this.height = t.height, this.crop.x = t.x, this.crop.y = t.y, this.crop.width = t.width, this.crop.height = t.height, this.trim || !(t.x + t.width > this.baseTexture.width || t.y + t.height > this.baseTexture.height)) this.valid = t && t.width && t.height && this.baseTexture.source && this.baseTexture.hasLoaded, this.trim && (this.width = this.trim.width, this.height = this.trim.height, this.frame.width = this.trim.width, this.frame.height = this.trim.height), this.valid && this._updateUvs();
        else {
            if (!i.TextureSilentFail) throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
            this.valid = !1
        }
    }, i.Texture.prototype._updateUvs = function() {
        this._uvs || (this._uvs = new i.TextureUvs);
        var t = this.crop,
            e = this.baseTexture.width,
            s = this.baseTexture.height;
        this._uvs.x0 = t.x / e, this._uvs.y0 = t.y / s, this._uvs.x1 = (t.x + t.width) / e, this._uvs.y1 = t.y / s, this._uvs.x2 = (t.x + t.width) / e, this._uvs.y2 = (t.y + t.height) / s, this._uvs.x3 = t.x / e, this._uvs.y3 = (t.y + t.height) / s
    }, i.Texture.prototype._updateUvsInverted = function() {
        this._uvs || (this._uvs = new i.TextureUvs);
        var t = this.crop,
            e = this.baseTexture.width,
            s = this.baseTexture.height;
        this._uvs.x0 = t.x / e, this._uvs.y0 = t.y / s, this._uvs.x1 = (t.x + t.height) / e, this._uvs.y1 = t.y / s, this._uvs.x2 = (t.x + t.height) / e, this._uvs.y2 = (t.y + t.width) / s, this._uvs.x3 = t.x / e, this._uvs.y3 = (t.y + t.width) / s
    }, i.Texture.fromCanvas = function(t, e) {
        var s = i.BaseTexture.fromCanvas(t, e);
        return new i.Texture(s)
    }, i.TextureUvs = function() {
        this.x0 = 0, this.y0 = 0, this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.x3 = 0, this.y3 = 0
    }, "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = i), exports.PIXI = i) : "undefined" != typeof define && define.amd ? define("PIXI", this.PIXI = i) : this.PIXI = i, i
}.call(this),
    function() {
        var t = t || {
            VERSION: "2.13.1",
            GAMES: [],
            AUTO: 0,
            CANVAS: 1,
            WEBGL: 2,
            HEADLESS: 3,
            WEBGL_MULTI: 4,
            NONE: 0,
            LEFT: 1,
            RIGHT: 2,
            UP: 3,
            DOWN: 4,
            SPRITE: 0,
            BUTTON: 1,
            IMAGE: 2,
            GRAPHICS: 3,
            TEXT: 4,
            TILESPRITE: 5,
            BITMAPTEXT: 6,
            GROUP: 7,
            RENDERTEXTURE: 8,
            TILEMAP: 9,
            TILEMAPLAYER: 10,
            EMITTER: 11,
            POLYGON: 12,
            BITMAPDATA: 13,
            CANVAS_FILTER: 14,
            WEBGL_FILTER: 15,
            ELLIPSE: 16,
            SPRITEBATCH: 17,
            RETROFONT: 18,
            POINTER: 19,
            ROPE: 20,
            CIRCLE: 21,
            RECTANGLE: 22,
            LINE: 23,
            MATRIX: 24,
            POINT: 25,
            ROUNDEDRECTANGLE: 26,
            CREATURE: 27,
            VIDEO: 28,
            PENDING_ATLAS: -1,
            HORIZONTAL: 0,
            VERTICAL: 1,
            LANDSCAPE: 0,
            PORTRAIT: 1,
            ANGLE_UP: 270,
            ANGLE_DOWN: 90,
            ANGLE_LEFT: 180,
            ANGLE_RIGHT: 0,
            ANGLE_NORTH_EAST: 315,
            ANGLE_NORTH_WEST: 225,
            ANGLE_SOUTH_EAST: 45,
            ANGLE_SOUTH_WEST: 135,
            TOP_LEFT: 0,
            TOP_CENTER: 1,
            TOP_RIGHT: 2,
            LEFT_TOP: 3,
            LEFT_CENTER: 4,
            LEFT_BOTTOM: 5,
            CENTER: 6,
            RIGHT_TOP: 7,
            RIGHT_CENTER: 8,
            RIGHT_BOTTOM: 9,
            BOTTOM_LEFT: 10,
            BOTTOM_CENTER: 11,
            BOTTOM_RIGHT: 12,
            blendModes: {
                NORMAL: 0,
                ADD: 1,
                MULTIPLY: 2,
                SCREEN: 3,
                OVERLAY: 4,
                DARKEN: 5,
                LIGHTEN: 6,
                COLOR_DODGE: 7,
                COLOR_BURN: 8,
                HARD_LIGHT: 9,
                SOFT_LIGHT: 10,
                DIFFERENCE: 11,
                EXCLUSION: 12,
                HUE: 13,
                SATURATION: 14,
                COLOR: 15,
                LUMINOSITY: 16
            },
            scaleModes: {
                DEFAULT: 0,
                LINEAR: 0,
                NEAREST: 1
            },
            PIXI: PIXI || {},
            _UID: 0
        };
        if ("undefined" != typeof AudioBufferSourceNode && (AudioBufferSourceNode.prototype.start || (AudioBufferSourceNode.prototype.start = AudioBufferSourceNode.prototype.noteGrainOn), AudioBufferSourceNode.prototype.stop || (AudioBufferSourceNode.prototype.stop = AudioBufferSourceNode.prototype.noteOff)), Math.trunc || (Math.trunc = function(t) {
                return t < 0 ? Math.ceil(t) : Math.floor(t)
            }), Function.prototype.bind || (Function.prototype.bind = function() {
                var t = Array.prototype.slice;
                return function(e) {
                    function i() {
                        var r = n.concat(t.call(arguments));
                        s.apply(this instanceof i ? this : e, r)
                    }
                    var s = this,
                        n = t.call(arguments, 1);
                    if ("function" != typeof s) throw new TypeError;
                    return i.prototype = function t(e) {
                        if (e && (t.prototype = e), !(this instanceof t)) return new t
                    }(s.prototype), i
                }
            }()), Array.isArray || (Array.isArray = function(t) {
                return "[object Array]" === Object.prototype.toString.call(t)
            }), Array.prototype.forEach || (Array.prototype.forEach = function(t) {
                "use strict";
                if (null == this) throw new TypeError;
                var e = Object(this),
                    i = e.length >>> 0;
                if ("function" != typeof t) throw new TypeError;
                for (var s = arguments.length >= 2 ? arguments[1] : void 0, n = 0; n < i; n++) n in e && t.call(s, e[n], n, e)
            }), "function" != typeof window.Uint32Array && "object" != typeof window.Uint32Array) {
            var e = function(t) {
                var e = new Array;
                window[t] = function(t) {
                    if ("number" == typeof t)
                        for (Array.call(this, t), this.length = t, e = 0; e < this.length; e++) this[e] = 0;
                    else {
                        Array.call(this, t.length), this.length = t.length;
                        for (var e = 0; e < this.length; e++) this[e] = t[e]
                    }
                }, window[t].prototype = e, window[t].constructor = window[t]
            };
            e("Float32Array"), e("Uint32Array"), e("Uint16Array"), e("Int16Array"), e("ArrayBuffer")
        }
        for (var i in window.console || (window.console = {}, window.gradle.event = window.console.assert = function() {}, window.console.warn = window.console.assert = function() {}), Object.assign || (Object.assign = function(t, e) {
                "use strict";
                if (null == t) throw new TypeError("Cannot convert undefined or null to object");
                for (var i = Object(t), s = Object.prototype.hasOwnProperty, n = 1; n < arguments.length; n++) {
                    var r = arguments[n];
                    if (null != r)
                        for (var o in r) s.call(r, o) && (i[o] = r[o])
                }
                return i
            }), t.Utils = {
                defaults: function(t, e) {
                    for (var i = Object.keys(e), s = 0, n = i.length; s < n; s++) {
                        var r = i[s];
                        void 0 === t[r] && (t[r] = e[r])
                    }
                    return t
                },
                reverseString: function(t) {
                    return t.split("").reverse().join("")
                },
                getProperty: function(t, e) {
                    var i = e.split(".");
                    switch (i.length) {
                        case 1:
                            return t[e];
                        case 2:
                            return t[i[0]][i[1]];
                        case 3:
                            return t[i[0]][i[1]][i[2]];
                        case 4:
                            return t[i[0]][i[1]][i[2]][i[3]];
                        default:
                            return this._getProperty(t, e)
                    }
                },
                setProperties: function(t, e) {
                    for (var i in e) this.setProperty(t, i, e[i]);
                    return t
                },
                setProperty: function(t, e, i) {
                    var s = e.split(".");
                    switch (s.length) {
                        case 1:
                            t[e] = i;
                            break;
                        case 2:
                            t[s[0]][s[1]] = i;
                            break;
                        case 3:
                            t[s[0]][s[1]][s[2]] = i;
                            break;
                        case 4:
                            t[s[0]][s[1]][s[2]][s[3]] = i;
                            break;
                        default:
                            this._setProperty(t, e, i)
                    }
                },
                _getProperty: function(t, e) {
                    for (var i = e.split("."), s = i.length, n = 0, r = t; n < s;) {
                        var o = i[n];
                        if (null == r) return;
                        r = r[o], n++
                    }
                    return r
                },
                _setProperty: function(t, e, i) {
                    var s = e.split("."),
                        n = s.length,
                        r = 0,
                        o = t,
                        a = s[0];
                    if (1 === n) t[e] = i;
                    else {
                        for (; r < n - 1;) o = o[a], a = s[++r];
                        o[a] = i
                    }
                    return t
                },
                chanceRoll: function(t) {
                    return void 0 === t && (t = 50), t > 0 && 100 * Math.random() <= t
                },
                randomChoice: function(t, e) {
                    return Math.random() < .5 ? t : e
                },
                parseDimension: function(t, e) {
                    var i = 0,
                        s = 0;
                    return "string" == typeof t ? "%" === t.substr(-1) ? (i = parseInt(t, 10) / 100, s = 0 === e ? window.innerWidth * i : window.innerHeight * i) : s = parseInt(t, 10) : s = t, s
                },
                pad: function(t, e, i, s) {
                    if (void 0 === e) e = 0;
                    if (void 0 === i) i = " ";
                    if (void 0 === s) s = 3;
                    var n = 0;
                    if (e + 1 >= (t = t.toString()).length) switch (s) {
                        case 1:
                            t = new Array(e + 1 - t.length).join(i) + t;
                            break;
                        case 3:
                            var r = Math.ceil((n = e - t.length) / 2);
                            t = new Array(n - r + 1).join(i) + t + new Array(r + 1).join(i);
                            break;
                        default:
                            t += new Array(e + 1 - t.length).join(i)
                    }
                    return t
                },
                isPlainObject: function(t) {
                    if ("object" != typeof t || t.nodeType || t === t.window) return !1;
                    try {
                        if (t.constructor && !{}.hasOwnProperty.call(t.constructor.prototype, "isPrototypeOf")) return !1
                    } catch (t) {
                        return !1
                    }
                    return !0
                },
                extend: function() {
                    var e, i, s, n, r, o, a = arguments[0] || {},
                        h = 1,
                        l = arguments.length,
                        c = !1;
                    for ("boolean" == typeof a && (c = a, a = arguments[1] || {}, h = 2), l === h && (a = this, --h); h < l; h++)
                        if (null != (e = arguments[h]))
                            for (i in e) s = a[i], a !== (n = e[i]) && (c && n && (t.Utils.isPlainObject(n) || (r = Array.isArray(n))) ? (r ? (r = !1, o = s && Array.isArray(s) ? s : []) : o = s && t.Utils.isPlainObject(s) ? s : {}, a[i] = t.Utils.extend(c, o, n)) : void 0 !== n && (a[i] = n));
                    return a
                },
                mixinPrototype: function(t, e, i) {
                    void 0 === i && (i = !1);
                    for (var s = Object.keys(e), n = 0; n < s.length; n++) {
                        var r = s[n],
                            o = e[r];
                        !i && r in t || (!o || "function" != typeof o.get && "function" != typeof o.set ? t[r] = o : "function" == typeof o.clone ? t[r] = o.clone() : Object.defineProperty(t, r, o))
                    }
                },
                mixin: function(e, i) {
                    if (!e || "object" != typeof e) return i;
                    for (var s in e) {
                        var n = e[s];
                        if (!n.childNodes && !n.cloneNode) {
                            var r = typeof e[s];
                            e[s] && "object" === r ? typeof i[s] === r ? i[s] = t.Utils.mixin(e[s], i[s]) : i[s] = t.Utils.mixin(e[s], new n.constructor) : i[s] = e[s]
                        }
                    }
                    return i
                }
            }, t.Circle = function(e, i, s) {
                e = e || 0, i = i || 0, s = s || 0, this.x = e, this.y = i, this._diameter = s, this._radius = 0, s > 0 && (this._radius = .5 * s), this.type = t.CIRCLE
            }, t.Circle.prototype = {
                circumference: function() {
                    return Math.PI * this._radius * 2
                },
                random: function(e) {
                    void 0 === e && (e = new t.Point);
                    var i = 2 * Math.PI * Math.random(),
                        s = Math.random() + Math.random(),
                        n = s > 1 ? 2 - s : s,
                        r = n * Math.cos(i),
                        o = n * Math.sin(i);
                    return e.x = this.x + r * this.radius, e.y = this.y + o * this.radius, e
                },
                getBounds: function() {
                    return new t.Rectangle(this.x - this.radius, this.y - this.radius, this.diameter, this.diameter)
                },
                setTo: function(t, e, i) {
                    return this.x = t, this.y = e, this._diameter = i, this._radius = .5 * i, this
                },
                copyFrom: function(t) {
                    return this.setTo(t.x, t.y, t.diameter)
                },
                copyTo: function(t) {
                    return t.x = this.x, t.y = this.y, t.diameter = this._diameter, t
                },
                distance: function(e, i) {
                    var s = t.Math.distance(this.x, this.y, e.x, e.y);
                    return i ? Math.round(s) : s
                },
                clone: function(e) {
                    return null == e ? e = new t.Circle(this.x, this.y, this.diameter) : e.setTo(this.x, this.y, this.diameter), e
                },
                contains: function(e, i) {
                    return t.Circle.contains(this, e, i)
                },
                circumferencePoint: function(e, i, s) {
                    return t.Circle.circumferencePoint(this, e, i, s)
                },
                sample: function(e, i, s, n, r) {
                    e || (e = 60), null == i && (i = 0), null == s && (s = t.Math.PI2), r || (r = []);
                    for (var o = 0; o < e;) this.circumferencePoint(t.Math.linear(i, s, o / e), n, r[o] || (r[o] = new t.Point)), o += 1;
                    return r
                },
                offset: function(t, e) {
                    return this.x += t, this.y += e, this
                },
                offsetPoint: function(t) {
                    return this.offset(t.x, t.y)
                },
                toString: function() {
                    return "[{Phaser.Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]"
                }
            }, t.Circle.prototype.constructor = t.Circle, Object.defineProperty(t.Circle.prototype, "diameter", {
                get: function() {
                    return this._diameter
                },
                set: function(t) {
                    t > 0 && (this._diameter = t, this._radius = .5 * t)
                }
            }), Object.defineProperty(t.Circle.prototype, "radius", {
                get: function() {
                    return this._radius
                },
                set: function(t) {
                    t > 0 && (this._radius = t, this._diameter = 2 * t)
                }
            }), Object.defineProperty(t.Circle.prototype, "left", {
                get: function() {
                    return this.x - this._radius
                },
                set: function(t) {
                    t > this.x ? (this._radius = 0, this._diameter = 0) : this.radius = this.x - t
                }
            }), Object.defineProperty(t.Circle.prototype, "right", {
                get: function() {
                    return this.x + this._radius
                },
                set: function(t) {
                    t < this.x ? (this._radius = 0, this._diameter = 0) : this.radius = t - this.x
                }
            }), Object.defineProperty(t.Circle.prototype, "top", {
                get: function() {
                    return this.y - this._radius
                },
                set: function(t) {
                    t > this.y ? (this._radius = 0, this._diameter = 0) : this.radius = this.y - t
                }
            }), Object.defineProperty(t.Circle.prototype, "bottom", {
                get: function() {
                    return this.y + this._radius
                },
                set: function(t) {
                    t < this.y ? (this._radius = 0, this._diameter = 0) : this.radius = t - this.y
                }
            }), Object.defineProperty(t.Circle.prototype, "area", {
                get: function() {
                    return this._radius > 0 ? Math.PI * this._radius * this._radius : 0
                }
            }), Object.defineProperty(t.Circle.prototype, "empty", {
                get: function() {
                    return 0 === this._diameter
                },
                set: function(t) {
                    !0 === t && this.setTo(0, 0, 0)
                }
            }), t.Circle.contains = function(t, e, i) {
                return t.radius > 0 && e >= t.left && e <= t.right && i >= t.top && i <= t.bottom && (t.x - e) * (t.x - e) + (t.y - i) * (t.y - i) <= t.radius * t.radius
            }, t.Circle.equals = function(t, e) {
                return t.x === e.x && t.y === e.y && t.diameter === e.diameter
            }, t.Circle.intersects = function(e, i) {
                return t.Math.distance(e.x, e.y, i.x, i.y) <= e.radius + i.radius
            }, t.Circle.circumferencePoint = function(e, i, s, n) {
                return void 0 === s && (s = !1), void 0 === n && (n = new t.Point), !0 === s && (i = t.Math.degToRad(i)), n.x = e.x + e.radius * Math.cos(i), n.y = e.y + e.radius * Math.sin(i), n
            }, t.Circle.intersectsRectangle = function(t, e) {
                var i = Math.abs(t.x - e.x - e.halfWidth);
                if (i > e.halfWidth + t.radius) return !1;
                var s = Math.abs(t.y - e.y - e.halfHeight);
                if (s > e.halfHeight + t.radius) return !1;
                if (i <= e.halfWidth || s <= e.halfHeight) return !0;
                var n = i - e.halfWidth,
                    r = s - e.halfHeight;
                return n * n + r * r <= t.radius * t.radius
            }, t.Circle.intersectsLine = function(e, i, s) {
                var n = e.x,
                    r = e.y,
                    o = (i.end.y - i.start.y) / (i.end.x - i.start.x),
                    a = i.end.y - o * i.end.x,
                    h = e.radius,
                    l = e.radius,
                    c = a + o * n,
                    u = (n * (l * l) - o * (h * h) * (a - r) + h * l * Math.sqrt(h * h * (o * o) + l * l - c * c - r * r + 2 * c * r)) / (h * h * (o * o) + l * l),
                    d = (n * (l * l) - o * (h * h) * (a - r) - h * l * Math.sqrt(h * h * (o * o) + l * l - c * c - r * r + 2 * c * r)) / (h * h * (o * o) + l * l),
                    p = o * u + a,
                    f = o * d + a,
                    g = new t.Point(u, p),
                    m = new t.Point(d, f),
                    y = i.pointOnSegment(g.x, g.y, .01),
                    v = i.pointOnSegment(m.x, m.y, .01);
                return y && v ? !s || [g, m] : y ? !s || [g] : v ? !s || [m] : !!s && []
            }, PIXI.Circle = t.Circle, t.Ellipse = function(e, i, s, n) {
                e = e || 0, i = i || 0, s = s || 0, n = n || 0, this.x = e, this.y = i, this.width = s, this.height = n, this.type = t.ELLIPSE
            }, t.Ellipse.prototype = {
                setTo: function(t, e, i, s) {
                    return this.x = t, this.y = e, this.width = i, this.height = s, this
                },
                getBounds: function() {
                    return new t.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height)
                },
                copyFrom: function(t) {
                    return this.setTo(t.x, t.y, t.width, t.height)
                },
                copyTo: function(t) {
                    return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
                },
                clone: function(e) {
                    return null == e ? e = new t.Ellipse(this.x, this.y, this.width, this.height) : e.setTo(this.x, this.y, this.width, this.height), e
                },
                contains: function(e, i) {
                    return t.Ellipse.contains(this, e, i)
                },
                random: function(e) {
                    void 0 === e && (e = new t.Point);
                    var i = Math.random() * Math.PI * 2,
                        s = Math.sqrt(Math.random());
                    return e.x = this.centerX + .5 * s * Math.cos(i) * this.width, e.y = this.centerY + .5 * s * Math.sin(i) * this.height, e
                },
                toString: function() {
                    return "[{Phaser.Ellipse (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + ")}]"
                }
            }, t.Ellipse.prototype.constructor = t.Ellipse, Object.defineProperty(t.Ellipse.prototype, "left", {
                get: function() {
                    return this.x
                },
                set: function(t) {
                    this.x = t
                }
            }), Object.defineProperty(t.Ellipse.prototype, "right", {
                get: function() {
                    return this.x + this.width
                },
                set: function(t) {
                    t < this.x ? this.width = 0 : this.width = t - this.x
                }
            }), Object.defineProperty(t.Ellipse.prototype, "top", {
                get: function() {
                    return this.y
                },
                set: function(t) {
                    this.y = t
                }
            }), Object.defineProperty(t.Ellipse.prototype, "bottom", {
                get: function() {
                    return this.y + this.height
                },
                set: function(t) {
                    t < this.y ? this.height = 0 : this.height = t - this.y
                }
            }), Object.defineProperty(t.Ellipse.prototype, "centerX", {
                get: function() {
                    return this.x + .5 * this.width
                }
            }), Object.defineProperty(t.Ellipse.prototype, "centerY", {
                get: function() {
                    return this.y + .5 * this.height
                }
            }), Object.defineProperty(t.Ellipse.prototype, "empty", {
                get: function() {
                    return 0 === this.width || 0 === this.height
                },
                set: function(t) {
                    !0 === t && this.setTo(0, 0, 0, 0)
                }
            }), t.Ellipse.contains = function(t, e, i) {
                if (t.width <= 0 || t.height <= 0) return !1;
                var s = (e - t.x) / t.width - .5,
                    n = (i - t.y) / t.height - .5;
                return (s *= s) + (n *= n) < .25
            }, t.Ellipse.intersectsLine = function(e, i, s) {
                var n = e.x,
                    r = e.y,
                    o = (i.end.y - i.start.y) / (i.end.x - i.start.x),
                    a = i.end.y - o * i.end.x,
                    h = e.width / 2,
                    l = e.height / 2,
                    c = a + o * n,
                    u = (n * (l * l) - o * (h * h) * (a - r) + h * l * Math.sqrt(h * h * (o * o) + l * l - c * c - r * r + 2 * c * r)) / (h * h * (o * o) + l * l),
                    d = (n * (l * l) - o * (h * h) * (a - r) - h * l * Math.sqrt(h * h * (o * o) + l * l - c * c - r * r + 2 * c * r)) / (h * h * (o * o) + l * l),
                    p = o * u + a,
                    f = o * d + a,
                    g = new t.Point(u, p),
                    m = new t.Point(d, f),
                    y = i.pointOnSegment(g.x, g.y, .01),
                    v = i.pointOnSegment(m.x, m.y, .01);
                return y && v ? !s || [g, m] : y ? !s || [g] : v ? !s || [m] : !!s && []
            }, PIXI.Ellipse = t.Ellipse, t.Line = function(e, i, s, n) {
                e = e || 0, i = i || 0, s = s || 0, n = n || 0, this.start = new t.Point(e, i), this.end = new t.Point(s, n), this.type = t.LINE
            }, t.Line.prototype = {
                setTo: function(t, e, i, s) {
                    return this.start.setTo(t, e), this.end.setTo(i, s), this
                },
                fromPoints: function(t, e) {
                    return this.setTo(t.x, t.y, e.x, e.y), this
                },
                fromSprite: function(t, e, i) {
                    return void 0 === i && (i = !1), i ? this.setTo(t.centerX, t.centerY, e.centerX, e.centerY) : this.fromPoints(t, e)
                },
                fromAngle: function(t, e, i, s) {
                    return this.start.setTo(t, e), this.end.setTo(t + Math.cos(i) * s, e + Math.sin(i) * s), this
                },
                rotate: function(t, e) {
                    var i = (this.start.x + this.end.x) / 2,
                        s = (this.start.y + this.end.y) / 2;
                    return this.start.rotate(i, s, t, e), this.end.rotate(i, s, t, e), this
                },
                rotateAround: function(t, e, i, s) {
                    return this.start.rotate(t, e, i, s), this.end.rotate(t, e, i, s), this
                },
                intersects: function(e, i, s) {
                    return t.Line.intersectsPoints(this.start, this.end, e.start, e.end, i, s)
                },
                reflect: function(e) {
                    return t.Line.reflect(this, e)
                },
                midPoint: function(e) {
                    return void 0 === e && (e = new t.Point), e.x = (this.start.x + this.end.x) / 2, e.y = (this.start.y + this.end.y) / 2, e
                },
                centerOn: function(t, e) {
                    var i = t - (this.start.x + this.end.x) / 2,
                        s = e - (this.start.y + this.end.y) / 2;
                    this.start.add(i, s), this.end.add(i, s)
                },
                pointOnLine: function(e, i, s) {
                    return t.Math.fuzzyEqual((e - this.start.x) * (this.end.y - this.start.y), (this.end.x - this.start.x) * (i - this.start.y), s || 0)
                },
                pointOnSegment: function(t, e, i) {
                    var s = Math.min(this.start.x, this.end.x),
                        n = Math.max(this.start.x, this.end.x),
                        r = Math.min(this.start.y, this.end.y),
                        o = Math.max(this.start.y, this.end.y);
                    return this.pointOnLine(t, e, i) && t >= s && t <= n && e >= r && e <= o
                },
                random: function(e) {
                    void 0 === e && (e = new t.Point);
                    var i = Math.random();
                    return e.x = this.start.x + i * (this.end.x - this.start.x), e.y = this.start.y + i * (this.end.y - this.start.y), e
                },
                coordinatesOnLine: function(t, e) {
                    void 0 === t && (t = 1), void 0 === e && (e = []);
                    var i = Math.round(this.start.x),
                        s = Math.round(this.start.y),
                        n = Math.round(this.end.x),
                        r = Math.round(this.end.y),
                        o = Math.abs(n - i),
                        a = Math.abs(r - s),
                        h = i < n ? 1 : -1,
                        l = s < r ? 1 : -1,
                        c = o - a;
                    e.push([i, s]);
                    for (var u = 1; i !== n || s !== r;) {
                        var d = c << 1;
                        d > -a && (c -= a, i += h), d < o && (c += o, s += l), u % t == 0 && e.push([i, s]), u++
                    }
                    return e
                },
                clone: function(e) {
                    return null == e ? e = new t.Line(this.start.x, this.start.y, this.end.x, this.end.y) : e.setTo(this.start.x, this.start.y, this.end.x, this.end.y), e
                }
            }, Object.defineProperty(t.Line.prototype, "length", {
                get: function() {
                    return Math.sqrt((this.end.x - this.start.x) * (this.end.x - this.start.x) + (this.end.y - this.start.y) * (this.end.y - this.start.y))
                }
            }), Object.defineProperty(t.Line.prototype, "angle", {
                get: function() {
                    return t.Point.angle(this.end, this.start)
                }
            }), Object.defineProperty(t.Line.prototype, "slope", {
                get: function() {
                    return (this.end.y - this.start.y) / (this.end.x - this.start.x)
                }
            }), Object.defineProperty(t.Line.prototype, "perpSlope", {
                get: function() {
                    return -(this.end.x - this.start.x) / (this.end.y - this.start.y)
                }
            }), Object.defineProperty(t.Line.prototype, "x", {
                get: function() {
                    return Math.min(this.start.x, this.end.x)
                }
            }), Object.defineProperty(t.Line.prototype, "y", {
                get: function() {
                    return Math.min(this.start.y, this.end.y)
                }
            }), Object.defineProperty(t.Line.prototype, "left", {
                get: function() {
                    return Math.min(this.start.x, this.end.x)
                }
            }), Object.defineProperty(t.Line.prototype, "right", {
                get: function() {
                    return Math.max(this.start.x, this.end.x)
                }
            }), Object.defineProperty(t.Line.prototype, "top", {
                get: function() {
                    return Math.min(this.start.y, this.end.y)
                }
            }), Object.defineProperty(t.Line.prototype, "bottom", {
                get: function() {
                    return Math.max(this.start.y, this.end.y)
                }
            }), Object.defineProperty(t.Line.prototype, "width", {
                get: function() {
                    return Math.abs(this.start.x - this.end.x)
                }
            }), Object.defineProperty(t.Line.prototype, "height", {
                get: function() {
                    return Math.abs(this.start.y - this.end.y)
                }
            }), Object.defineProperty(t.Line.prototype, "normalX", {
                get: function() {
                    return Math.cos(this.angle - 1.5707963267948966)
                }
            }), Object.defineProperty(t.Line.prototype, "normalY", {
                get: function() {
                    return Math.sin(this.angle - 1.5707963267948966)
                }
            }), Object.defineProperty(t.Line.prototype, "normalAngle", {
                get: function() {
                    return t.Math.wrap(this.angle - 1.5707963267948966, -Math.PI, Math.PI)
                }
            }), t.Line.intersectsPoints = function(e, i, s, n, r, o) {
                void 0 === r && (r = !0), void 0 === o && (o = new t.Point);
                var a = i.y - e.y,
                    h = n.y - s.y,
                    l = e.x - i.x,
                    c = s.x - n.x,
                    u = i.x * e.y - e.x * i.y,
                    d = n.x * s.y - s.x * n.y,
                    p = a * c - h * l;
                if (0 === p) return null;
                if (o.x = (l * d - c * u) / p, o.y = (h * u - a * d) / p, r) {
                    var f = (n.y - s.y) * (i.x - e.x) - (n.x - s.x) * (i.y - e.y),
                        g = ((n.x - s.x) * (e.y - s.y) - (n.y - s.y) * (e.x - s.x)) / f,
                        m = ((i.x - e.x) * (e.y - s.y) - (i.y - e.y) * (e.x - s.x)) / f;
                    return g >= 0 && g <= 1 && m >= 0 && m <= 1 ? o : null
                }
                return o
            }, t.Line.intersects = function(e, i, s, n) {
                return t.Line.intersectsPoints(e.start, e.end, i.start, i.end, s, n)
            }, t.Line.intersectsRectangle = function(t, e) {
                if (0 === t.length || e.empty) return !1;
                var i = t.start.x,
                    s = t.start.y,
                    n = t.end.x,
                    r = t.end.y,
                    o = e.x,
                    a = e.y,
                    h = e.right,
                    l = e.bottom,
                    c = 0;
                if (i >= o && i <= h && s >= a && s <= l || n >= o && n <= h && r >= a && r <= l) return !0;
                if (i < o && n >= o) {
                    if ((c = s + (r - s) * (o - i) / (n - i)) > a && c <= l) return !0
                } else if (i > h && n <= h && (c = s + (r - s) * (h - i) / (n - i)) >= a && c <= l) return !0;
                if (s < a && r >= a) {
                    if ((c = i + (n - i) * (a - s) / (r - s)) >= o && c <= h) return !0
                } else if (s > l && r <= l && (c = i + (n - i) * (l - s) / (r - s)) >= o && c <= h) return !0;
                return !1
            }, t.Line.intersectionWithRectangle = function(e, i, s) {
                var n = t.Line.intersectionWithRectangle;
                s || (s = new t.Point), n.edges || (n.edges = [new t.Line, new t.Line, new t.Line, new t.Line]), n.edgeIntersection || (n.edgeIntersection = new t.Point);
                var r = n.edges,
                    o = n.edgeIntersection.set(0),
                    a = i.x,
                    h = i.y,
                    l = i.right,
                    c = i.bottom,
                    u = 1 / 0;
                r[0].setTo(a, h, l, h), r[1].setTo(a, c, l, c), r[2].setTo(a, h, a, c), r[3].setTo(l, h, l, c);
                for (var d, p = 0; d = r[p]; p++)
                    if (e.intersects(d, !0, o)) {
                        var f = e.start.distance(o);
                        f < u && (u = f, s.copyFrom(o))
                    }
                return null != f ? s : null
            }, t.Line.reflect = function(t, e) {
                return 2 * e.normalAngle - 3.141592653589793 - t.angle
            }, t.Matrix = function(e, i, s, n, r, o) {
                null != e || (e = 1), null != i || (i = 0), null != s || (s = 0), null != n || (n = 1), null != r || (r = 0), null != o || (o = 0), this.a = e, this.b = i, this.c = s, this.d = n, this.tx = r, this.ty = o, this.type = t.MATRIX
            }, t.Matrix.prototype = {
                fromArray: function(t) {
                    return this.setTo(t[0], t[1], t[3], t[4], t[2], t[5])
                },
                setTo: function(t, e, i, s, n, r) {
                    return this.a = t, this.b = e, this.c = i, this.d = s, this.tx = n, this.ty = r, this
                },
                clone: function(e) {
                    return null == e ? e = new t.Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty) : (e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty), e
                },
                copyTo: function(t) {
                    return t.copyFrom(this), t
                },
                copyFrom: function(t) {
                    return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this
                },
                toArray: function(t, e) {
                    return void 0 === e && (e = new Float32Array(9)), t ? (e[0] = this.a, e[1] = this.b, e[2] = 0, e[3] = this.c, e[4] = this.d, e[5] = 0, e[6] = this.tx, e[7] = this.ty, e[8] = 1) : (e[0] = this.a, e[1] = this.c, e[2] = this.tx, e[3] = this.b, e[4] = this.d, e[5] = this.ty, e[6] = 0, e[7] = 0, e[8] = 1), e
                },
                apply: function(e, i) {
                    return void 0 === i && (i = new t.Point), i.x = this.a * e.x + this.c * e.y + this.tx, i.y = this.b * e.x + this.d * e.y + this.ty, i
                },
                applyInverse: function(e, i) {
                    void 0 === i && (i = new t.Point);
                    var s = 1 / (this.a * this.d + this.c * -this.b),
                        n = e.x,
                        r = e.y;
                    return i.x = this.d * s * n + -this.c * s * r + (this.ty * this.c - this.tx * this.d) * s, i.y = this.a * s * r + -this.b * s * n + (-this.ty * this.a + this.tx * this.b) * s, i
                },
                translate: function(t, e) {
                    return this.tx += t, this.ty += e, this
                },
                scale: function(t, e) {
                    return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this
                },
                rotate: function(t) {
                    var e = Math.cos(t),
                        i = Math.sin(t),
                        s = this.a,
                        n = this.c,
                        r = this.tx;
                    return this.a = s * e - this.b * i, this.b = s * i + this.b * e, this.c = n * e - this.d * i, this.d = n * i + this.d * e, this.tx = r * e - this.ty * i, this.ty = r * i + this.ty * e, this
                },
                append: function(t) {
                    var e = this.a,
                        i = this.b,
                        s = this.c,
                        n = this.d;
                    return this.a = t.a * e + t.b * s, this.b = t.a * i + t.b * n, this.c = t.c * e + t.d * s, this.d = t.c * i + t.d * n, this.tx = t.tx * e + t.ty * s + this.tx, this.ty = t.tx * i + t.ty * n + this.ty, this
                },
                identity: function() {
                    return this.setTo(1, 0, 0, 1, 0, 0)
                }
            }, t.identityMatrix = new t.Matrix, t.Point = function(e, i) {
                e = e || 0, i = i || 0, this.x = e, this.y = i, this.type = t.POINT
            }, t.Point.prototype = {
                copyFrom: function(t) {
                    return this.setTo(t.x, t.y)
                },
                invert: function() {
                    return this.setTo(this.y, this.x)
                },
                setTo: function(e, i) {
                    return t.Point.set(this, e, i)
                },
                set: function(e, i) {
                    return t.Point.set(this, e, i)
                },
                setToPolar: function(e, i, s) {
                    return null == i && (i = 1), s && (e = t.Math.degToRad(e)), this.setTo(Math.cos(e) * i, Math.sin(e) * i)
                },
                add: function(t, e) {
                    return this.x += t, this.y += e, this
                },
                subtract: function(t, e) {
                    return this.x -= t, this.y -= e, this
                },
                multiply: function(t, e) {
                    return this.x *= t, this.y *= e, this
                },
                divide: function(t, e) {
                    return this.x /= t, this.y /= e, this
                },
                clampX: function(e, i) {
                    return this.x = t.Math.clamp(this.x, e, i), this
                },
                clampY: function(e, i) {
                    return this.y = t.Math.clamp(this.y, e, i), this
                },
                clamp: function(e, i) {
                    return this.x = t.Math.clamp(this.x, e, i), this.y = t.Math.clamp(this.y, e, i), this
                },
                clip: function(t) {
                    var e = t.left,
                        i = t.top,
                        s = t.right,
                        n = t.bottom;
                    return this.x < e ? this.x = e : this.x > s && (this.x = s), this.y < i ? this.y = i : this.y > n && (this.y = n), this
                },
                clone: function(e) {
                    return null == e ? e = new t.Point(this.x, this.y) : e.setTo(this.x, this.y), e
                },
                copyTo: function(t) {
                    return t.x = this.x, t.y = this.y, t
                },
                distance: function(e, i) {
                    return t.Point.distance(this, e, i)
                },
                equals: function(t) {
                    return t.x === this.x && t.y === this.y
                },
                equalsXY: function(t, e) {
                    return this.x === t && this.y === e
                },
                fuzzyEquals: function(e, i) {
                    return t.Point.fuzzyEquals(this, e, i)
                },
                fuzzyEqualsXY: function(e, i, s) {
                    return t.Point.fuzzyEqualsXY(this, e, i, s)
                },
                angle: function(t, e) {
                    return this.angleXY(t.x, t.y, e)
                },
                angleXY: function(e, i, s) {
                    var n = Math.atan2(i - this.y, e - this.x);
                    return s ? t.Math.radToDeg(n) : n
                },
                atan: function(e) {
                    var i = Math.atan2(this.y, this.x);
                    return e ? t.Math.radToDeg(i) : i
                },
                rotate: function(e, i, s, n, r) {
                    return t.Point.rotate(this, e, i, s, n, r)
                },
                getMagnitude: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                },
                getMagnitudeSq: function() {
                    return this.x * this.x + this.y * this.y
                },
                setMagnitude: function(t) {
                    return this.normalize().multiply(t, t)
                },
                normalize: function() {
                    if (!this.isZero()) {
                        var t = this.getMagnitude();
                        this.x /= t, this.y /= t
                    }
                    return this
                },
                limit: function(t) {
                    return this.getMagnitudeSq() > t * t && this.setMagnitude(t), this
                },
                expand: function(t) {
                    return this.getMagnitudeSq() < t * t && this.setMagnitude(t), this
                },
                isZero: function() {
                    return 0 === this.x && 0 === this.y
                },
                dot: function(t) {
                    return this.x * t.x + this.y * t.y
                },
                cross: function(t) {
                    return this.x * t.y - this.y * t.x
                },
                perp: function() {
                    return this.setTo(-this.y, this.x)
                },
                rperp: function() {
                    return this.setTo(this.y, -this.x)
                },
                normalRightHand: function() {
                    return this.setTo(-1 * this.y, this.x)
                },
                floor: function() {
                    return this.setTo(Math.floor(this.x), Math.floor(this.y))
                },
                ceil: function() {
                    return this.setTo(Math.ceil(this.x), Math.ceil(this.y))
                },
                round: function() {
                    return this.setTo(Math.round(this.x), Math.round(this.y))
                },
                toString: function() {
                    return "[{Point (x=" + this.x + " y=" + this.y + ")}]"
                }
            }, t.Point.prototype.constructor = t.Point, t.Point.add = function(e, i, s) {
                return void 0 === s && (s = new t.Point), s.x = e.x + i.x, s.y = e.y + i.y, s
            }, t.Point.subtract = function(e, i, s) {
                return void 0 === s && (s = new t.Point), s.x = e.x - i.x, s.y = e.y - i.y, s
            }, t.Point.multiply = function(e, i, s) {
                return void 0 === s && (s = new t.Point), s.x = e.x * i.x, s.y = e.y * i.y, s
            }, t.Point.divide = function(e, i, s) {
                return void 0 === s && (s = new t.Point), s.x = e.x / i.x, s.y = e.y / i.y, s
            }, t.Point.equals = function(t, e) {
                return t.x === e.x && t.y === e.y
            }, t.Point.equalsXY = function(t, e, i) {
                return t.x === e && t.y === i
            }, t.Point.fuzzyEquals = function(e, i, s) {
                return t.Math.fuzzyEquals(e.x, i.x, s) && t.Math.fuzzyEquals(e.y, i.y, s)
            }, t.Point.fuzzyEqualsXY = function(e, i, s, n) {
                return t.Math.fuzzyEquals(e.x, i, n) && t.Math.fuzzyEquals(e.y, s, n)
            }, t.Point.angle = function(t, e) {
                return Math.atan2(t.y - e.y, t.x - e.x)
            }, t.Point.negative = function(e, i) {
                return void 0 === i && (i = new t.Point), i.setTo(-e.x, -e.y)
            }, t.Point.multiplyAdd = function(e, i, s, n) {
                return void 0 === n && (n = new t.Point), n.setTo(e.x + i.x * s, e.y + i.y * s)
            }, t.Point.interpolate = function(e, i, s, n) {
                return void 0 === n && (n = new t.Point), n.setTo(e.x + (i.x - e.x) * s, e.y + (i.y - e.y) * s)
            }, t.Point.perp = function(e, i) {
                return void 0 === i && (i = new t.Point), i.setTo(-e.y, e.x)
            }, t.Point.rperp = function(e, i) {
                return void 0 === i && (i = new t.Point), i.setTo(e.y, -e.x)
            }, t.Point.distance = function(e, i, s) {
                var n = t.Math.distance(e.x, e.y, i.x, i.y);
                return s ? Math.round(n) : n
            }, t.Point.project = function(e, i, s) {
                void 0 === s && (s = new t.Point);
                var n = e.dot(i) / i.getMagnitudeSq();
                return 0 !== n && s.setTo(n * i.x, n * i.y), s
            }, t.Point.projectUnit = function(e, i, s) {
                void 0 === s && (s = new t.Point);
                var n = e.dot(i);
                return 0 !== n && s.setTo(n * i.x, n * i.y), s
            }, t.Point.normalRightHand = function(e, i) {
                return void 0 === i && (i = new t.Point), i.setTo(-1 * e.y, e.x)
            }, t.Point.normalize = function(e, i) {
                void 0 === i && (i = new t.Point);
                var s = e.getMagnitude();
                return 0 !== s && i.setTo(e.x / s, e.y / s), i
            }, t.Point.rotate = function(e, i, s, n, r, o) {
                if (r && (n = t.Math.degToRad(n)), void 0 === o) {
                    e.subtract(i, s);
                    var a = Math.sin(n),
                        h = Math.cos(n),
                        l = h * e.x - a * e.y,
                        c = a * e.x + h * e.y;
                    e.x = l + i, e.y = c + s
                } else {
                    var u = n + Math.atan2(e.y - s, e.x - i);
                    e.x = i + o * Math.cos(u), e.y = s + o * Math.sin(u)
                }
                return e
            }, t.Point.centroid = function(e, i) {
                if (void 0 === i && (i = new t.Point), "[object Array]" !== Object.prototype.toString.call(e)) throw new Error("Phaser.Point. Parameter 'points' must be an array");
                var s = e.length;
                if (s < 1) throw new Error("Phaser.Point. Parameter 'points' array must not be empty");
                if (1 === s) return i.copyFrom(e[0]), i;
                for (var n = 0; n < s; n++) t.Point.add(i, e[n], i);
                return i.divide(s, s), i
            }, t.Point.parse = function(e, i, s) {
                i = i || "x", s = s || "y";
                var n = new t.Point;
                return e[i] && (n.x = parseFloat(e[i])), e[s] && (n.y = parseFloat(e[s])), n
            }, t.Point.trunc = function(e) {
                return e.x = t.Math.trunc(e.x), e.y = t.Math.trunc(e.y), e
            }, t.Point.isPoint = function(t) {
                return null != t && "number" == typeof t.x && "number" == typeof t.y
            }, t.Point.set = function(t, e, i) {
                return t.x = e || 0, t.y = i || (0 !== i ? t.x : 0), t
            }, t.Point.sortClockwise = function(t, e) {
                e || (e = this.centroid(t));
                var i = e.x,
                    s = e.y;
                return t.sort(function(t, e) {
                    if (t.x - i >= 0 && e.x - i < 0) return -1;
                    if (t.x - i < 0 && e.x - i >= 0) return 1;
                    if (t.x - i == 0 && e.x - i == 0) return t.y - s >= 0 || e.y - s >= 0 ? t.y > e.y ? 1 : -1 : e.y > t.y ? 1 : -1;
                    var n = (t.x - i) * -(e.y - s) - (e.x - i) * -(t.y - s);
                    return n < 0 ? -1 : n > 0 ? 1 : (t.x - i) * (t.x - i) + (t.y - s) * (t.y - s) > (e.x - i) * (e.x - i) + (e.y - s) * (e.y - s) ? -1 : 1
                })
            }, PIXI.Point = t.Point, t.Polygon = function() {
                this.area = 0, this._points = [], arguments.length > 0 && this.setTo.apply(this, arguments), this.closed = !0, this.flattened = !1, this.type = t.POLYGON
            }, t.Polygon.prototype = {
                toNumberArray: function(t) {
                    void 0 === t && (t = []);
                    for (var e = 0; e < this._points.length; e++) "number" == typeof this._points[e] ? (t.push(this._points[e]), t.push(this._points[e + 1]), e++) : (t.push(this._points[e].x), t.push(this._points[e].y));
                    return t
                },
                flatten: function() {
                    return this._points = this.toNumberArray(), this.flattened = !0, this
                },
                clone: function(e) {
                    var i = this._points.slice();
                    return null == e ? e = new t.Polygon(i) : e.setTo(i), e
                },
                contains: function(t, e) {
                    var i = !1;
                    if (this.flattened)
                        for (var s = -2, n = this._points.length - 2;
                            (s += 2) < this._points.length; n = s) {
                            var r = this._points[s],
                                o = this._points[s + 1],
                                a = this._points[n],
                                h = this._points[n + 1];
                            (o <= e && e < h || h <= e && e < o) && t < (a - r) * (e - o) / (h - o) + r && (i = !i)
                        } else
                            for (s = -1, n = this._points.length - 1; ++s < this._points.length; n = s) {
                                r = this._points[s].x, o = this._points[s].y, a = this._points[n].x, h = this._points[n].y;
                                (o <= e && e < h || h <= e && e < o) && t < (a - r) * (e - o) / (h - o) + r && (i = !i)
                            }
                    return i
                },
                setTo: function(t) {
                    if (this.area = 0, this._points = [], arguments.length > 0) {
                        Array.isArray(t) || (t = Array.prototype.slice.call(arguments));
                        for (var e = Number.MAX_VALUE, i = 0, s = t.length; i < s; i++) {
                            if ("number" == typeof t[i]) n = new PIXI.Point(t[i], t[i + 1]), i++;
                            else if (Array.isArray(t[i])) n = new PIXI.Point(t[i][0], t[i][1]);
                            else var n = new PIXI.Point(t[i].x, t[i].y);
                            this._points.push(n), n.y < e && (e = n.y)
                        }
                        this.calculateArea(e)
                    }
                    return this
                },
                calculateArea: function(t) {
                    for (var e, i, s, n, r = 0, o = this._points.length; r < o; r++) e = this._points[r], i = r === o - 1 ? this._points[0] : this._points[r + 1], s = (e.y - t + (i.y - t)) / 2, n = e.x - i.x, this.area += s * n;
                    return this.area
                }
            }, t.Polygon.prototype.constructor = t.Polygon, Object.defineProperty(t.Polygon.prototype, "points", {
                get: function() {
                    return this._points
                }
            }), PIXI.Polygon = t.Polygon, t.Rectangle = function(e, i, s, n) {
                e = e || 0, i = i || 0, s = s || 0, n = n || 0, this.x = e, this.y = i, this.width = s, this.height = n, this.type = t.RECTANGLE
            }, t.Rectangle.prototype = {
                offset: function(t, e) {
                    return this.x += t, this.y += e, this
                },
                offsetPoint: function(t) {
                    return this.offset(t.x, t.y)
                },
                setTo: function(t, e, i, s) {
                    return this.x = t, this.y = e, this.width = i, this.height = s, this
                },
                scale: function(t, e) {
                    return void 0 === e && (e = t), this.width *= t, this.height *= e, this
                },
                centerOn: function(t, e) {
                    return this.centerX = t, this.centerY = e, this
                },
                floor: function() {
                    this.x = Math.floor(this.x), this.y = Math.floor(this.y)
                },
                floorAll: function() {
                    this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.width = Math.floor(this.width), this.height = Math.floor(this.height)
                },
                ceil: function() {
                    this.x = Math.ceil(this.x), this.y = Math.ceil(this.y)
                },
                ceilAll: function() {
                    this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.width = Math.ceil(this.width), this.height = Math.ceil(this.height)
                },
                copyFrom: function(t) {
                    return this.setTo(t.x, t.y, t.width, t.height)
                },
                copyFromBounds: function(t) {
                    return this.setTo(t.left, t.top, t.width, t.height)
                },
                copyTo: function(t) {
                    return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
                },
                inflate: function(e, i) {
                    return t.Rectangle.inflate(this, e, i)
                },
                size: function(e) {
                    return t.Rectangle.size(this, e)
                },
                resize: function(t, e) {
                    return this.width = t, this.height = e, this
                },
                clone: function(e) {
                    return t.Rectangle.clone(this, e)
                },
                contains: function(e, i) {
                    return t.Rectangle.contains(this, e, i)
                },
                containsRect: function(e) {
                    return t.Rectangle.containsRect(e, this)
                },
                equals: function(e) {
                    return t.Rectangle.equals(this, e)
                },
                intersection: function(e, i) {
                    return t.Rectangle.intersection(this, e, i)
                },
                intersects: function(e) {
                    return t.Rectangle.intersects(this, e)
                },
                intersectsRaw: function(e, i, s, n, r) {
                    return t.Rectangle.intersectsRaw(this, e, i, s, n, r)
                },
                union: function(e, i) {
                    return t.Rectangle.union(this, e, i)
                },
                random: function(e) {
                    return void 0 === e && (e = new t.Point), e.x = this.randomX, e.y = this.randomY, e
                },
                getPoint: function(e, i) {
                    switch (void 0 === i && (i = new t.Point), e) {
                        default:
                            case t.TOP_LEFT:
                            return i.set(this.x, this.y);
                        case t.TOP_CENTER:
                                return i.set(this.centerX, this.y);
                        case t.TOP_RIGHT:
                                return i.set(this.right, this.y);
                        case t.LEFT_CENTER:
                                return i.set(this.x, this.centerY);
                        case t.CENTER:
                                return i.set(this.centerX, this.centerY);
                        case t.RIGHT_CENTER:
                                return i.set(this.right, this.centerY);
                        case t.BOTTOM_LEFT:
                                return i.set(this.x, this.bottom);
                        case t.BOTTOM_CENTER:
                                return i.set(this.centerX, this.bottom);
                        case t.BOTTOM_RIGHT:
                                return i.set(this.right, this.bottom)
                    }
                },
                sides: function(e, i, s, n) {
                    arguments.length || (e = new t.Line, i = new t.Line, s = new t.Line, n = new t.Line);
                    var r = this.x,
                        o = this.y,
                        a = this.right,
                        h = this.bottom;
                    return e.setTo(r, o, a, o), i.setTo(a, o, a, h), s.setTo(r, h, a, h), n.setTo(r, o, r, h), arguments.length ? null : [e, i, s, n]
                },
                toString: function() {
                    return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " empty=" + this.empty + ")}]"
                }
            }, Object.defineProperty(t.Rectangle.prototype, "halfWidth", {
                get: function() {
                    return Math.round(this.width / 2)
                }
            }), Object.defineProperty(t.Rectangle.prototype, "halfHeight", {
                get: function() {
                    return Math.round(this.height / 2)
                }
            }), Object.defineProperty(t.Rectangle.prototype, "bottom", {
                get: function() {
                    return this.y + this.height
                },
                set: function(t) {
                    t <= this.y ? this.height = 0 : this.height = t - this.y
                }
            }), Object.defineProperty(t.Rectangle.prototype, "bottomLeft", {
                get: function() {
                    return new t.Point(this.x, this.bottom)
                },
                set: function(t) {
                    this.x = t.x, this.bottom = t.y
                }
            }), Object.defineProperty(t.Rectangle.prototype, "bottomRight", {
                get: function() {
                    return new t.Point(this.right, this.bottom)
                },
                set: function(t) {
                    this.right = t.x, this.bottom = t.y
                }
            }), Object.defineProperty(t.Rectangle.prototype, "left", {
                get: function() {
                    return this.x
                },
                set: function(t) {
                    t >= this.right ? this.width = 0 : this.width = this.right - t, this.x = t
                }
            }), Object.defineProperty(t.Rectangle.prototype, "right", {
                get: function() {
                    return this.x + this.width
                },
                set: function(t) {
                    t <= this.x ? this.width = 0 : this.width = t - this.x
                }
            }), Object.defineProperty(t.Rectangle.prototype, "volume", {
                get: function() {
                    return this.width * this.height
                }
            }), Object.defineProperty(t.Rectangle.prototype, "perimeter", {
                get: function() {
                    return 2 * this.width + 2 * this.height
                }
            }), Object.defineProperty(t.Rectangle.prototype, "centerX", {
                get: function() {
                    return this.x + this.halfWidth
                },
                set: function(t) {
                    this.x = t - this.halfWidth
                }
            }), Object.defineProperty(t.Rectangle.prototype, "centerY", {
                get: function() {
                    return this.y + this.halfHeight
                },
                set: function(t) {
                    this.y = t - this.halfHeight
                }
            }), Object.defineProperty(t.Rectangle.prototype, "randomX", {
                get: function() {
                    return this.x + Math.random() * this.width
                }
            }), Object.defineProperty(t.Rectangle.prototype, "randomY", {
                get: function() {
                    return this.y + Math.random() * this.height
                }
            }), Object.defineProperty(t.Rectangle.prototype, "top", {
                get: function() {
                    return this.y
                },
                set: function(t) {
                    t >= this.bottom ? (this.height = 0, this.y = t) : this.height = this.bottom - t
                }
            }), Object.defineProperty(t.Rectangle.prototype, "topLeft", {
                get: function() {
                    return new t.Point(this.x, this.y)
                },
                set: function(t) {
                    this.x = t.x, this.y = t.y
                }
            }), Object.defineProperty(t.Rectangle.prototype, "topRight", {
                get: function() {
                    return new t.Point(this.x + this.width, this.y)
                },
                set: function(t) {
                    this.right = t.x, this.y = t.y
                }
            }), Object.defineProperty(t.Rectangle.prototype, "empty", {
                get: function() {
                    return !this.width || !this.height
                },
                set: function(t) {
                    !0 === t && this.setTo(0, 0, 0, 0)
                }
            }), t.Rectangle.prototype.constructor = t.Rectangle, t.Rectangle.inflate = function(t, e, i) {
                return t.x -= e, t.width += 2 * e, t.y -= i, t.height += 2 * i, t
            }, t.Rectangle.inflatePoint = function(e, i) {
                return t.Rectangle.inflate(e, i.x, i.y)
            }, t.Rectangle.size = function(e, i) {
                return null == i ? i = new t.Point(e.width, e.height) : i.setTo(e.width, e.height), i
            }, t.Rectangle.clone = function(e, i) {
                return null == i ? i = new t.Rectangle(e.x, e.y, e.width, e.height) : i.setTo(e.x, e.y, e.width, e.height), i
            }, t.Rectangle.createFromBounds = function(e, i) {
                return null != i || (i = new t.Rectangle(e.x, e.y, e.width, e.height)), i.copyFromBounds(e)
            }, t.Rectangle.contains = function(t, e, i) {
                return !(t.width <= 0 || t.height <= 0) && e >= t.x && e < t.right && i >= t.y && i < t.bottom
            }, t.Rectangle.containsRaw = function(t, e, i, s, n, r) {
                return n >= t && n < t + i && r >= e && r < e + s
            }, t.Rectangle.containsPoint = function(e, i) {
                return t.Rectangle.contains(e, i.x, i.y)
            }, t.Rectangle.containsRect = function(t, e) {
                return !(t.volume > e.volume) && t.x >= e.x && t.y >= e.y && t.right < e.right && t.bottom < e.bottom
            }, t.Rectangle.equals = function(t, e) {
                return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height
            }, t.Rectangle.sameDimensions = function(t, e) {
                return t.width === e.width && t.height === e.height
            }, t.Rectangle.intersection = function(e, i, s) {
                return void 0 === s && (s = new t.Rectangle), t.Rectangle.intersects(e, i) && (s.x = Math.max(e.x, i.x), s.y = Math.max(e.y, i.y), s.width = Math.min(e.right, i.right) - s.x, s.height = Math.min(e.bottom, i.bottom) - s.y), s
            }, t.Rectangle.intersects = function(t, e) {
                return !(t.width <= 0 || t.height <= 0 || e.width <= 0 || e.height <= 0 || t.right < e.x || t.bottom < e.y || t.x > e.right || t.y > e.bottom)
            }, t.Rectangle.intersectsRaw = function(t, e, i, s, n, r) {
                return void 0 === r && (r = 0), !(e > t.right + r || i < t.left - r || s > t.bottom + r || n < t.top - r)
            }, t.Rectangle.union = function(e, i, s) {
                return void 0 === s && (s = new t.Rectangle), s.setTo(Math.min(e.x, i.x), Math.min(e.y, i.y), Math.max(e.right, i.right) - Math.min(e.left, i.left), Math.max(e.bottom, i.bottom) - Math.min(e.top, i.top))
            }, t.Rectangle.aabb = function(e, i) {
                void 0 === i && (i = new t.Rectangle);
                var s = Number.NEGATIVE_INFINITY,
                    n = Number.POSITIVE_INFINITY,
                    r = Number.NEGATIVE_INFINITY,
                    o = Number.POSITIVE_INFINITY;
                return e.forEach(function(t) {
                    t.x > s && (s = t.x), t.x < n && (n = t.x), t.y > r && (r = t.y), t.y < o && (o = t.y)
                }), i.setTo(n, o, s - n, r - o), i
            }, PIXI.Rectangle = t.Rectangle, t.EmptyRectangle = new t.Rectangle(0, 0, 0, 0), t.RoundedRectangle = function(e, i, s, n, r) {
                void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === n && (n = 0), void 0 === r && (r = 20), this.x = e, this.y = i, this.width = s, this.height = n, this.radius = r || 20, this.type = t.ROUNDEDRECTANGLE
            }, t.RoundedRectangle.prototype = {
                clone: function() {
                    return new t.RoundedRectangle(this.x, this.y, this.width, this.height, this.radius)
                },
                contains: function(t, e) {
                    if (this.width <= 0 || this.height <= 0) return !1;
                    var i = this.x;
                    if (t >= i && t <= i + this.width) {
                        var s = this.y;
                        if (e >= s && e <= s + this.height) return !0
                    }
                    return !1
                }
            }, t.RoundedRectangle.prototype.constructor = t.RoundedRectangle, PIXI.RoundedRectangle = t.RoundedRectangle, t.Camera = function(e, i, s, n, r, o) {
                this.game = e, this.world = e.world, this.id = 0, this.view = new t.Rectangle(s, n, r, o), this.bounds = new t.Rectangle(s, n, r, o), this.deadzone = null, this.visible = !0, this.roundPx = !0, this.atLimit = {
                    x: !1,
                    y: !1
                }, this.target = null, this.displayObject = null, this.scale = null, this.totalInView = 0, this.lerp = new t.Point(1, 1), this.onShakeComplete = new t.Signal, this.onFlashComplete = new t.Signal, this.onFadeComplete = new t.Signal, this.fx = null, this._targetPosition = new t.Point, this._edge = 0, this._position = new t.Point, this._shake = {
                    intensity: 0,
                    duration: 0,
                    horizontal: !1,
                    vertical: !1,
                    shakeBounds: !0,
                    x: 0,
                    y: 0
                }, this._fxDuration = 0, this._fxType = 0, this._fixedView = new t.Rectangle
            }, t.Camera.FOLLOW_LOCKON = 0, t.Camera.FOLLOW_PLATFORMER = 1, t.Camera.FOLLOW_TOPDOWN = 2, t.Camera.FOLLOW_TOPDOWN_TIGHT = 3, t.Camera.SHAKE_BOTH = 4, t.Camera.SHAKE_HORIZONTAL = 5, t.Camera.SHAKE_VERTICAL = 6, t.Camera.ENABLE_FX = !0, t.Camera.prototype = {
                boot: function() {
                    this.displayObject = this.game.world, this.scale = this.game.world.scale, this.game.camera = this, t.Graphics && t.Camera.ENABLE_FX && (this.fx = new t.Graphics(this.game), this.game.stage.addChild(this.fx))
                },
                preUpdate: function() {
                    this.totalInView = 0
                },
                follow: function(e, i, s, n) {
                    var r;
                    switch (void 0 === i && (i = t.Camera.FOLLOW_LOCKON), void 0 === s && (s = 1), void 0 === n && (n = 1), this.target = e, this.lerp.set(s, n), i) {
                        case t.Camera.FOLLOW_PLATFORMER:
                            var o = this.width / 8,
                                a = this.height / 3;
                            this.deadzone = new t.Rectangle((this.width - o) / 2, (this.height - a) / 2 - .25 * a, o, a);
                            break;
                        case t.Camera.FOLLOW_TOPDOWN:
                            r = Math.max(this.width, this.height) / 4, this.deadzone = new t.Rectangle((this.width - r) / 2, (this.height - r) / 2, r, r);
                            break;
                        case t.Camera.FOLLOW_TOPDOWN_TIGHT:
                            r = Math.max(this.width, this.height) / 8, this.deadzone = new t.Rectangle((this.width - r) / 2, (this.height - r) / 2, r, r);
                            break;
                        case t.Camera.FOLLOW_LOCKON:
                        default:
                            this.deadzone = null
                    }
                },
                unfollow: function() {
                    this.target = null
                },
                focusOn: function(t) {
                    this.setPosition(Math.round(t.x - this.view.halfWidth), Math.round(t.y - this.view.halfHeight))
                },
                focusOnXY: function(t, e) {
                    this.setPosition(Math.round(t - this.view.halfWidth), Math.round(e - this.view.halfHeight))
                },
                shake: function(e, i, s, n, r) {
                    return void 0 === e && (e = .05), void 0 === i && (i = 500), void 0 === s && (s = !0), void 0 === n && (n = t.Camera.SHAKE_BOTH), void 0 === r && (r = !0), !(!s && this._shake.duration > 0 || (this._shake.intensity = e, this._shake.duration = i, this._shake.shakeBounds = r, this._shake.x = 0, this._shake.y = 0, this._shake.horizontal = n === t.Camera.SHAKE_BOTH || n === t.Camera.SHAKE_HORIZONTAL, this._shake.vertical = n === t.Camera.SHAKE_BOTH || n === t.Camera.SHAKE_VERTICAL, 0))
                },
                flash: function(t, e, i, s) {
                    return void 0 === t && (t = 16777215), void 0 === e && (e = 500), void 0 === i && (i = !1), void 0 === s && (s = 1), !(!this.fx || !i && this._fxDuration > 0 || (this.fx.clear(), this.fx.beginFill(t, s), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 1, this._fxDuration = e, this._fxType = 0, 0))
                },
                fade: function(t, e, i, s) {
                    return void 0 === t && (t = 0), void 0 === e && (e = 500), void 0 === i && (i = !1), void 0 === s && (s = 1), !(!this.fx || !i && this._fxDuration > 0 || (this.fx.clear(), this.fx.beginFill(t, s), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 0, this._fxDuration = e, this._fxType = 1, 0))
                },
                update: function() {
                    this._fxDuration > 0 && this.updateFX(), this._shake.duration > 0 && this.updateShake(), this.bounds && this.checkBounds(), this.roundPx && (this.view.floor(), this._shake.x = Math.floor(this._shake.x), this._shake.y = Math.floor(this._shake.y)), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y
                },
                updateFX: function() {
                    0 === this._fxType ? (this.fx.alpha -= this.game.time.elapsedMS / this._fxDuration, this.fx.alpha <= 0 && (this._fxDuration = 0, this.fx.alpha = 0, this.onFlashComplete.dispatch())) : (this.fx.alpha += this.game.time.elapsedMS / this._fxDuration, this.fx.alpha >= 1 && (this._fxDuration = 0, this.fx.alpha = 1, this.onFadeComplete.dispatch()))
                },
                updateShake: function() {
                    this._shake.duration -= this.game.time.elapsedMS, this._shake.duration <= 0 ? (this.onShakeComplete.dispatch(), this._shake.x = 0, this._shake.y = 0) : (this._shake.horizontal && (this._shake.x = this.game.rnd.frac() * this._shake.intensity * this.view.width * 2 - this._shake.intensity * this.view.width), this._shake.vertical && (this._shake.y = this.game.rnd.frac() * this._shake.intensity * this.view.height * 2 - this._shake.intensity * this.view.height))
                },
                updateTarget: function() {
                    this._targetPosition.x = this.view.x + this.target.worldPosition.x, this._targetPosition.y = this.view.y + this.target.worldPosition.y, this.deadzone ? (this._edge = this._targetPosition.x - this.view.x, this._edge < this.deadzone.left ? this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.left, this.lerp.x) : this._edge > this.deadzone.right && (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.right, this.lerp.x)), this._edge = this._targetPosition.y - this.view.y, this._edge < this.deadzone.top ? this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.top, this.lerp.y) : this._edge > this.deadzone.bottom && (this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.bottom, this.lerp.y))) : (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.view.halfWidth, this.lerp.x), this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.view.halfHeight, this.lerp.y)), this.bounds && this.checkBounds(), this.roundPx && this.view.floor(), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y
                },
                setBoundsToWorld: function() {
                    this.bounds && this.bounds.copyFrom(this.game.world.bounds)
                },
                checkBounds: function() {
                    this.atLimit.x = !1, this.atLimit.y = !1;
                    var t = this.view.x + this._shake.x,
                        e = this.view.right + this._shake.x,
                        i = this.view.y + this._shake.y,
                        s = this.view.bottom + this._shake.y;
                    t <= this.bounds.x * this.scale.x ? (this.atLimit.x = !0, this.view.x = this.bounds.x * this.scale.x, this._shake.shakeBounds || (this._shake.x = 0)) : e >= this.bounds.right * this.scale.x && (this.atLimit.x = !0, this.view.x = this.bounds.right * this.scale.x - this.width, this._shake.shakeBounds || (this._shake.x = 0)), i <= this.bounds.top * this.scale.y ? (this.atLimit.y = !0, this.view.y = this.bounds.top * this.scale.y, this._shake.shakeBounds || (this._shake.y = 0)) : s >= this.bounds.bottom * this.scale.y && (this.atLimit.y = !0, this.view.y = this.bounds.bottom * this.scale.y - this.height, this._shake.shakeBounds || (this._shake.y = 0))
                },
                setPosition: function(t, e) {
                    this.view.x = t, this.view.y = e, this.bounds && this.checkBounds()
                },
                setSize: function(t, e) {
                    this.view.width = t, this.view.height = e
                },
                reset: function() {
                    this.target = null, this.view.x = 0, this.view.y = 0, this._shake.duration = 0, this._shake.x = 0, this._shake.y = 0, this.resetFX()
                },
                resetFX: function() {
                    this.fx && (this.fx.clear(), this.fx.alpha = 0), this._fxDuration = 0
                }
            }, t.Camera.prototype.constructor = t.Camera, Object.defineProperty(t.Camera.prototype, "x", {
                get: function() {
                    return this.view.x
                },
                set: function(t) {
                    this.view.x = t, this.bounds && this.checkBounds()
                }
            }), Object.defineProperty(t.Camera.prototype, "y", {
                get: function() {
                    return this.view.y
                },
                set: function(t) {
                    this.view.y = t, this.bounds && this.checkBounds()
                }
            }), Object.defineProperty(t.Camera.prototype, "position", {
                get: function() {
                    return this._position.set(this.view.x, this.view.y), this._position
                },
                set: function(t) {
                    void 0 !== t.x && (this.view.x = t.x), void 0 !== t.y && (this.view.y = t.y), this.bounds && this.checkBounds()
                }
            }), Object.defineProperty(t.Camera.prototype, "width", {
                get: function() {
                    return this.view.width
                },
                set: function(t) {
                    this.view.width = t
                }
            }), Object.defineProperty(t.Camera.prototype, "height", {
                get: function() {
                    return this.view.height
                },
                set: function(t) {
                    this.view.height = t
                }
            }), Object.defineProperty(t.Camera.prototype, "shakeIntensity", {
                get: function() {
                    return this._shake.intensity
                },
                set: function(t) {
                    this._shake.intensity = t
                }
            }), Object.defineProperty(t.Camera.prototype, "fixedView", {
                get: function() {
                    return this._fixedView.setTo(0, 0, this.view.width, this.view.height), this._fixedView
                }
            }), Object.defineProperty(t.Camera.prototype, "centerX", {
                get: function() {
                    return this.x + .5 * this.width
                }
            }), Object.defineProperty(t.Camera.prototype, "centerY", {
                get: function() {
                    return this.y + .5 * this.height
                }
            }), t.State = function() {
                this.game = null, this.key = "", this.add = null, this.make = null, this.camera = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.sound = null, this.scale = null, this.stage = null, this.state = null, this.time = null, this.tweens = null, this.world = null, this.particles = null, this.physics = null, this.rnd = null
            }, t.State.prototype = {
                init: function() {},
                preload: function() {},
                loadUpdate: function() {},
                loadRender: function() {},
                create: function() {},
                update: function() {},
                postUpdate: function() {},
                preRender: function() {},
                render: function() {},
                resize: function() {},
                paused: function() {},
                resumed: function() {},
                pauseUpdate: function() {},
                shutdown: function() {}
            }, t.State.prototype.constructor = t.State, t.StateManager = function(e, i) {
                this.game = e, this.states = {}, this._pendingState = null, null != i && (this._pendingState = i), this._clearWorld = !1, this._clearCache = !1, this._created = !1, this._args = [], this.current = "", this.onStateChange = new t.Signal, this.onInitCallback = null, this.onPreloadCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPreRenderCallback = null, this.onLoadUpdateCallback = null, this.onLoadRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.onShutDownCallback = null
            }, t.StateManager.prototype = {
                boot: function() {
                    this.game.onPause.add(this.pause, this), this.game.onResume.add(this.resume, this), null !== this._pendingState && "string" != typeof this._pendingState && this.add("default", this._pendingState, !0)
                },
                add: function(e, i, s) {
                    var n;
                    return void 0 === s && (s = !1), i instanceof t.State ? n = i : "object" == typeof i ? (n = i).game = this.game : "function" == typeof i && (n = new i(this.game)), this.states[e] = n, s && (this.game.isBooted ? this.start(e) : this._pendingState = e), n
                },
                remove: function(t) {
                    this.current === t && (this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onPreRenderCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null), delete this.states[t]
                },
                start: function(t, e, i) {
                    void 0 === e && (e = !0), void 0 === i && (i = !1), this.checkState(t) && (this._pendingState = t, this._clearWorld = e, this._clearCache = i, arguments.length > 3 && (this._args = Array.prototype.splice.call(arguments, 3)))
                },
                restart: function(t, e) {
                    void 0 === t && (t = !0), void 0 === e && (e = !1), this._pendingState = this.current, this._clearWorld = t, this._clearCache = e, arguments.length > 2 && (this._args = Array.prototype.slice.call(arguments, 2))
                },
                dummy: function() {},
                preUpdate: function() {
                    if (this._pendingState && this.game.isBooted) {
                        var t = this.current;
                        if (this.clearCurrentState(), this.setCurrentState(this._pendingState), this.onStateChange.dispatch(this.current, t), this.current !== this._pendingState) return;
                        this._pendingState = null, this.onPreloadCallback ? (this.game.load.reset(!0), this.onPreloadCallback.call(this.callbackContext, this.game), 0 === this.game.load.totalQueuedFiles() && 0 === this.game.load.totalQueuedPacks() ? this.loadComplete() : this.game.load.start()) : this.loadComplete()
                    }
                },
                clearCurrentState: function() {
                    this.current && (this.onShutDownCallback && this.onShutDownCallback.call(this.callbackContext, this.game), this.game.tweens.removeAll(), this.game.camera.reset(), this.game.input.reset(!0), this.game.physics.clear(), this.game.time.removeAll(), this.game.scale.reset(this._clearWorld), this.game.debug && this.game.debug.reset(), this._clearWorld && (this.game.world.shutdown(), this._clearCache && this.game.cache.destroy()))
                },
                checkState: function(t) {
                    var e = this.states[t];
                    return e ? !!(e.preload || e.create || e.update || e.render) || (console.warn("Invalid Phaser State object given. Must contain at least one of the required functions: preload, create, update or render"), !1) : (console.warn("Phaser.StateManager - No state found with the key: " + t), !1)
                },
                link: function(t) {
                    var e = this.states[t];
                    e.game = this.game, e.add = this.game.add, e.make = this.game.make, e.camera = this.game.camera, e.cache = this.game.cache, e.input = this.game.input, e.load = this.game.load, e.math = this.game.math, e.sound = this.game.sound, e.scale = this.game.scale, e.state = this, e.stage = this.game.stage, e.time = this.game.time, e.tweens = this.game.tweens, e.world = this.game.world, e.particles = this.game.particles, e.rnd = this.game.rnd, e.physics = this.game.physics, e.key = t
                },
                unlink: function(t) {
                    var e = this.states[t];
                    e && (e.game = null, e.add = null, e.make = null, e.camera = null, e.cache = null, e.input = null, e.load = null, e.math = null, e.sound = null, e.scale = null, e.state = null, e.stage = null, e.time = null, e.tweens = null, e.world = null, e.particles = null, e.rnd = null, e.physics = null)
                },
                setCurrentState: function(t) {
                    var e = this.states[t];
                    this.callbackContext = e, this.link(t), this.onInitCallback = e.init || this.dummy, this.onPreloadCallback = e.preload || null, this.onLoadRenderCallback = e.loadRender || null, this.onLoadUpdateCallback = e.loadUpdate || null, this.onCreateCallback = e.create || null, this.onUpdateCallback = e.update || null, this.onPostUpdateCallback = e.postUpdate || null, this.onPreRenderCallback = e.preRender || null, this.onRenderCallback = e.render || null, this.onResizeCallback = e.resize || null, this.onPausedCallback = e.paused || null, this.onResumedCallback = e.resumed || null, this.onPauseUpdateCallback = e.pauseUpdate || null, this.onShutDownCallback = e.shutdown || this.dummy, "" !== this.current && this.game.physics.reset(), this.current = t, this._created = !1, this.onInitCallback.apply(this.callbackContext, this._args), t === this._pendingState && (this._args = []), this.game._kickstart = !0
                },
                getCurrentState: function() {
                    return this.states[this.current]
                },
                loadComplete: function() {
                    !1 === this._created && this.onCreateCallback ? (this._created = !0, this.onCreateCallback.call(this.callbackContext, this.game)) : this._created = !0
                },
                loadUpdate: function() {
                    !1 === this._created && this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
                },
                pause: function() {
                    this._created && this.onPausedCallback && this.onPausedCallback.call(this.callbackContext, this.game)
                },
                resume: function() {
                    this._created && this.onResumedCallback && this.onResumedCallback.call(this.callbackContext, this.game)
                },
                update: function() {
                    this._created ? this.onUpdateCallback && this.onUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
                },
                postUpdate: function() {
                    this._created && this.onPostUpdateCallback && this.onPostUpdateCallback.call(this.callbackContext, this.game)
                },
                pauseUpdate: function() {
                    this._created ? this.onPauseUpdateCallback && this.onPauseUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
                },
                preRender: function(t) {
                    this._created && this.onPreRenderCallback && this.onPreRenderCallback.call(this.callbackContext, this.game, t)
                },
                resize: function(t, e) {
                    this.onResizeCallback && this.onResizeCallback.call(this.callbackContext, t, e)
                },
                render: function() {
                    this._created ? this.onRenderCallback && (this.game.renderType === t.CANVAS ? (this.game.context.save(), this.game.context.setTransform(1, 0, 0, 1, 0, 0), this.onRenderCallback.call(this.callbackContext, this.game), this.game.context.restore()) : this.onRenderCallback.call(this.callbackContext, this.game)) : this.onLoadRenderCallback && this.onLoadRenderCallback.call(this.callbackContext, this.game)
                },
                destroy: function() {
                    this._clearWorld = !0, this._clearCache = !0, this.clearCurrentState(), this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onPostUpdateCallback = null, this.onRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.game = null, this.states = {}, this._pendingState = null, this.current = ""
                }
            }, t.StateManager.prototype.constructor = t.StateManager, Object.defineProperty(t.StateManager.prototype, "created", {
                get: function() {
                    return this._created
                }
            }), t.Signal = function() {}, t.Signal.prototype = {
                _bindings: null,
                _prevParams: null,
                memorize: !1,
                _shouldPropagate: !0,
                active: !0,
                _boundDispatch: !1,
                validateListener: function(t, e) {
                    if ("function" != typeof t) throw new Error("Phaser.Signal: listener is a required param of {fn}() and should be a Function.".replace("{fn}", e))
                },
                _registerListener: function(e, i, s, n, r) {
                    var o, a = this._indexOfListener(e, s);
                    if (-1 !== a) {
                        if ((o = this._bindings[a]).isOnce() !== i) throw new Error("You cannot add" + (i ? "" : "Once") + "() then add" + (i ? "Once" : "") + "() the same listener without removing the relationship first.")
                    } else o = new t.SignalBinding(this, e, i, s, n, r), this._addBinding(o);
                    return this.memorize && this._prevParams && o.execute(this._prevParams), o
                },
                _addBinding: function(t) {
                    this._bindings || (this._bindings = []);
                    var e = this._bindings.length;
                    do {
                        e--
                    } while (this._bindings[e] && t._priority <= this._bindings[e]._priority);
                    this._bindings.splice(e + 1, 0, t)
                },
                _indexOfListener: function(t, e) {
                    if (!this._bindings) return -1;
                    void 0 === e && (e = null);
                    for (var i, s = this._bindings.length; s--;)
                        if ((i = this._bindings[s])._listener === t && i.context === e) return s;
                    return -1
                },
                has: function(t, e) {
                    return -1 !== this._indexOfListener(t, e)
                },
                add: function(t, e, i) {
                    this.validateListener(t, "add");
                    var s = [];
                    if (arguments.length > 3)
                        for (var n = 3; n < arguments.length; n++) s.push(arguments[n]);
                    return this._registerListener(t, !1, e, i, s)
                },
                addOnce: function(t, e, i) {
                    this.validateListener(t, "addOnce");
                    var s = [];
                    if (arguments.length > 3)
                        for (var n = 3; n < arguments.length; n++) s.push(arguments[n]);
                    return this._registerListener(t, !0, e, i, s)
                },
                remove: function(t, e) {
                    this.validateListener(t, "remove");
                    var i = this._indexOfListener(t, e);
                    return -1 !== i && (this._bindings[i]._destroy(), this._bindings.splice(i, 1)), t
                },
                removeAll: function(t) {
                    if (void 0 === t && (t = null), this._bindings) {
                        for (var e = this._bindings.length; e--;) t ? this._bindings[e].context === t && (this._bindings[e]._destroy(), this._bindings.splice(e, 1)) : this._bindings[e]._destroy();
                        t || (this._bindings.length = 0)
                    }
                },
                getNumListeners: function() {
                    return this._bindings ? this._bindings.length : 0
                },
                halt: function() {
                    this._shouldPropagate = !1
                },
                dispatch: function() {
                    if (this.active && (this._bindings || this.memorize)) {
                        var t = Array.prototype.slice.call(arguments);
                        this.memorize && (this._prevParams = t);
                        var e = this._bindings ? this._bindings.length : 0;
                        if (e) {
                            var i = this._bindings.slice();
                            this._shouldPropagate = !0;
                            do {
                                e--
                            } while (i[e] && this._shouldPropagate && !1 !== i[e].execute(t))
                        }
                    }
                },
                forget: function() {
                    this._prevParams && (this._prevParams = null)
                },
                dispose: function() {
                    this.removeAll(), this._bindings = null, this._prevParams && (this._prevParams = null)
                },
                toString: function() {
                    return "[Phaser.Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]"
                }
            }, Object.defineProperty(t.Signal.prototype, "boundDispatch", {
                get: function() {
                    var t = this;
                    return this._boundDispatch || (this._boundDispatch = function() {
                        return t.dispatch.apply(t, arguments)
                    })
                }
            }), t.Signal.prototype.constructor = t.Signal, t.SignalBinding = function(t, e, i, s, n, r) {
                this._listener = e, i && (this._isOnce = !0), null != s && (this.context = s), this._signal = t, n && (this._priority = n), r && r.length && (this._args = r)
            }, t.SignalBinding.prototype = {
                context: null,
                _isOnce: !1,
                _priority: 0,
                _args: null,
                callCount: 0,
                active: !0,
                params: null,
                execute: function(t) {
                    var e, i;
                    return this.active && this._listener && (i = this.params ? this.params.concat(t) : t, this._args && (i = i.concat(this._args)), e = this._listener.apply(this.context, i), this.callCount++, this._isOnce && this.detach()), e
                },
                detach: function() {
                    return this.isBound() ? this._signal.remove(this._listener, this.context) : null
                },
                isBound: function() {
                    return !!this._signal && !!this._listener
                },
                isOnce: function() {
                    return this._isOnce
                },
                getListener: function() {
                    return this._listener
                },
                getSignal: function() {
                    return this._signal
                },
                _destroy: function() {
                    delete this._signal, delete this._listener, delete this.context
                },
                toString: function() {
                    return "[Phaser.SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]"
                }
            }, t.SignalBinding.prototype.constructor = t.SignalBinding, t.Filter = function(e, i, s) {
                this.game = e, this.type = t.WEBGL_FILTER, this.passes = [this], this.shaders = [], this.dirty = !0, this.padding = 0, this.prevPoint = new t.Point;
                var n = new Date;
                if (this.uniforms = {
                        resolution: {
                            type: "2f",
                            value: {
                                x: 256,
                                y: 256
                            }
                        },
                        time: {
                            type: "1f",
                            value: 0
                        },
                        mouse: {
                            type: "2f",
                            value: {
                                x: 0,
                                y: 0
                            }
                        },
                        date: {
                            type: "4fv",
                            value: [n.getFullYear(), n.getMonth(), n.getDate(), 60 * n.getHours() * 60 + 60 * n.getMinutes() + n.getSeconds()]
                        },
                        sampleRate: {
                            type: "1f",
                            value: 44100
                        },
                        iChannel0: {
                            type: "sampler2D",
                            value: null,
                            textureData: {
                                repeat: !0
                            }
                        },
                        iChannel1: {
                            type: "sampler2D",
                            value: null,
                            textureData: {
                                repeat: !0
                            }
                        },
                        iChannel2: {
                            type: "sampler2D",
                            value: null,
                            textureData: {
                                repeat: !0
                            }
                        },
                        iChannel3: {
                            type: "sampler2D",
                            value: null,
                            textureData: {
                                repeat: !0
                            }
                        }
                    }, i)
                    for (var r in i) this.uniforms[r] = i[r];
                "string" == typeof s && (s = s.split("\n")), this.fragmentSrc = s || []
            }, t.Filter.prototype = {
                init: function() {},
                setResolution: function(t, e) {
                    this.uniforms.resolution.value.x = t, this.uniforms.resolution.value.y = e
                },
                update: function(t) {
                    if (t) {
                        var e = t.x / this.game.width,
                            i = 1 - t.y / this.game.height;
                        e === this.prevPoint.x && i === this.prevPoint.y || (this.uniforms.mouse.value.x = e.toFixed(2), this.uniforms.mouse.value.y = i.toFixed(2), this.prevPoint.set(e, i))
                    }
                    this.uniforms.time.value = this.game.time.totalElapsedSeconds()
                },
                addToWorld: function(e, i, s, n, r, o) {
                    void 0 === r && (r = 0), void 0 === o && (o = 0), null != s ? this.width = s : s = this.width, null != n ? this.height = n : n = this.height;
                    var a = this.game.add.image(e, i, t.Cache.DEFAULT);
                    return a.width = s, a.height = n, a.anchor.set(r, o), a.filters = [this], a
                },
                syncUniforms: function() {
                    for (var t = 0; t < this.shaders.length; t++) this.shaders[t].dirty = !0
                },
                destroy: function() {
                    this.passes.length = 0, this.shaders.length = 0, this.fragmentSrc.length = 0, this.game = null, this.uniforms = null, this.prevPoint = null
                }
            }, t.Filter.prototype.constructor = t.Filter, Object.defineProperty(t.Filter.prototype, "width", {
                get: function() {
                    return this.uniforms.resolution.value.x
                },
                set: function(t) {
                    this.uniforms.resolution.value.x = t
                }
            }), Object.defineProperty(t.Filter.prototype, "height", {
                get: function() {
                    return this.uniforms.resolution.value.y
                },
                set: function(t) {
                    this.uniforms.resolution.value.y = t
                }
            }), t.Plugin = function(t, e) {
                void 0 === e && (e = null), this.game = t, this.parent = e, this.active = !1, this.visible = !1, this.hasPreUpdate = !1, this.hasUpdate = !1, this.hasPostUpdate = !1, this.hasRender = !1, this.hasPostRender = !1
            }, t.Plugin.prototype = {
                preUpdate: function() {},
                update: function() {},
                render: function() {},
                postRender: function() {},
                destroy: function() {
                    this.game = null, this.parent = null, this.active = !1, this.visible = !1
                }
            }, t.Plugin.prototype.constructor = t.Plugin, t.PluginManager = function(t) {
                this.game = t, this.plugins = [], this._len = 0, this._i = 0
            }, t.PluginManager.prototype = {
                add: function(t) {
                    var e = Array.prototype.slice.call(arguments, 1),
                        i = !1;
                    return "function" == typeof t ? t = new t(this.game, this) : (t.game = this.game, t.parent = this), "function" == typeof t.preUpdate && (t.hasPreUpdate = !0, i = !0), "function" == typeof t.update && (t.hasUpdate = !0, i = !0), "function" == typeof t.postUpdate && (t.hasPostUpdate = !0, i = !0), "function" == typeof t.render && (t.hasRender = !0, i = !0), "function" == typeof t.postRender && (t.hasPostRender = !0, i = !0), i ? ((t.hasPreUpdate || t.hasUpdate || t.hasPostUpdate) && (t.active = !0), (t.hasRender || t.hasPostRender) && (t.visible = !0), this._len = this.plugins.push(t), "function" == typeof t.init && t.init.apply(t, e), t) : null
                },
                remove: function(t, e) {
                    for (void 0 === e && (e = !0), this._i = this._len; this._i--;)
                        if (this.plugins[this._i] === t) return e && t.destroy(), this.plugins.splice(this._i, 1), void this._len--
                },
                removeAll: function() {
                    for (this._i = this._len; this._i--;) this.plugins[this._i].destroy();
                    this.plugins.length = 0, this._len = 0
                },
                preUpdate: function() {
                    for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPreUpdate && this.plugins[this._i].preUpdate()
                },
                update: function() {
                    for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasUpdate && this.plugins[this._i].update()
                },
                postUpdate: function() {
                    for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPostUpdate && this.plugins[this._i].postUpdate()
                },
                render: function() {
                    for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasRender && this.plugins[this._i].render()
                },
                postRender: function() {
                    for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasPostRender && this.plugins[this._i].postRender()
                },
                destroy: function() {
                    this.removeAll(), this.game = null
                }
            }, t.PluginManager.prototype.constructor = t.PluginManager, t.Stage = function(e) {
                this.game = e, PIXI.DisplayObjectContainer.call(this), this.name = "_stage_root", this.disableVisibilityChange = !1, this.exists = !0, this.worldTransform = new t.Matrix, this.stage = this, this.currentRenderOrderID = 0, this._hiddenVar = "hidden", this._onChange = null, this._bgColor = {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 0,
                    color: 0,
                    rgba: "#000000"
                }, this.game.transparent || (this._bgColor.a = 1), e.config && this.parseConfig(e.config)
            }, t.Stage.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), t.Stage.prototype.constructor = t.Stage, t.Stage.prototype.parseConfig = function(t) {
                t.disableVisibilityChange && (this.disableVisibilityChange = t.disableVisibilityChange), t.backgroundColor && this.setBackgroundColor(t.backgroundColor)
            }, t.Stage.prototype.boot = function() {
                t.DOM.getOffset(this.game.canvas, this.offset), t.Canvas.setUserSelect(this.game.canvas, "none"), t.Canvas.setTouchAction(this.game.canvas, "none"), this.checkVisibility()
            }, t.Stage.prototype.preUpdate = function() {
                this.currentRenderOrderID = 0;
                for (var t = 0; t < this.children.length;) {
                    var e = this.children[t];
                    e.preUpdate(), this === e.parent && t++
                }
            }, t.Stage.prototype.update = function() {
                for (var t = this.children.length; t--;) this.children[t].update()
            }, t.Stage.prototype.postUpdate = function() {
                this.game.camera.update(), this.game.camera.target && (this.game.camera.target.postUpdate(), this.updateTransform(), this.game.camera.updateTarget());
                for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate();
                this.updateTransform()
            }, t.Stage.prototype.updateTransform = function() {
                this.worldAlpha = 1;
                for (var t = 0; t < this.children.length; t++) this.children[t].updateTransform()
            }, t.Stage.prototype.checkVisibility = function() {
                void 0 !== document.hidden ? this._hiddenVar = "visibilitychange" : void 0 !== document.webkitHidden ? this._hiddenVar = "webkitvisibilitychange" : void 0 !== document.mozHidden ? this._hiddenVar = "mozvisibilitychange" : void 0 !== document.msHidden ? this._hiddenVar = "msvisibilitychange" : this._hiddenVar = null;
                var t = this;
                this._onChange = function(e) {
                    return t.visibilityChange(e)
                }, this._onChangePause = function() {
                    return t._onChange({
                        type: "pause"
                    })
                }, this._onChangeResume = function() {
                    return t._onChange({
                        type: "resume"
                    })
                }, this._onClick = function(e) {
                    void 0 === document.hasFocus || document.hasFocus() || t.visibilityChange(e)
                }, this._hiddenVar && document.addEventListener(this._hiddenVar, this._onChange, !1), window.onblur = this._onChange, window.onfocus = this._onChange, window.onpagehide = this._onChange, window.onpageshow = this._onChange, window.addEventListener("click", this._onClick), this.game.device.cocoonJSApp && CocoonJS.App && (CocoonJS.App.onSuspended && CocoonJS.App.onSuspended.addEventListener(this._onChangePause), CocoonJS.App.onActivated && CocoonJS.App.onActivated.addEventListener(this._onChangeResume), CocoonJS.App.on && (CocoonJS.App.on("activated", this._onChangeResume), CocoonJS.App.on("suspended", this._onChangePause)))
            }, t.Stage.prototype.visibilityChange = function(t) {
                switch (t.type) {
                    case "blur":
                    case "pagehide":
                        return void this.game.focusLoss(t);
                    case "click":
                    case "focus":
                    case "pageshow":
                        return void this.game.focusGain(t)
                }
                this.disableVisibilityChange || (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden || "pause" === t.type ? this.game.gamePaused(t) : this.game.gameResumed(t))
            }, t.Stage.prototype.setBackgroundColor = function(e) {
                this.game.transparent || (t.Color.valueToColor(e, this._bgColor), t.Color.updateColor(this._bgColor), this._bgColor.r /= 255, this._bgColor.g /= 255, this._bgColor.b /= 255, this._bgColor.a = 1)
            }, t.Stage.prototype.destroy = function() {
                this._hiddenVar && document.removeEventListener(this._hiddenVar, this._onChange, !1), window.onpagehide = null, window.onpageshow = null, window.onblur = null, window.onfocus = null, window.removeEventListener("click", this._onClick)
            }, t.Stage.prototype.add = function(t, e, i) {
                return t.parent === this ? t : (t.body && t.parent && t.parent.hash && t.parent.removeFromHash(t), void 0 === i ? this.addChild(t) : this.addChildAt(t, i), t)
            }, Object.defineProperty(t.Stage.prototype, "backgroundColor", {
                get: function() {
                    return this._bgColor.color
                },
                set: function(t) {
                    this.setBackgroundColor(t)
                }
            }), Object.defineProperty(t.Stage.prototype, "smoothed", {
                get: function() {
                    return PIXI.scaleModes.DEFAULT === PIXI.scaleModes.LINEAR
                },
                set: function(t) {
                    PIXI.scaleModes.DEFAULT = t ? PIXI.scaleModes.LINEAR : PIXI.scaleModes.NEAREST
                }
            }), t.Group = function(e, i, s, n, r, o) {
                void 0 === n && (n = !1), void 0 === r && (r = !1), void 0 === o && (o = t.Physics.ARCADE), this.game = e, void 0 === i && (i = e.world), this.name = s || "group", this.z = 0, PIXI.DisplayObjectContainer.call(this), n ? (this.game.stage.addChild(this), this.z = this.game.stage.children.length) : i && (i.addChild(this), this.z = i.children.length), this.type = t.GROUP, this.physicsType = t.GROUP, this.alive = !0, this.exists = !0, this.ignoreDestroy = !1, this.pendingDestroy = !1, this.classType = t.Sprite, this.cursor = null, this.inputEnableChildren = !1, this.updateOnlyExistingChildren = !1, this.onChildInputDown = new t.Signal, this.onChildInputUp = new t.Signal, this.onChildInputOver = new t.Signal, this.onChildInputOut = new t.Signal, this.enableBody = r, this.enableBodyDebug = !1, this.physicsBodyType = o, this.physicsSortDirection = null, this.onDestroy = new t.Signal, this.cursorIndex = 0, this.fixedToCamera = !1, this.cameraOffset = new t.Point, this.hash = [], this._sortProperty = "z"
            }, t.Group.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), t.Group.prototype.constructor = t.Group, t.Group.RETURN_NONE = 0, t.Group.RETURN_TOTAL = 1, t.Group.RETURN_CHILD = 2, t.Group.RETURN_ALL = 3, t.Group.SORT_ASCENDING = -1, t.Group.SORT_DESCENDING = 1, t.Group.prototype.add = function(t, e, i) {
                return void 0 === e && (e = !1), t.parent === this ? t : (t.body && t.parent && t.parent.hash && t.parent.removeFromHash(t), void 0 === i ? (t.z = this.children.length, this.addChild(t)) : (this.addChildAt(t, i), this.updateZ()), this.enableBody && t.hasOwnProperty("body") && null === t.body ? this.game.physics.enable(t, this.physicsBodyType) : t.body && this.addToHash(t), !this.inputEnableChildren || t.input && !t.inputEnabled || (t.inputEnabled = !0), !e && t.events && t.events.onAddedToGroup$dispatch(t, this), null === this.cursor && (this.cursor = t), t)
            }, t.Group.prototype.addAt = function(t, e, i) {
                return this.add(t, i, e)
            }, t.Group.prototype.addToHash = function(t) {
                return t.parent === this && -1 === this.hash.indexOf(t) && (this.hash.push(t), !0)
            }, t.Group.prototype.removeFromHash = function(t) {
                if (t) {
                    var e = this.hash.indexOf(t);
                    if (-1 !== e) return this.hash.splice(e, 1), !0
                }
                return !1
            }, t.Group.prototype.addMultiple = function(e, i) {
                if (e instanceof t.Group) e.moveAll(this, i);
                else if (Array.isArray(e))
                    for (var s = 0; s < e.length; s++) this.add(e[s], i);
                return e
            }, t.Group.prototype.getAt = function(t) {
                return t < 0 || t >= this.children.length ? -1 : this.getChildAt(t)
            }, t.Group.prototype.create = function(t, e, i, s, n, r) {
                void 0 === n && (n = !0);
                var o = new this.classType(this.game, t, e, i, s);
                return o.exists = n, o.visible = n, o.alive = n, this.add(o, !1, r)
            }, t.Group.prototype.createMultiple = function(t, e, i, s, n, r) {
                void 0 === i && (i = 0), void 0 === s && (s = !1), Array.isArray(e) || (e = [e]), Array.isArray(i) || (i = [i]);
                var o = this,
                    a = [];
                return e.forEach(function(e) {
                    i.forEach(function(i) {
                        for (var h = 0; h < t; h++) {
                            var l = o.create(0, 0, e, i, s);
                            n && n.call(r || l, l, h), a.push(l)
                        }
                    })
                }), a
            }, t.Group.prototype.updateZ = function() {
                for (var t = this.children.length; t--;) this.children[t].z = t
            }, t.Group.prototype.align = function(e, i, s, n, r, o) {
                if (void 0 === r && (r = t.TOP_LEFT), void 0 === o && (o = 0), 0 === this.children.length || o > this.children.length || -1 === e && -1 === i) return !1;
                for (var a = new t.Rectangle(0, 0, s, n), h = e * s, l = i * n, c = o; c < this.children.length; c++) {
                    var u = this.children[c];
                    if (u.alignIn)
                        if (u.alignIn(a, r), -1 === e) a.y += n, a.y === l && (a.x += s, a.y = 0);
                        else if (-1 === i) a.x += s, a.x === h && (a.x = 0, a.y += n);
                    else if (a.x += s, a.x === h && (a.x = 0, a.y += n, a.y === l)) return !0
                }
                return !0
            }, t.Group.prototype.resetCursor = function(t) {
                if (void 0 === t && (t = 0), t > this.children.length - 1 && (t = 0), this.cursor) return this.cursorIndex = t, this.cursor = this.children[this.cursorIndex], this.cursor
            }, t.Group.prototype.next = function() {
                if (this.cursor) return this.cursorIndex >= this.children.length - 1 ? this.cursorIndex = 0 : this.cursorIndex++, this.cursor = this.children[this.cursorIndex], this.cursor
            }, t.Group.prototype.previous = function() {
                if (this.cursor) return 0 === this.cursorIndex ? this.cursorIndex = this.children.length - 1 : this.cursorIndex--, this.cursor = this.children[this.cursorIndex], this.cursor
            }, t.Group.prototype.swap = function(t, e) {
                this.swapChildren(t, e), this.updateZ()
            }, t.Group.prototype.bringToTop = function(t) {
                return t.parent === this && this.getIndex(t) < this.children.length && (this.remove(t, !1, !0), this.add(t, !0)), t
            }, t.Group.prototype.bringChildToTop = t.Group.prototype.bringToTop, t.Group.prototype.sendToBack = function(t) {
                return t.parent === this && this.getIndex(t) > 0 && (this.remove(t, !1, !0), this.addAt(t, 0, !0)), t
            }, t.Group.prototype.sendChildToBack = t.Group.prototype.sendToBack, t.Group.prototype.moveUp = function(t) {
                if (t.parent === this && this.getIndex(t) < this.children.length - 1) {
                    var e = this.getIndex(t),
                        i = this.getAt(e + 1);
                    i && this.swap(t, i)
                }
                return t
            }, t.Group.prototype.moveDown = function(t) {
                if (t.parent === this && this.getIndex(t) > 0) {
                    var e = this.getIndex(t),
                        i = this.getAt(e - 1);
                    i && this.swap(t, i)
                }
                return t
            }, t.Group.prototype.xy = function(t, e, i) {
                if (t < 0 || t > this.children.length) return -1;
                this.getChildAt(t).x = e, this.getChildAt(t).y = i
            }, t.Group.prototype.reverse = function() {
                this.children.reverse(), this.updateZ()
            }, t.Group.prototype.getIndex = function(t) {
                return this.children.indexOf(t)
            }, t.Group.prototype.getByName = function(t) {
                return this.getFirst("name", t)
            }, t.Group.prototype.replace = function(e, i) {
                var s = this.getIndex(e);
                if (-1 !== s) return i.parent && (i.parent instanceof t.Group ? i.parent.remove(i) : i.parent.removeChild(i)), this.remove(e), this.addAt(i, s), e
            }, t.Group.prototype.hasProperty = function(t, e) {
                var i = e.length;
                return 1 === i && e[0] in t || 2 === i && e[0] in t && e[1] in t[e[0]] || 3 === i && e[0] in t && e[1] in t[e[0]] && e[2] in t[e[0]][e[1]] || 4 === i && e[0] in t && e[1] in t[e[0]] && e[2] in t[e[0]][e[1]] && e[3] in t[e[0]][e[1]][e[2]]
            }, t.Group.prototype.setProperty = function(t, e, i, s, n) {
                if (void 0 === n && (n = !1), s = s || 0, !this.hasProperty(t, e) && (!n || s > 0)) return !1;
                var r = e.length;
                return 1 === r ? 0 === s ? t[e[0]] = i : 1 === s ? t[e[0]] += i : 2 === s ? t[e[0]] -= i : 3 === s ? t[e[0]] *= i : 4 === s && (t[e[0]] /= i) : 2 === r ? 0 === s ? t[e[0]][e[1]] = i : 1 === s ? t[e[0]][e[1]] += i : 2 === s ? t[e[0]][e[1]] -= i : 3 === s ? t[e[0]][e[1]] *= i : 4 === s && (t[e[0]][e[1]] /= i) : 3 === r ? 0 === s ? t[e[0]][e[1]][e[2]] = i : 1 === s ? t[e[0]][e[1]][e[2]] += i : 2 === s ? t[e[0]][e[1]][e[2]] -= i : 3 === s ? t[e[0]][e[1]][e[2]] *= i : 4 === s && (t[e[0]][e[1]][e[2]] /= i) : 4 === r && (0 === s ? t[e[0]][e[1]][e[2]][e[3]] = i : 1 === s ? t[e[0]][e[1]][e[2]][e[3]] += i : 2 === s ? t[e[0]][e[1]][e[2]][e[3]] -= i : 3 === s ? t[e[0]][e[1]][e[2]][e[3]] *= i : 4 === s && (t[e[0]][e[1]][e[2]][e[3]] /= i)), !0
            }, t.Group.prototype.checkProperty = function(e, i, s, n) {
                if (void 0 === n && (n = !1), this !== e.parent) return !1;
                var r = t.Utils.getProperty(e, i);
                return !(void 0 === r && n || r !== s)
            }, t.Group.prototype.set = function(t, e, i, s, n, r, o) {
                if (void 0 === o && (o = !1), e = e.split("."), void 0 === s && (s = !1), void 0 === n && (n = !1), (!1 === s || s && t.alive) && (!1 === n || n && t.visible)) return this.setProperty(t, e, i, r, o)
            }, t.Group.prototype.setAll = function(t, e, i, s, n, r) {
                void 0 === i && (i = !1), void 0 === s && (s = !1), void 0 === r && (r = !1), t = t.split("."), n = n || 0;
                for (var o = this.children.length, a = 0; a < o; a++) {
                    var h = this.children[a];
                    i && !h.alive || s && !h.visible || this.setProperty(h, t, e, n, r)
                }
            }, t.Group.prototype.setAllChildren = function(e, i, s, n, r, o) {
                void 0 === s && (s = !1), void 0 === n && (n = !1), void 0 === o && (o = !1), r = r || 0;
                for (var a = this.children.length, h = 0; h < a; h++) {
                    var l = this.children[h];
                    s && !l.alive || n && !l.visible || (l instanceof t.Group ? l.setAllChildren(e, i, s, n, r, o) : this.setProperty(l, e.split("."), i, r, o))
                }
            }, t.Group.prototype.checkAll = function(t, e, i, s, n) {
                void 0 === i && (i = !1), void 0 === s && (s = !1), void 0 === n && (n = !1);
                for (var r = 0; r < this.children.length; r++) {
                    var o = this.children[r];
                    if ((!i || o.alive) && (!s || o.visible) && !this.checkProperty(o, t, e, n)) return !1
                }
                return !0
            }, t.Group.prototype.checkAny = function(t, e, i, s) {
                void 0 === i && (i = !1), void 0 === s && (s = !1);
                for (var n = 0; n < this.children.length; n++) {
                    var r = this.children[n];
                    if ((!i || r.alive) && (!s || r.visible) && this.checkProperty(r, t, e)) return !0
                }
                return !1
            }, t.Group.prototype.addAll = function(t, e, i, s) {
                this.setAll(t, e, i, s, 1)
            }, t.Group.prototype.subAll = function(t, e, i, s) {
                this.setAll(t, e, i, s, 2)
            }, t.Group.prototype.multiplyAll = function(t, e, i, s) {
                this.setAll(t, e, i, s, 3)
            }, t.Group.prototype.divideAll = function(t, e, i, s) {
                this.setAll(t, e, i, s, 4)
            }, t.Group.prototype.kill = function() {
                this.alive = !1, this.exists = !1, this.visible = !1
            }, t.Group.prototype.killAll = function() {
                this.callAllExists("kill", !0)
            }, t.Group.prototype.revive = function() {
                this.alive = !0, this.exists = !0, this.visible = !0
            }, t.Group.prototype.reviveAll = function() {
                this.callAllExists("revive", !1)
            }, t.Group.prototype.resetAll = function(t, e, i, s, n) {
                this.forEach(this.resetChild, this, n, t, e, i, s)
            }, t.Group.prototype.callAllExists = function(t, e) {
                var i;
                if (arguments.length > 2)
                    for (i = [], s = 2; s < arguments.length; s++) i.push(arguments[s]);
                for (var s = 0; s < this.children.length; s++) {
                    var n = this.children[s];
                    n.exists === e && n[t] && n[t].apply(n, i)
                }
            }, t.Group.prototype.callbackFromArray = function(t, e, i) {
                if (1 === i) {
                    if (t[e[0]]) return t[e[0]]
                } else if (2 === i) {
                    if (t[e[0]][e[1]]) return t[e[0]][e[1]]
                } else if (3 === i) {
                    if (t[e[0]][e[1]][e[2]]) return t[e[0]][e[1]][e[2]]
                } else if (4 === i) {
                    if (t[e[0]][e[1]][e[2]][e[3]]) return t[e[0]][e[1]][e[2]][e[3]]
                } else if (t[e]) return t[e];
                return !1
            }, t.Group.prototype.callAll = function(t, e) {
                if (void 0 !== t) {
                    var i, s = (t = t.split(".")).length;
                    if (null == e || "" === e) e = null;
                    else if ("string" == typeof e) var n = (e = e.split(".")).length;
                    if (arguments.length > 2)
                        for (i = [], a = 2; a < arguments.length; a++) i.push(arguments[a]);
                    for (var r = null, o = null, a = 0; a < this.children.length; a++) {
                        var h = this.children[a];
                        r = this.callbackFromArray(h, t, s), e && r ? (o = this.callbackFromArray(h, e, n), r.apply(o, i)) : r && r.apply(h, i)
                    }
                }
            }, t.Group.prototype.preUpdate = function() {
                if (this.pendingDestroy) return this.destroy(), !1;
                if (!this.exists || !this.parent.exists) return this.renderOrderID = -1, !1;
                for (var t = 0; t < this.children.length;) {
                    var e = this.children[t];
                    e.preUpdate(), this === e.parent && t++
                }
                return !0
            }, t.Group.prototype.update = function() {
                for (var t = this.children.length; t--;) {
                    var e = this.children.length;
                    t >= e && (t = e - 1);
                    var i = this.children[t];
                    this.updateOnlyExistingChildren && !i.exists || i.update()
                }
            }, t.Group.prototype.postUpdate = function() {
                this.fixedToCamera && (this.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y);
                for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate()
            }, t.Group.prototype.filter = function(e, i) {
                for (var s = -1, n = this.children.length, r = []; ++s < n;) {
                    var o = this.children[s];
                    (!i || i && o.exists) && e(o, s, this.children) && r.push(o)
                }
                return new t.ArraySet(r)
            }, t.Group.prototype.forEach = function(t, e, i) {
                if (void 0 === i && (i = !1), arguments.length <= 3)
                    for (n = 0; n < this.children.length; n++) r = this.children[n], i && !r.exists || t.call(e, r);
                else {
                    for (var s = [null], n = 3; n < arguments.length; n++) s.push(arguments[n]);
                    for (n = 0; n < this.children.length; n++) {
                        var r = this.children[n];
                        i && !r.exists || (s[0] = r, t.apply(e, s))
                    }
                }
            }, t.Group.prototype.forEachExists = function(e, i) {
                var s;
                if (arguments.length > 2) {
                    s = [null];
                    for (var n = 2; n < arguments.length; n++) s.push(arguments[n])
                }
                this.iterate("exists", !0, t.Group.RETURN_TOTAL, e, i, s)
            }, t.Group.prototype.forEachAlive = function(e, i) {
                var s;
                if (arguments.length > 2) {
                    s = [null];
                    for (var n = 2; n < arguments.length; n++) s.push(arguments[n])
                }
                this.iterate("alive", !0, t.Group.RETURN_TOTAL, e, i, s)
            }, t.Group.prototype.forEachDead = function(e, i) {
                var s;
                if (arguments.length > 2) {
                    s = [null];
                    for (var n = 2; n < arguments.length; n++) s.push(arguments[n])
                }
                this.iterate("alive", !1, t.Group.RETURN_TOTAL, e, i, s)
            }, t.Group.prototype.sort = function(e, i) {
                this.children.length < 2 || (void 0 === e && (e = "z"), void 0 === i && (i = t.Group.SORT_ASCENDING), this._sortProperty = e, i === t.Group.SORT_ASCENDING ? this.children.sort(this.ascendingSortHandler.bind(this)) : this.children.sort(this.descendingSortHandler.bind(this)), this.updateZ())
            }, t.Group.prototype.customSort = function(t, e) {
                this.children.length < 2 || (this.children.sort(t.bind(e)), this.updateZ())
            }, t.Group.prototype.ascendingSortHandler = function(t, e) {
                return t[this._sortProperty] < e[this._sortProperty] ? -1 : t[this._sortProperty] > e[this._sortProperty] ? 1 : t.z < e.z ? -1 : 1
            }, t.Group.prototype.descendingSortHandler = function(t, e) {
                return t[this._sortProperty] < e[this._sortProperty] ? 1 : t[this._sortProperty] > e[this._sortProperty] ? -1 : 0
            }, t.Group.prototype.iterate = function(e, i, s, n, r, o) {
                if (0 === this.children.length) {
                    if (s === t.Group.RETURN_TOTAL) return 0;
                    if (s === t.Group.RETURN_ALL) return []
                }
                var a = 0;
                if (s === t.Group.RETURN_ALL) var h = [];
                for (var l = 0; l < this.children.length; l++)
                    if (this.children[l][e] === i) {
                        if (a++, n && (o ? (o[0] = this.children[l], n.apply(r, o)) : n.call(r, this.children[l])), s === t.Group.RETURN_CHILD) return this.children[l];
                        s === t.Group.RETURN_ALL && h.push(this.children[l])
                    }
                return s === t.Group.RETURN_TOTAL ? a : s === t.Group.RETURN_ALL ? h : null
            }, t.Group.prototype.getFirst = function(e, i) {
                return this.iterate(e, i, t.Group.RETURN_CHILD)
            }, t.Group.prototype.getFirstExists = function(t, e, i, s, n, r) {
                void 0 === e && (e = !1), "boolean" != typeof t && (t = !0);
                var o = this.getFirst("exists", t);
                return null === o && e ? this.create(i, s, n, r) : this.resetChild(o, i, s, n, r)
            }, t.Group.prototype.getFirstAlive = function(t, e, i, s, n) {
                void 0 === t && (t = !1);
                var r = this.getFirst("alive", !0);
                return null === r && t ? this.create(e, i, s, n) : this.resetChild(r, e, i, s, n)
            }, t.Group.prototype.getFirstDead = function(t, e, i, s, n) {
                void 0 === t && (t = !1);
                var r = this.getFirst("alive", !1);
                return null === r && t ? this.create(e, i, s, n) : this.resetChild(r, e, i, s, n)
            }, t.Group.prototype.resetChild = function(t, e, i, s, n) {
                return null === t ? null : (void 0 === e && (e = null), void 0 === i && (i = null), null !== e && null !== i && t.reset(e, i), void 0 !== s && t.loadTexture(s, n), t)
            }, t.Group.prototype.getTop = function() {
                if (this.children.length > 0) return this.children[this.children.length - 1]
            }, t.Group.prototype.getBottom = function() {
                if (this.children.length > 0) return this.children[0]
            }, t.Group.prototype.getClosestTo = function(e, i, s) {
                for (var n = Number.MAX_VALUE, r = 0, o = null, a = 0; a < this.children.length; a++) {
                    var h = this.children[a];
                    h.exists && (r = Math.abs(t.Point.distance(e, h))) < n && (!i || i.call(s, h, r)) && (n = r, o = h)
                }
                return o
            }, t.Group.prototype.getFurthestFrom = function(e, i, s) {
                for (var n = 0, r = 0, o = null, a = 0; a < this.children.length; a++) {
                    var h = this.children[a];
                    h.exists && (r = Math.abs(t.Point.distance(e, h))) > n && (!i || i.call(s, h, r)) && (n = r, o = h)
                }
                return o
            }, t.Group.prototype.count = function(e, i) {
                return this.iterate(e, i, t.Group.RETURN_TOTAL)
            }, t.Group.prototype.countLiving = function() {
                return this.count("alive", !0)
            }, t.Group.prototype.countDead = function() {
                return this.count("alive", !1)
            }, t.Group.prototype.getRandom = function(e, i) {
                return void 0 === e && (e = 0), void 0 === i && (i = this.children.length), 0 === i ? null : t.ArrayUtils.getRandomItem(this.children, e, i)
            }, t.Group.prototype.getRandomExists = function(t, e) {
                var i = this.getAll("exists", !0, t, e);
                return this.game.rnd.pick(i)
            }, t.Group.prototype.getAll = function(t, e, i, s) {
                void 0 === i && (i = 0), void 0 === s && (s = this.children.length);
                for (var n = [], r = i; r < s; r++) {
                    var o = this.children[r];
                    t ? o[t] === e && n.push(o) : n.push(o)
                }
                return n
            }, t.Group.prototype.remove = function(t, e, i) {
                if (void 0 === e && (e = !1), void 0 === i && (i = !1), 0 === this.children.length || -1 === this.children.indexOf(t)) return !1;
                i || !t.events || t.destroyPhase || t.events.onRemovedFromGroup$dispatch(t, this);
                var s = this.removeChild(t);
                return this.removeFromHash(t), this.updateZ(), this.cursor === t && this.next(), e && s && s.destroy(!0), !0
            }, t.Group.prototype.moveAll = function(e, i) {
                if (void 0 === i && (i = !1), this.children.length > 0 && e instanceof t.Group) {
                    do {
                        e.add(this.children[0], i)
                    } while (this.children.length > 0);
                    this.hash = [], this.cursor = null
                }
                return e
            }, t.Group.prototype.removeAll = function(t, e, i) {
                if (void 0 === t && (t = !1), void 0 === e && (e = !1), void 0 === i && (i = !1), 0 !== this.children.length) {
                    do {
                        !e && this.children[0].events && this.children[0].events.onRemovedFromGroup$dispatch(this.children[0], this);
                        var s = this.removeChild(this.children[0]);
                        this.removeFromHash(s), t && s && s.destroy(!0, i)
                    } while (this.children.length > 0);
                    this.hash = [], this.cursor = null
                }
            }, t.Group.prototype.removeBetween = function(t, e, i, s) {
                if (void 0 === e && (e = this.children.length - 1), void 0 === i && (i = !1), void 0 === s && (s = !1), 0 !== this.children.length) {
                    if (t > e || t < 0 || e > this.children.length) return !1;
                    for (var n = e; n >= t;) {
                        !s && this.children[n].events && this.children[n].events.onRemovedFromGroup$dispatch(this.children[n], this);
                        var r = this.removeChild(this.children[n]);
                        this.removeFromHash(r), i && r && r.destroy(!0), this.cursor === this.children[n] && (this.cursor = null), n--
                    }
                    this.updateZ()
                }
            }, t.Group.prototype.scatter = function(t, e) {
                null == t && (t = this.game.world.bounds), this.forEach(function(e) {
                    e.position.set(t.randomX, t.randomY)
                }, null, e)
            }, t.Group.prototype.shuffle = function() {
                t.ArrayUtils.shuffle(this.children), this.updateZ()
            }, t.Group.prototype.destroy = function(t, e) {
                null === this.game || this.ignoreDestroy || (void 0 === t && (t = !0), void 0 === e && (e = !1), this.onDestroy.dispatch(this, t, e), this.removeAll(t), this.cursor = null, this.filters = null, this.pendingDestroy = !1, e || (this.parent && this.parent.removeChild(this), this.game = null, this.exists = !1))
            }, Object.defineProperty(t.Group.prototype, "total", {
                get: function() {
                    return this.iterate("exists", !0, t.Group.RETURN_TOTAL)
                }
            }), Object.defineProperty(t.Group.prototype, "length", {
                get: function() {
                    return this.children.length
                }
            }), Object.defineProperty(t.Group.prototype, "angle", {
                get: function() {
                    return t.Math.radToDeg(this.rotation)
                },
                set: function(e) {
                    this.rotation = t.Math.degToRad(e)
                }
            }), Object.defineProperty(t.Group.prototype, "centerX", {
                get: function() {
                    return this.getBounds(this.parent).centerX
                },
                set: function(t) {
                    var e = this.getBounds(this.parent),
                        i = this.x - e.x;
                    this.x = t + i - e.halfWidth
                }
            }), Object.defineProperty(t.Group.prototype, "centerY", {
                get: function() {
                    return this.getBounds(this.parent).centerY
                },
                set: function(t) {
                    var e = this.getBounds(this.parent),
                        i = this.y - e.y;
                    this.y = t + i - e.halfHeight
                }
            }), Object.defineProperty(t.Group.prototype, "left", {
                get: function() {
                    return this.getBounds(this.parent).left
                },
                set: function(t) {
                    var e = this.getBounds(this.parent),
                        i = this.x - e.x;
                    this.x = t + i
                }
            }), Object.defineProperty(t.Group.prototype, "right", {
                get: function() {
                    return this.getBounds(this.parent).right
                },
                set: function(t) {
                    var e = this.getBounds(this.parent),
                        i = this.x - e.x;
                    this.x = t + i - e.width
                }
            }), Object.defineProperty(t.Group.prototype, "top", {
                get: function() {
                    return this.getBounds(this.parent).top
                },
                set: function(t) {
                    var e = this.getBounds(this.parent),
                        i = this.y - e.y;
                    this.y = t + i
                }
            }), Object.defineProperty(t.Group.prototype, "bottom", {
                get: function() {
                    return this.getBounds(this.parent).bottom
                },
                set: function(t) {
                    var e = this.getBounds(this.parent),
                        i = this.y - e.y;
                    this.y = t + i - e.height
                }
            }), t.World = function(e) {
                t.Group.call(this, e, null, "__world", !1), this.bounds = new t.Rectangle(0, 0, e.width, e.height), this.camera = null, this._definedSize = !1, this._width = e.width, this._height = e.height, this.game.state.onStateChange.add(this.stateChange, this)
            }, t.World.prototype = Object.create(t.Group.prototype), t.World.prototype.constructor = t.World, t.World.prototype.boot = function() {
                this.camera = new t.Camera(this.game, 0, 0, 0, this.game.width, this.game.height), this.game.stage.addChild(this), this.camera.boot()
            }, t.World.prototype.stateChange = function() {
                this.x = 0, this.y = 0, this.camera.reset()
            }, t.World.prototype.setBounds = function(t, e, i, s) {
                this._definedSize = !0, this._width = i, this._height = s, this.bounds.setTo(t, e, i, s), this.x = t, this.y = e, this.camera.bounds && this.camera.bounds.setTo(t, e, Math.max(i, this.game.width), Math.max(s, this.game.height)), this.game.physics.setBoundsToWorld()
            }, t.World.prototype.resize = function(t, e) {
                this._definedSize && (t < this._width && (t = this._width), e < this._height && (e = this._height)), this.bounds.width = t, this.bounds.height = e, this.game.camera.setBoundsToWorld(), this.game.physics.setBoundsToWorld()
            }, t.World.prototype.shutdown = function() {
                this.destroy(!0, !0)
            }, t.World.prototype.wrap = function(t, e, i, s, n) {
                void 0 === e && (e = 0), void 0 === i && (i = !1), void 0 === s && (s = !0), void 0 === n && (n = !0), i ? (t.getBounds(), s && (t.x + t._currentBounds.width < this.bounds.x ? t.x = this.bounds.right : t.x > this.bounds.right && (t.x = this.bounds.left)), n && (t.y + t._currentBounds.height < this.bounds.top ? t.y = this.bounds.bottom : t.y > this.bounds.bottom && (t.y = this.bounds.top))) : (s && t.x + e < this.bounds.x ? t.x = this.bounds.right + e : s && t.x - e > this.bounds.right && (t.x = this.bounds.left - e), n && t.y + e < this.bounds.top ? t.y = this.bounds.bottom + e : n && t.y - e > this.bounds.bottom && (t.y = this.bounds.top - e))
            }, t.World.prototype.wrapAll = function(t, e, i, s, n, r) {
                t.forEach(this.wrap, this, e, i, s, n, r)
            }, Object.defineProperty(t.World.prototype, "width", {
                get: function() {
                    return this.bounds.width
                },
                set: function(t) {
                    t < this.game.width && (t = this.game.width), this.bounds.width = t, this._width = t, this._definedSize = !0
                }
            }), Object.defineProperty(t.World.prototype, "height", {
                get: function() {
                    return this.bounds.height
                },
                set: function(t) {
                    t < this.game.height && (t = this.game.height), this.bounds.height = t, this._height = t, this._definedSize = !0
                }
            }), Object.defineProperty(t.World.prototype, "centerX", {
                get: function() {
                    return this.bounds.halfWidth + this.bounds.x
                }
            }), Object.defineProperty(t.World.prototype, "centerY", {
                get: function() {
                    return this.bounds.halfHeight + this.bounds.y
                }
            }), Object.defineProperty(t.World.prototype, "randomX", {
                get: function() {
                    return this.bounds.x < 0 ? this.game.rnd.between(this.bounds.x, this.bounds.width - Math.abs(this.bounds.x)) : this.game.rnd.between(this.bounds.x, this.bounds.width)
                }
            }), Object.defineProperty(t.World.prototype, "randomY", {
                get: function() {
                    return this.bounds.y < 0 ? this.game.rnd.between(this.bounds.y, this.bounds.height - Math.abs(this.bounds.y)) : this.game.rnd.between(this.bounds.y, this.bounds.height)
                }
            }), t.Game = function(e, i, s, n, r, o, a, h) {
                return this.id = t.GAMES.push(this) - 1, this.config = null, this.physicsConfig = h, this.parent = "", this.width = 800, this.height = 600, this.resolution = 1, this._width = 800, this._height = 600, this.transparent = !1, this.antialias = !0, this.multiTexture = !1, this.preserveDrawingBuffer = !1, this.clearBeforeRender = !0, this.renderer = null, this.renderType = t.AUTO, this.state = null, this.isBooted = !1, this.isRunning = !1, this.raf = null, this.add = null, this.make = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.net = null, this.scale = null, this.sound = null, this.stage = null, this.time = null, this.tweens = null, this.world = null, this.physics = null, this.plugins = null, this.rnd = null, this.device = t.Device, this.camera = null, this.canvas = null, this.context = null, this.debug = null, this.particles = null, this.create = null, this.lockRender = !1, this.pendingDestroy = !1, this.stepping = !1, this.pendingStep = !1, this.stepCount = 0, this.onPause = null, this.onResume = null, this.onBlur = null, this.onFocus = null, this._paused = !1, this._codePaused = !1, this.currentUpdateID = 0, this.updatesThisFrame = 1, this.rendersThisFrame = 1, this._deltaTime = 0, this._lastCount = 0, this._spiraling = 0, this._kickstart = !0, this.fpsProblemNotifier = new t.Signal, this.forceSingleUpdate = !0, this.forceSingleRender = !0, this.dropFrames = !1, this._nextFpsNotification = 0, 1 === arguments.length && "object" == typeof arguments[0] ? this.parseConfig(arguments[0]) : (this.config = {
                    enableDebug: !0
                }, void 0 !== e && (this._width = e), void 0 !== i && (this._height = i), void 0 !== s && (this.renderType = s), void 0 !== n && (this.parent = n), void 0 !== o && (this.transparent = o), void 0 !== a && (this.antialias = a), this.rnd = new t.RandomDataGenerator([(Date.now() * Math.random()).toString()]), this.state = new t.StateManager(this, r)), this.device.whenReady(this.boot, this), this
            }, t.Game.prototype = {
                parseConfig: function(e) {
                    this.config = e, void 0 === e.enableDebug && (this.config.enableDebug = !0), e.width && (this._width = e.width), e.height && (this._height = e.height), e.renderer && (this.renderType = e.renderer), e.parent && (this.parent = e.parent), void 0 !== e.transparent && (this.transparent = e.transparent), void 0 !== e.antialias && (this.antialias = e.antialias), void 0 !== e.clearBeforeRender && (this.clearBeforeRender = e.clearBeforeRender), void 0 !== e.multiTexture && (this.multiTexture = e.multiTexture), e.resolution && (this.resolution = e.resolution), void 0 !== e.preserveDrawingBuffer && (this.preserveDrawingBuffer = e.preserveDrawingBuffer), e.physicsConfig && (this.physicsConfig = e.physicsConfig);
                    var i = [(Date.now() * Math.random()).toString()];
                    e.seed && (i = e.seed), this.rnd = new t.RandomDataGenerator(i);
                    var s = null;
                    e.state && (s = e.state), this.state = new t.StateManager(this, s)
                },
                boot: function() {
                    if (!this.isBooted) {
                        if (this.onPause = new t.Signal, this.onResume = new t.Signal, this.onBlur = new t.Signal, this.onFocus = new t.Signal, this.isBooted = !0, PIXI.game = this, this.math = t.Math, this.scale = new t.ScaleManager(this, this._width, this._height), this.stage = new t.Stage(this), this.setUpRenderer(), this.world = new t.World(this), this.add = new t.GameObjectFactory(this), this.make = new t.GameObjectCreator(this), this.cache = new t.Cache(this), this.load = new t.Loader(this), this.time = new t.Time(this), this.tweens = new t.TweenManager(this), this.input = new t.Input(this), this.sound = new t.SoundManager(this), this.physics = new t.Physics(this, this.physicsConfig), this.particles = new t.Particles(this), this.create = new t.Create(this), this.plugins = new t.PluginManager(this), this.net = new t.Net(this), this.time.boot(), this.stage.boot(), this.world.boot(), this.scale.boot(), this.input.boot(this.config), this.sound.boot(), this.state.boot(), this.config.enableDebug) this.debug = new t.Utils.Debug(this), this.debug.boot();
                        else {
                            var e = function() {};
                            this.debug = {
                                preUpdate: e,
                                update: e,
                                reset: e,
                                destroy: e,
                                isDisabled: !0
                            }
                        }
                        this.showDebugHeader(), this.isRunning = !0, this.config && this.config.forceSetTimeOut ? this.raf = new t.RequestAnimationFrame(this, this.config.forceSetTimeOut) : this.raf = new t.RequestAnimationFrame(this, !1), this._kickstart = !0, this.focusWindow(), this.config.disableStart || (this.cache.isReady ? this.raf.start() : this.cache.onReady.addOnce(function() {
                            this.raf.start()
                        }, this))
                    }
                },
                showDebugHeader: function() {
                    if (!window.PhaserGlobal || !window.PhaserGlobal.hideBanner) {
                        var e = t.VERSION,
                            i = "Canvas",
                            s = "HTML Audio",
                            n = 1;
                        if (this.renderType === t.WEBGL ? (i = "WebGL", n++) : this.renderType === t.HEADLESS && (i = "Headless"), this.device.webAudio && (s = "WebAudio", n++), this.device.ie) window.console && gradle.event("Phaser v" + e + " | Pixi.js | " + i + " | " + s + " | http://phaser.io");
                        else {
                            for (var r = ["%c %c %c Phaser CE v" + e + " | Pixi.js | " + i + " | " + s + "  %c %c %c http://phaser.io %c%c%c", "background: #fb8cb3", "background: #d44a52", "color: #ffffff; background: #871905;", "background: #d44a52", "background: #fb8cb3", "background: #ffffff"], o = 0; o < 3; o++) o < n ? r.push("color: #ff2424; background: #fff") : r.push("color: #959595; background: #fff");
                            // gradle.event.apply(console, r)
                        }
                    }
                },
                setUpRenderer: function() {
                    if (!this.device.canvas) throw new Error("Phaser.Game - Cannot create Canvas 2d context, aborting.");
                    if (this.config.canvas ? this.canvas = this.config.canvas : this.canvas = t.Canvas.create(this, this.width, this.height, this.config.canvasID, !0), this.config.canvasStyle ? this.canvas.style = this.config.canvasStyle : this.canvas.style["-webkit-full-screen"] = "width: 100%; height: 100%", this.config.crisp && t.Canvas.setImageRenderingCrisp(this.canvas), this.renderType === t.WEBGL || this.renderType === t.WEBGL_MULTI || this.renderType === t.AUTO && this.device.webGL) {
                        (this.multiTexture || this.renderType === t.WEBGL_MULTI) && (PIXI.enableMultiTexture(), this.multiTexture = !0);
                        try {
                            this.renderer = new PIXI.WebGLRenderer(this, this.config), this.renderType = t.WEBGL, this.context = null, this.canvas.addEventListener("webglcontextlost", this.contextLost.bind(this), !1), this.canvas.addEventListener("webglcontextrestored", this.contextRestored.bind(this), !1)
                        } catch (e) {
                            if (PIXI.defaultRenderer = null, this.renderer = null, this.multiTexture = !1, PIXI._enableMultiTextureToggle = !1, this.renderType === t.WEBGL) throw e
                        }
                    }
                    this.renderer || (this.renderer = new PIXI.CanvasRenderer(this, this.config), this.context = this.renderer.context, this.renderType === t.AUTO && (this.renderType = t.CANVAS)), this.device.cocoonJS && (this.canvas.screencanvas = this.renderType === t.CANVAS), this.renderType !== t.HEADLESS && (this.stage.smoothed = this.antialias, t.Canvas.addToDOM(this.canvas, this.parent, !1), t.Canvas.setTouchAction(this.canvas))
                },
                contextLost: function(t) {
                    t.preventDefault(), this.renderer.contextLost = !0
                },
                contextRestored: function() {
                    this.renderer.initContext(), this.cache.clearGLTextures(), this.renderer.contextLost = !1
                },
                update: function(t) {
                    if (this.pendingDestroy) this.destroy();
                    else {
                        if (this.time.update(t), this._kickstart) return this.updateLogic(this.time.desiredFpsMult), this.updateRender(this.time.slowMotion * this.time.desiredFps), void(this._kickstart = !1);
                        if (this._spiraling > 1 && !this.forceSingleUpdate) this.time.time > this._nextFpsNotification && (this._nextFpsNotification = this.time.time + 1e4, this.fpsProblemNotifier.dispatch()), this._deltaTime = 0, this._spiraling = 0, this.dropFrames ? this.rendersThisFrame = 0 : (this.updateRender(this.time.slowMotion * this.time.desiredFps), this.rendersThisFrame = 1);
                        else {
                            var e = 1e3 * this.time.slowMotion / this.time.desiredFps;
                            this._deltaTime += Math.max(Math.min(3 * e, this.time.elapsed), 0);
                            var i = 0;
                            for (this.updatesThisFrame = Math.floor(this._deltaTime / e), this.forceSingleUpdate && (this.updatesThisFrame = Math.min(1, this.updatesThisFrame)), this.forceSingleRender ? this.rendersThisFrame = 1 : this.rendersThisFrame = Math.min(1, this.updatesThisFrame); this._deltaTime >= e && (this._deltaTime -= e, this.currentUpdateID = i, this.updateLogic(this.time.desiredFpsMult), i++, !this.forceSingleUpdate || 1 !== i);) this.time.refresh();
                            i > this._lastCount ? this._spiraling++ : i < this._lastCount && (this._spiraling = 0), this._lastCount = i, this.rendersThisFrame > 0 && this.updateRender(this._deltaTime / e)
                        }
                    }
                },
                updateLogic: function(t) {
                    this._paused || this.pendingStep ? (this.scale.pauseUpdate(), this.state.pauseUpdate(t), this.debug.preUpdate(), this.input.pauseUpdate()) : (this.stepping && (this.pendingStep = !0), this.time.countUpdate(), this.scale.preUpdate(), this.debug.preUpdate(), this.camera.preUpdate(), this.physics.preUpdate(), this.state.preUpdate(t), this.plugins.preUpdate(t), this.stage.preUpdate(), this.state.update(), this.stage.update(), this.tweens.update(), this.sound.update(), this.input.update(), this.physics.update(), this.plugins.update(), this.stage.postUpdate(), this.state.postUpdate(), this.plugins.postUpdate()), this.stage.updateTransform()
                },
                updateRender: function(e) {
                    this.lockRender || this.renderType === t.HEADLESS || (this.time.countRender(), this.state.preRender(e), this.renderer.render(this.stage), this.plugins.render(e), this.state.render(e), this.plugins.postRender(e))
                },
                enableStep: function() {
                    this.stepping = !0, this.pendingStep = !1, this.stepCount = 0
                },
                disableStep: function() {
                    this.stepping = !1, this.pendingStep = !1
                },
                step: function() {
                    this.pendingStep = !1, this.stepCount++
                },
                destroy: function() {
                    this.raf.stop(), this.debug.destroy(), this.state.destroy(), this.sound.destroy(), this.scale.destroy(), this.stage.destroy(), this.input.destroy(), this.physics.destroy(), this.plugins.destroy(), this.tweens.destroy(), this.debug = null, this.state = null, this.sound = null, this.scale = null, this.stage = null, this.input = null, this.physics = null, this.plugins = null, this.tweens = null, this.cache = null, this.load = null, this.time = null, this.world = null, this.isBooted = !1, this.renderer.destroy(!1), t.Canvas.removeFromDOM(this.canvas), PIXI.game === this && (PIXI.game = null), PIXI.defaultRenderer = null, t.GAMES[this.id] = null
                },
                gamePaused: function(t) {
                    this._paused || (this._paused = !0, this.time.gamePaused(), this.sound.muteOnPause && this.sound.setMute(), this.onPause.dispatch(t), this.device.cordova && this.device.iOS && (this.lockRender = !0))
                },
                gameResumed: function(t) {
                    this._paused && !this._codePaused && (this._paused = !1, this.time.gameResumed(), this.input.reset(), this.sound.muteOnPause && this.sound.unsetMute(), this.onResume.dispatch(t), this.device.cordova && this.device.iOS && (this.lockRender = !1))
                },
                focusLoss: function(t) {
                    this.onBlur.dispatch(t), this.stage.disableVisibilityChange || this.gamePaused(t)
                },
                focusGain: function(t) {
                    this.focusWindow(), this.onFocus.dispatch(t), this.stage.disableVisibilityChange || this.gameResumed(t)
                },
                focusWindow: function() {
                    window.focus && (!window.PhaserGlobal || window.PhaserGlobal && !window.PhaserGlobal.stopFocus) && window.focus()
                }
            }, t.Game.prototype.constructor = t.Game, Object.defineProperty(t.Game.prototype, "paused", {
                get: function() {
                    return this._paused
                },
                set: function(t) {
                    !0 === t ? (!1 === this._paused && (this._paused = !0, this.sound.muteOnPause && this.sound.setMute(), this.time.gamePaused(), this.onPause.dispatch(this)), this._codePaused = !0) : (this._paused && (this._paused = !1, this.input.reset(), this.sound.unsetMute(), this.time.gameResumed(), this.onResume.dispatch(this)), this._codePaused = !1)
                }
            }), t.Input = function(e) {
                this.game = e, this.hitCanvas = null, this.hitContext = null, this.moveCallbacks = [], this.customCandidateHandler = null, this.customCandidateHandlerContext = null, this.pollRate = 0, this.enabled = !0, this.multiInputOverride = t.Input.MOUSE_TOUCH_COMBINE, this.position = null, this.speed = null, this.circle = null, this.scale = null, this.maxPointers = -1, this.tapRate = 200, this.doubleTapRate = 300, this.holdRate = 2e3, this.justPressedRate = 200, this.justReleasedRate = 200, this.recordPointerHistory = !1, this.recordRate = 100, this.recordLimit = 100, this.touchLockCallbacks = [], this.pointer1 = null, this.pointer2 = null, this.pointer3 = null, this.pointer4 = null, this.pointer5 = null, this.pointer6 = null, this.pointer7 = null, this.pointer8 = null, this.pointer9 = null, this.pointer10 = null, this.pointers = [], this.activePointer = null, this.mousePointer = null, this.mouse = null, this.keyboard = null, this.touch = null, this.mspointer = null, this.gamepad = null, this.resetLocked = !1, this.onDown = null, this.onUp = null, this.onTap = null, this.onHold = null, this.minPriorityID = 0, this.interactiveItems = new t.ArraySet, this._localPoint = new t.Point, this._pollCounter = 0, this._oldPosition = null, this._x = 0, this._y = 0
            }, t.Input.MOUSE_OVERRIDES_TOUCH = 0, t.Input.TOUCH_OVERRIDES_MOUSE = 1, t.Input.MOUSE_TOUCH_COMBINE = 2, t.Input.MAX_POINTERS = 10, t.Input.prototype = {
                boot: function(e) {
                    "maxPointers" in e && (this.maxPointers = e.maxPointers), this.mousePointer = new t.Pointer(this.game, 0, t.PointerMode.CURSOR), this.addPointer(), this.addPointer(), this.mouse = new t.Mouse(this.game), this.touch = new t.Touch(this.game), this.mspointer = new t.MSPointer(this.game), this.mouseWheel = new t.MouseWheel(this.game), this.pointerLock = new t.PointerLock(this.game), t.Keyboard && (this.keyboard = new t.Keyboard(this.game)), t.Gamepad && (this.gamepad = new t.Gamepad(this.game)), this.onDown = new t.Signal, this.onUp = new t.Signal, this.onTap = new t.Signal, this.onHold = new t.Signal, this.scale = new t.Point(1, 1), this.speed = new t.Point, this.position = new t.Point, this._oldPosition = new t.Point, this.circle = new t.Circle(0, 0, 45), this.activePointer = this.mousePointer, this.hitCanvas = t.CanvasPool.create(this, 1, 1), this.hitContext = this.hitCanvas.getContext("2d"), this.game.device.mspointer && !1 !== e.mspointer ? this.mspointer.start() : this.game.device.touch && !1 !== e.touch && this.touch.start(), this.mspointer.active || !1 === e.mouse || this.mouse.start(), this.mousePointer.active = !0, !1 !== e.mouseWheel && this.mouseWheel.start(), !1 !== e.pointerLock && this.pointerLock.start(), this.keyboard && !1 !== e.keyboard && this.keyboard.start();
                    var i = this;
                    this._onClickTrampoline = function(t) {
                        i.onClickTrampoline(t)
                    }, this.game.canvas.addEventListener("click", this._onClickTrampoline, !1)
                },
                destroy: function() {
                    this.mouse.stop(), this.mouseWheel.stop(), this.touch.stop(), this.mspointer.stop(), this.pointerLock.stop(), this.keyboard && this.keyboard.stop(), this.gamepad && this.gamepad.stop(), this.moveCallbacks = [], t.CanvasPool.remove(this), this.game.canvas.removeEventListener("click", this._onClickTrampoline)
                },
                setInteractiveCandidateHandler: function(t, e) {
                    this.customCandidateHandler = t, this.customCandidateHandlerContext = e
                },
                addMoveCallback: function(t, e) {
                    this.moveCallbacks.push({
                        callback: t,
                        context: e
                    })
                },
                addTouchLockCallback: function(t, e, i) {
                    void 0 === i && (i = !1), this.touchLockCallbacks.push({
                        callback: t,
                        context: e,
                        onEnd: i
                    })
                },
                removeTouchLockCallback: function(t, e) {
                    for (var i = this.touchLockCallbacks.length; i--;)
                        if (this.touchLockCallbacks[i].callback === t && this.touchLockCallbacks[i].context === e) return this.touchLockCallbacks.splice(i, 1), !0;
                    return !1
                },
                executeTouchLockCallbacks: function(t, e) {
                    for (var i = this.touchLockCallbacks.length; i--;) {
                        var s = this.touchLockCallbacks[i];
                        s.onEnd === t && s.callback.call(s.context, this, e) && this.touchLockCallbacks.splice(i, 1)
                    }
                },
                deleteMoveCallback: function(t, e) {
                    for (var i = this.moveCallbacks.length; i--;)
                        if (this.moveCallbacks[i].callback === t && this.moveCallbacks[i].context === e) return void this.moveCallbacks.splice(i, 1)
                },
                addPointer: function() {
                    if (this.pointers.length >= t.Input.MAX_POINTERS) return console.warn("Phaser.Input.addPointer: Maximum limit of " + t.Input.MAX_POINTERS + " pointers reached."), null;
                    var e = this.pointers.length + 1,
                        i = new t.Pointer(this.game, e, t.PointerMode.CONTACT);
                    return this.pointers.push(i), this["pointer" + e] = i, i
                },
                update: function() {
                    if (this.keyboard && this.keyboard.update(), this.pollRate > 0 && this._pollCounter < this.pollRate) this._pollCounter++;
                    else {
                        this.speed.x = this.position.x - this._oldPosition.x, this.speed.y = this.position.y - this._oldPosition.y, this._oldPosition.copyFrom(this.position), this.mousePointer.update(), this.gamepad && this.gamepad.active && this.gamepad.update();
                        for (var t = 0; t < this.pointers.length; t++) this.pointers[t].update();
                        this._pollCounter = 0
                    }
                },
                pauseUpdate: function() {
                    this.gamepad && this.gamepad.active && this.gamepad.update()
                },
                reset: function(e) {
                    if (this.game.isBooted && !this.resetLocked) {
                        void 0 === e && (e = !1), this.mousePointer.reset(), this.keyboard && this.keyboard.reset(e);
                        for (var i = 0; i < this.pointers.length; i++) this.pointers[i].reset();
                        "none" !== this.game.canvas.style.cursor && (this.game.canvas.style.cursor = ""), e && (this.onDown.dispose(), this.onUp.dispose(), this.onTap.dispose(), this.onHold.dispose(), this.onDown = new t.Signal, this.onUp = new t.Signal, this.onTap = new t.Signal, this.onHold = new t.Signal, this.moveCallbacks = []), this._pollCounter = 0
                    }
                },
                resetSpeed: function(t, e) {
                    this._oldPosition.setTo(t, e), this.speed.setTo(0, 0)
                },
                startPointer: function(t) {
                    if (this.maxPointers >= 0 && this.countActivePointers(this.maxPointers) >= this.maxPointers) return null;
                    if (!this.pointer1.active) return this.pointer1.start(t);
                    if (!this.pointer2.active) return this.pointer2.start(t);
                    for (var e = 2; e < this.pointers.length; e++) {
                        var i = this.pointers[e];
                        if (!i.active) return i.start(t)
                    }
                    return null
                },
                updatePointer: function(t) {
                    if (this.pointer1.active && this.pointer1.identifier === t.identifier) return this.pointer1.move(t);
                    if (this.pointer2.active && this.pointer2.identifier === t.identifier) return this.pointer2.move(t);
                    for (var e = 2; e < this.pointers.length; e++) {
                        var i = this.pointers[e];
                        if (i.active && i.identifier === t.identifier) return i.move(t)
                    }
                    return null
                },
                stopPointer: function(t) {
                    if (this.pointer1.active && this.pointer1.identifier === t.identifier) return this.pointer1.stop(t);
                    if (this.pointer2.active && this.pointer2.identifier === t.identifier) return this.pointer2.stop(t);
                    for (var e = 2; e < this.pointers.length; e++) {
                        var i = this.pointers[e];
                        if (i.active && i.identifier === t.identifier) return i.stop(t)
                    }
                    return null
                },
                countActivePointers: function(t) {
                    void 0 === t && (t = this.pointers.length);
                    for (var e = t, i = 0; i < this.pointers.length && e > 0; i++) this.pointers[i].active && e--;
                    return t - e
                },
                getPointer: function(t) {
                    void 0 === t && (t = !1);
                    for (var e = 0; e < this.pointers.length; e++) {
                        var i = this.pointers[e];
                        if (i.active === t) return i
                    }
                    return null
                },
                getPointerFromIdentifier: function(t) {
                    for (var e = 0; e < this.pointers.length; e++) {
                        var i = this.pointers[e];
                        if (i.identifier === t) return i
                    }
                    return null
                },
                getPointerFromId: function(t) {
                    for (var e = 0; e < this.pointers.length; e++) {
                        var i = this.pointers[e];
                        if (i.pointerId === t) return i
                    }
                    return null
                },
                getLocalPosition: function(e, i, s) {
                    void 0 === s && (s = new t.Point);
                    var n = e.worldTransform,
                        r = 1 / (n.a * n.d + n.c * -n.b);
                    return s.setTo(n.d * r * i.x + -n.c * r * i.y + (n.ty * n.c - n.tx * n.d) * r, n.a * r * i.y + -n.b * r * i.x + (-n.ty * n.a + n.tx * n.b) * r)
                },
                hitTest: function(e, i, s) {
                    if (!e.worldVisible) return !1;
                    if (this.getLocalPosition(e, i, this._localPoint), s.copyFrom(this._localPoint), e.hitArea && e.hitArea.contains) return e.hitArea.contains(this._localPoint.x, this._localPoint.y);
                    if (t.Creature && e instanceof t.Creature) {
                        var n = Math.abs(e.width),
                            r = Math.abs(e.height),
                            o = e.x - n * e.anchorX;
                        if (this.game.camera.x + i.x >= o && this.game.camera.x + i.x < o + n && (a = e.y - r * e.anchorY, this.game.camera.y + i.y >= a && this.game.camera.y + i.y < a + r)) return !0
                    } else if (e instanceof t.TileSprite) {
                        n = e.width, r = e.height, o = -n * e.anchor.x;
                        if (this._localPoint.x >= o && this._localPoint.x < o + n && (a = -r * e.anchor.y, this._localPoint.y >= a && this._localPoint.y < a + r)) return !0
                    } else if (e instanceof PIXI.Sprite) {
                        n = e.texture.frame.width / e.texture.baseTexture.resolution, r = e.texture.frame.height / e.texture.baseTexture.resolution, o = -n * e.anchor.x;
                        if (this._localPoint.x >= o && this._localPoint.x < o + n) {
                            var a = -r * e.anchor.y;
                            if (this._localPoint.y >= a && this._localPoint.y < a + r) return !0
                        }
                    } else if (e instanceof t.Graphics)
                        for (l = 0; l < e.graphicsData.length; l++) {
                            var h = e.graphicsData[l];
                            if (h.fill && h.shape && h.shape.contains(this._localPoint.x, this._localPoint.y)) return !0
                        }
                    for (var l = 0; l < e.children.length; l++)
                        if (this.hitTest(e.children[l], i, s)) return !0;
                    return !1
                },
                onClickTrampoline: function() {
                    this.activePointer.processClickTrampolines()
                },
                callAll: function(t, e) {
                    for (var i = this.interactiveItems.list, s = i.length; s--;) {
                        var n = i[s];
                        n.enabled && n[t](e)
                    }
                }
            }, t.Input.prototype.constructor = t.Input, Object.defineProperty(t.Input.prototype, "x", {
                get: function() {
                    return this._x
                },
                set: function(t) {
                    this._x = Math.floor(t)
                }
            }), Object.defineProperty(t.Input.prototype, "y", {
                get: function() {
                    return this._y
                },
                set: function(t) {
                    this._y = Math.floor(t)
                }
            }), Object.defineProperty(t.Input.prototype, "pollLocked", {
                get: function() {
                    return this.pollRate > 0 && this._pollCounter < this.pollRate
                }
            }), Object.defineProperty(t.Input.prototype, "totalInactivePointers", {
                get: function() {
                    return this.pointers.length - this.countActivePointers()
                }
            }), Object.defineProperty(t.Input.prototype, "totalActivePointers", {
                get: function() {
                    return this.countActivePointers()
                }
            }), Object.defineProperty(t.Input.prototype, "worldX", {
                get: function() {
                    return this.game.camera.view.x + this.x
                }
            }), Object.defineProperty(t.Input.prototype, "worldY", {
                get: function() {
                    return this.game.camera.view.y + this.y
                }
            }), t.Mouse = function(t) {
                this.game = t, this.input = t.input, this.callbackContext = this.game, this.mouseDownCallback = null, this.mouseUpCallback = null, this.mouseOutCallback = null, this.mouseOverCallback = null, this.capture = !1, this.active = !1, this.enabled = !0, this.stopOnGameOut = !1, this.event = null, this._onMouseDown = null, this._onMouseMove = null, this._onMouseUp = null, this._onMouseOut = null, this._onMouseOver = null
            }, t.Mouse.NO_BUTTON = -1, t.Mouse.LEFT_BUTTON = 0, t.Mouse.MIDDLE_BUTTON = 1, t.Mouse.RIGHT_BUTTON = 2, t.Mouse.BACK_BUTTON = 3, t.Mouse.FORWARD_BUTTON = 4, t.Mouse.prototype = {
                start: function() {
                    var t = this.game.device;
                    if (t.isAndroidStockBrowser() && this.input.touch.active) return !1;
                    if (null !== this._onMouseDown) return !1;
                    var e = this;
                    this._onMouseDown = function(t) {
                        return e.onMouseDown(t)
                    }, this._onMouseMove = function(t) {
                        return e.onMouseMove(t)
                    }, this._onMouseUp = function(t) {
                        return e.onMouseUp(t)
                    }, this._onMouseUpGlobal = function(t) {
                        return e.onMouseUpGlobal(t)
                    }, this._onMouseOutGlobal = function(t) {
                        return e.onMouseOutGlobal(t)
                    }, this._onMouseOut = function(t) {
                        return e.onMouseOut(t)
                    }, this._onMouseOver = function(t) {
                        return e.onMouseOver(t)
                    };
                    var i = this.game.canvas;
                    return i.addEventListener("mousedown", this._onMouseDown, !0), i.addEventListener("mousemove", this._onMouseMove, !0), i.addEventListener("mouseup", this._onMouseUp, !0), t.cocoonJS || (window.addEventListener("mouseup", this._onMouseUpGlobal, !0), window.addEventListener("mouseout", this._onMouseOutGlobal, !0), i.addEventListener("mouseover", this._onMouseOver, !0), i.addEventListener("mouseout", this._onMouseOut, !0)), this.active = !0, !0
                },
                onMouseDown: function(t) {
                    this.event = t, this.capture && t.preventDefault(), this.mouseDownCallback && this.mouseDownCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.start(t))
                },
                onMouseMove: function(t) {
                    this.event = t, this.capture && t.preventDefault(), this.mouseMoveCallback && this.mouseMoveCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.move(t))
                },
                onMouseUp: function(t) {
                    this.event = t, this.capture && t.preventDefault(), this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.stop(t))
                },
                onMouseUpGlobal: function(t) {
                    this.input.mousePointer.withinGame || (this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, t), t.identifier = 0, this.input.mousePointer.stop(t))
                },
                onMouseOutGlobal: function(t) {
                    this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !1, this.input.enabled && this.enabled && (this.input.mousePointer.stop(t), this.input.mousePointer.resetButtons())
                },
                onMouseOut: function(t) {
                    this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !1, this.mouseOutCallback && this.mouseOutCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (this.input.mousePointer.updateButtons(t), this.stopOnGameOut && (t.identifier = 0, this.input.mousePointer.stop(t), this.input.callAll("_pointerOutHandler", this.input.mousePointer)))
                },
                onMouseOver: function(t) {
                    this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !0, this.mouseOverCallback && this.mouseOverCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && this.input.mousePointer.updateButtons(t)
                },
                stop: function() {
                    var t = this.game.canvas;
                    t.removeEventListener("mousedown", this._onMouseDown, !0), t.removeEventListener("mousemove", this._onMouseMove, !0), t.removeEventListener("mouseup", this._onMouseUp, !0), t.removeEventListener("mouseover", this._onMouseOver, !0), t.removeEventListener("mouseout", this._onMouseOut, !0), window.removeEventListener("mouseup", this._onMouseUpGlobal, !0), window.removeEventListener("mouseout", this._onMouseOutGlobal, !0), this.active = !1
                }
            }, t.Mouse.prototype.constructor = t.Mouse, t.MouseWheel = function(t) {
                this.game = t, this.input = t.input, this.element = t.canvas, this.preventDefault = !0, this.active = !1, this.callback = null, this.callbackContext = t, this.delta = 0, this.wheelEventName = t.device.wheelEvent, this.boundOnWheelHandler = this.onWheelHandler.bind(this), this.eventProxy = null
            }, t.MouseWheel.UP = 1, t.MouseWheel.DOWN = -1, t.MouseWheel.prototype.start = function() {
                return !(!this.wheelEventName || this.active || (this.element.addEventListener(this.wheelEventName, this.boundOnWheelHandler, !0), "mousewheel" === this.wheelEventName ? this.eventProxy = new t.WheelEventProxy(-.025, 1) : "DOMMouseScroll" === this.wheelEventName && (this.eventProxy = new t.WheelEventProxy(1, 1)), this.active = !0, 0))
            }, t.MouseWheel.prototype.stop = function() {
                this.active && (this.element.removeEventListener(this.wheelEventName, this.boundOnWheelHandler, !0), this.active = !1)
            }, t.MouseWheel.prototype.onWheelHandler = function(e) {
                this.eventProxy && (e = this.eventProxy.bindEvent(e)), this.preventDefault && e.preventDefault(), this.delta = t.Math.clamp(-e.deltaY, -1, 1), this.callback && this.callback.call(this.callbackContext, e)
            }, t.MSPointer = function(t) {
                this.game = t, this.input = t.input, this.callbackContext = this.game, this.pointerDownCallback = null, this.pointerMoveCallback = null, this.pointerUpCallback = null, this.pointerOutCallback = null, this.pointerOverCallback = null, this.capture = !1, this.event = null, this.active = !1, this.enabled = !0, this.stopOnGameOut = !1, this._onMSPointerDown = null, this._onMSPointerMove = null, this._onMSPointerUp = null, this._onMSPointerUpGlobal = null, this._onMSPointerOut = null, this._onMSPointerOver = null
            }, t.MSPointer.prototype = {
                start: function() {
                    if (!this.game.device.mspointer) return !1;
                    if (null !== this._onMSPointerDown) return !1;
                    var t = this;
                    this._onMSPointerDown = function(e) {
                        return t.onPointerDown(e)
                    }, this._onMSPointerMove = function(e) {
                        return t.onPointerMove(e)
                    }, this._onMSPointerUp = function(e) {
                        return t.onPointerUp(e)
                    }, this._onMSPointerUpGlobal = function(e) {
                        return t.onPointerUpGlobal(e)
                    }, this._onMSPointerOut = function(e) {
                        return t.onPointerOut(e)
                    }, this._onMSPointerOver = function(e) {
                        return t.onPointerOver(e)
                    };
                    var e = this.game.canvas;
                    return e.addEventListener("MSPointerDown", this._onMSPointerDown, !1), e.addEventListener("MSPointerMove", this._onMSPointerMove, !1), e.addEventListener("MSPointerUp", this._onMSPointerUp, !1), e.addEventListener("pointerdown", this._onMSPointerDown, !1), e.addEventListener("pointermove", this._onMSPointerMove, !1), e.addEventListener("pointerup", this._onMSPointerUp, !1), e.style["-ms-content-zooming"] = "none", e.style["-ms-touch-action"] = "none", this.game.device.cocoonJS || (window.addEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), e.addEventListener("MSPointerOver", this._onMSPointerOver, !0), e.addEventListener("MSPointerOut", this._onMSPointerOut, !0), window.addEventListener("pointerup", this._onMSPointerUpGlobal, !0), e.addEventListener("pointerover", this._onMSPointerOver, !0), e.addEventListener("pointerout", this._onMSPointerOut, !0)), this.active = !0, !0
                },
                onPointerDown: function(t) {
                    this.game.input.executeTouchLockCallbacks(!1, t), this.event = t, this.capture && t.preventDefault(), this.pointerDownCallback && this.pointerDownCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.start(t) : this.input.startPointer(t))
                },
                onPointerMove: function(t) {
                    this.event = t, this.capture && t.preventDefault(), this.pointerMoveCallback && this.pointerMoveCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.move(t) : this.input.updatePointer(t))
                },
                onPointerUp: function(t) {
                    this.game.input.executeTouchLockCallbacks(!0, t), this.event = t, this.capture && t.preventDefault(), this.pointerUpCallback && this.pointerUpCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.stop(t) : this.input.stopPointer(t))
                },
                onPointerUpGlobal: function(t) {
                    if (t.identifier = t.pointerId, "mouse" !== t.pointerType && 4 !== t.pointerType || this.input.mousePointer.withinGame) {
                        var e = this.input.getPointerFromIdentifier(t.identifier);
                        e && e.withinGame && this.onPointerUp(t)
                    } else this.onPointerUp(t)
                },
                onPointerOut: function(t) {
                    if (this.event = t, this.capture && t.preventDefault(), t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType) this.input.mousePointer.withinGame = !1;
                    else {
                        var e = this.input.getPointerFromIdentifier(t.identifier);
                        e && (e.withinGame = !1)
                    }
                    this.pointerOutCallback && this.pointerOutCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && this.stopOnGameOut && (t.identifier = 0, e || (e = this.input.mousePointer), e.stop(t), this.input.callAll("_pointerOutHandler", e))
                },
                onPointerOver: function(t) {
                    if (this.event = t, this.capture && t.preventDefault(), t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType) this.input.mousePointer.withinGame = !0;
                    else {
                        var e = this.input.getPointerFromIdentifier(t.identifier);
                        e && (e.withinGame = !0)
                    }
                    this.pointerOverCallback && this.pointerOverCallback.call(this.callbackContext, t)
                },
                stop: function() {
                    var t = this.game.canvas;
                    t.removeEventListener("MSPointerDown", this._onMSPointerDown, !1), t.removeEventListener("MSPointerMove", this._onMSPointerMove, !1), t.removeEventListener("MSPointerUp", this._onMSPointerUp, !1), t.removeEventListener("pointerdown", this._onMSPointerDown, !1), t.removeEventListener("pointermove", this._onMSPointerMove, !1), t.removeEventListener("pointerup", this._onMSPointerUp, !1), window.removeEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), t.removeEventListener("MSPointerOver", this._onMSPointerOver, !0), t.removeEventListener("MSPointerOut", this._onMSPointerOut, !0), window.removeEventListener("pointerup", this._onMSPointerUpGlobal, !0), t.removeEventListener("pointerover", this._onMSPointerOver, !0), t.removeEventListener("pointerout", this._onMSPointerOut, !0), this.active = !1
                }
            }, t.MSPointer.prototype.constructor = t.MSPointer, t.DeviceButton = function(e, i) {
                this.parent = e, this.game = e.game, this.event = null, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1, this.value = 0, this.buttonCode = i, this.onDown = new t.Signal, this.onUp = new t.Signal, this.onFloat = new t.Signal
            }, t.DeviceButton.prototype = {
                start: function(t, e) {
                    this.isDown || (this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.repeats = 0, this.event = t, this.value = e, t && (this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.ctrlKey = t.ctrlKey), this.onDown.dispatch(this, e))
                },
                stop: function(t, e) {
                    this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.event = t, this.value = e, t && (this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.ctrlKey = t.ctrlKey), this.onUp.dispatch(this, e))
                },
                startStop: function(t, e, i) {
                    t ? this.start(e, i) : this.stop(e, i)
                },
                padFloat: function(t) {
                    this.isDown = !1, this.isUp = !1, this.value = t, this.onFloat.dispatch(this, t)
                },
                justPressed: function(t) {
                    return t = t || 250, this.isDown && this.timeDown + t > this.game.time.time
                },
                justReleased: function(t) {
                    return t = t || 250, this.isUp && this.timeUp + t > this.game.time.time
                },
                reset: function() {
                    this.isDown = !1, this.isUp = !0, this.timeDown = this.game.time.time, this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1
                },
                destroy: function() {
                    this.onDown.dispose(), this.onUp.dispose(), this.onFloat.dispose(), this.parent = null, this.game = null
                }
            }, t.DeviceButton.prototype.constructor = t.DeviceButton, Object.defineProperty(t.DeviceButton.prototype, "duration", {
                get: function() {
                    return this.isUp ? -1 : this.game.time.time - this.timeDown
                }
            }), t.Pointer = function(e, i, s) {
                this.game = e, this.id = i, this.type = t.POINTER, this.exists = !0, this.identifier = 0, this.pointerId = null, this.pointerMode = s || t.PointerMode.CURSOR | t.PointerMode.CONTACT, this.target = null, this.button = null, this.leftButton = new t.DeviceButton(this, t.Pointer.LEFT_BUTTON), this.middleButton = new t.DeviceButton(this, t.Pointer.MIDDLE_BUTTON), this.rightButton = new t.DeviceButton(this, t.Pointer.RIGHT_BUTTON), this.backButton = new t.DeviceButton(this, t.Pointer.BACK_BUTTON), this.forwardButton = new t.DeviceButton(this, t.Pointer.FORWARD_BUTTON), this.eraserButton = new t.DeviceButton(this, t.Pointer.ERASER_BUTTON), this._holdSent = !1, this._history = [], this._nextDrop = 0, this._stateReset = !1, this.withinGame = !1, this.clientX = -1, this.clientY = -1, this.pageX = -1, this.pageY = -1, this.screenX = -1, this.screenY = -1, this.rawMovementX = 0, this.rawMovementY = 0, this.movementX = 0, this.movementY = 0, this.x = -1, this.y = -1, this.isMouse = 0 === i, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.previousTapTime = 0, this.totalTouches = 0, this.msSinceLastClick = Number.MAX_VALUE, this.targetObject = null, this.interactiveCandidates = [], this.active = !1, this.dirty = !1, this.position = new t.Point, this.positionDown = new t.Point, this.positionUp = new t.Point, this.circle = new t.Circle(0, 0, 44), this._clickTrampolines = null, this._trampolineTargetObject = null
            }, t.Pointer.NO_BUTTON = 0, t.Pointer.LEFT_BUTTON = 1, t.Pointer.RIGHT_BUTTON = 2, t.Pointer.MIDDLE_BUTTON = 4, t.Pointer.BACK_BUTTON = 8, t.Pointer.FORWARD_BUTTON = 16, t.Pointer.ERASER_BUTTON = 32, t.Pointer.prototype = {
                resetButtons: function() {
                    this.isDown = !1, this.isUp = !0, this.isMouse && (this.leftButton.reset(), this.middleButton.reset(), this.rightButton.reset(), this.backButton.reset(), this.forwardButton.reset(), this.eraserButton.reset())
                },
                processButtonsDown: function(e, i) {
                    switch (e) {
                        case t.Mouse.LEFT_BUTTON:
                            this.leftButton.start(i);
                            break;
                        case t.Mouse.RIGHT_BUTTON:
                            this.rightButton.start(i);
                            break;
                        case t.Mouse.MIDDLE_BUTTON:
                            this.middleButton.start(i);
                            break;
                        case t.Mouse.BACK_BUTTON:
                            this.backButton.start(i);
                            break;
                        case t.Mouse.FORWARD_BUTTON:
                            this.forwardButton.start(i)
                    }
                },
                processButtonsUp: function(e, i) {
                    switch (e) {
                        case t.Mouse.LEFT_BUTTON:
                            this.leftButton.stop(i);
                            break;
                        case t.Mouse.RIGHT_BUTTON:
                            this.rightButton.stop(i);
                            break;
                        case t.Mouse.MIDDLE_BUTTON:
                            this.middleButton.stop(i);
                            break;
                        case t.Mouse.BACK_BUTTON:
                            this.backButton.stop(i);
                            break;
                        case t.Mouse.FORWARD_BUTTON:
                            this.forwardButton.stop(i)
                    }
                },
                processButtonsUpDown: function(e, i) {
                    var s = i.type.toLowerCase().substr(-4),
                        n = "down" === s,
                        r = "move" === s;
                    void 0 !== e ? (n && 1 === e && i.ctrlKey && (e = 2), this.leftButton.startStop(t.Pointer.LEFT_BUTTON & e, i), this.rightButton.startStop(t.Pointer.RIGHT_BUTTON & e, i), this.middleButton.startStop(t.Pointer.MIDDLE_BUTTON & e, i), this.backButton.startStop(t.Pointer.BACK_BUTTON & e, i), this.forwardButton.startStop(t.Pointer.FORWARD_BUTTON & e, i), this.eraserButton.startStop(t.Pointer.ERASER_BUTTON & e, i)) : void 0 !== i.button ? n && i.ctrlKey && 0 === i.button ? this.rightButton.start(i) : n ? this.processButtonsDown(i.button, i) : r || this.processButtonsUp(i.button, i) : n ? i.ctrlKey ? this.rightButton.start(i) : this.leftButton.start(i) : (this.leftButton.stop(i), this.rightButton.stop(i))
                },
                updateButtons: function(t) {
                    this.button = t.button, this.processButtonsUpDown(t.buttons, t), this.isUp = !0, this.isDown = !1, (this.leftButton.isDown || this.rightButton.isDown || this.middleButton.isDown || this.backButton.isDown || this.forwardButton.isDown || this.eraserButton.isDown) && (this.isUp = !1, this.isDown = !0)
                },
                start: function(e) {
                    var i = this.game.input;
                    return e.pointerId && (this.pointerId = e.pointerId), this.identifier = e.identifier, this.target = e.target, this.isMouse ? this.updateButtons(e) : (this.isDown = !0, this.isUp = !1), this.active = !0, this.withinGame = !0, this.dirty = !1, this._history = [], this._clickTrampolines = null, this._trampolineTargetObject = null, this.msSinceLastClick = this.game.time.time - this.timeDown, this.timeDown = this.game.time.time, this._holdSent = !1, this.move(e, !0), this.positionDown.setTo(this.x, this.y), (i.multiInputOverride === t.Input.MOUSE_OVERRIDES_TOUCH || i.multiInputOverride === t.Input.MOUSE_TOUCH_COMBINE || i.multiInputOverride === t.Input.TOUCH_OVERRIDES_MOUSE && 0 === i.totalActivePointers) && (i.x = this.x, i.y = this.y, i.position.setTo(this.x, this.y), i.onDown.dispatch(this, e), i.resetSpeed(this.x, this.y)), this._stateReset = !1, this.totalTouches++, null !== this.targetObject && this.targetObject._touchedHandler(this), this
                },
                update: function() {
                    var e = this.game.input;
                    this.active && (this.dirty && (e.interactiveItems.total > 0 && this.processInteractiveObjects(!1), this.dirty = !1), !1 === this._holdSent && this.duration >= e.holdRate && ((e.multiInputOverride === t.Input.MOUSE_OVERRIDES_TOUCH || e.multiInputOverride === t.Input.MOUSE_TOUCH_COMBINE || e.multiInputOverride === t.Input.TOUCH_OVERRIDES_MOUSE && 0 === e.totalActivePointers) && e.onHold.dispatch(this), this._holdSent = !0), e.recordPointerHistory && this.game.time.time >= this._nextDrop && (this._nextDrop = this.game.time.time + e.recordRate, this._history.push({
                        x: this.position.x,
                        y: this.position.y
                    }), this._history.length > e.recordLimit && this._history.shift()))
                },
                move: function(e, i) {
                    var s = this.game.input;
                    if (!s.pollLocked) {
                        void 0 === i && (i = !1), void 0 !== e.button && (this.button = e.button), this.isMouse && this.updateButtons(e), this.clientX = e.clientX, this.clientY = e.clientY, this.pageX = e.pageX, this.pageY = e.pageY, this.screenX = e.screenX, this.screenY = e.screenY, this.isMouse && s.pointerLock.locked && !i && (this.rawMovementX = e.movementX || e.mozMovementX || e.webkitMovementX || 0, this.rawMovementY = e.movementY || e.mozMovementY || e.webkitMovementY || 0, this.movementX += this.rawMovementX, this.movementY += this.rawMovementY), this.x = (this.pageX - this.game.scale.offset.x) * s.scale.x, this.y = (this.pageY - this.game.scale.offset.y) * s.scale.y, this.position.setTo(this.x, this.y), this.circle.x = this.x, this.circle.y = this.y, (s.multiInputOverride === t.Input.MOUSE_OVERRIDES_TOUCH || s.multiInputOverride === t.Input.MOUSE_TOUCH_COMBINE || s.multiInputOverride === t.Input.TOUCH_OVERRIDES_MOUSE && 0 === s.totalActivePointers) && (s.activePointer = this, s.x = this.x, s.y = this.y, s.position.setTo(s.x, s.y), s.circle.x = s.x, s.circle.y = s.y), this.withinGame = this.game.scale.bounds.contains(this.pageX, this.pageY);
                        for (var n = s.moveCallbacks.length; n--;) s.moveCallbacks[n].callback.call(s.moveCallbacks[n].context, this, this.x, this.y, i, e);
                        return null === this.targetObject || this.game.paused && !this.targetObject.noPause || !0 !== this.targetObject.isDragged ? s.interactiveItems.total > 0 && this.processInteractiveObjects(i) : !1 === this.targetObject.update(this) && (this.targetObject = null), this
                    }
                },
                processInteractiveObjects: function(t) {
                    var e = 0,
                        i = -1,
                        s = null,
                        n = this.game.input.interactiveItems.first;
                    for (this.interactiveCandidates = []; n;) n.checked = !1, !n.validForInput(i, e, !1) || this.game.paused && !n.sprite.noPause || (n.checked = !0, (t && n.checkPointerDown(this, !0) || !t && n.checkPointerOver(this, !0)) && (e = n.sprite.renderOrderID, i = n.priorityID, s = n, this.interactiveCandidates.push(n))), n = this.game.input.interactiveItems.next;
                    for (n = this.game.input.interactiveItems.first; n;) !n.checked && n.validForInput(i, e, !0) && (t && n.checkPointerDown(this, !1) || !t && n.checkPointerOver(this, !1)) && (e = n.sprite.renderOrderID, i = n.priorityID, s = n, this.interactiveCandidates.push(n)), n = this.game.input.interactiveItems.next;
                    return this.game.input.customCandidateHandler && (s = this.game.input.customCandidateHandler.call(this.game.input.customCandidateHandlerContext, this, this.interactiveCandidates, s)), this.swapTarget(s, !1), null !== this.targetObject
                },
                swapTarget: function(t, e) {
                    void 0 === e && (e = !1), null === t ? this.targetObject && (this.targetObject._pointerOutHandler(this, e), this.targetObject = null) : null === this.targetObject ? (this.targetObject = t, t._pointerOverHandler(this, e)) : this.targetObject === t ? !1 === t.update(this) && (this.targetObject = null) : (this.targetObject._pointerOutHandler(this, e), this.targetObject = t, this.targetObject._pointerOverHandler(this, e))
                },
                leave: function(t) {
                    this.withinGame = !1, this.move(t, !1)
                },
                stop: function(e) {
                    var i = this.game.input;
                    if (!this._stateReset || !this.withinGame) {
                        if (this.timeUp = this.game.time.time, (i.multiInputOverride === t.Input.MOUSE_OVERRIDES_TOUCH || i.multiInputOverride === t.Input.MOUSE_TOUCH_COMBINE || i.multiInputOverride === t.Input.TOUCH_OVERRIDES_MOUSE && 0 === i.totalActivePointers) && (i.onUp.dispatch(this, e), this.duration >= 0 && this.duration <= i.tapRate)) {
                            var s = this.timeUp - this.previousTapTime < i.doubleTapRate;
                            i.onTap.dispatch(this, s, e), this.previousTapTime = this.timeUp
                        }
                        return this.isMouse ? this.updateButtons(e) : (this.isDown = !1, this.isUp = !0), this.id > 0 && (this.active = !1), this.withinGame = this.game.scale.bounds.contains(e.pageX, e.pageY), this.pointerId = null, this.identifier = null, this.positionUp.setTo(this.x, this.y), !1 === this.isMouse && i.currentPointers--, i.callAll("_releasedHandler", this), this._clickTrampolines && (this._trampolineTargetObject = this.targetObject), this.targetObject = null, this
                    }
                    e.preventDefault()
                },
                justPressed: function(t) {
                    return t = t || this.game.input.justPressedRate, !0 === this.isDown && this.timeDown + t > this.game.time.time
                },
                justReleased: function(t) {
                    return t = t || this.game.input.justReleasedRate, this.isUp && this.timeUp + t > this.game.time.time
                },
                addClickTrampoline: function(t, e, i, s) {
                    if (this.isDown) {
                        for (var n = this._clickTrampolines = this._clickTrampolines || [], r = 0; r < n.length; r++)
                            if (n[r].name === t) {
                                n.splice(r, 1);
                                break
                            }
                        n.push({
                            name: t,
                            targetObject: this.targetObject,
                            callback: e,
                            callbackContext: i,
                            callbackArgs: s
                        })
                    }
                },
                processClickTrampolines: function() {
                    var t = this._clickTrampolines;
                    if (t) {
                        for (var e = 0; e < t.length; e++) {
                            var i = t[e];
                            i.targetObject === this._trampolineTargetObject && i.callback.apply(i.callbackContext, i.callbackArgs)
                        }
                        this._clickTrampolines = null, this._trampolineTargetObject = null
                    }
                },
                reset: function() {
                    !1 === this.isMouse && (this.active = !1), this.pointerId = null, this.identifier = null, this.dirty = !1, this.totalTouches = 0, this._holdSent = !1, this._history.length = 0, this._stateReset = !0, this.resetButtons(), this.targetObject && this.targetObject._releasedHandler(this), this.targetObject = null
                },
                resetMovement: function() {
                    this.movementX = 0, this.movementY = 0
                }
            }, t.Pointer.prototype.constructor = t.Pointer, Object.defineProperty(t.Pointer.prototype, "duration", {
                get: function() {
                    return this.isUp ? -1 : this.game.time.time - this.timeDown
                }
            }), Object.defineProperty(t.Pointer.prototype, "worldX", {
                get: function() {
                    return this.game.world.camera.x + this.x
                }
            }), Object.defineProperty(t.Pointer.prototype, "worldY", {
                get: function() {
                    return this.game.world.camera.y + this.y
                }
            }), t.PointerMode = {
                CURSOR: 1,
                CONTACT: 2
            }, t.PointerModes = {}, t.PointerModes[t.PointerMode.CURSOR] = "CURSOR", t.PointerModes[t.PointerMode.CONTACT] = "CONTACT", t.Touch = function(t) {
                this.game = t, this.active = !1, this.enabled = !0, this.callbackContext = this.game, this.touchStartCallback = null, this.touchMoveCallback = null, this.touchEndCallback = null, this.touchEnterCallback = null, this.touchLeaveCallback = null, this.touchCancelCallback = null, this.preventDefault = !0, this.event = null, this._onTouchStart = null, this._onTouchMove = null, this._onTouchEnd = null, this._onTouchEnter = null, this._onTouchLeave = null, this._onTouchCancel = null, this._onTouchMove = null
            }, t.Touch.prototype = {
                start: function() {
                    if (!this.game.device.touch) return !1;
                    if (null !== this._onTouchStart) return !1;
                    var t = this;
                    return this._onTouchStart = function(e) {
                        return t.onTouchStart(e)
                    }, this._onTouchMove = function(e) {
                        return t.onTouchMove(e)
                    }, this._onTouchEnd = function(e) {
                        return t.onTouchEnd(e)
                    }, this._onTouchEnter = function(e) {
                        return t.onTouchEnter(e)
                    }, this._onTouchLeave = function(e) {
                        return t.onTouchLeave(e)
                    }, this._onTouchCancel = function(e) {
                        return t.onTouchCancel(e)
                    }, this.game.canvas.addEventListener("touchstart", this._onTouchStart, !1), this.game.canvas.addEventListener("touchmove", this._onTouchMove, !1), this.game.canvas.addEventListener("touchend", this._onTouchEnd, !1), this.game.canvas.addEventListener("touchcancel", this._onTouchCancel, !1), this.game.device.cocoonJS || (this.game.canvas.addEventListener("touchenter", this._onTouchEnter, !1), this.game.canvas.addEventListener("touchleave", this._onTouchLeave, !1)), this.active = !0, !0
                },
                consumeDocumentTouches: function() {
                    this._documentTouchMove = function(t) {
                        t.preventDefault()
                    }, document.addEventListener("touchmove", this._documentTouchMove, !1)
                },
                onTouchStart: function(t) {
                    if (this.game.input.executeTouchLockCallbacks(!1, t), this.event = t, this.game.input.enabled && this.enabled) {
                        this.touchStartCallback && this.touchStartCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                        for (var e = 0; e < t.changedTouches.length; e++) this.game.input.startPointer(t.changedTouches[e])
                    }
                },
                onTouchCancel: function(t) {
                    if (this.event = t, this.touchCancelCallback && this.touchCancelCallback.call(this.callbackContext, t), this.game.input.enabled && this.enabled) {
                        this.preventDefault && t.preventDefault();
                        for (var e = 0; e < t.changedTouches.length; e++) this.game.input.stopPointer(t.changedTouches[e])
                    }
                },
                onTouchEnter: function(t) {
                    this.event = t, this.touchEnterCallback && this.touchEnterCallback.call(this.callbackContext, t), this.game.input.enabled && this.enabled && this.preventDefault && t.preventDefault()
                },
                onTouchLeave: function(t) {
                    this.event = t, this.touchLeaveCallback && this.touchLeaveCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault()
                },
                onTouchMove: function(t) {
                    this.event = t, this.touchMoveCallback && this.touchMoveCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                    for (var e = 0; e < t.changedTouches.length; e++) this.game.input.updatePointer(t.changedTouches[e])
                },
                onTouchEnd: function(t) {
                    this.game.input.executeTouchLockCallbacks(!0, t), this.event = t, this.touchEndCallback && this.touchEndCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                    for (var e = 0; e < t.changedTouches.length; e++) this.game.input.stopPointer(t.changedTouches[e])
                },
                stop: function() {
                    this.game.device.touch && (this.game.canvas.removeEventListener("touchstart", this._onTouchStart), this.game.canvas.removeEventListener("touchmove", this._onTouchMove), this.game.canvas.removeEventListener("touchend", this._onTouchEnd), this.game.canvas.removeEventListener("touchenter", this._onTouchEnter), this.game.canvas.removeEventListener("touchleave", this._onTouchLeave), this.game.canvas.removeEventListener("touchcancel", this._onTouchCancel), this.active = !1)
                }
            }, t.Touch.prototype.constructor = t.Touch, t.InputHandler = function(e) {
                this.sprite = e, this.game = e.game, this.enabled = !1, this.checked = !1, this.priorityID = 0, this.useHandCursor = !1, this._setHandCursor = !1, this.isDragged = !1, this.allowHorizontalDrag = !0, this.allowVerticalDrag = !0, this.bringToTop = !1, this.snapOffset = null, this.snapOnDrag = !1, this.snapOnRelease = !1, this.snapX = 0, this.snapY = 0, this.snapOffsetX = 0, this.snapOffsetY = 0, this.pixelPerfectOver = !1, this.pixelPerfectClick = !1, this.pixelPerfectAlpha = 255, this.draggable = !1, this.boundsRect = null, this.boundsSprite = null, this.scaleLayer = !1, this.dragOffset = new t.Point, this.dragFromCenter = !1, this.dragStopBlocksInputUp = !1, this.dragStartPoint = new t.Point, this.dragDistanceThreshold = 0, this.dragTimeThreshold = 0, this.downPoint = new t.Point, this.snapPoint = new t.Point, this._dragPoint = new t.Point, this._dragPhase = !1, this._pendingDrag = !1, this._dragTimePass = !1, this._dragDistancePass = !1, this._wasEnabled = !1, this._tempPoint = new t.Point, this._pointerData = [], this._pointerData.push({
                    id: 0,
                    x: 0,
                    y: 0,
                    camX: 0,
                    camY: 0,
                    isDown: !1,
                    isUp: !1,
                    isOver: !1,
                    isOut: !1,
                    timeOver: 0,
                    timeOut: 0,
                    timeDown: 0,
                    timeUp: 0,
                    downDuration: 0,
                    isDragged: !1
                })
            }, t.InputHandler.prototype = {
                start: function(e, i) {
                    if (e = e || 0, void 0 === i && (i = !1), !1 === this.enabled) {
                        this.game.input.interactiveItems.add(this), this.useHandCursor = i, this.priorityID = e;
                        for (var s = 0; s < 10; s++) this._pointerData[s] = {
                            id: s,
                            x: 0,
                            y: 0,
                            isDown: !1,
                            isUp: !1,
                            isOver: !1,
                            isOut: !1,
                            timeOver: 0,
                            timeOut: 0,
                            timeDown: 0,
                            timeUp: 0,
                            downDuration: 0,
                            isDragged: !1
                        };
                        this.snapOffset = new t.Point, this.enabled = !0, this._wasEnabled = !0
                    }
                    return this.sprite.events.onAddedToGroup.add(this.addedToGroup, this), this.sprite.events.onRemovedFromGroup.add(this.removedFromGroup, this), this.sprite
                },
                addedToGroup: function() {
                    this._dragPhase || this._wasEnabled && !this.enabled && this.start()
                },
                removedFromGroup: function() {
                    this._dragPhase || (this.enabled ? (this._wasEnabled = !0, this.stop()) : this._wasEnabled = !1)
                },
                reset: function() {
                    this.enabled = !1;
                    for (var t = 0; t < 10; t++) this._pointerData[t] = {
                        id: t,
                        x: 0,
                        y: 0,
                        isDown: !1,
                        isUp: !1,
                        isOver: !1,
                        isOut: !1,
                        timeOver: 0,
                        timeOut: 0,
                        timeDown: 0,
                        timeUp: 0,
                        downDuration: 0,
                        isDragged: !1
                    }
                },
                stop: function() {
                    !1 !== this.enabled && (this.enabled = !1, this.game.input.interactiveItems.remove(this))
                },
                destroy: function() {
                    this.sprite && (this._setHandCursor && (this.game.canvas.style.cursor = "", this._setHandCursor = !1), this.enabled = !1, this.game.input.interactiveItems.remove(this), this._pointerData.length = 0, this.boundsRect = null, this.boundsSprite = null, this.sprite = null)
                },
                validForInput: function(t, e, i) {
                    return void 0 === i && (i = !0), !(!this.enabled || 0 === this.sprite.scale.x || 0 === this.sprite.scale.y || this.priorityID < this.game.input.minPriorityID || this.sprite.parent && this.sprite.parent.ignoreChildInput || !i && (this.pixelPerfectClick || this.pixelPerfectOver) || !(this.priorityID > t || this.priorityID === t && this.sprite.renderOrderID > e))
                },
                isPixelPerfect: function() {
                    return this.pixelPerfectClick || this.pixelPerfectOver
                },
                pointerX: function(t) {
                    return t = t || 0, this._pointerData[t].x
                },
                pointerY: function(t) {
                    return t = t || 0, this._pointerData[t].y
                },
                pointerDown: function(t) {
                    return t = t || 0, this._pointerData[t].isDown
                },
                pointerUp: function(t) {
                    return t = t || 0, this._pointerData[t].isUp
                },
                pointerTimeDown: function(t) {
                    return t = t || 0, this._pointerData[t].timeDown
                },
                pointerTimeUp: function(t) {
                    return t = t || 0, this._pointerData[t].timeUp
                },
                pointerOver: function(t) {
                    if (!this.enabled) return !1;
                    if (void 0 === t) {
                        for (var e = 0; e < 10; e++)
                            if (this._pointerData[e].isOver) return !0;
                        return !1
                    }
                    return this._pointerData[t].isOver
                },
                pointerOut: function(t) {
                    if (!this.enabled) return !1;
                    if (void 0 !== t) return this._pointerData[t].isOut;
                    for (var e = 0; e < 10; e++)
                        if (this._pointerData[e].isOut) return !0
                },
                pointerTimeOver: function(t) {
                    return t = t || 0, this._pointerData[t].timeOver
                },
                pointerTimeOut: function(t) {
                    return t = t || 0, this._pointerData[t].timeOut
                },
                pointerDragged: function(t) {
                    return t = t || 0, this._pointerData[t].isDragged
                },
                checkPointerDown: function(t, e) {
                    return !!(t.isDown && this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && !!this.game.input.hitTest(this.sprite, t, this._tempPoint) && (void 0 === e && (e = !1), !(!e && this.pixelPerfectClick) || this.checkPixel(this._tempPoint.x, this._tempPoint.y))
                },
                checkPointerOver: function(t, e) {
                    return !!(this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && !!this.game.input.hitTest(this.sprite, t, this._tempPoint) && (void 0 === e && (e = !1), !(!e && this.pixelPerfectOver) || this.checkPixel(this._tempPoint.x, this._tempPoint.y))
                },
                checkPixel: function(t, e, i) {
                    if (this.sprite.texture.baseTexture.source) {
                        if (null === t && null === e) {
                            this.game.input.getLocalPosition(this.sprite, i, this._tempPoint);
                            t = this._tempPoint.x, e = this._tempPoint.y
                        }
                        if (0 !== this.sprite.anchor.x && (t -= -this.sprite.texture.frame.width * this.sprite.anchor.x), 0 !== this.sprite.anchor.y && (e -= -this.sprite.texture.frame.height * this.sprite.anchor.y), t += this.sprite.texture.frame.x, e += this.sprite.texture.frame.y, this.sprite.texture.trim && (t -= this.sprite.texture.trim.x, e -= this.sprite.texture.trim.y, t < this.sprite.texture.crop.x || t > this.sprite.texture.crop.right || e < this.sprite.texture.crop.y || e > this.sprite.texture.crop.bottom)) return this._dx = t, this._dy = e, !1;
                        if (this._dx = t, this._dy = e, this.game.input.hitContext.clearRect(0, 0, 1, 1), this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, t, e, 1, 1, 0, 0, 1, 1), this.game.input.hitContext.getImageData(0, 0, 1, 1).data[3] >= this.pixelPerfectAlpha) return !0
                    }
                    return !1
                },
                update: function(e) {
                    if (null !== this.sprite && void 0 !== this.sprite.parent) return this.enabled && this.sprite.visible && this.sprite.parent.visible ? this._pendingDrag ? (this._dragDistancePass || (this._dragDistancePass = t.Math.distance(e.x, e.y, this.downPoint.x, this.downPoint.y) >= this.dragDistanceThreshold), this._dragDistancePass && this._dragTimePass && this.startDrag(e), !0) : this.draggable && this._draggedPointerID === e.id ? this.updateDrag(e, !1) : this._pointerData[e.id].isOver ? this.checkPointerOver(e) ? (this._pointerData[e.id].x = e.x - this.sprite.x, this._pointerData[e.id].y = e.y - this.sprite.y, !0) : (this._pointerOutHandler(e), !1) : void 0 : (this._pointerOutHandler(e), !1)
                },
                _pointerOverHandler: function(t, e) {
                    if (null !== this.sprite) {
                        var i = this._pointerData[t.id];
                        if (!1 === i.isOver || t.dirty) {
                            var s = !1 === i.isOver;
                            i.isOver = !0, i.isOut = !1, i.timeOver = this.game.time.time, i.x = t.x - this.sprite.x, i.y = t.y - this.sprite.y, this.useHandCursor && !1 === i.isDragged && (this.game.canvas.style.cursor = "pointer", this._setHandCursor = !0), !e && s && this.sprite && this.sprite.events && this.sprite.events.onInputOver$dispatch(this.sprite, t), this.sprite.parent && this.sprite.parent.onChildInputOver && this.sprite.parent.onChildInputOver.dispatch(this.sprite, t)
                        }
                    }
                },
                _pointerOutHandler: function(t, e) {
                    if (null !== this.sprite) {
                        var i = this._pointerData[t.id];
                        i.isOver = !1, i.isOut = !0, i.timeOut = this.game.time.time, this.useHandCursor && !1 === i.isDragged && (this.game.canvas.style.cursor = "", this._setHandCursor = !1), !e && this.sprite && this.sprite.events && (this.sprite.events.onInputOut$dispatch(this.sprite, t), this.sprite && this.sprite.parent && this.sprite.parent.onChildInputOut && this.sprite.parent.onChildInputOut.dispatch(this.sprite, t))
                    }
                },
                _touchedHandler: function(t) {
                    if (null !== this.sprite) {
                        var e = this._pointerData[t.id];
                        if (!e.isDown && e.isOver) {
                            if (this.pixelPerfectClick && !this.checkPixel(null, null, t)) return;
                            if (e.isDown = !0, e.isUp = !1, e.timeDown = this.game.time.time, this.downPoint.set(t.x, t.y), t.dirty = !0, this.sprite && this.sprite.events && (this.sprite.events.onInputDown$dispatch(this.sprite, t), this.sprite && this.sprite.parent && this.sprite.parent.onChildInputDown && this.sprite.parent.onChildInputDown.dispatch(this.sprite, t), null === this.sprite)) return;
                            this.draggable && !1 === this.isDragged && (0 === this.dragTimeThreshold && 0 === this.dragDistanceThreshold ? this.startDrag(t) : (this._pendingDrag = !0, this._dragDistancePass = 0 === this.dragDistanceThreshold, this.dragTimeThreshold > 0 ? (this._dragTimePass = !1, this.game.time.events.add(this.dragTimeThreshold, this.dragTimeElapsed, this, t)) : this._dragTimePass = !0)), this.bringToTop && this.sprite.bringToTop()
                        }
                    }
                },
                dragTimeElapsed: function(t) {
                    this._dragTimePass = !0, this._pendingDrag && this.sprite && this._dragDistancePass && this.startDrag(t)
                },
                _releasedHandler: function(t) {
                    if (null !== this.sprite) {
                        var e = this._pointerData[t.id];
                        if (e.isDown && t.isUp) {
                            e.isDown = !1, e.isUp = !0, e.timeUp = this.game.time.time, e.downDuration = e.timeUp - e.timeDown;
                            var i = this.checkPointerOver(t);
                            this.sprite && this.sprite.events && (this.dragStopBlocksInputUp && (!this.dragStopBlocksInputUp || this.draggable && this.isDragged && this._draggedPointerID === t.id) || this.sprite.events.onInputUp$dispatch(this.sprite, t, i), this.sprite && this.sprite.parent && this.sprite.parent.onChildInputUp && this.sprite.parent.onChildInputUp.dispatch(this.sprite, t, i), i && (i = this.checkPointerOver(t))), e.isOver = i, !i && this.useHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), t.dirty = !0, this._pendingDrag = !1, this.draggable && this.isDragged && this._draggedPointerID === t.id && this.stopDrag(t)
                        }
                    }
                },
                updateDrag: function(t, e) {
                    var i = this.game.camera,
                        s = this.dragOffset,
                        n = this._dragPoint,
                        r = this._pointerData[t.id],
                        o = this.snapPoint,
                        a = this.sprite;
                    if (void 0 === e && (e = !1), t.isUp) return this.stopDrag(t), !1;
                    var h = this.globalToLocal(t);
                    if (a.fixedToCamera) var l = i.scale.x * h.x + n.x + s.x,
                        c = i.scale.y * h.y + n.y + s.y;
                    else l = h.x + n.x + s.x, c = h.y + n.y + s.y;
                    if (a.fixedToCamera) {
                        var u = a.cameraOffset,
                            d = u.x,
                            p = u.y;
                        this.allowHorizontalDrag && (u.x = l - i.x), this.allowVerticalDrag && (u.y = c - i.y), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (u.x = Math.round((u.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, u.y = Math.round((u.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, o.set(u.x, u.y));
                        var f = u.x - d,
                            g = u.y - p
                    } else {
                        var m = i.x - r.camX,
                            y = i.y - r.camY;
                        d = a.x, p = a.y;
                        this.allowHorizontalDrag && (a.x = l + m), this.allowVerticalDrag && (a.y = c + y), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (a.x = Math.round((a.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, a.y = Math.round((a.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, o.set(a.x, a.y));
                        f = a.x - d, g = a.y - p
                    }
                    return this.sprite.events.onDragUpdate.dispatch(a, t, l, c, o, e, f, g), !0
                },
                justOver: function(t, e) {
                    return t = t || 0, e = e || 500, this._pointerData[t].isOver && this.overDuration(t) < e
                },
                justOut: function(t, e) {
                    return t = t || 0, e = e || 500, this._pointerData[t].isOut && this.game.time.time - this._pointerData[t].timeOut < e
                },
                justPressed: function(t, e) {
                    return t = t || 0, e = e || 500, this._pointerData[t].isDown && this.downDuration(t) < e
                },
                justReleased: function(t, e) {
                    return t = t || 0, e = e || 500, this._pointerData[t].isUp && this.game.time.time - this._pointerData[t].timeUp < e
                },
                overDuration: function(t) {
                    return t = t || 0, this._pointerData[t].isOver ? this.game.time.time - this._pointerData[t].timeOver : -1
                },
                downDuration: function(t) {
                    return t = t || 0, this._pointerData[t].isDown ? this.game.time.time - this._pointerData[t].timeDown : -1
                },
                enableDrag: function(e, i, s, n, r, o) {
                    void 0 === e && (e = !1), void 0 === i && (i = !1), void 0 === s && (s = !1), void 0 === n && (n = 255), void 0 === r && (r = null), void 0 === o && (o = null), this._dragPoint = new t.Point, this.draggable = !0, this.bringToTop = i, this.dragOffset = new t.Point, this.dragFromCenter = e, this.pixelPerfectClick = s, this.pixelPerfectAlpha = n, r && (this.boundsRect = r), o && (this.boundsSprite = o)
                },
                disableDrag: function() {
                    if (this._pointerData)
                        for (var t = 0; t < 10; t++) this._pointerData[t].isDragged = !1;
                    this.draggable = !1, this.isDragged = !1, this._draggedPointerID = -1, this._pendingDrag = !1
                },
                startDrag: function(e) {
                    var i = this.sprite.x,
                        s = this.sprite.y,
                        n = this.globalToLocal(e);
                    if (this.isDragged = !0, this._draggedPointerID = e.id, this._pointerData[e.id].camX = this.game.camera.x, this._pointerData[e.id].camY = this.game.camera.y, this._pointerData[e.id].isDragged = !0, this.sprite.fixedToCamera) {
                        if (this.dragFromCenter) {
                            var r = this.sprite.getBounds(),
                                o = this.globalToLocal(new t.Point(r.centerX, r.centerY));
                            this.sprite.cameraOffset.x = n.x + (this.sprite.cameraOffset.x - o.x), this.sprite.cameraOffset.y = n.y + (this.sprite.cameraOffset.y - o.y)
                        }
                        this._dragPoint.setTo(this.sprite.cameraOffset.x - e.x, this.sprite.cameraOffset.y - e.y)
                    } else {
                        if (this.dragFromCenter) {
                            r = this.sprite.getBounds(), o = this.globalToLocal(new t.Point(r.centerX, r.centerY));
                            this.sprite.x = n.x + (this.sprite.x - o.x), this.sprite.y = n.y + (this.sprite.y - o.y)
                        }
                        this._dragPoint.setTo(this.sprite.x - n.x, this.sprite.y - n.y)
                    }
                    this.updateDrag(e, !0), this.bringToTop && (this._dragPhase = !0, this.sprite.bringToTop()), this.dragStartPoint.set(i, s), this.sprite.events.onDragStart$dispatch(this.sprite, e, i, s), this._pendingDrag = !1
                },
                globalToLocalX: function(t) {
                    return this.scaleLayer && (t -= this.game.scale.grid.boundsFluid.x, t *= this.game.scale.grid.scaleFluidInversed.x), t
                },
                globalToLocalY: function(t) {
                    return this.scaleLayer && (t -= this.game.scale.grid.boundsFluid.y, t *= this.game.scale.grid.scaleFluidInversed.y), t
                },
                globalToLocal: function(t) {
                    return this.sprite.parent ? this.game.input.getLocalPosition(this.sprite.parent, {
                        x: t.x,
                        y: t.y
                    }) : t
                },
                stopDrag: function(t) {
                    this.isDragged = !1, this._draggedPointerID = -1, this._pointerData[t.id].isDragged = !1, this._dragPhase = !1, this._pendingDrag = !1, this.snapOnRelease && (this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY) : (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY)), this.sprite.events.onDragStop$dispatch(this.sprite, t), !1 === this.checkPointerOver(t) && this._pointerOutHandler(t)
                },
                setDragLock: function(t, e) {
                    void 0 === t && (t = !0), void 0 === e && (e = !0), this.allowHorizontalDrag = t, this.allowVerticalDrag = e
                },
                enableSnap: function(t, e, i, s, n, r) {
                    void 0 === i && (i = !0), void 0 === s && (s = !1), void 0 === n && (n = 0), void 0 === r && (r = 0), this.snapX = t, this.snapY = e, this.snapOffsetX = n, this.snapOffsetY = r, this.snapOnDrag = i, this.snapOnRelease = s
                },
                disableSnap: function() {
                    this.snapOnDrag = !1, this.snapOnRelease = !1
                },
                checkBoundsRect: function() {
                    this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsRect.left ? this.sprite.cameraOffset.x = this.boundsRect.left : this.sprite.cameraOffset.x + this.sprite.width > this.boundsRect.right && (this.sprite.cameraOffset.x = this.boundsRect.right - this.sprite.width), this.sprite.cameraOffset.y < this.boundsRect.top ? this.sprite.cameraOffset.y = this.boundsRect.top : this.sprite.cameraOffset.y + this.sprite.height > this.boundsRect.bottom && (this.sprite.cameraOffset.y = this.boundsRect.bottom - this.sprite.height)) : (this.sprite.left < this.boundsRect.left ? this.sprite.x = this.boundsRect.x + this.sprite.offsetX : this.sprite.right > this.boundsRect.right && (this.sprite.x = this.boundsRect.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsRect.top ? this.sprite.y = this.boundsRect.top + this.sprite.offsetY : this.sprite.bottom > this.boundsRect.bottom && (this.sprite.y = this.boundsRect.bottom - (this.sprite.height - this.sprite.offsetY)))
                },
                checkBoundsSprite: function() {
                    this.sprite.fixedToCamera && this.boundsSprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsSprite.cameraOffset.x ? this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x : this.sprite.cameraOffset.x + this.sprite.width > this.boundsSprite.cameraOffset.x + this.boundsSprite.width && (this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x + this.boundsSprite.width - this.sprite.width), this.sprite.cameraOffset.y < this.boundsSprite.cameraOffset.y ? this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y : this.sprite.cameraOffset.y + this.sprite.height > this.boundsSprite.cameraOffset.y + this.boundsSprite.height && (this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y + this.boundsSprite.height - this.sprite.height)) : (this.sprite.left < this.boundsSprite.left ? this.sprite.x = this.boundsSprite.left + this.sprite.offsetX : this.sprite.right > this.boundsSprite.right && (this.sprite.x = this.boundsSprite.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsSprite.top ? this.sprite.y = this.boundsSprite.top + this.sprite.offsetY : this.sprite.bottom > this.boundsSprite.bottom && (this.sprite.y = this.boundsSprite.bottom - (this.sprite.height - this.sprite.offsetY)))
                }
            }, t.InputHandler.prototype.constructor = t.InputHandler, t.PointerLock = function(e) {
                this.game = e, this.input = e.input, this.element = e.canvas, this.active = !1, this.locked = !1, this.onChange = new t.Signal, this.onError = new t.Signal, this.boundOnChangeHandler = this.onChangeHandler.bind(this), this.boundOnErrorHandler = this.onErrorHandler.bind(this);
                var i = e.device;
                this.pointerLockElement = i.pointerLockElement, this.pointerlockchange = i.pointerlockchange, this.pointerlockerror = i.pointerlockerror
            }, t.PointerLock.prototype.start = function() {
                return !(!this.game.device.pointerLock || this.active || (this.element.requestPointerLock || (this.element.requestPointerLock = this.element.mozRequestPointerLock || this.element.webkitRequestPointerLock), document.exitPointerLock || (document.exitPointerLock = document.mozExitPointerLock || document.webkitExitPointerLock), document.addEventListener(this.pointerlockchange, this.boundOnChangeHandler, !0), document.addEventListener(this.pointerlockerror, this.boundOnErrorHandler, !0), this.active = !0, 0))
            }, t.PointerLock.prototype.stop = function() {
                this.active && (document.removeEventListener(this.pointerlockchange, this.boundOnChangeHandler, !0), document.removeEventListener(this.pointerlockerror, this.boundOnErrorHandler, !0), this.active = !1)
            }, t.PointerLock.prototype.request = function() {
                this.active && !this.locked && this.element.requestPointerLock()
            }, t.PointerLock.prototype.exit = function() {
                document.exitPointerLock()
            }, t.PointerLock.prototype.onChangeHandler = function(t) {
                this.locked = document[this.pointerLockElement] === this.element, this.onChange.dispatch(this.locked, t)
            }, t.PointerLock.prototype.onErrorHandler = function(t) {
                this.onError.dispatch(t)
            }, t.Gamepad = function(e) {
                this.game = e, this._gamepadIndexMap = {}, this._rawPads = [], this._active = !1, this.enabled = !0, this._gamepadSupportAvailable = !!navigator.webkitGetGamepads || !!navigator.webkitGamepads || -1 !== navigator.userAgent.indexOf("Firefox/") || !!navigator.getGamepads, this._prevRawGamepadTypes = [], this._prevTimestamps = [], this.callbackContext = this, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null, this._ongamepadconnected = null, this._gamepaddisconnected = null, this._gamepads = [new t.SinglePad(e, this), new t.SinglePad(e, this), new t.SinglePad(e, this), new t.SinglePad(e, this)]
            }, t.Gamepad.prototype = {
                addCallbacks: function(t, e) {
                    void 0 !== e && (this.onConnectCallback = "function" == typeof e.onConnect ? e.onConnect : this.onConnectCallback, this.onDisconnectCallback = "function" == typeof e.onDisconnect ? e.onDisconnect : this.onDisconnectCallback, this.onDownCallback = "function" == typeof e.onDown ? e.onDown : this.onDownCallback, this.onUpCallback = "function" == typeof e.onUp ? e.onUp : this.onUpCallback, this.onAxisCallback = "function" == typeof e.onAxis ? e.onAxis : this.onAxisCallback, this.onFloatCallback = "function" == typeof e.onFloat ? e.onFloat : this.onFloatCallback, this.callbackContext = t)
                },
                start: function() {
                    if (!this._active) {
                        this._active = !0;
                        var t = this;
                        this._onGamepadConnected = function(e) {
                            return t.onGamepadConnected(e)
                        }, this._onGamepadDisconnected = function(e) {
                            return t.onGamepadDisconnected(e)
                        }, window.addEventListener("gamepadconnected", this._onGamepadConnected, !1), window.addEventListener("gamepaddisconnected", this._onGamepadDisconnected, !1)
                    }
                },
                onGamepadConnected: function(t) {
                    var e = t.gamepad;
                    this._rawPads.push(e), this._gamepads[e.index].connect(e)
                },
                onGamepadDisconnected: function(t) {
                    var e = t.gamepad;
                    for (var i in this._rawPads) this._rawPads[i].index === e.index && this._rawPads.splice(i, 1);
                    this._gamepads[e.index].disconnect()
                },
                update: function() {
                    this._pollGamepads(), this.pad1.pollStatus(), this.pad2.pollStatus(), this.pad3.pollStatus(), this.pad4.pollStatus()
                },
                _pollGamepads: function() {
                    if (this._active) {
                        if (navigator.getGamepads) t = navigator.getGamepads();
                        else if (navigator.webkitGetGamepads) t = navigator.webkitGetGamepads();
                        else if (navigator.webkitGamepads) var t = navigator.webkitGamepads();
                        if (t) {
                            this._rawPads = [];
                            for (var e = !1, i = 0; i < t.length && (typeof t[i] !== this._prevRawGamepadTypes[i] && (e = !0, this._prevRawGamepadTypes[i] = typeof t[i]), t[i] && this._rawPads.push(t[i]), 3 !== i); i++);
                            for (var s = 0; s < this._gamepads.length; s++) this._gamepads[s]._rawPad = this._rawPads[s];
                            if (e) {
                                for (var n, r = {
                                        rawIndices: {},
                                        padIndices: {}
                                    }, o = 0; o < this._gamepads.length; o++)
                                    if ((n = this._gamepads[o]).connected)
                                        for (var a = 0; a < this._rawPads.length; a++) this._rawPads[a].index === n.index && (r.rawIndices[n.index] = !0, r.padIndices[o] = !0);
                                for (var h = 0; h < this._gamepads.length; h++)
                                    if (n = this._gamepads[h], !r.padIndices[h]) {
                                        this._rawPads.length < 1 && n.disconnect();
                                        for (var l = 0; l < this._rawPads.length && !r.padIndices[h]; l++) {
                                            var c = this._rawPads[l];
                                            if (c) {
                                                if (r.rawIndices[c.index]) {
                                                    n.disconnect();
                                                    continue
                                                }
                                                n.connect(c), r.rawIndices[c.index] = !0, r.padIndices[h] = !0
                                            } else n.disconnect()
                                        }
                                    }
                            }
                        }
                    }
                },
                setDeadZones: function(t) {
                    for (var e = 0; e < this._gamepads.length; e++) this._gamepads[e].deadZone = t
                },
                stop: function() {
                    this._active = !1, window.removeEventListener("gamepadconnected", this._onGamepadConnected), window.removeEventListener("gamepaddisconnected", this._onGamepadDisconnected)
                },
                reset: function() {
                    this.update();
                    for (var t = 0; t < this._gamepads.length; t++) this._gamepads[t].reset()
                },
                justPressed: function(t, e) {
                    for (var i = 0; i < this._gamepads.length; i++)
                        if (!0 === this._gamepads[i].justPressed(t, e)) return !0;
                    return !1
                },
                justReleased: function(t, e) {
                    for (var i = 0; i < this._gamepads.length; i++)
                        if (!0 === this._gamepads[i].justReleased(t, e)) return !0;
                    return !1
                },
                isDown: function(t) {
                    for (var e = 0; e < this._gamepads.length; e++)
                        if (!0 === this._gamepads[e].isDown(t)) return !0;
                    return !1
                },
                destroy: function() {
                    this.stop();
                    for (var t = 0; t < this._gamepads.length; t++) this._gamepads[t].destroy()
                }
            }, t.Gamepad.prototype.constructor = t.Gamepad, Object.defineProperty(t.Gamepad.prototype, "active", {
                get: function() {
                    return this._active
                }
            }), Object.defineProperty(t.Gamepad.prototype, "supported", {
                get: function() {
                    return this._gamepadSupportAvailable
                }
            }), Object.defineProperty(t.Gamepad.prototype, "padsConnected", {
                get: function() {
                    return this._rawPads.length
                }
            }), Object.defineProperty(t.Gamepad.prototype, "pad1", {
                get: function() {
                    return this._gamepads[0]
                }
            }), Object.defineProperty(t.Gamepad.prototype, "pad2", {
                get: function() {
                    return this._gamepads[1]
                }
            }), Object.defineProperty(t.Gamepad.prototype, "pad3", {
                get: function() {
                    return this._gamepads[2]
                }
            }), Object.defineProperty(t.Gamepad.prototype, "pad4", {
                get: function() {
                    return this._gamepads[3]
                }
            }), t.Gamepad.BUTTON_0 = 0, t.Gamepad.BUTTON_1 = 1, t.Gamepad.BUTTON_2 = 2, t.Gamepad.BUTTON_3 = 3, t.Gamepad.BUTTON_4 = 4, t.Gamepad.BUTTON_5 = 5, t.Gamepad.BUTTON_6 = 6, t.Gamepad.BUTTON_7 = 7, t.Gamepad.BUTTON_8 = 8, t.Gamepad.BUTTON_9 = 9, t.Gamepad.BUTTON_10 = 10, t.Gamepad.BUTTON_11 = 11, t.Gamepad.BUTTON_12 = 12, t.Gamepad.BUTTON_13 = 13, t.Gamepad.BUTTON_14 = 14, t.Gamepad.BUTTON_15 = 15, t.Gamepad.AXIS_0 = 0, t.Gamepad.AXIS_1 = 1, t.Gamepad.AXIS_2 = 2, t.Gamepad.AXIS_3 = 3, t.Gamepad.AXIS_4 = 4, t.Gamepad.AXIS_5 = 5, t.Gamepad.AXIS_6 = 6, t.Gamepad.AXIS_7 = 7, t.Gamepad.AXIS_8 = 8, t.Gamepad.AXIS_9 = 9, t.Gamepad.XBOX360_A = 0, t.Gamepad.XBOX360_B = 1, t.Gamepad.XBOX360_X = 2, t.Gamepad.XBOX360_Y = 3, t.Gamepad.XBOX360_LEFT_BUMPER = 4, t.Gamepad.XBOX360_RIGHT_BUMPER = 5, t.Gamepad.XBOX360_LEFT_TRIGGER = 6, t.Gamepad.XBOX360_RIGHT_TRIGGER = 7, t.Gamepad.XBOX360_BACK = 8, t.Gamepad.XBOX360_START = 9, t.Gamepad.XBOX360_STICK_LEFT_BUTTON = 10, t.Gamepad.XBOX360_STICK_RIGHT_BUTTON = 11, t.Gamepad.XBOX360_DPAD_LEFT = 14, t.Gamepad.XBOX360_DPAD_RIGHT = 15, t.Gamepad.XBOX360_DPAD_UP = 12, t.Gamepad.XBOX360_DPAD_DOWN = 13, t.Gamepad.XBOX360_STICK_LEFT_X = 0, t.Gamepad.XBOX360_STICK_LEFT_Y = 1, t.Gamepad.XBOX360_STICK_RIGHT_X = 2, t.Gamepad.XBOX360_STICK_RIGHT_Y = 3, t.Gamepad.PS3XC_X = 0, t.Gamepad.PS3XC_CIRCLE = 1, t.Gamepad.PS3XC_SQUARE = 2, t.Gamepad.PS3XC_TRIANGLE = 3, t.Gamepad.PS3XC_L1 = 4, t.Gamepad.PS3XC_R1 = 5, t.Gamepad.PS3XC_L2 = 6, t.Gamepad.PS3XC_R2 = 7, t.Gamepad.PS3XC_SELECT = 8, t.Gamepad.PS3XC_START = 9, t.Gamepad.PS3XC_STICK_LEFT_BUTTON = 10, t.Gamepad.PS3XC_STICK_RIGHT_BUTTON = 11, t.Gamepad.PS3XC_DPAD_UP = 12, t.Gamepad.PS3XC_DPAD_DOWN = 13, t.Gamepad.PS3XC_DPAD_LEFT = 14, t.Gamepad.PS3XC_DPAD_RIGHT = 15, t.Gamepad.PS3XC_STICK_LEFT_X = 0, t.Gamepad.PS3XC_STICK_LEFT_Y = 1, t.Gamepad.PS3XC_STICK_RIGHT_X = 2, t.Gamepad.PS3XC_STICK_RIGHT_Y = 3, t.SinglePad = function(t, e) {
                this.game = t, this.index = null, this.connected = !1, this.callbackContext = this, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null, this.deadZone = .26, this._padParent = e, this._rawPad = null, this._prevTimestamp = null, this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0
            }, t.SinglePad.prototype = {
                addCallbacks: function(t, e) {
                    void 0 !== e && (this.onConnectCallback = "function" == typeof e.onConnect ? e.onConnect : this.onConnectCallback, this.onDisconnectCallback = "function" == typeof e.onDisconnect ? e.onDisconnect : this.onDisconnectCallback, this.onDownCallback = "function" == typeof e.onDown ? e.onDown : this.onDownCallback, this.onUpCallback = "function" == typeof e.onUp ? e.onUp : this.onUpCallback, this.onAxisCallback = "function" == typeof e.onAxis ? e.onAxis : this.onAxisCallback, this.onFloatCallback = "function" == typeof e.onFloat ? e.onFloat : this.onFloatCallback, this.callbackContext = t)
                },
                getButton: function(t) {
                    return this._buttons[t] ? this._buttons[t] : null
                },
                pollStatus: function() {
                    if (this.connected && this.game.input.enabled && this.game.input.gamepad.enabled && (!this._rawPad || !this._rawPad.timestamp || this._rawPad.timestamp !== this._prevTimestamp)) {
                        for (var t = 0; t < this._buttonsLen; t++) {
                            var e = isNaN(this._rawPad.buttons[t]) ? this._rawPad.buttons[t].value : this._rawPad.buttons[t];
                            e !== this._buttons[t].value && (1 === e ? this.processButtonDown(t, e) : 0 === e ? this.processButtonUp(t, e) : this.processButtonFloat(t, e))
                        }
                        for (var i = 0; i < this._axesLen; i++) {
                            var s = this._rawPad.axes[i];
                            s > 0 && s > this.deadZone || s < 0 && s < -this.deadZone ? this.processAxisChange(i, s) : this.processAxisChange(i, 0)
                        }
                        this._prevTimestamp = this._rawPad.timestamp
                    }
                },
                connect: function(e) {
                    var i = !this.connected;
                    this.connected = !0, this.index = e.index, this._rawPad = e, this._buttons = [], this._buttonsLen = e.buttons.length, this._axes = [], this._axesLen = e.axes.length;
                    for (var s = 0; s < this._axesLen; s++) this._axes[s] = e.axes[s];
                    for (var n in e.buttons) n = parseInt(n, 10), this._buttons[n] = new t.DeviceButton(this, n);
                    i && this._padParent.onConnectCallback && this._padParent.onConnectCallback.call(this._padParent.callbackContext, this.index), i && this.onConnectCallback && this.onConnectCallback.call(this.callbackContext)
                },
                disconnect: function() {
                    var t = this.connected,
                        e = this.index;
                    this.connected = !1, this.index = null, this._rawPad = void 0;
                    for (var i = 0; i < this._buttonsLen; i++) this._buttons[i].destroy();
                    this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0, t && this._padParent.onDisconnectCallback && this._padParent.onDisconnectCallback.call(this._padParent.callbackContext, e), t && this.onDisconnectCallback && this.onDisconnectCallback.call(this.callbackContext)
                },
                destroy: function() {
                    this._rawPad = void 0;
                    for (var t = 0; t < this._buttonsLen; t++) this._buttons[t].destroy();
                    this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null
                },
                processAxisChange: function(t, e) {
                    this._axes[t] !== e && (this._axes[t] = e, this._padParent.onAxisCallback && this._padParent.onAxisCallback.call(this._padParent.callbackContext, this, t, e), this.onAxisCallback && this.onAxisCallback.call(this.callbackContext, this, t, e))
                },
                processButtonDown: function(t, e) {
                    this._buttons[t] && this._buttons[t].start(null, e), this._padParent.onDownCallback && this._padParent.onDownCallback.call(this._padParent.callbackContext, t, e, this.index), this.onDownCallback && this.onDownCallback.call(this.callbackContext, t, e)
                },
                processButtonUp: function(t, e) {
                    this._padParent.onUpCallback && this._padParent.onUpCallback.call(this._padParent.callbackContext, t, e, this.index), this.onUpCallback && this.onUpCallback.call(this.callbackContext, t, e), this._buttons[t] && this._buttons[t].stop(null, e)
                },
                processButtonFloat: function(t, e) {
                    this._padParent.onFloatCallback && this._padParent.onFloatCallback.call(this._padParent.callbackContext, t, e, this.index), this.onFloatCallback && this.onFloatCallback.call(this.callbackContext, t, e), this._buttons[t] && this._buttons[t].padFloat(e)
                },
                axis: function(t) {
                    return !!this._axes[t] && this._axes[t]
                },
                isDown: function(t) {
                    return !!this._buttons[t] && this._buttons[t].isDown
                },
                isUp: function(t) {
                    return !!this._buttons[t] && this._buttons[t].isUp
                },
                justReleased: function(t, e) {
                    if (this._buttons[t]) return this._buttons[t].justReleased(e)
                },
                justPressed: function(t, e) {
                    if (this._buttons[t]) return this._buttons[t].justPressed(e)
                },
                buttonValue: function(t) {
                    return this._buttons[t] ? this._buttons[t].value : null
                },
                reset: function() {
                    for (var t = 0; t < this._axes.length; t++) this._axes[t] = 0
                }
            }, t.SinglePad.prototype.constructor = t.SinglePad, t.Key = function(e, i) {
                this.game = e, this._enabled = !0, this.event = null, this.isDown = !1, this.isUp = !0, this.altKey = !1, this.ctrlKey = !1, this.shiftKey = !1, this.timeDown = 0, this.duration = 0, this.timeUp = -2500, this.durationUp = -2500, this.repeats = 0, this.keyCode = i, this.onDown = new t.Signal, this.onHoldCallback = null, this.onHoldContext = null, this.onUp = new t.Signal, this._justDown = !1, this._justUp = !1
            }, t.Key.prototype = {
                update: function() {
                    this._enabled && (this.isDown ? (this.duration = this.game.time.time - this.timeDown, this.repeats++, this.onHoldCallback && this.onHoldCallback.call(this.onHoldContext, this)) : this.durationUp = this.game.time.time - this.timeUp)
                },
                processKeyDown: function(t) {
                    this._enabled && (this.event = t, this.isDown || (this.altKey = t.altKey, this.ctrlKey = t.ctrlKey, this.shiftKey = t.shiftKey, this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.duration = 0, this.durationUp = this.game.time.time - this.timeUp, this.repeats = 0, this._justDown = !0, this.onDown.dispatch(this)))
                },
                processKeyUp: function(t) {
                    this._enabled && (this.event = t, this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.duration = this.game.time.time - this.timeDown, this.durationUp = 0, this._justUp = !0, this.onUp.dispatch(this)))
                },
                reset: function(t) {
                    void 0 === t && (t = !0), this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.duration = 0, this.durationUp = -2500, this._enabled = !0, this._justDown = !1, this._justUp = !1, t && (this.onDown.removeAll(), this.onUp.removeAll(), this.onHoldCallback = null, this.onHoldContext = null)
                },
                downDuration: function(t) {
                    return void 0 === t && (t = 50), this.isDown && this.duration < t
                },
                upDuration: function(t) {
                    return void 0 === t && (t = 50), !this.isDown && this.game.time.time - this.timeUp < t
                },
                justPressed: function() {
                    return this.isDown && 0 === this.duration
                },
                justReleased: function() {
                    return !this.isDown && 0 === this.durationUp
                }
            }, Object.defineProperty(t.Key.prototype, "justDown", {
                get: function() {
                    var t = this._justDown;
                    return this._justDown = !1, t
                }
            }), Object.defineProperty(t.Key.prototype, "justUp", {
                get: function() {
                    var t = this._justUp;
                    return this._justUp = !1, t
                }
            }), Object.defineProperty(t.Key.prototype, "enabled", {
                get: function() {
                    return this._enabled
                },
                set: function(t) {
                    (t = !!t) !== this._enabled && (t || this.reset(!1), this._enabled = t)
                }
            }), t.Key.prototype.constructor = t.Key, t.Keyboard = function(t) {
                this.game = t, this.active = !1, this.enabled = !0, this.event = null, this.pressEvent = null, this.callbackContext = this, this.onDownCallback = null, this.onPressCallback = null, this.onUpCallback = null, this._keys = [], this._capture = [], this._onKeyDown = null, this._onKeyPress = null, this._onKeyUp = null, this._i = 0, this._k = 0
            }, t.Keyboard.prototype = {
                addCallbacks: function(t, e, i, s) {
                    this.callbackContext = t, null != e && (this.onDownCallback = e), null != i && (this.onUpCallback = i), null != s && (this.onPressCallback = s)
                },
                removeCallbacks: function() {
                    this.callbackContext = this, this.onDownCallback = null, this.onUpCallback = null, this.onPressCallback = null
                },
                addKey: function(e) {
                    return this._keys[e] || (this._keys[e] = new t.Key(this.game, e), this.addKeyCapture(e)), this._keys[e]
                },
                addKeys: function(t) {
                    var e = {};
                    for (var i in t) e[i] = this.addKey(t[i]);
                    return e
                },
                removeKey: function(t) {
                    this._keys[t] && (this._keys[t] = null, this.removeKeyCapture(t))
                },
                createCursorKeys: function() {
                    return this.addKeys({
                        up: t.KeyCode.UP,
                        down: t.KeyCode.DOWN,
                        left: t.KeyCode.LEFT,
                        right: t.KeyCode.RIGHT
                    })
                },
                start: function() {
                    if (this.game.device.cocoonJS) return !1;
                    if (this.active) return !1;
                    var t = this;
                    return this._onKeyDown = function(e) {
                        return t.processKeyDown(e)
                    }, this._onKeyUp = function(e) {
                        return t.processKeyUp(e)
                    }, this._onKeyPress = function(e) {
                        return t.processKeyPress(e)
                    }, window.addEventListener("keydown", this._onKeyDown, !1), window.addEventListener("keyup", this._onKeyUp, !1), window.addEventListener("keypress", this._onKeyPress, !1), this.active = !0, !0
                },
                stop: function() {
                    window.removeEventListener("keydown", this._onKeyDown), window.removeEventListener("keyup", this._onKeyUp), window.removeEventListener("keypress", this._onKeyPress), this._onKeyDown = null, this._onKeyUp = null, this._onKeyPress = null, this.active = !1
                },
                destroy: function() {
                    this.stop(), this.clearCaptures(), this._keys.length = 0, this._i = 0
                },
                addKeyCapture: function(t) {
                    if ("object" == typeof t)
                        for (var e in t) this._capture[t[e]] = !0;
                    else this._capture[t] = !0
                },
                removeKeyCapture: function(t) {
                    delete this._capture[t]
                },
                clearCaptures: function() {
                    this._capture = {}
                },
                update: function() {
                    for (this._i = this._keys.length; this._i--;) this._keys[this._i] && this._keys[this._i].update()
                },
                processKeyDown: function(e) {
                    if (this.event = e, this.game.input.enabled && this.enabled) {
                        var i = e.keyCode;
                        this._capture[i] && e.preventDefault(), this._keys[i] || (this._keys[i] = new t.Key(this.game, i)), this._keys[i].processKeyDown(e), this._k = i, this.onDownCallback && this.onDownCallback.call(this.callbackContext, e)
                    }
                },
                processKeyPress: function(t) {
                    this.pressEvent = t, this.game.input.enabled && this.enabled && this.onPressCallback && this.onPressCallback.call(this.callbackContext, String.fromCharCode(t.charCode), t)
                },
                processKeyUp: function(e) {
                    if (this.event = e, this.game.input.enabled && this.enabled) {
                        var i = e.keyCode;
                        this._capture[i] && e.preventDefault(), this._keys[i] || (this._keys[i] = new t.Key(this.game, i)), this._keys[i].processKeyUp(e), this.onUpCallback && this.onUpCallback.call(this.callbackContext, e)
                    }
                },
                reset: function(t) {
                    void 0 === t && (t = !0), this.event = null;
                    for (var e = this._keys.length; e--;) this._keys[e] && this._keys[e].reset(t)
                },
                downDuration: function(t, e) {
                    return this._keys[t] ? this._keys[t].downDuration(e) : null
                },
                upDuration: function(t, e) {
                    return this._keys[t] ? this._keys[t].upDuration(e) : null
                },
                justPressed: function(t) {
                    return this._keys[t] ? this._keys[t].justPressed() : null
                },
                justReleased: function(t) {
                    return this._keys[t] ? this._keys[t].justReleased() : null
                },
                isDown: function(t) {
                    return this._keys[t] ? this._keys[t].isDown : null
                }
            }, Object.defineProperty(t.Keyboard.prototype, "lastChar", {
                get: function() {
                    return this.event && 32 === this.event.charCode ? "" : this.pressEvent ? String.fromCharCode(this.pressEvent.charCode) : null
                }
            }), Object.defineProperty(t.Keyboard.prototype, "lastKey", {
                get: function() {
                    return this._keys[this._k]
                }
            }), t.Keyboard.prototype.constructor = t.Keyboard, t.KeyCode = {
                A: "A".charCodeAt(0),
                B: "B".charCodeAt(0),
                C: "C".charCodeAt(0),
                D: "D".charCodeAt(0),
                E: "E".charCodeAt(0),
                F: "F".charCodeAt(0),
                G: "G".charCodeAt(0),
                H: "H".charCodeAt(0),
                I: "I".charCodeAt(0),
                J: "J".charCodeAt(0),
                K: "K".charCodeAt(0),
                L: "L".charCodeAt(0),
                M: "M".charCodeAt(0),
                N: "N".charCodeAt(0),
                O: "O".charCodeAt(0),
                P: "P".charCodeAt(0),
                Q: "Q".charCodeAt(0),
                R: "R".charCodeAt(0),
                S: "S".charCodeAt(0),
                T: "T".charCodeAt(0),
                U: "U".charCodeAt(0),
                V: "V".charCodeAt(0),
                W: "W".charCodeAt(0),
                X: "X".charCodeAt(0),
                Y: "Y".charCodeAt(0),
                Z: "Z".charCodeAt(0),
                ZERO: "0".charCodeAt(0),
                ONE: "1".charCodeAt(0),
                TWO: "2".charCodeAt(0),
                THREE: "3".charCodeAt(0),
                FOUR: "4".charCodeAt(0),
                FIVE: "5".charCodeAt(0),
                SIX: "6".charCodeAt(0),
                SEVEN: "7".charCodeAt(0),
                EIGHT: "8".charCodeAt(0),
                NINE: "9".charCodeAt(0),
                NUMPAD_0: 96,
                NUMPAD_1: 97,
                NUMPAD_2: 98,
                NUMPAD_3: 99,
                NUMPAD_4: 100,
                NUMPAD_5: 101,
                NUMPAD_6: 102,
                NUMPAD_7: 103,
                NUMPAD_8: 104,
                NUMPAD_9: 105,
                NUMPAD_MULTIPLY: 106,
                NUMPAD_ADD: 107,
                NUMPAD_ENTER: 108,
                NUMPAD_SUBTRACT: 109,
                NUMPAD_DECIMAL: 110,
                NUMPAD_DIVIDE: 111,
                F1: 112,
                F2: 113,
                F3: 114,
                F4: 115,
                F5: 116,
                F6: 117,
                F7: 118,
                F8: 119,
                F9: 120,
                F10: 121,
                F11: 122,
                F12: 123,
                F13: 124,
                F14: 125,
                F15: 126,
                COLON: 186,
                EQUALS: 187,
                COMMA: 188,
                UNDERSCORE: 189,
                PERIOD: 190,
                QUESTION_MARK: 191,
                TILDE: 192,
                OPEN_BRACKET: 219,
                BACKWARD_SLASH: 220,
                CLOSED_BRACKET: 221,
                QUOTES: 222,
                BACKSPACE: 8,
                TAB: 9,
                CLEAR: 12,
                ENTER: 13,
                SHIFT: 16,
                CONTROL: 17,
                ALT: 18,
                CAPS_LOCK: 20,
                ESC: 27,
                SPACEBAR: 32,
                PAGE_UP: 33,
                PAGE_DOWN: 34,
                END: 35,
                HOME: 36,
                LEFT: 37,
                UP: 38,
                RIGHT: 39,
                DOWN: 40,
                PLUS: 43,
                MINUS: 44,
                INSERT: 45,
                DELETE: 46,
                HELP: 47,
                NUM_LOCK: 144
            }, t.KeyCode) t.KeyCode.hasOwnProperty(i) && !i.match(/[a-z]/) && (t.Keyboard[i] = t.KeyCode[i]);
        for (var s in t.Component = function() {}, t.Component.Angle = function() {}, t.Component.Angle.prototype = {
                angle: {
                    get: function() {
                        return t.Math.wrapAngle(t.Math.radToDeg(this.rotation))
                    },
                    set: function(e) {
                        this.rotation = t.Math.degToRad(t.Math.wrapAngle(e))
                    }
                }
            }, t.Component.Animation = function() {}, t.Component.Animation.prototype = {
                play: function(t, e, i, s) {
                    if (this.animations) return this.animations.play(t, e, i, s)
                }
            }, t.Component.AutoCull = function() {}, t.Component.AutoCull.prototype = {
                autoCull: !1,
                inCamera: {
                    get: function() {
                        return this.autoCull || this.checkWorldBounds || (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y), this.game.world.camera.view.intersects(this._bounds)
                    }
                }
            }, t.Component.Bounds = function() {}, t.Component.Bounds.prototype = {
                offsetX: {
                    get: function() {
                        return this.anchor.x * this.width
                    }
                },
                offsetY: {
                    get: function() {
                        return this.anchor.y * this.height
                    }
                },
                centerX: {
                    get: function() {
                        return this.x - this.offsetX + .5 * this.width
                    },
                    set: function(t) {
                        this.x = t + this.offsetX - .5 * this.width
                    }
                },
                centerY: {
                    get: function() {
                        return this.y - this.offsetY + .5 * this.height
                    },
                    set: function(t) {
                        this.y = t + this.offsetY - .5 * this.height
                    }
                },
                left: {
                    get: function() {
                        return this.x - this.offsetX
                    },
                    set: function(t) {
                        this.x = t + this.offsetX
                    }
                },
                right: {
                    get: function() {
                        return this.x + this.width - this.offsetX
                    },
                    set: function(t) {
                        this.x = t - this.width + this.offsetX
                    }
                },
                top: {
                    get: function() {
                        return this.y - this.offsetY
                    },
                    set: function(t) {
                        this.y = t + this.offsetY
                    }
                },
                bottom: {
                    get: function() {
                        return this.y + this.height - this.offsetY
                    },
                    set: function(t) {
                        this.y = t - this.height + this.offsetY
                    }
                },
                alignIn: function(e, i, s, n) {
                    switch (void 0 === s && (s = 0), void 0 === n && (n = 0), i) {
                        default:
                            case t.TOP_LEFT:
                            this.left = e.left - s,
                        this.top = e.top - n;
                        break;
                        case t.TOP_CENTER:
                                this.centerX = e.centerX + s,
                            this.top = e.top - n;
                            break;
                        case t.TOP_RIGHT:
                                this.right = e.right + s,
                            this.top = e.top - n;
                            break;
                        case t.LEFT_CENTER:
                                this.left = e.left - s,
                            this.centerY = e.centerY + n;
                            break;
                        case t.CENTER:
                                this.centerX = e.centerX + s,
                            this.centerY = e.centerY + n;
                            break;
                        case t.RIGHT_CENTER:
                                this.right = e.right + s,
                            this.centerY = e.centerY + n;
                            break;
                        case t.BOTTOM_LEFT:
                                this.left = e.left - s,
                            this.bottom = e.bottom + n;
                            break;
                        case t.BOTTOM_CENTER:
                                this.centerX = e.centerX + s,
                            this.bottom = e.bottom + n;
                            break;
                        case t.BOTTOM_RIGHT:
                                this.right = e.right + s,
                            this.bottom = e.bottom + n
                    }
                    return this
                },
                alignTo: function(e, i, s, n) {
                    switch (void 0 === s && (s = 0), void 0 === n && (n = 0), i) {
                        default:
                            case t.TOP_LEFT:
                            this.left = e.left - s,
                        this.bottom = e.top - n;
                        break;
                        case t.TOP_CENTER:
                                this.centerX = e.centerX + s,
                            this.bottom = e.top - n;
                            break;
                        case t.TOP_RIGHT:
                                this.right = e.right + s,
                            this.bottom = e.top - n;
                            break;
                        case t.LEFT_TOP:
                                this.right = e.left - s,
                            this.top = e.top - n;
                            break;
                        case t.LEFT_CENTER:
                                this.right = e.left - s,
                            this.centerY = e.centerY + n;
                            break;
                        case t.LEFT_BOTTOM:
                                this.right = e.left - s,
                            this.bottom = e.bottom + n;
                            break;
                        case t.RIGHT_TOP:
                                this.left = e.right + s,
                            this.top = e.top - n;
                            break;
                        case t.RIGHT_CENTER:
                                this.left = e.right + s,
                            this.centerY = e.centerY + n;
                            break;
                        case t.RIGHT_BOTTOM:
                                this.left = e.right + s,
                            this.bottom = e.bottom + n;
                            break;
                        case t.BOTTOM_LEFT:
                                this.left = e.left - s,
                            this.top = e.bottom + n;
                            break;
                        case t.BOTTOM_CENTER:
                                this.centerX = e.centerX + s,
                            this.top = e.bottom + n;
                            break;
                        case t.BOTTOM_RIGHT:
                                this.right = e.right + s,
                            this.top = e.bottom + n
                    }
                    return this
                }
            }, t.Group.prototype.alignIn = t.Component.Bounds.prototype.alignIn, t.Group.prototype.alignTo = t.Component.Bounds.prototype.alignTo, t.Component.BringToTop = function() {}, t.Component.BringToTop.prototype.bringToTop = function() {
                return this.parent && this.parent.bringChildToTop && this.parent.bringChildToTop(this), this
            }, t.Component.BringToTop.prototype.sendToBack = function() {
                return this.parent && this.parent.sendChildToBack && this.parent.sendChildToBack(this), this
            }, t.Component.BringToTop.prototype.moveUp = function() {
                return this.parent && this.parent.moveUp(this), this
            }, t.Component.BringToTop.prototype.moveDown = function() {
                return this.parent && this.parent.moveDown(this), this
            }, t.Component.Core = function() {}, t.Component.Core.skipTypeChecks = !1, t.Component.Core.install = function(e) {
                t.Utils.mixinPrototype(this, t.Component.Core.prototype), this.components = {};
                for (var i = 0; i < e.length; i++) {
                    var s = e[i],
                        n = !1;
                    "Destroy" === s && (n = !0), t.Utils.mixinPrototype(this, t.Component[s].prototype, n), this.components[s] = !0
                }
            }, t.Component.Core.init = function(e, i, s, n, r) {
                if (!t.Component.Core.skipTypeChecks) {
                    if (!(e instanceof t.Game)) throw new Error("The value passed as the `game` argument (" + e + ") is not an instance of Phaser.Game.");
                    "number" != typeof i && (console.warn("The `x` argument value (%s) should be a number.", i), i = 0), "number" != typeof s && (console.warn("The `y` argument value (%s) should be a number.", s), s = 0)
                }
                this.game = e, this.key = n, this.data = {}, this.position.set(i, s), this.world = new t.Point(i, s), this.previousPosition = new t.Point(i, s), this.events = new t.Events(this), this._bounds = new t.Rectangle, this.components.PhysicsBody && (this.body = this.body), this.components.Animation && (this.animations = new t.AnimationManager(this)), this.components.LoadTexture && null !== n && this.loadTexture(n, r), this.components.FixedToCamera && (this.cameraOffset = new t.Point(i, s))
            }, t.Component.Core.preUpdate = function() {
                return this.pendingDestroy ? (this.destroy(), !1) : (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, this.exists && this.parent.exists ? (this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty), this.visible && (this.renderOrderID = this.game.stage.currentRenderOrderID++), this.animations && this.animations.update(), this.body && this.body.preUpdate(), this.preUpdateChildren(), !0) : (this.renderOrderID = -1, !1))
            }, t.Component.Core.prototype = {
                game: null,
                name: "",
                data: {},
                components: {},
                z: 0,
                events: void 0,
                animations: void 0,
                key: "",
                world: null,
                debug: !1,
                previousPosition: null,
                previousRotation: 0,
                renderOrderID: 0,
                fresh: !0,
                pendingDestroy: !1,
                _bounds: null,
                _exists: !0,
                exists: {
                    get: function() {
                        return this._exists
                    },
                    set: function(e) {
                        e ? (this._exists = !0, this.body && this.body.type === t.Physics.P2JS && this.body.addToWorld(), this.visible = !0) : (this._exists = !1, this.body && this.body.type === t.Physics.P2JS && this.body.removeFromWorld(), this.visible = !1)
                    }
                },
                preUpdateChildren: function() {
                    for (var t = 0; t < this.children.length;) {
                        var e = this.children[t];
                        e.preUpdate(), this === e.parent && t++
                    }
                },
                update: function() {},
                postUpdate: function() {
                    this.customRender && this.key.render(), this.components.PhysicsBody && t.Component.PhysicsBody.postUpdate.call(this), this.components.FixedToCamera && t.Component.FixedToCamera.postUpdate.call(this);
                    for (var e = 0; e < this.children.length; e++) this.children[e].postUpdate()
                }
            }, t.Component.Crop = function() {}, t.Component.Crop.prototype = {
                cropRect: null,
                _crop: null,
                crop: function(e, i) {
                    void 0 === i && (i = !1), e ? (i && null !== this.cropRect ? this.cropRect.setTo(e.x, e.y, e.width, e.height) : i && null === this.cropRect ? this.cropRect = new t.Rectangle(e.x, e.y, e.width, e.height) : this.cropRect = e, this.updateCrop()) : (this._crop = null, this.cropRect = null, this.resetFrame())
                },
                updateCrop: function() {
                    if (this.cropRect) {
                        var e = this.texture.crop.x,
                            i = this.texture.crop.y,
                            s = this.texture.crop.width,
                            n = this.texture.crop.height;
                        this._crop = t.Rectangle.clone(this.cropRect, this._crop), this._crop.x += this._frame.x, this._crop.y += this._frame.y;
                        var r = Math.max(this._frame.x, this._crop.x),
                            o = Math.max(this._frame.y, this._crop.y),
                            a = Math.min(this._frame.right, this._crop.right) - r,
                            h = Math.min(this._frame.bottom, this._crop.bottom) - o;
                        this.texture.crop.x = r, this.texture.crop.y = o, this.texture.crop.width = a, this.texture.crop.height = h, this.texture.frame.width = Math.min(a, this.cropRect.width), this.texture.frame.height = Math.min(h, this.cropRect.height), this.texture.width = this.texture.frame.width, this.texture.height = this.texture.frame.height, this.texture._updateUvs(), 16777215 === this.tint || e === r && i === o && s === a && n === h || (this.texture.requiresReTint = !0)
                    }
                }
            }, t.Component.Delta = function() {}, t.Component.Delta.prototype = {
                deltaX: {
                    get: function() {
                        return this.world.x - this.previousPosition.x
                    }
                },
                deltaY: {
                    get: function() {
                        return this.world.y - this.previousPosition.y
                    }
                },
                deltaZ: {
                    get: function() {
                        return this.rotation - this.previousRotation
                    }
                }
            }, t.Component.Destroy = function() {}, t.Component.Destroy.prototype = {
                destroyPhase: !1,
                destroy: function(e, i) {
                    if (null !== this.game && !this.destroyPhase) {
                        void 0 === e && (e = !0), void 0 === i && (i = !1), this.destroyPhase = !0, this.events && this.events.onDestroy$dispatch(this), this.parent && (this.parent instanceof t.Group ? this.parent.remove(this) : this.parent.removeChild(this)), this.input && this.input.destroy(), this.animations && this.animations.destroy(), this.body && this.body.destroy(), this.events && this.events.destroy(), this.game.tweens.removeFrom(this);
                        var s = this.children.length;
                        if (e)
                            for (; s--;) this.children[s].destroy(e);
                        else
                            for (; s--;) this.removeChild(this.children[s]);
                        this._crop && (this._crop = null, this.cropRect = null), this._frame && (this._frame = null), t.Video && this.key instanceof t.Video && this.key.onChangeSource.remove(this.resizeFrame, this), t.BitmapText && this._glyphs && (this._glyphs = []), this.alive = !1, this.exists = !1, this.visible = !1, this.filters = null, this.mask = null, this.game = null, this.data = {}, this.renderable = !1, this.transformCallback && (this.transformCallback = null, this.transformCallbackContext = null), this.hitArea = null, this.parent = null, this.stage = null, this.worldTransform = null, this.filterArea = null, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite(), i && this.texture.destroy(!0), this.destroyPhase = !1, this.pendingDestroy = !1
                    }
                }
            }, t.Events = function(t) {
                this.parent = t
            }, t.Events.prototype = {
                destroy: function() {
                    this._parent = null, this._onDestroy && this._onDestroy.dispose(), this._onAddedToGroup && this._onAddedToGroup.dispose(), this._onRemovedFromGroup && this._onRemovedFromGroup.dispose(), this._onKilled && this._onKilled.dispose(), this._onRevived && this._onRevived.dispose(), this._onEnterBounds && this._onEnterBounds.dispose(), this._onOutOfBounds && this._onOutOfBounds.dispose(), this._onInputOver && this._onInputOver.dispose(), this._onInputOut && this._onInputOut.dispose(), this._onInputDown && this._onInputDown.dispose(), this._onInputUp && this._onInputUp.dispose(), this._onDragStart && this._onDragStart.dispose(), this._onDragUpdate && this._onDragUpdate.dispose(), this._onDragStop && this._onDragStop.dispose(), this._onAnimationStart && this._onAnimationStart.dispose(), this._onAnimationComplete && this._onAnimationComplete.dispose(), this._onAnimationLoop && this._onAnimationLoop.dispose()
                },
                onAddedToGroup: null,
                onRemovedFromGroup: null,
                onDestroy: null,
                onKilled: null,
                onRevived: null,
                onOutOfBounds: null,
                onEnterBounds: null,
                onInputOver: null,
                onInputOut: null,
                onInputDown: null,
                onInputUp: null,
                onDragStart: null,
                onDragUpdate: null,
                onDragStop: null,
                onAnimationStart: null,
                onAnimationComplete: null,
                onAnimationLoop: null
            }, t.Events.prototype.constructor = t.Events, t.Events.prototype) t.Events.prototype.hasOwnProperty(s) && 0 === s.indexOf("on") && null === t.Events.prototype[s] && function(e, i) {
            "use strict";
            Object.defineProperty(t.Events.prototype, e, {
                get: function() {
                    return this[i] || (this[i] = new t.Signal)
                }
            }), t.Events.prototype[e + "$dispatch"] = function() {
                return this[i] ? this[i].dispatch.apply(this[i], arguments) : null
            }
        }(s, "_" + s);
        return t.Component.FixedToCamera = function() {}, t.Component.FixedToCamera.postUpdate = function() {
            this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y)
        }, t.Component.FixedToCamera.prototype = {
            _fixedToCamera: !1,
            fixedToCamera: {
                get: function() {
                    return this._fixedToCamera
                },
                set: function(t) {
                    t ? (this._fixedToCamera = !0, this.cameraOffset.set(this.x, this.y)) : this._fixedToCamera = !1
                }
            },
            cameraOffset: new t.Point
        }, t.Component.Health = function() {}, t.Component.Health.prototype = {
            health: 1,
            maxHealth: 100,
            damage: function(t) {
                return this.alive && (this.health -= t, this.health <= 0 && this.kill()), this
            },
            setHealth: function(t) {
                return this.health = t, this.health > this.maxHealth && (this.health = this.maxHealth), this
            },
            heal: function(t) {
                return this.alive && (this.health += t, this.health > this.maxHealth && (this.health = this.maxHealth)), this
            }
        }, t.Component.InCamera = function() {}, t.Component.InCamera.prototype = {
            inCamera: {
                get: function() {
                    return this.game.world.camera.view.intersects(this._bounds)
                }
            }
        }, t.Component.InputEnabled = function() {}, t.Component.InputEnabled.prototype = {
            input: null,
            inputEnabled: {
                get: function() {
                    return this.input && this.input.enabled
                },
                set: function(e) {
                    e ? null === this.input ? (this.input = new t.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop()
                }
            }
        }, t.Component.InWorld = function() {}, t.Component.InWorld.preUpdate = function() {
            if (this.pendingDestroy) return this.destroy(), !1;
            if (this.autoCull || this.checkWorldBounds) {
                if (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y, this.autoCull)
                    if (this.game.world.camera.view.intersects(this._bounds)) this.renderable = !0, this.game.world.camera.totalInView++;
                    else if (this.renderable = !1, this.outOfCameraBoundsKill) return this.kill(), !1;
                if (this.checkWorldBounds)
                    if (this._outOfBoundsFired && this.game.world.bounds.intersects(this._bounds)) this._outOfBoundsFired = !1, this.events.onEnterBounds$dispatch(this);
                    else if (!this._outOfBoundsFired && !this.game.world.bounds.intersects(this._bounds) && (this._outOfBoundsFired = !0, this.events.onOutOfBounds$dispatch(this), this.outOfBoundsKill)) return this.kill(), !1
            }
            return !0
        }, t.Component.InWorld.prototype = {
            checkWorldBounds: !1,
            outOfBoundsKill: !1,
            outOfCameraBoundsKill: !1,
            _outOfBoundsFired: !1,
            inWorld: {
                get: function() {
                    return this.game.world.bounds.intersects(this.getBounds())
                }
            }
        }, t.Component.LifeSpan = function() {}, t.Component.LifeSpan.preUpdate = function() {
            return this.pendingDestroy ? (this.destroy(), !1) : !(this.lifespan > 0 && (this.lifespan -= this.game.time.physicsElapsedMS, this.lifespan <= 0) && (this.kill(), 1))
        }, t.Component.LifeSpan.prototype = {
            alive: !0,
            lifespan: 0,
            revive: function(t) {
                return void 0 === t && (t = 100), this.alive = !0, this.exists = !0, this.visible = !0, "function" == typeof this.setHealth && this.setHealth(t), this.events && this.events.onRevived$dispatch(this), this
            },
            kill: function() {
                return this.alive = !1, this.exists = !1, this.visible = !1, this.events && this.events.onKilled$dispatch(this), this
            }
        }, t.Component.LoadTexture = function() {}, t.Component.LoadTexture.prototype = {
            customRender: !1,
            _frame: null,
            loadTexture: function(e, i, s) {
                e === t.PENDING_ATLAS ? (e = i, i = 0) : i = i || 0, (s || void 0 === s) && this.animations && this.animations.stop(), this.key = e, this.customRender = !1;
                var n = this.game.cache,
                    r = !0,
                    o = !this.texture.baseTexture.scaleMode;
                if (t.RenderTexture && e instanceof t.RenderTexture) this.key = e.key, this.setTexture(e);
                else if (t.BitmapData && e instanceof t.BitmapData) this.customRender = !0, this.setTexture(e.texture), r = n.hasFrameData(e.key, t.Cache.BITMAPDATA) ? !this.animations.loadFrameData(n.getFrameData(e.key, t.Cache.BITMAPDATA), i) : !this.animations.loadFrameData(e.frameData, 0);
                else if (t.Video && e instanceof t.Video) {
                    this.customRender = !0;
                    var a = e.texture.valid;
                    this.setTexture(e.texture), this.setFrame(e.texture.frame.clone()), e.onChangeSource.add(this.resizeFrame, this), this.texture.valid = a
                } else if (t.Tilemap && e instanceof t.TilemapLayer) this.setTexture(PIXI.Texture.fromCanvas(e.canvas));
                else if (e instanceof PIXI.Texture) this.setTexture(e);
                else {
                    var h = n.getImage(e, !0);
                    this.key = h.key, this.setTexture(new PIXI.Texture(h.base)), this.texture.baseTexture.skipRender = "__default" === e, r = !this.animations.loadFrameData(h.frameData, i)
                }
                r && (this._frame = t.Rectangle.clone(this.texture.frame)), o || (this.texture.baseTexture.scaleMode = 1)
            },
            setFrame: function(t) {
                this._frame = t, this.texture.frame.x = t.x, this.texture.frame.y = t.y, this.texture.frame.width = t.width, this.texture.frame.height = t.height, this.texture.crop.x = t.x, this.texture.crop.y = t.y, this.texture.crop.width = t.width, this.texture.crop.height = t.height, t.trimmed ? (this.texture.trim ? (this.texture.trim.x = t.spriteSourceSizeX, this.texture.trim.y = t.spriteSourceSizeY, this.texture.trim.width = t.sourceSizeW, this.texture.trim.height = t.sourceSizeH) : this.texture.trim = {
                    x: t.spriteSourceSizeX,
                    y: t.spriteSourceSizeY,
                    width: t.sourceSizeW,
                    height: t.sourceSizeH
                }, this.texture.width = t.sourceSizeW, this.texture.height = t.sourceSizeH, this.texture.frame.width = t.sourceSizeW, this.texture.frame.height = t.sourceSizeH) : !t.trimmed && this.texture.trim && (this.texture.trim = null), t.rotated && (this.texture.rotated = !0), this.cropRect && this.updateCrop(), this.texture.requiresReTint = !0, this.texture._updateUvs(), this.tilingTexture && (this.refreshTexture = !0)
            },
            resizeFrame: function(t, e, i) {
                this.texture.frame.resize(e, i), this.texture.setFrame(this.texture.frame)
            },
            resetFrame: function() {
                this._frame && this.setFrame(this._frame)
            },
            frame: {
                get: function() {
                    return this.animations.frame
                },
                set: function(t) {
                    this.animations.frame = t
                }
            },
            frameName: {
                get: function() {
                    return this.animations.frameName
                },
                set: function(t) {
                    this.animations.frameName = t
                }
            }
        }, t.Component.Overlap = function() {}, t.Component.Overlap.prototype = {
            overlap: function(e) {
                return t.Rectangle.intersects(this.getBounds(), e.getBounds())
            }
        }, t.Component.PhysicsBody = function() {}, t.Component.PhysicsBody.preUpdate = function() {
            return this.pendingDestroy ? (this.destroy(), !1) : this.fresh && this.exists ? (this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y), this.worldTransform.tx = this.world.x, this.worldTransform.ty = this.world.y, this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, this.body && this.body.preUpdate(), this.fresh = !1, this.preUpdateChildren(), !1) : (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, !(!this._exists || !this.parent.exists) || (this.renderOrderID = -1, !1))
        }, t.Component.PhysicsBody.postUpdate = function() {
            this.exists && this.body && this.body.postUpdate()
        }, t.Component.PhysicsBody.prototype = {
            body: null,
            x: {
                get: function() {
                    return this.position.x
                },
                set: function(t) {
                    this.position.x = t, this.body && !this.body.dirty && (this.body._reset = !0)
                }
            },
            y: {
                get: function() {
                    return this.position.y
                },
                set: function(t) {
                    this.position.y = t, this.body && !this.body.dirty && (this.body._reset = !0)
                }
            }
        }, t.Component.Reset = function() {}, t.Component.Reset.prototype.reset = function(t, e, i) {
            return void 0 === i && (i = 1), this.world.set(t, e), this.position.set(t, e), this.fresh = !0, this.exists = !0, this.visible = !0, this.renderable = !0, this.components.InWorld && (this._outOfBoundsFired = !1), this.components.LifeSpan && (this.alive = !0, this.health = i), this.components.PhysicsBody && this.body && this.body.reset(t, e, !1, !1), this
        }, t.Component.ScaleMinMax = function() {}, t.Component.ScaleMinMax.prototype = {
            transformCallback: null,
            transformCallbackContext: this,
            scaleMin: null,
            scaleMax: null,
            checkTransform: function(t) {
                this.scaleMin && (t.a < this.scaleMin.x && (t.a = this.scaleMin.x), t.d < this.scaleMin.y && (t.d = this.scaleMin.y)), this.scaleMax && (t.a > this.scaleMax.x && (t.a = this.scaleMax.x), t.d > this.scaleMax.y && (t.d = this.scaleMax.y))
            },
            setScaleMinMax: function(e, i, s, n) {
                void 0 === i ? i = s = n = e : void 0 === s && (s = n = i, i = e), null === e ? this.scaleMin = null : this.scaleMin ? this.scaleMin.set(e, i) : this.scaleMin = new t.Point(e, i), null === s ? this.scaleMax = null : this.scaleMax ? this.scaleMax.set(s, n) : this.scaleMax = new t.Point(s, n), null === this.scaleMin ? this.transformCallback = null : (this.transformCallback = this.checkTransform, this.transformCallbackContext = this)
            }
        }, t.Component.Smoothed = function() {}, t.Component.Smoothed.prototype = {
            smoothed: {
                get: function() {
                    return !this.texture.baseTexture.scaleMode
                },
                set: function(t) {
                    t ? this.texture && (this.texture.baseTexture.scaleMode = 0, this.texture.baseTexture.dirty()) : this.texture && (this.texture.baseTexture.scaleMode = 1, this.texture.baseTexture.dirty())
                }
            }
        }, t.GameObjectFactory = function(t) {
            this.game = t, this.world = this.game.world
        }, t.GameObjectFactory.prototype = {
            existing: function(t) {
                return this.world.add(t)
            },
            weapon: function(e, i, s, n, r) {
                var o = this.game.plugins.add(t.Weapon);
                return r && (o.bulletClass = r), o.createBullets(e, i, s, n), o
            },
            image: function(e, i, s, n, r) {
                return void 0 === r && (r = this.world), r.add(new t.Image(this.game, e, i, s, n))
            },
            sprite: function(e, i, s, n, r) {
                return void 0 === r && (r = this.world), r.add(new t.Sprite(this.game, e, i, s, n))
            },
            creature: function(e, i, s, n, r, o, a) {
                void 0 === r && (r = this.world);
                var h = new t.Creature(this.game, e, i, s, n, o, a);
                return r.add(h), h
            },
            tween: function(t) {
                return this.game.tweens.create(t)
            },
            group: function(e, i, s, n, r) {
                return new t.Group(this.game, e, i, s, n, r)
            },
            physicsGroup: function(e, i, s, n) {
                return new t.Group(this.game, i, s, n, !0, e)
            },
            spriteBatch: function(e, i, s) {
                return void 0 === e && (e = null), void 0 === i && (i = "group"), void 0 === s && (s = !1), new t.SpriteBatch(this.game, e, i, s)
            },
            audio: function(t, e, i, s) {
                return this.game.sound.add(t, e, i, s)
            },
            sound: function(t, e, i, s) {
                return this.game.sound.add(t, e, i, s)
            },
            audioSprite: function(t) {
                return this.game.sound.addSprite(t)
            },
            tileSprite: function(e, i, s, n, r, o, a) {
                return void 0 === a && (a = this.world), a.add(new t.TileSprite(this.game, e, i, s, n, r, o))
            },
            rope: function(e, i, s, n, r, o) {
                return void 0 === o && (o = this.world), o.add(new t.Rope(this.game, e, i, s, n, r))
            },
            text: function(e, i, s, n, r) {
                return void 0 === r && (r = this.world), r.add(new t.Text(this.game, e, i, s, n))
            },
            button: function(e, i, s, n, r, o, a, h, l, c) {
                return void 0 === c && (c = this.world), c.add(new t.Button(this.game, e, i, s, n, r, o, a, h, l))
            },
            graphics: function(e, i, s) {
                return void 0 === s && (s = this.world), s.add(new t.Graphics(this.game, e, i))
            },
            emitter: function(e, i, s) {
                return this.game.particles.add(new t.Particles.Arcade.Emitter(this.game, e, i, s))
            },
            retroFont: function(e, i, s, n, r, o, a, h, l) {
                return new t.RetroFont(this.game, e, i, s, n, r, o, a, h, l)
            },
            bitmapText: function(e, i, s, n, r, o) {
                return void 0 === o && (o = this.world), o.add(new t.BitmapText(this.game, e, i, s, n, r))
            },
            tilemap: function(e, i, s, n, r) {
                return new t.Tilemap(this.game, e, i, s, n, r)
            },
            renderTexture: function(e, i, s, n) {
                void 0 !== s && "" !== s || (s = this.game.rnd.uuid()), void 0 === n && (n = !1);
                var r = new t.RenderTexture(this.game, e, i, s);
                return n && this.game.cache.addRenderTexture(s, r), r
            },
            video: function(e, i) {
                return new t.Video(this.game, e, i)
            },
            bitmapData: function(e, i, s, n) {
                void 0 === n && (n = !1), void 0 !== s && "" !== s || (s = this.game.rnd.uuid());
                var r = new t.BitmapData(this.game, s, e, i);
                return n && this.game.cache.addBitmapData(s, r), r
            },
            filter: function(e) {
                var i = Array.prototype.slice.call(arguments, 1);
                return (e = new t.Filter[e](this.game)).init.apply(e, i), e
            },
            plugin: function() {
                return this.game.plugins.add.apply(this.game.plugins, arguments)
            }
        }, t.GameObjectFactory.prototype.constructor = t.GameObjectFactory, t.GameObjectCreator = function(t) {
            this.game = t, this.world = this.game.world
        }, t.GameObjectCreator.prototype = {
            image: function(e, i, s, n) {
                return new t.Image(this.game, e, i, s, n)
            },
            sprite: function(e, i, s, n) {
                return new t.Sprite(this.game, e, i, s, n)
            },
            tween: function(e) {
                return new t.Tween(e, this.game, this.game.tweens)
            },
            group: function(e, i, s, n, r) {
                return new t.Group(this.game, e || null, i, s, n, r)
            },
            spriteBatch: function(e, i, s) {
                return void 0 === i && (i = "group"), void 0 === s && (s = !1), new t.SpriteBatch(this.game, e, i, s)
            },
            audio: function(t, e, i, s) {
                return this.game.sound.add(t, e, i, s)
            },
            audioSprite: function(t) {
                return this.game.sound.addSprite(t)
            },
            sound: function(t, e, i, s) {
                return this.game.sound.add(t, e, i, s)
            },
            tileSprite: function(e, i, s, n, r, o) {
                return new t.TileSprite(this.game, e, i, s, n, r, o)
            },
            rope: function(e, i, s, n, r) {
                return new t.Rope(this.game, e, i, s, n, r)
            },
            text: function(e, i, s, n) {
                return new t.Text(this.game, e, i, s, n)
            },
            button: function(e, i, s, n, r, o, a, h, l) {
                return new t.Button(this.game, e, i, s, n, r, o, a, h, l)
            },
            graphics: function(e, i) {
                return new t.Graphics(this.game, e, i)
            },
            emitter: function(e, i, s) {
                return new t.Particles.Arcade.Emitter(this.game, e, i, s)
            },
            retroFont: function(e, i, s, n, r, o, a, h, l) {
                return new t.RetroFont(this.game, e, i, s, n, r, o, a, h, l)
            },
            bitmapText: function(e, i, s, n, r, o) {
                return new t.BitmapText(this.game, e, i, s, n, r, o)
            },
            tilemap: function(e, i, s, n, r) {
                return new t.Tilemap(this.game, e, i, s, n, r)
            },
            renderTexture: function(e, i, s, n) {
                void 0 !== s && "" !== s || (s = this.game.rnd.uuid()), void 0 === n && (n = !1);
                var r = new t.RenderTexture(this.game, e, i, s);
                return n && this.game.cache.addRenderTexture(s, r), r
            },
            bitmapData: function(e, i, s, n) {
                void 0 === n && (n = !1), void 0 !== s && "" !== s || (s = this.game.rnd.uuid());
                var r = new t.BitmapData(this.game, s, e, i);
                return n && this.game.cache.addBitmapData(s, r), r
            },
            filter: function(e) {
                var i = Array.prototype.slice.call(arguments, 1);
                return (e = new t.Filter[e](this.game)).init.apply(e, i), e
            }
        }, t.GameObjectCreator.prototype.constructor = t.GameObjectCreator, t.Sprite = function(e, i, s, n, r) {
            i = i || 0, s = s || 0, n = n || null, r = r || null, this.type = t.SPRITE, this.physicsType = t.SPRITE, PIXI.Sprite.call(this, t.Cache.DEFAULT), t.Component.Core.init.call(this, e, i, s, n, r)
        }, t.Sprite.prototype = Object.create(PIXI.Sprite.prototype), t.Sprite.prototype.constructor = t.Sprite, t.Component.Core.install.call(t.Sprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"]), t.Sprite.prototype.preUpdatePhysics = t.Component.PhysicsBody.preUpdate, t.Sprite.prototype.preUpdateLifeSpan = t.Component.LifeSpan.preUpdate, t.Sprite.prototype.preUpdateInWorld = t.Component.InWorld.preUpdate, t.Sprite.prototype.preUpdateCore = t.Component.Core.preUpdate, t.Sprite.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, t.Image = function(e, i, s, n, r) {
            i = i || 0, s = s || 0, n = n || null, r = r || null, this.type = t.IMAGE, PIXI.Sprite.call(this, t.Cache.DEFAULT), t.Component.Core.init.call(this, e, i, s, n, r)
        }, t.Image.prototype = Object.create(PIXI.Sprite.prototype), t.Image.prototype.constructor = t.Image, t.Component.Core.install.call(t.Image.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Destroy", "FixedToCamera", "InputEnabled", "LifeSpan", "LoadTexture", "Overlap", "Reset", "ScaleMinMax", "Smoothed"]), t.Image.prototype.preUpdateLifeSpan = t.Component.LifeSpan.preUpdate, t.Image.prototype.preUpdateInWorld = t.Component.InWorld.preUpdate, t.Image.prototype.preUpdateCore = t.Component.Core.preUpdate, t.Image.prototype.preUpdate = function() {
            return !(!this.preUpdateInWorld() || !this.preUpdateLifeSpan()) && this.preUpdateCore()
        }, t.Button = function(e, i, s, n, r, o, a, h, l, c) {
            i = i || 0, s = s || 0, n = n || null, r = r || null, o = o || this, t.Image.call(this, e, i, s, n, h), this.type = t.BUTTON, this.physicsType = t.SPRITE, this._onOverFrame = null, this._onOutFrame = null, this._onDownFrame = null, this._onUpFrame = null, this.onOverSound = null, this.onOutSound = null, this.onDownSound = null, this.onUpSound = null, this.onOverSoundMarker = "", this.onOutSoundMarker = "", this.onDownSoundMarker = "", this.onUpSoundMarker = "", this.onInputOver = new t.Signal, this.onInputOut = new t.Signal, this.onInputDown = new t.Signal, this.onInputUp = new t.Signal, this.onOverMouseOnly = !0, this.justReleasedPreventsOver = t.PointerMode.CONTACT, this.freezeFrames = !1, this.forceOut = !1, this.inputEnabled = !0, this.input.start(0, !0), this.input.useHandCursor = !0, this.setFrames(a, h, l, c), null !== r && this.onInputUp.add(r, o), this.events.onInputOver.add(this.onInputOverHandler, this), this.events.onInputOut.add(this.onInputOutHandler, this), this.events.onInputDown.add(this.onInputDownHandler, this), this.events.onInputUp.add(this.onInputUpHandler, this)
        }, t.Button.prototype = Object.create(t.Image.prototype), t.Button.prototype.constructor = t.Button, t.Button.prototype.clearFrames = function() {
            this.setFrames(null, null, null, null)
        }, t.Button.prototype.setStateFrame = function(t, e, i) {
            var s = "_on" + t + "Frame";
            null !== e ? (this[s] = e, i && this.changeStateFrame(t)) : this[s] = null
        }, t.Button.prototype.changeStateFrame = function(t) {
            if (this.freezeFrames) return !1;
            var e = this["_on" + t + "Frame"];
            return "string" == typeof e ? (this.frameName = e, !0) : "number" == typeof e && (this.frame = e, !0)
        }, t.Button.prototype.setFrames = function(t, e, i, s) {
            this.setStateFrame("Over", t, this.input.pointerOver()), this.setStateFrame("Out", e, !this.input.pointerOver()), this.setStateFrame("Down", i, this.input.pointerDown()), this.setStateFrame("Up", s, this.input.pointerUp())
        }, t.Button.prototype.setStateSound = function(e, i, s) {
            var n = "on" + e + "Sound",
                r = "on" + e + "SoundMarker";
            i instanceof t.Sound || i instanceof t.AudioSprite ? (this[n] = i, this[r] = "string" == typeof s ? s : "") : (this[n] = null, this[r] = "")
        }, t.Button.prototype.playStateSound = function(t) {
            var e = this["on" + t + "Sound"];
            if (e) {
                var i = this["on" + t + "SoundMarker"];
                return e.play(i), !0
            }
            return !1
        }, t.Button.prototype.setSounds = function(t, e, i, s, n, r, o, a) {
            this.setStateSound("Over", t, e), this.setStateSound("Out", n, r), this.setStateSound("Down", i, s), this.setStateSound("Up", o, a)
        }, t.Button.prototype.setOverSound = function(t, e) {
            this.setStateSound("Over", t, e)
        }, t.Button.prototype.setOutSound = function(t, e) {
            this.setStateSound("Out", t, e)
        }, t.Button.prototype.setDownSound = function(t, e) {
            this.setStateSound("Down", t, e)
        }, t.Button.prototype.setUpSound = function(t, e) {
            this.setStateSound("Up", t, e)
        }, t.Button.prototype.onInputOverHandler = function(t, e) {
            e.justReleased() && (this.justReleasedPreventsOver & e.pointerMode) === e.pointerMode || (this.changeStateFrame("Over"), this.onOverMouseOnly && !e.isMouse || (this.playStateSound("Over"), this.onInputOver && this.onInputOver.dispatch(this, e)))
        }, t.Button.prototype.onInputOutHandler = function(t, e) {
            this.changeStateFrame("Out"), this.playStateSound("Out"), this.onInputOut && this.onInputOut.dispatch(this, e)
        }, t.Button.prototype.onInputDownHandler = function(t, e) {
            this.changeStateFrame("Down"), this.playStateSound("Down"), this.onInputDown && this.onInputDown.dispatch(this, e)
        }, t.Button.prototype.onInputUpHandler = function(t, e, i) {
            this.playStateSound("Up"), this.onInputUp && this.onInputUp.dispatch(this, e, i), this.freezeFrames || (!0 === this.forceOut || (this.forceOut & e.pointerMode) === e.pointerMode ? this.changeStateFrame("Out") : this.changeStateFrame("Up") || (i ? this.changeStateFrame("Over") : this.changeStateFrame("Out")))
        }, t.SpriteBatch = function(e, i, s, n) {
            null != i || (i = e.world), t.Group.call(this, e, i, s, n), this.type = t.SPRITEBATCH, this.fastSpriteBatch = null, this.ready = !1
        }, t.SpriteBatch.prototype = Object.create(t.Group.prototype), t.SpriteBatch.prototype.constructor = t.SpriteBatch, t.SpriteBatch.prototype._renderWebGL = function(t) {
            !this.visible || this.alpha <= 0 || !this.children.length || (this.ready || (this.fastSpriteBatch = new PIXI.WebGLFastSpriteBatch(t.gl), this.ready = !0), this.fastSpriteBatch.gl !== t.gl && this.fastSpriteBatch.setContext(t.gl), t.spriteBatch.stop(), t.shaderManager.setShader(t.shaderManager.fastShader), this.fastSpriteBatch.begin(this, t), this.fastSpriteBatch.render(this), t.spriteBatch.start())
        }, t.SpriteBatch.prototype._renderCanvas = function(t) {
            if (this.visible && !(this.alpha <= 0) && this.children.length) {
                var e = t.context;
                e.globalAlpha = this.worldAlpha, this.displayObjectUpdateTransform();
                for (var i = this.worldTransform, s = !0, n = 0; n < this.children.length; n++) {
                    var r = this.children[n];
                    if (r.visible) {
                        var o = r.texture,
                            a = o.frame;
                        if (e.globalAlpha = this.worldAlpha * r.alpha, r.rotation % (2 * Math.PI) == 0) s && (e.setTransform(i.a, i.b, i.c, i.d, i.tx, i.ty), s = !1), e.drawImage(o.baseTexture.source, a.x, a.y, a.width, a.height, r.anchor.x * (-a.width * r.scale.x) + r.position.x + .5 + t.shakeX | 0, r.anchor.y * (-a.height * r.scale.y) + r.position.y + .5 + t.shakeY | 0, a.width * r.scale.x, a.height * r.scale.y);
                        else {
                            s || (s = !0), r.displayObjectUpdateTransform();
                            var h = r.worldTransform,
                                l = h.tx * t.resolution + t.shakeX,
                                c = h.ty * t.resolution + t.shakeY;
                            t.roundPixels ? e.setTransform(h.a, h.b, h.c, h.d, 0 | l, 0 | c) : e.setTransform(h.a, h.b, h.c, h.d, l, c), e.drawImage(o.baseTexture.source, a.x, a.y, a.width, a.height, r.anchor.x * -a.width + .5 | 0, r.anchor.y * -a.height + .5 | 0, a.width, a.height)
                        }
                    }
                }
            }
        }, t.BitmapData = function(e, i, s, n, r) {
            void 0 !== s && 0 !== s || (s = 256), void 0 !== n && 0 !== n || (n = 256), void 0 === r && (r = !1), this.game = e, this.key = i, this.width = s, this.height = n, this.canvas = t.Canvas.create(this, s, n, null, r), this.context = this.canvas.getContext("2d", {
                alpha: !0
            }), this.ctx = this.context, this.smoothProperty = e.renderType === t.CANVAS ? e.renderer.renderSession.smoothProperty : t.Canvas.getSmoothingPrefix(this.context), this.imageData = this.context.getImageData(0, 0, s, n), this.data = null, this.imageData && (this.data = this.imageData.data), this.pixels = null, this.data && (this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data), this.baseTexture = new PIXI.BaseTexture(this.canvas, null, this.game.resolution), this.texture = new PIXI.Texture(this.baseTexture), this.frameData = new t.FrameData, this.textureFrame = this.frameData.addFrame(new t.Frame(0, 0, 0, s, n, "bitmapData")), this.texture.frame = this.textureFrame, this.type = t.BITMAPDATA, this.disableTextureUpload = !1, this.dirty = !1, this.cls = this.clear, this._image = null, this._pos = new t.Point, this._size = new t.Point, this._scale = new t.Point, this._rotate = 0, this._alpha = {
                prev: 1,
                current: 1
            }, this._anchor = new t.Point, this._tempR = 0, this._tempG = 0, this._tempB = 0, this._circle = new t.Circle, this._swapCanvas = void 0
        }, t.BitmapData.prototype = {
            move: function(t, e, i) {
                return 0 !== t && this.moveH(t, i), 0 !== e && this.moveV(e, i), this
            },
            moveH: function(e, i) {
                void 0 === i && (i = !0), void 0 === this._swapCanvas && (this._swapCanvas = t.CanvasPool.create(this, this.width, this.height));
                var s = this._swapCanvas.getContext("2d"),
                    n = this.height,
                    r = this.canvas;
                if (s.clearRect(0, 0, this.width, this.height), e < 0) e = Math.abs(e), o = this.width - e, i && s.drawImage(r, 0, 0, e, n, o, 0, e, n), s.drawImage(r, e, 0, o, n, 0, 0, o, n);
                else {
                    var o = this.width - e;
                    i && s.drawImage(r, o, 0, e, n, 0, 0, e, n), s.drawImage(r, 0, 0, o, n, e, 0, o, n)
                }
                return this.clear(), this.copy(this._swapCanvas)
            },
            moveV: function(e, i) {
                void 0 === i && (i = !0), void 0 === this._swapCanvas && (this._swapCanvas = t.CanvasPool.create(this, this.width, this.height));
                var s = this._swapCanvas.getContext("2d"),
                    n = this.width,
                    r = this.canvas;
                if (s.clearRect(0, 0, this.width, this.height), e < 0) e = Math.abs(e), o = this.height - e, i && s.drawImage(r, 0, 0, n, e, 0, o, n, e), s.drawImage(r, 0, e, n, o, 0, 0, n, o);
                else {
                    var o = this.height - e;
                    i && s.drawImage(r, 0, o, n, e, 0, 0, n, e), s.drawImage(r, 0, 0, n, o, 0, e, n, o)
                }
                return this.clear(), this.copy(this._swapCanvas)
            },
            add: function(t) {
                if (Array.isArray(t))
                    for (var e = 0; e < t.length; e++) t[e].loadTexture && t[e].loadTexture(this);
                else t.loadTexture(this);
                return this
            },
            load: function(t) {
                if ("string" == typeof t && (t = this.game.cache.getImage(t)), t) return this.resize(t.width, t.height), this.cls(), this.draw(t), this.update(), this
            },
            clear: function(t, e, i, s) {
                return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.width), void 0 === s && (s = this.height), this.context.clearRect(t, e, i, s), this.dirty = !0, this
            },
            fill: function(t, e, i, s) {
                return void 0 === s && (s = 1), this.context.fillStyle = "rgba(" + t + "," + e + "," + i + "," + s + ")", this.context.fillRect(0, 0, this.width, this.height), this.dirty = !0, this
            },
            generateTexture: function(t, e, i) {
                var s = this.game.cache,
                    n = new Image;
                if (e && (n.onload = function() {
                        var r = s.addImage(t, "", n),
                            o = new PIXI.Texture(r.base);
                        e.call(i || null, o), n.onload = null
                    }), n.src = this.canvas.toDataURL("image/png"), !e) {
                    var r = s.addImage(t, "", n);
                    return new PIXI.Texture(r.base)
                }
                return null
            },
            resize: function(t, e) {
                return t === this.width && e === this.height || (this.width = t, this.height = e, this.canvas.width = t, this.canvas.height = e, void 0 !== this._swapCanvas && (this._swapCanvas.width = t, this._swapCanvas.height = e), this.baseTexture.width = t, this.baseTexture.height = e, this.textureFrame.width = t, this.textureFrame.height = e, this.texture.width = t, this.texture.height = e, this.texture.crop.width = t, this.texture.crop.height = e, this.update(), this.dirty = !0), this
            },
            update: function(t, e, i, s) {
                return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = Math.max(1, this.width)), void 0 === s && (s = Math.max(1, this.height)), this.imageData = this.context.getImageData(t, e, i, s), this.data = this.imageData.data, this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data, this
            },
            processPixelRGB: function(e, i, s, n, r, o) {
                void 0 === s && (s = 0), void 0 === n && (n = 0), void 0 === r && (r = this.width), void 0 === o && (o = this.height);
                for (var a = s + r, h = n + o, l = t.Color.createColor(), c = {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 0
                    }, u = !1, d = n; d < h; d++)
                    for (var p = s; p < a; p++) t.Color.unpackPixel(this.getPixel32(p, d), l), !1 !== (c = e.call(i, l, p, d)) && null != c && (this.setPixel32(p, d, c.r, c.g, c.b, c.a, !1), u = !0);
                return u && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0), this
            },
            processPixel: function(t, e, i, s, n, r) {
                void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === n && (n = this.width), void 0 === r && (r = this.height);
                for (var o = i + n, a = s + r, h = 0, l = 0, c = !1, u = s; u < a; u++)
                    for (var d = i; d < o; d++) h = this.getPixel32(d, u), (l = t.call(e, h, d, u)) !== h && (this.pixels[u * this.width + d] = l, c = !0);
                return c && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0), this
            },
            replaceRGB: function(e, i, s, n, r, o, a, h, l) {
                var c = 0,
                    u = 0,
                    d = this.width,
                    p = this.height,
                    f = t.Color.packPixel(e, i, s, n);
                void 0 !== l && l instanceof t.Rectangle && (c = l.x, u = l.y, d = l.width, p = l.height);
                for (var g = 0; g < p; g++)
                    for (var m = 0; m < d; m++) this.getPixel32(c + m, u + g) === f && this.setPixel32(c + m, u + g, r, o, a, h, !1);
                return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
            },
            setHSL: function(e, i, s, n) {
                var r = e || 0 === e,
                    o = i || 0 === i,
                    a = s || 0 === s;
                if (r || o || a) {
                    void 0 === n && (n = new t.Rectangle(0, 0, this.width, this.height));
                    for (var h = t.Color.createColor(), l = n.y; l < n.bottom; l++)
                        for (var c = n.x; c < n.right; c++) t.Color.unpackPixel(this.getPixel32(c, l), h, !0), r && (h.h = e), o && (h.s = i), a && (h.l = s), t.Color.HSLtoRGB(h.h, h.s, h.l, h), this.setPixel32(c, l, h.r, h.g, h.b, h.a, !1);
                    return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
                }
            },
            shiftHSL: function(e, i, s, n) {
                if (null != e || (e = !1), null != i || (i = !1), null != s || (s = !1), e || i || s) {
                    void 0 === n && (n = new t.Rectangle(0, 0, this.width, this.height));
                    for (var r = t.Color.createColor(), o = n.y; o < n.bottom; o++)
                        for (var a = n.x; a < n.right; a++) t.Color.unpackPixel(this.getPixel32(a, o), r, !0), e && (r.h = this.game.math.wrap(r.h + e, 0, 1)), i && (r.s = this.game.math.clamp(r.s + i, 0, 1)), s && (r.l = this.game.math.clamp(r.l + s, 0, 1)), t.Color.HSLtoRGB(r.h, r.s, r.l, r), this.setPixel32(a, o, r.r, r.g, r.b, r.a, !1);
                    return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
                }
            },
            setPixel32: function(e, i, s, n, r, o, a) {
                return void 0 === a && (a = !0), e >= 0 && e <= this.width && i >= 0 && i <= this.height && (t.Device.LITTLE_ENDIAN ? this.pixels[i * this.width + e] = o << 24 | r << 16 | n << 8 | s : this.pixels[i * this.width + e] = s << 24 | n << 16 | r << 8 | o, a && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0)), this
            },
            setPixel: function(t, e, i, s, n, r) {
                return this.setPixel32(t, e, i, s, n, 255, r)
            },
            getPixel: function(e, i, s) {
                s || (s = t.Color.createColor());
                var n = ~~(e + i * this.width);
                return n *= 4, s.r = this.data[n], s.g = this.data[++n], s.b = this.data[++n], s.a = this.data[++n], s
            },
            getPixel32: function(t, e) {
                if (t >= 0 && t <= this.width && e >= 0 && e <= this.height) return this.pixels[e * this.width + t]
            },
            getPixelRGB: function(e, i, s, n, r) {
                return t.Color.unpackPixel(this.getPixel32(e, i), s, n, r)
            },
            getPixels: function(t) {
                return this.context.getImageData(t.x, t.y, t.width, t.height)
            },
            getFirstPixel: function(e) {
                void 0 === e && (e = 0);
                var i = t.Color.createColor(),
                    s = 0,
                    n = 0,
                    r = 1,
                    o = !1;
                1 === e ? (r = -1, n = this.height) : 3 === e && (r = -1, s = this.width);
                do {
                    t.Color.unpackPixel(this.getPixel32(s, n), i), 0 === e || 1 === e ? ++s === this.width && (s = 0, ((n += r) >= this.height || n <= 0) && (o = !0)) : 2 !== e && 3 !== e || ++n === this.height && (n = 0, ((s += r) >= this.width || s <= 0) && (o = !0))
                } while (0 === i.a && !o);
                return i.x = s, i.y = n, i
            },
            getBounds: function(e) {
                return void 0 === e && (e = new t.Rectangle), e.x = this.getFirstPixel(2).x, e.x === this.width ? e.setTo(0, 0, 0, 0) : (e.y = this.getFirstPixel(0).y, e.width = this.getFirstPixel(3).x - e.x + 1, e.height = this.getFirstPixel(1).y - e.y + 1, e)
            },
            addToWorld: function(t, e, i, s, n, r) {
                n = n || 1, r = r || 1;
                var o = this.game.add.image(t, e, this);
                return o.anchor.set(i, s), o.scale.set(n, r), o
            },
            copy: function(e, i, s, n, r, o, a, h, l, c, u, d, p, f, g, m, y) {
                if (null != e || (e = this), e instanceof t.RenderTexture && (e = e.getCanvas()), this._image = e, e instanceof t.Sprite || e instanceof t.Image || e instanceof t.Text || e instanceof PIXI.Sprite) this._pos.set(e.texture.crop.x, e.texture.crop.y), this._size.set(e.texture.crop.width, e.texture.crop.height), this._scale.set(e.scale.x, e.scale.y), this._anchor.set(e.anchor.x, e.anchor.y), this._rotate = e.rotation, this._alpha.current = e.alpha, e.texture instanceof t.RenderTexture ? this._image = e.texture.getCanvas() : this._image = e.texture.baseTexture.source, null != o || (o = e.x), null != a || (a = e.y), e.texture.trim && (o += e.texture.trim.x - e.anchor.x * e.texture.trim.width, a += e.texture.trim.y - e.anchor.y * e.texture.trim.height), 16777215 !== e.tint && (e.cachedTint !== e.tint && (e.cachedTint = e.tint, e.tintedTexture = PIXI.CanvasTinter.getTintedTexture(e, e.tint)), this._image = e.tintedTexture, this._pos.set(0));
                else {
                    if (this._pos.set(0), this._scale.set(1), this._anchor.set(0), this._rotate = 0, this._alpha.current = 1, e instanceof t.BitmapData) this._image = e.canvas;
                    else if ("string" == typeof e) {
                        if (null === (e = this.game.cache.getImage(e))) return this;
                        this._image = e
                    }
                    this._size.set(this._image.width, this._image.height)
                }
                if (null != i || (i = 0), null != s || (s = 0), n && (this._size.x = n), r && (this._size.y = r), null != o || (o = i), null != a || (a = s), null != h || (h = this._size.x), null != l || (l = this._size.y), "number" == typeof c && (this._rotate = c), "number" == typeof u && (this._anchor.x = u), "number" == typeof d && (this._anchor.y = d), "number" == typeof p && (this._scale.x = p), "number" == typeof f && (this._scale.y = f), "number" == typeof g && (this._alpha.current = g), void 0 === m && (m = null), void 0 === y && (y = !1), this._alpha.current <= 0 || 0 === this._scale.x || 0 === this._scale.y || 0 === this._size.x || 0 === this._size.y) return this;
                var v = this.context;
                return this._alpha.prev = v.globalAlpha, v.save(), v.globalAlpha = this._alpha.current, m && (this.op = m), y && (o |= 0, a |= 0), v.translate(o, a), v.scale(this._scale.x, this._scale.y), v.rotate(this._rotate), v.drawImage(this._image, this._pos.x + i, this._pos.y + s, this._size.x, this._size.y, -h * this._anchor.x, -l * this._anchor.y, h, l), v.restore(), v.globalAlpha = this._alpha.prev, this.dirty = !0, this
            },
            copyTransform: function(e, i, s) {
                if (void 0 === i && (i = null), void 0 === s && (s = !1), !e.hasOwnProperty("worldTransform") || !e.worldVisible || 0 === e.worldAlpha) return this;
                var n = e.worldTransform;
                if (this._pos.set(e.texture.crop.x, e.texture.crop.y), this._size.set(e.texture.crop.width, e.texture.crop.height), 0 === n.a || 0 === n.d || 0 === this._size.x || 0 === this._size.y) return this;
                e.texture instanceof t.RenderTexture ? this._image = e.texture.getCanvas() : this._image = e.texture.baseTexture.source;
                var r = n.tx,
                    o = n.ty;
                e.texture.trim && (r += e.texture.trim.x - e.anchor.x * e.texture.trim.width, o += e.texture.trim.y - e.anchor.y * e.texture.trim.height), 16777215 !== e.tint && (e.cachedTint !== e.tint && (e.cachedTint = e.tint, e.tintedTexture = PIXI.CanvasTinter.getTintedTexture(e, e.tint)), this._image = e.tintedTexture, this._pos.set(0)), s && (r |= 0, o |= 0);
                var a = this.context;
                return this._alpha.prev = a.globalAlpha, a.save(), a.globalAlpha = this._alpha.current, i && (this.op = i), a[this.smoothProperty] = e.texture.baseTexture.scaleMode === PIXI.scaleModes.LINEAR, a.setTransform(n.a, n.b, n.c, n.d, r, o), a.drawImage(this._image, this._pos.x, this._pos.y, this._size.x, this._size.y, -this._size.x * e.anchor.x, -this._size.y * e.anchor.y, this._size.x, this._size.y), a.restore(), a.globalAlpha = this._alpha.prev, this.dirty = !0, this
            },
            copyRect: function(t, e, i, s, n, r, o) {
                return this.copy(t, e.x, e.y, e.width, e.height, i, s, e.width, e.height, 0, 0, 0, 1, 1, n, r, o)
            },
            draw: function(t, e, i, s, n, r, o) {
                return this.copy(t, null, null, null, null, e, i, s, n, null, null, null, null, null, null, r, o)
            },
            drawGroup: function(t, e, i) {
                return t.total > 0 && t.forEachExists(this.drawGroupProxy, this, e, i), this
            },
            drawGroupProxy: function(e, i, s) {
                if (e.hasOwnProperty("texture") && this.copyTransform(e, i, s), e.type === t.GROUP && e.exists) this.drawGroup(e, i, s);
                else if (e.hasOwnProperty("children") && e.children.length > 0)
                    for (var n = 0; n < e.children.length; n++) e.children[n].exists && this.copyTransform(e.children[n], i, s)
            },
            drawFull: function(e, i, s) {
                if (!1 === e.worldVisible || 0 === e.worldAlpha || e.hasOwnProperty("exists") && !1 === e.exists) return this;
                if (e.type !== t.GROUP && e.type !== t.EMITTER && e.type !== t.BITMAPTEXT)
                    if (e.type === t.GRAPHICS) {
                        var n = e.getBounds();
                        this.ctx.save(), this.ctx.translate(n.x, n.y), PIXI.CanvasGraphics.renderGraphics(e, this.ctx), this.ctx.restore()
                    } else this.copy(e, null, null, null, null, e.worldPosition.x, e.worldPosition.y, null, null, e.worldRotation, null, null, e.worldScale.x, e.worldScale.y, e.worldAlpha, i, s);
                if (e.children)
                    for (var r = 0; r < e.children.length; r++) this.drawFull(e.children[r], i, s);
                return this
            },
            shadow: function(t, e, i, s) {
                var n = this.context;
                return null == t ? n.shadowColor = "rgba(0,0,0,0)" : (n.shadowColor = t, n.shadowBlur = 0 === e ? 0 : e || 5, n.shadowOffsetX = 0 === i ? 0 : i || 10, n.shadowOffsetY = 0 === s ? 0 : s || 10), this
            },
            alphaMask: function(t, e, i, s) {
                return null == s ? this.draw(e).blendSourceAtop() : this.draw(e, s.x, s.y, s.width, s.height).blendSourceAtop(), null == i ? this.draw(t).blendReset() : this.draw(t, i.x, i.y, i.width, i.height).blendReset(), this
            },
            extract: function(t, e, i, s, n, r, o, a, h) {
                return void 0 === n && (n = 255), void 0 === r && (r = !1), void 0 === o && (o = e), void 0 === a && (a = i), void 0 === h && (h = s), r && t.resize(this.width, this.height), this.processPixelRGB(function(r, l, c) {
                    return r.r === e && r.g === i && r.b === s && t.setPixel32(l, c, o, a, h, n, !1), !1
                }, this), t.context.putImageData(t.imageData, 0, 0), t.dirty = !0, t
            },
            rect: function(t, e, i, s, n) {
                return void 0 !== n && (this.context.fillStyle = n), this.context.fillRect(t, e, i, s), this
            },
            text: function(t, e, i, s, n, r) {
                void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = "14px Courier"), void 0 === n && (n = "rgb(255,255,255)"), void 0 === r && (r = !0);
                var o = this.context,
                    a = o.font;
                return o.font = s, r && (o.fillStyle = "rgb(0,0,0)", o.fillText(t, e + 1, i + 1)), o.fillStyle = n, o.fillText(t, e, i), o.font = a, this
            },
            circle: function(t, e, i, s) {
                var n = this.context;
                return void 0 !== s && (n.fillStyle = s), n.beginPath(), n.arc(t, e, i, 0, 2 * Math.PI, !1), n.closePath(), n.fill(), this
            },
            line: function(t, e, i, s, n, r) {
                void 0 === n && (n = "#fff"), void 0 === r && (r = 1);
                var o = this.context;
                return o.beginPath(), o.moveTo(t, e), o.lineTo(i, s), o.lineWidth = r, o.strokeStyle = n, o.stroke(), o.closePath(), this
            },
            polygon: function(t, e, i, s) {
                void 0 === s && (s = "#fff"), void 0 === i && (i = 0);
                var n = this.context;
                e && (n.fillStyle = e), i && (n.lineWidth = i, n.strokeStyle = s), n.beginPath(), n.moveTo(t[0].x, t[0].y);
                for (var r = 1, o = t.length; r < o; r++) {
                    var a = t[r];
                    n.lineTo(a.x, a.y)
                }
                return n.closePath(), e && n.fill(), i && n.stroke(), this
            },
            textureLine: function(e, i, s) {
                if (void 0 === s && (s = "repeat-x"), "string" != typeof i || (i = this.game.cache.getImage(i))) {
                    var n = e.length;
                    "no-repeat" === s && n > i.width && (n = i.width);
                    var r = this.context;
                    return r.fillStyle = r.createPattern(i, s), this._circle = new t.Circle(e.start.x, e.start.y, i.height), this._circle.circumferencePoint(e.angle - 1.5707963267948966, !1, this._pos), r.save(), r.translate(this._pos.x, this._pos.y), r.rotate(e.angle), r.fillRect(0, 0, n, i.height), r.restore(), this.dirty = !0, this
                }
            },
            render: function() {
                return !this.disableTextureUpload && this.dirty && (this.baseTexture.dirty(), this.dirty = !1), this
            },
            destroy: function() {
                this.frameData.destroy(), this.texture.destroy(!0), t.CanvasPool.remove(this)
            },
            blendReset: function() {
                return this.op = "source-over", this
            },
            blendSourceOver: function() {
                return this.op = "source-over", this
            },
            blendSourceIn: function() {
                return this.op = "source-in", this
            },
            blendSourceOut: function() {
                return this.op = "source-out", this
            },
            blendSourceAtop: function() {
                return this.op = "source-atop", this
            },
            blendDestinationOver: function() {
                return this.op = "destination-over", this
            },
            blendDestinationIn: function() {
                return this.op = "destination-in", this
            },
            blendDestinationOut: function() {
                return this.op = "destination-out", this
            },
            blendDestinationAtop: function() {
                return this.op = "destination-atop", this
            },
            blendXor: function() {
                return this.op = "xor", this
            },
            blendAdd: function() {
                return this.op = "lighter", this
            },
            blendMultiply: function() {
                return this.op = "multiply", this
            },
            blendScreen: function() {
                return this.op = "screen", this
            },
            blendOverlay: function() {
                return this.op = "overlay", this
            },
            blendDarken: function() {
                return this.op = "darken", this
            },
            blendLighten: function() {
                return this.op = "lighten", this
            },
            blendColorDodge: function() {
                return this.op = "color-dodge", this
            },
            blendColorBurn: function() {
                return this.op = "color-burn", this
            },
            blendHardLight: function() {
                return this.op = "hard-light", this
            },
            blendSoftLight: function() {
                return this.op = "soft-light", this
            },
            blendDifference: function() {
                return this.op = "difference", this
            },
            blendExclusion: function() {
                return this.op = "exclusion", this
            },
            blendHue: function() {
                return this.op = "hue", this
            },
            blendSaturation: function() {
                return this.op = "saturation", this
            },
            blendColor: function() {
                return this.op = "color", this
            },
            blendLuminosity: function() {
                return this.op = "luminosity", this
            },
            copyBitmapData: function(t, e, i) {
                t.update();
                for (var s, n = 0; n < t.height; n++) {
                    s = (i + n) * this.width + e;
                    for (var r = 0; r < t.width; r++) this.pixels[s + r] = t.pixels[n * t.width + r]
                }
                return this
            }
        }, Object.defineProperty(t.BitmapData.prototype, "smoothed", {
            get: function() {
                return t.Canvas.getSmoothingEnabled(this.context)
            },
            set: function(e) {
                t.Canvas.setSmoothingEnabled(this.context, e)
            }
        }), Object.defineProperty(t.BitmapData.prototype, "op", {
            get: function() {
                return this.context.globalCompositeOperation
            },
            set: function(t) {
                this.context.globalCompositeOperation = t
            }
        }), t.BitmapData.getTransform = function(t, e, i, s, n, r) {
            return "number" != typeof t && (t = 0), "number" != typeof e && (e = 0), "number" != typeof i && (i = 1), "number" != typeof s && (s = 1), "number" != typeof n && (n = 0), "number" != typeof r && (r = 0), {
                sx: i,
                sy: s,
                scaleX: i,
                scaleY: s,
                skewX: n,
                skewY: r,
                translateX: t,
                translateY: e,
                tx: t,
                ty: e
            }
        }, t.BitmapData.prototype.constructor = t.BitmapData, t.EarCut = {}, t.EarCut.Triangulate = function(e, i, s) {
            s = s || 2;
            var n, r, o, a, h, l, c, u = i && i.length,
                d = u ? i[0] * s : e.length,
                p = t.EarCut.linkedList(e, 0, d, s, !0),
                f = [];
            if (!p) return f;
            if (u && (p = t.EarCut.eliminateHoles(e, i, p, s)), e.length > 80 * s) {
                n = o = e[0], r = a = e[1];
                for (var g = s; g < d; g += s)(h = e[g]) < n && (n = h), (l = e[g + 1]) < r && (r = l), h > o && (o = h), l > a && (a = l);
                c = Math.max(o - n, a - r)
            }
            return t.EarCut.earcutLinked(p, f, s, n, r, c), f
        }, t.EarCut.linkedList = function(e, i, s, n, r) {
            var o, a, h, l = 0;
            for (o = i, a = s - n; o < s; o += n) l += (e[a] - e[o]) * (e[o + 1] + e[a + 1]), a = o;
            if (r === l > 0)
                for (o = i; o < s; o += n) h = t.EarCut.insertNode(o, e[o], e[o + 1], h);
            else
                for (o = s - n; o >= i; o -= n) h = t.EarCut.insertNode(o, e[o], e[o + 1], h);
            return h
        }, t.EarCut.filterPoints = function(e, i) {
            if (!e) return e;
            i || (i = e);
            var s, n = e;
            do {
                if (s = !1, n.steiner || !t.EarCut.equals(n, n.next) && 0 !== t.EarCut.area(n.prev, n, n.next)) n = n.next;
                else {
                    if (t.EarCut.removeNode(n), (n = i = n.prev) === n.next) return null;
                    s = !0
                }
            } while (s || n !== i);
            return i
        }, t.EarCut.earcutLinked = function(e, i, s, n, r, o, a) {
            if (e) {
                !a && o && t.EarCut.indexCurve(e, n, r, o);
                for (var h, l, c = e; e.prev !== e.next;)
                    if (h = e.prev, l = e.next, o ? t.EarCut.isEarHashed(e, n, r, o) : t.EarCut.isEar(e)) i.push(h.i / s), i.push(e.i / s), i.push(l.i / s), t.EarCut.removeNode(e), e = l.next, c = l.next;
                    else if ((e = l) === c) {
                    a ? 1 === a ? (e = t.EarCut.cureLocalIntersections(e, i, s), t.EarCut.earcutLinked(e, i, s, n, r, o, 2)) : 2 === a && t.EarCut.splitEarcut(e, i, s, n, r, o) : t.EarCut.earcutLinked(t.EarCut.filterPoints(e), i, s, n, r, o, 1);
                    break
                }
            }
        }, t.EarCut.isEar = function(e) {
            var i = e.prev,
                s = e,
                n = e.next;
            if (t.EarCut.area(i, s, n) >= 0) return !1;
            for (var r = e.next.next; r !== e.prev;) {
                if (t.EarCut.pointInTriangle(i.x, i.y, s.x, s.y, n.x, n.y, r.x, r.y) && t.EarCut.area(r.prev, r, r.next) >= 0) return !1;
                r = r.next
            }
            return !0
        }, t.EarCut.isEarHashed = function(e, i, s, n) {
            var r = e.prev,
                o = e,
                a = e.next;
            if (t.EarCut.area(r, o, a) >= 0) return !1;
            for (var h = r.x < o.x ? r.x < a.x ? r.x : a.x : o.x < a.x ? o.x : a.x, l = r.y < o.y ? r.y < a.y ? r.y : a.y : o.y < a.y ? o.y : a.y, c = r.x > o.x ? r.x > a.x ? r.x : a.x : o.x > a.x ? o.x : a.x, u = r.y > o.y ? r.y > a.y ? r.y : a.y : o.y > a.y ? o.y : a.y, d = t.EarCut.zOrder(h, l, i, s, n), p = t.EarCut.zOrder(c, u, i, s, n), f = e.nextZ; f && f.z <= p;) {
                if (f !== e.prev && f !== e.next && t.EarCut.pointInTriangle(r.x, r.y, o.x, o.y, a.x, a.y, f.x, f.y) && t.EarCut.area(f.prev, f, f.next) >= 0) return !1;
                f = f.nextZ
            }
            for (f = e.prevZ; f && f.z >= d;) {
                if (f !== e.prev && f !== e.next && t.EarCut.pointInTriangle(r.x, r.y, o.x, o.y, a.x, a.y, f.x, f.y) && t.EarCut.area(f.prev, f, f.next) >= 0) return !1;
                f = f.prevZ
            }
            return !0
        }, t.EarCut.cureLocalIntersections = function(e, i, s) {
            var n = e;
            do {
                var r = n.prev,
                    o = n.next.next;
                t.EarCut.intersects(r, n, n.next, o) && t.EarCut.locallyInside(r, o) && t.EarCut.locallyInside(o, r) && (i.push(r.i / s), i.push(n.i / s), i.push(o.i / s), t.EarCut.removeNode(n), t.EarCut.removeNode(n.next), n = e = o), n = n.next
            } while (n !== e);
            return n
        }, t.EarCut.splitEarcut = function(e, i, s, n, r, o) {
            var a = e;
            do {
                for (var h = a.next.next; h !== a.prev;) {
                    if (a.i !== h.i && t.EarCut.isValidDiagonal(a, h)) {
                        var l = t.EarCut.splitPolygon(a, h);
                        return a = t.EarCut.filterPoints(a, a.next), l = t.EarCut.filterPoints(l, l.next), t.EarCut.earcutLinked(a, i, s, n, r, o), void t.EarCut.earcutLinked(l, i, s, n, r, o)
                    }
                    h = h.next
                }
                a = a.next
            } while (a !== e)
        }, t.EarCut.eliminateHoles = function(e, i, s, n) {
            var r, o, a, h, l, c = [];
            for (r = 0, o = i.length; r < o; r++) a = i[r] * n, h = r < o - 1 ? i[r + 1] * n : e.length, (l = t.EarCut.linkedList(e, a, h, n, !1)) === l.next && (l.steiner = !0), c.push(t.EarCut.getLeftmost(l));
            for (c.sort(t.EarCut.compareX), r = 0; r < c.length; r++) t.EarCut.eliminateHole(c[r], s), s = t.EarCut.filterPoints(s, s.next);
            return s
        }, t.EarCut.compareX = function(t, e) {
            return t.x - e.x
        }, t.EarCut.eliminateHole = function(e, i) {
            if (i = t.EarCut.findHoleBridge(e, i)) {
                var s = t.EarCut.splitPolygon(i, e);
                t.EarCut.filterPoints(s, s.next)
            }
        }, t.EarCut.findHoleBridge = function(e, i) {
            var s, n = i,
                r = e.x,
                o = e.y,
                a = -1 / 0;
            do {
                if (o <= n.y && o >= n.next.y) {
                    var h = n.x + (o - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                    h <= r && h > a && (a = h, s = n.x < n.next.x ? n : n.next)
                }
                n = n.next
            } while (n !== i);
            if (!s) return null;
            if (e.x === s.x) return s.prev;
            var l, c = s,
                u = 1 / 0;
            for (n = s.next; n !== c;) r >= n.x && n.x >= s.x && t.EarCut.pointInTriangle(o < s.y ? r : a, o, s.x, s.y, o < s.y ? a : r, o, n.x, n.y) && ((l = Math.abs(o - n.y) / (r - n.x)) < u || l === u && n.x > s.x) && t.EarCut.locallyInside(n, e) && (s = n, u = l), n = n.next;
            return s
        }, t.EarCut.indexCurve = function(e, i, s, n) {
            var r = e;
            do {
                null === r.z && (r.z = t.EarCut.zOrder(r.x, r.y, i, s, n)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
            } while (r !== e);
            r.prevZ.nextZ = null, r.prevZ = null, t.EarCut.sortLinked(r)
        }, t.EarCut.sortLinked = function(t) {
            var e, i, s, n, r, o, a, h, l = 1;
            do {
                for (i = t, t = null, r = null, o = 0; i;) {
                    for (o++, s = i, a = 0, e = 0; e < l && (a++, s = s.nextZ); e++);
                    for (h = l; a > 0 || h > 0 && s;) 0 === a ? (n = s, s = s.nextZ, h--) : 0 !== h && s ? i.z <= s.z ? (n = i, i = i.nextZ, a--) : (n = s, s = s.nextZ, h--) : (n = i, i = i.nextZ, a--), r ? r.nextZ = n : t = n, n.prevZ = r, r = n;
                    i = s
                }
                r.nextZ = null, l *= 2
            } while (o > 1);
            return t
        }, t.EarCut.zOrder = function(t, e, i, s, n) {
            return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) / n) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - s) / n) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
        }, t.EarCut.getLeftmost = function(t) {
            var e = t,
                i = t;
            do {
                e.x < i.x && (i = e), e = e.next
            } while (e !== t);
            return i
        }, t.EarCut.pointInTriangle = function(t, e, i, s, n, r, o, a) {
            return (n - o) * (e - a) - (t - o) * (r - a) >= 0 && (t - o) * (s - a) - (i - o) * (e - a) >= 0 && (i - o) * (r - a) - (n - o) * (s - a) >= 0
        }, t.EarCut.isValidDiagonal = function(e, i) {
            return t.EarCut.equals(e, i) || e.next.i !== i.i && e.prev.i !== i.i && !t.EarCut.intersectsPolygon(e, i) && t.EarCut.locallyInside(e, i) && t.EarCut.locallyInside(i, e) && t.EarCut.middleInside(e, i)
        }, t.EarCut.area = function(t, e, i) {
            return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
        }, t.EarCut.equals = function(t, e) {
            return t.x === e.x && t.y === e.y
        }, t.EarCut.intersects = function(e, i, s, n) {
            return t.EarCut.area(e, i, s) > 0 != t.EarCut.area(e, i, n) > 0 && t.EarCut.area(s, n, e) > 0 != t.EarCut.area(s, n, i) > 0
        }, t.EarCut.intersectsPolygon = function(e, i) {
            var s = e;
            do {
                if (s.i !== e.i && s.next.i !== e.i && s.i !== i.i && s.next.i !== i.i && t.EarCut.intersects(s, s.next, e, i)) return !0;
                s = s.next
            } while (s !== e);
            return !1
        }, t.EarCut.locallyInside = function(e, i) {
            return t.EarCut.area(e.prev, e, e.next) < 0 ? t.EarCut.area(e, i, e.next) >= 0 && t.EarCut.area(e, e.prev, i) >= 0 : t.EarCut.area(e, i, e.prev) < 0 || t.EarCut.area(e, e.next, i) < 0
        }, t.EarCut.middleInside = function(t, e) {
            var i = t,
                s = !1,
                n = (t.x + e.x) / 2,
                r = (t.y + e.y) / 2;
            do {
                i.y > r != i.next.y > r && n < (i.next.x - i.x) * (r - i.y) / (i.next.y - i.y) + i.x && (s = !s), i = i.next
            } while (i !== t);
            return s
        }, t.EarCut.splitPolygon = function(e, i) {
            var s = new t.EarCut.Node(e.i, e.x, e.y),
                n = new t.EarCut.Node(i.i, i.x, i.y),
                r = e.next,
                o = i.prev;
            return e.next = i, i.prev = e, s.next = r, r.prev = s, n.next = s, s.prev = n, o.next = n, n.prev = o, n
        }, t.EarCut.insertNode = function(e, i, s, n) {
            var r = new t.EarCut.Node(e, i, s);
            return n ? (r.next = n.next, r.prev = n, n.next.prev = r, n.next = r) : (r.prev = r, r.next = r), r
        }, t.EarCut.removeNode = function(t) {
            t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
        }, t.EarCut.Node = function(t, e, i) {
            this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
        }, PIXI.WebGLGraphics = function() {}, PIXI.WebGLGraphics.stencilBufferLimit = 6, PIXI.WebGLGraphics.renderGraphics = function(e, i) {
            var s, n = i.gl,
                r = i.projection,
                o = i.offset,
                a = i.shaderManager.primitiveShader;
            e.dirty && PIXI.WebGLGraphics.updateGraphics(e, n);
            var h = e._webGL[n.id];
            if (h)
                for (var l = 0; l < h.data.length; l++) 1 === h.data[l].mode ? (s = h.data[l], i.stencilManager.pushStencil(e, s, i), n.drawElements(n.TRIANGLE_FAN, 4, n.UNSIGNED_SHORT, 2 * (s.indices.length - 4)), i.stencilManager.popStencil(e, s, i)) : (s = h.data[l], i.shaderManager.setShader(a), a = i.shaderManager.primitiveShader, n.uniformMatrix3fv(a.translationMatrix, !1, e.worldTransform.toArray(!0)), n.uniform1f(a.flipY, 1), n.uniform2f(a.projectionVector, r.x, -r.y), n.uniform2f(a.offsetVector, -o.x, -o.y), n.uniform3fv(a.tintColor, t.Color.hexToRGBArray(e.tint)), n.uniform1f(a.alpha, e.worldAlpha), n.bindBuffer(n.ARRAY_BUFFER, s.buffer), n.vertexAttribPointer(a.aVertexPosition, 2, n.FLOAT, !1, 24, 0), n.vertexAttribPointer(a.colorAttribute, 4, n.FLOAT, !1, 24, 8), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, s.indexBuffer), n.drawElements(n.TRIANGLE_STRIP, s.indices.length, n.UNSIGNED_SHORT, 0))
        }, PIXI.WebGLGraphics.updateGraphics = function(e, i) {
            var s, n, r = e._webGL[i.id];
            if (r || (r = e._webGL[i.id] = {
                    lastIndex: 0,
                    data: [],
                    gl: i
                }), e.dirty = !1, e.clearDirty) {
                for (e.clearDirty = !1, s = 0; s < r.data.length; s++) {
                    var o = r.data[s];
                    o.reset(), PIXI.WebGLGraphics.graphicsDataPool.push(o)
                }
                r.data = [], r.lastIndex = 0
            }
            for (s = r.lastIndex; s < e.graphicsData.length; s++) {
                var a = e.graphicsData[s];
                a.type === t.POLYGON ? (a.points = a.shape.points.slice(), a.shape.closed && (a.points[0] === a.points[a.points.length - 2] && a.points[1] === a.points[a.points.length - 1] || a.points.push(a.points[0], a.points[1])), a.fill && a.points.length >= PIXI.WebGLGraphics.stencilBufferLimit && (a.points.length < 2 * PIXI.WebGLGraphics.stencilBufferLimit ? (n = PIXI.WebGLGraphics.switchMode(r, 0), PIXI.WebGLGraphics.buildPoly(a, n) || (n = PIXI.WebGLGraphics.switchMode(r, 1), PIXI.WebGLGraphics.buildComplexPoly(a, n))) : (n = PIXI.WebGLGraphics.switchMode(r, 1), PIXI.WebGLGraphics.buildComplexPoly(a, n))), a.lineWidth > 0 && (n = PIXI.WebGLGraphics.switchMode(r, 0), PIXI.WebGLGraphics.buildLine(a, n))) : (n = PIXI.WebGLGraphics.switchMode(r, 0), a.type === t.RECTANGLE ? PIXI.WebGLGraphics.buildRectangle(a, n) : a.type === t.CIRCLE || a.type === t.ELLIPSE ? PIXI.WebGLGraphics.buildCircle(a, n) : a.type === t.ROUNDEDRECTANGLE && PIXI.WebGLGraphics.buildRoundedRectangle(a, n)), r.lastIndex++
            }
            for (s = 0; s < r.data.length; s++)(n = r.data[s]).dirty && n.upload()
        }, PIXI.WebGLGraphics.switchMode = function(t, e) {
            var i;
            return t.data.length && (i = t.data[t.data.length - 1]).mode === e && 1 !== e || ((i = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(t.gl)).mode = e, t.data.push(i)), i.dirty = !0, i
        }, PIXI.WebGLGraphics.buildRectangle = function(e, i) {
            var s = e.shape,
                n = s.x,
                r = s.y,
                o = s.width,
                a = s.height;
            if (e.fill) {
                var h = t.Color.hexToRGBArray(e.fillColor),
                    l = e.fillAlpha,
                    c = h[0] * l,
                    u = h[1] * l,
                    d = h[2] * l,
                    p = i.points,
                    f = i.indices,
                    g = p.length / 6;
                p.push(n, r), p.push(c, u, d, l), p.push(n + o, r), p.push(c, u, d, l), p.push(n, r + a), p.push(c, u, d, l), p.push(n + o, r + a), p.push(c, u, d, l), f.push(g, g, g + 1, g + 2, g + 3, g + 3)
            }
            if (e.lineWidth) {
                var m = e.points;
                e.points = [n, r, n + o, r, n + o, r + a, n, r + a, n, r], PIXI.WebGLGraphics.buildLine(e, i), e.points = m
            }
        }, PIXI.WebGLGraphics.buildRoundedRectangle = function(e, i) {
            var s = e.shape,
                n = s.x,
                r = s.y,
                o = s.width,
                a = s.height,
                h = s.radius,
                l = [];
            if (l.push(n, r + h), l = (l = (l = (l = l.concat(PIXI.WebGLGraphics.quadraticBezierCurve(n, r + a - h, n, r + a, n + h, r + a))).concat(PIXI.WebGLGraphics.quadraticBezierCurve(n + o - h, r + a, n + o, r + a, n + o, r + a - h))).concat(PIXI.WebGLGraphics.quadraticBezierCurve(n + o, r + h, n + o, r, n + o - h, r))).concat(PIXI.WebGLGraphics.quadraticBezierCurve(n + h, r, n, r, n, r + h)), e.fill) {
                var c = t.Color.hexToRGBArray(e.fillColor),
                    u = e.fillAlpha,
                    d = c[0] * u,
                    p = c[1] * u,
                    f = c[2] * u,
                    g = i.points,
                    m = i.indices,
                    y = g.length / 6,
                    v = t.EarCut.Triangulate(l, null, 2),
                    x = 0;
                for (x = 0; x < v.length; x += 3) m.push(v[x] + y), m.push(v[x] + y), m.push(v[x + 1] + y), m.push(v[x + 2] + y), m.push(v[x + 2] + y);
                for (x = 0; x < l.length; x++) g.push(l[x], l[++x], d, p, f, u)
            }
            if (e.lineWidth) {
                var b = e.points;
                e.points = l, PIXI.WebGLGraphics.buildLine(e, i), e.points = b
            }
        }, PIXI.WebGLGraphics.quadraticBezierCurve = function(t, e, i, s, n, r) {
            function o(t, e, i) {
                return t + (e - t) * i
            }
            for (var a, h, l, c, u, d, p = [], f = 0, g = 0; g <= 20; g++) a = o(t, i, f = g / 20), h = o(e, s, f), l = o(i, n, f), c = o(s, r, f), u = o(a, l, f), d = o(h, c, f), p.push(u, d);
            return p
        }, PIXI.WebGLGraphics.buildCircle = function(e, i) {
            var s, n, r = e.shape,
                o = r.x,
                a = r.y;
            e.type === t.CIRCLE ? (s = r.radius, n = r.radius) : (s = r.width, n = r.height);
            var h = 2 * Math.PI / 40,
                l = 0;
            if (e.fill) {
                var c = t.Color.hexToRGBArray(e.fillColor),
                    u = e.fillAlpha,
                    d = c[0] * u,
                    p = c[1] * u,
                    f = c[2] * u,
                    g = i.points,
                    m = i.indices,
                    y = g.length / 6;
                for (m.push(y), l = 0; l < 41; l++) g.push(o, a, d, p, f, u), g.push(o + Math.sin(h * l) * s, a + Math.cos(h * l) * n, d, p, f, u), m.push(y++, y++);
                m.push(y - 1)
            }
            if (e.lineWidth) {
                var v = e.points;
                for (e.points = [], l = 0; l < 41; l++) e.points.push(o + Math.sin(h * l) * s, a + Math.cos(h * l) * n);
                PIXI.WebGLGraphics.buildLine(e, i), e.points = v
            }
        }, PIXI.WebGLGraphics.buildLine = function(e, i) {
            var s = 0,
                n = e.points;
            if (0 !== n.length) {
                if (e.lineWidth % 2)
                    for (s = 0; s < n.length; s++) n[s] += .5;
                var r = new PIXI.Point(n[0], n[1]),
                    o = new PIXI.Point(n[n.length - 2], n[n.length - 1]);
                if (r.x === o.x && r.y === o.y) {
                    (n = n.slice()).pop(), n.pop();
                    var a = (o = new PIXI.Point(n[n.length - 2], n[n.length - 1])).x + .5 * (r.x - o.x),
                        h = o.y + .5 * (r.y - o.y);
                    n.unshift(a, h), n.push(a, h)
                }
                var l, c, u, d, p, f, g, m, y, v, x, b, _, w, T, P, C, S, A, E, M, R, L = i.points,
                    B = i.indices,
                    I = n.length / 2,
                    O = n.length,
                    k = L.length / 6,
                    F = e.lineWidth / 2,
                    D = t.Color.hexToRGBArray(e.lineColor),
                    U = e.lineAlpha,
                    G = D[0] * U,
                    N = D[1] * U,
                    X = D[2] * U;
                for (u = n[0], d = n[1], p = n[2], y = -(d - (f = n[3])), v = u - p, y /= R = Math.sqrt(y * y + v * v), v /= R, y *= F, v *= F, L.push(u - y, d - v, G, N, X, U), L.push(u + y, d + v, G, N, X, U), s = 1; s < I - 1; s++) u = n[2 * (s - 1)], d = n[2 * (s - 1) + 1], p = n[2 * s], f = n[2 * s + 1], g = n[2 * (s + 1)], m = n[2 * (s + 1) + 1], y = -(d - f), v = u - p, y /= R = Math.sqrt(y * y + v * v), v /= R, y *= F, v *= F, x = -(f - m), b = p - g, x /= R = Math.sqrt(x * x + b * b), b /= R, C = (-y + u) * (-v + f) - (-y + p) * (-v + d), E = (-(x *= F) + g) * (-(b *= F) + f) - (-x + p) * (-b + m), M = (T = -v + d - (-v + f)) * (A = -x + p - (-x + g)) - (S = -b + m - (-b + f)) * (P = -y + p - (-y + u)), Math.abs(M) < .1 ? (M += 10.1, L.push(p - y, f - v, G, N, X, U), L.push(p + y, f + v, G, N, X, U)) : ((l = (P * E - A * C) / M) - p) * (l - p) + ((c = (S * C - T * E) / M) - f) + (c - f) > 19600 ? (_ = y - x, w = v - b, _ /= R = Math.sqrt(_ * _ + w * w), w /= R, _ *= F, w *= F, L.push(p - _, f - w), L.push(G, N, X, U), L.push(p + _, f + w), L.push(G, N, X, U), L.push(p - _, f - w), L.push(G, N, X, U), O++) : (L.push(l, c), L.push(G, N, X, U), L.push(p - (l - p), f - (c - f)), L.push(G, N, X, U));
                for (u = n[2 * (I - 2)], d = n[2 * (I - 2) + 1], p = n[2 * (I - 1)], y = -(d - (f = n[2 * (I - 1) + 1])), v = u - p, y /= R = Math.sqrt(y * y + v * v), v /= R, y *= F, v *= F, L.push(p - y, f - v), L.push(G, N, X, U), L.push(p + y, f + v), L.push(G, N, X, U), B.push(k), s = 0; s < O; s++) B.push(k++);
                B.push(k - 1)
            }
        }, PIXI.WebGLGraphics.buildComplexPoly = function(e, i) {
            var s = e.points.slice();
            if (!(s.length < 6)) {
                var n = i.indices;
                i.points = s, i.alpha = e.fillAlpha, i.color = t.Color.hexToRGBArray(e.fillColor);
                for (var r, o, a = 1 / 0, h = -1 / 0, l = 1 / 0, c = -1 / 0, u = 0; u < s.length; u += 2) a = (r = s[u]) < a ? r : a, h = r > h ? r : h, l = (o = s[u + 1]) < l ? o : l, c = o > c ? o : c;
                s.push(a, l, h, l, h, c, a, c);
                var d = s.length / 2;
                for (u = 0; u < d; u++) n.push(u)
            }
        }, PIXI.WebGLGraphics.buildPoly = function(e, i) {
            var s = e.points;
            if (!(s.length < 6)) {
                var n = i.points,
                    r = i.indices,
                    o = s.length / 2,
                    a = t.Color.hexToRGBArray(e.fillColor),
                    h = e.fillAlpha,
                    l = a[0] * h,
                    c = a[1] * h,
                    u = a[2] * h,
                    d = t.EarCut.Triangulate(s, null, 2);
                if (!d) return !1;
                var p = n.length / 6,
                    f = 0;
                for (f = 0; f < d.length; f += 3) r.push(d[f] + p), r.push(d[f] + p), r.push(d[f + 1] + p), r.push(d[f + 2] + p), r.push(d[f + 2] + p);
                for (f = 0; f < o; f++) n.push(s[2 * f], s[2 * f + 1], l, c, u, h);
                return !0
            }
        }, PIXI.WebGLGraphics.graphicsDataPool = [], PIXI.WebGLGraphicsData = function(t) {
            this.gl = t, this.color = [0, 0, 0], this.points = [], this.indices = [], this.buffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), this.mode = 1, this.alpha = 1, this.dirty = !0
        }, PIXI.WebGLGraphicsData.prototype.reset = function() {
            this.points = [], this.indices = []
        }, PIXI.WebGLGraphicsData.prototype.upload = function() {
            var t = this.gl;
            this.glPoints = new Float32Array(this.points), t.bindBuffer(t.ARRAY_BUFFER, this.buffer), t.bufferData(t.ARRAY_BUFFER, this.glPoints, t.STATIC_DRAW), this.glIndicies = new Uint16Array(this.indices), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.glIndicies, t.STATIC_DRAW), this.dirty = !1
        }, PIXI.CanvasGraphics = function() {}, PIXI.CanvasGraphics.renderGraphics = function(e, i) {
            var s = e.worldAlpha;
            e.dirty && (this.updateGraphicsTint(e), e.dirty = !1);
            for (var n = 0; n < e.graphicsData.length; n++) {
                var r = e.graphicsData[n],
                    o = r.shape,
                    a = r._fillTint,
                    h = r._lineTint;
                if (i.lineWidth = r.lineWidth, r.type === t.POLYGON) {
                    i.beginPath();
                    var l = o.points;
                    i.moveTo(l[0], l[1]);
                    for (var c = 1; c < l.length / 2; c++) i.lineTo(l[2 * c], l[2 * c + 1]);
                    o.closed && i.lineTo(l[0], l[1]), l[0] === l[l.length - 2] && l[1] === l[l.length - 1] && i.closePath(), r.fill && (i.globalAlpha = r.fillAlpha * s, i.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), i.fill()), r.lineWidth && (i.globalAlpha = r.lineAlpha * s, i.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), i.stroke())
                } else if (r.type === t.RECTANGLE)(r.fillColor || 0 === r.fillColor) && (i.globalAlpha = r.fillAlpha * s, i.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), i.fillRect(o.x, o.y, o.width, o.height)), r.lineWidth && (i.globalAlpha = r.lineAlpha * s, i.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), i.strokeRect(o.x, o.y, o.width, o.height));
                else if (r.type === t.CIRCLE) i.beginPath(), i.arc(o.x, o.y, o.radius, 0, 2 * Math.PI), i.closePath(), r.fill && (i.globalAlpha = r.fillAlpha * s, i.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), i.fill()), r.lineWidth && (i.globalAlpha = r.lineAlpha * s, i.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), i.stroke());
                else if (r.type === t.ELLIPSE) {
                    var u = 2 * o.width,
                        d = 2 * o.height,
                        p = o.x - u / 2,
                        f = o.y - d / 2;
                    i.beginPath();
                    var g = u / 2 * .5522848,
                        m = d / 2 * .5522848,
                        y = p + u,
                        v = f + d,
                        x = p + u / 2,
                        b = f + d / 2;
                    i.moveTo(p, b), i.bezierCurveTo(p, b - m, x - g, f, x, f), i.bezierCurveTo(x + g, f, y, b - m, y, b), i.bezierCurveTo(y, b + m, x + g, v, x, v), i.bezierCurveTo(x - g, v, p, b + m, p, b), i.closePath(), r.fill && (i.globalAlpha = r.fillAlpha * s, i.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), i.fill()), r.lineWidth && (i.globalAlpha = r.lineAlpha * s, i.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), i.stroke())
                } else if (r.type === t.ROUNDEDRECTANGLE) {
                    var _ = o.x,
                        w = o.y,
                        T = o.width,
                        P = o.height,
                        C = o.radius,
                        S = Math.min(T, P) / 2 | 0;
                    C = C > S ? S : C, i.beginPath(), i.moveTo(_, w + C), i.lineTo(_, w + P - C), i.quadraticCurveTo(_, w + P, _ + C, w + P), i.lineTo(_ + T - C, w + P), i.quadraticCurveTo(_ + T, w + P, _ + T, w + P - C), i.lineTo(_ + T, w + C), i.quadraticCurveTo(_ + T, w, _ + T - C, w), i.lineTo(_ + C, w), i.quadraticCurveTo(_, w, _, w + C), i.closePath(), (r.fillColor || 0 === r.fillColor) && (i.globalAlpha = r.fillAlpha * s, i.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), i.fill()), r.lineWidth && (i.globalAlpha = r.lineAlpha * s, i.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), i.stroke())
                }
            }
        }, PIXI.CanvasGraphics.renderGraphicsMask = function(e, i) {
            var s = e.graphicsData.length;
            if (0 !== s) {
                i.beginPath();
                for (var n = 0; n < s; n++) {
                    var r = e.graphicsData[n],
                        o = r.shape;
                    if (r.type === t.POLYGON) {
                        var a = o.points;
                        i.moveTo(a[0], a[1]);
                        for (var h = 1; h < a.length / 2; h++) i.lineTo(a[2 * h], a[2 * h + 1]);
                        a[0] === a[a.length - 2] && a[1] === a[a.length - 1] && i.closePath()
                    } else if (r.type === t.RECTANGLE) i.rect(o.x, o.y, o.width, o.height), i.closePath();
                    else if (r.type === t.CIRCLE) i.arc(o.x, o.y, o.radius, 0, 2 * Math.PI), i.closePath();
                    else if (r.type === t.ELLIPSE) {
                        var l = 2 * o.width,
                            c = 2 * o.height,
                            u = o.x - l / 2,
                            d = o.y - c / 2,
                            p = l / 2 * .5522848,
                            f = c / 2 * .5522848,
                            g = u + l,
                            m = d + c,
                            y = u + l / 2,
                            v = d + c / 2;
                        i.moveTo(u, v), i.bezierCurveTo(u, v - f, y - p, d, y, d), i.bezierCurveTo(y + p, d, g, v - f, g, v), i.bezierCurveTo(g, v + f, y + p, m, y, m), i.bezierCurveTo(y - p, m, u, v + f, u, v), i.closePath()
                    } else if (r.type === t.ROUNDEDRECTANGLE) {
                        var x = o.x,
                            b = o.y,
                            _ = o.width,
                            w = o.height,
                            T = o.radius,
                            P = Math.min(_, w) / 2 | 0;
                        T = T > P ? P : T, i.moveTo(x, b + T), i.lineTo(x, b + w - T), i.quadraticCurveTo(x, b + w, x + T, b + w), i.lineTo(x + _ - T, b + w), i.quadraticCurveTo(x + _, b + w, x + _, b + w - T), i.lineTo(x + _, b + T), i.quadraticCurveTo(x + _, b, x + _ - T, b), i.lineTo(x + T, b), i.quadraticCurveTo(x, b, x, b + T), i.closePath()
                    }
                }
            }
        }, PIXI.CanvasGraphics.updateGraphicsTint = function(t) {
            if (16777215 !== t.tint)
                for (var e = (t.tint >> 16 & 255) / 255, i = (t.tint >> 8 & 255) / 255, s = (255 & t.tint) / 255, n = 0; n < t.graphicsData.length; n++) {
                    var r = t.graphicsData[n],
                        o = 0 | r.fillColor,
                        a = 0 | r.lineColor;
                    r._fillTint = ((o >> 16 & 255) / 255 * e * 255 << 16) + ((o >> 8 & 255) / 255 * i * 255 << 8) + (255 & o) / 255 * s * 255, r._lineTint = ((a >> 16 & 255) / 255 * e * 255 << 16) + ((a >> 8 & 255) / 255 * i * 255 << 8) + (255 & a) / 255 * s * 255
                }
        }, t.GraphicsData = function(t, e, i, s, n, r, o) {
            this.lineWidth = t, this.lineColor = e, this.lineAlpha = i, this._lineTint = e, this.fillColor = s, this.fillAlpha = n, this._fillTint = s, this.fill = r, this.shape = o, this.type = o.type
        }, t.GraphicsData.prototype.constructor = t.GraphicsData, t.GraphicsData.prototype.clone = function() {
            return new t.GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.fill, this.shape)
        }, t.Graphics = function(e, i, s) {
            void 0 === i && (i = 0), void 0 === s && (s = 0), this.type = t.GRAPHICS, this.physicsType = t.SPRITE, this.anchor = new t.Point, PIXI.DisplayObjectContainer.call(this), this.renderable = !0, this.fillAlpha = 1, this.lineWidth = 0, this.lineColor = 0, this.graphicsData = [], this.tint = 16777215, this.blendMode = PIXI.blendModes.NORMAL, this.currentPath = null, this._webGL = [], this.isMask = !1, this.boundsPadding = 0, this._localBounds = new t.Rectangle(0, 0, 1, 1), this.dirty = !0, this._boundsDirty = !1, this.webGLDirty = !1, this.cachedSpriteDirty = !1, t.Component.Core.init.call(this, e, i, s, "", null)
        }, t.Graphics.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), t.Graphics.prototype.constructor = t.Graphics, t.Component.Core.install.call(t.Graphics.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]), t.Graphics.prototype.preUpdatePhysics = t.Component.PhysicsBody.preUpdate, t.Graphics.prototype.preUpdateLifeSpan = t.Component.LifeSpan.preUpdate, t.Graphics.prototype.preUpdateInWorld = t.Component.InWorld.preUpdate, t.Graphics.prototype.preUpdateCore = t.Component.Core.preUpdate, t.Graphics.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, t.Graphics.prototype.postUpdate = function() {
            t.Component.PhysicsBody.postUpdate.call(this), t.Component.FixedToCamera.postUpdate.call(this), this._boundsDirty && (this.updateLocalBounds(), this._boundsDirty = !1);
            for (var e = 0; e < this.children.length; e++) this.children[e].postUpdate()
        }, t.Graphics.prototype.destroy = function(e) {
            this.clear(), t.Component.Destroy.prototype.destroy.call(this, e)
        }, t.Graphics.prototype.drawTriangle = function(e, i) {
            void 0 === i && (i = !1);
            var s = new t.Polygon(e);
            if (i) {
                var n = new t.Point(this.game.camera.x - e[0].x, this.game.camera.y - e[0].y),
                    r = new t.Point(e[1].x - e[0].x, e[1].y - e[0].y),
                    o = new t.Point(e[1].x - e[2].x, e[1].y - e[2].y).cross(r);
                n.dot(o) > 0 && this.drawPolygon(s)
            } else this.drawPolygon(s)
        }, t.Graphics.prototype.drawTriangles = function(e, i, s) {
            void 0 === s && (s = !1);
            var n, r = new t.Point,
                o = new t.Point,
                a = new t.Point,
                h = [];
            if (i)
                if (e[0] instanceof t.Point)
                    for (n = 0; n < i.length / 3; n++) h.push(e[i[3 * n]]), h.push(e[i[3 * n + 1]]), h.push(e[i[3 * n + 2]]), 3 === h.length && (this.drawTriangle(h, s), h = []);
                else
                    for (n = 0; n < i.length; n++) r.x = e[2 * i[n]], r.y = e[2 * i[n] + 1], h.push(r.copyTo({})), 3 === h.length && (this.drawTriangle(h, s), h = []);
            else if (e[0] instanceof t.Point)
                for (n = 0; n < e.length / 3; n++) this.drawTriangle([e[3 * n], e[3 * n + 1], e[3 * n + 2]], s);
            else
                for (n = 0; n < e.length / 6; n++) r.x = e[6 * n + 0], r.y = e[6 * n + 1], o.x = e[6 * n + 2], o.y = e[6 * n + 3], a.x = e[6 * n + 4], a.y = e[6 * n + 5], this.drawTriangle([r, o, a], s)
        }, t.Graphics.prototype.lineStyle = function(e, i, s) {
            return this.lineWidth = e || 0, this.lineColor = i || 0, this.lineAlpha = void 0 === s ? 1 : s, this.currentPath && (this.currentPath.shape.points.length ? this.drawShape(new t.Polygon(this.currentPath.shape.points.slice(-2))) : (this.currentPath.lineWidth = this.lineWidth, this.currentPath.lineColor = this.lineColor, this.currentPath.lineAlpha = this.lineAlpha)), this
        }, t.Graphics.prototype.moveTo = function(e, i) {
            return this.drawShape(new t.Polygon([e, i])), this
        }, t.Graphics.prototype.lineTo = function(t, e) {
            return this.currentPath || this.moveTo(0, 0), this.currentPath.shape.points.push(t, e), this.dirty = !0, this._boundsDirty = !0, this
        }, t.Graphics.prototype.quadraticCurveTo = function(t, e, i, s) {
            this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
            var n, r, o = this.currentPath.shape.points;
            0 === o.length && this.moveTo(0, 0);
            for (var a = o[o.length - 2], h = o[o.length - 1], l = 0, c = 1; c <= 20; ++c) n = a + (t - a) * (l = c / 20), r = h + (e - h) * l, o.push(n + (t + (i - t) * l - n) * l, r + (e + (s - e) * l - r) * l);
            return this.dirty = !0, this._boundsDirty = !0, this
        }, t.Graphics.prototype.bezierCurveTo = function(t, e, i, s, n, r) {
            this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
            for (var o, a, h, l, c, u = this.currentPath.shape.points, d = u[u.length - 2], p = u[u.length - 1], f = 0, g = 1; g <= 20; ++g) h = (a = (o = 1 - (f = g / 20)) * o) * o, c = (l = f * f) * f, u.push(h * d + 3 * a * f * t + 3 * o * l * i + c * n, h * p + 3 * a * f * e + 3 * o * l * s + c * r);
            return this.dirty = !0, this._boundsDirty = !0, this
        }, t.Graphics.prototype.arcTo = function(t, e, i, s, n) {
            this.currentPath ? 0 === this.currentPath.shape.points.length && this.currentPath.shape.points.push(t, e) : this.moveTo(t, e);
            var r = this.currentPath.shape.points,
                o = r[r.length - 2],
                a = r[r.length - 1] - e,
                h = o - t,
                l = s - e,
                c = i - t,
                u = Math.abs(a * c - h * l);
            if (u < 1e-8 || 0 === n) r[r.length - 2] === t && r[r.length - 1] === e || r.push(t, e);
            else {
                var d = a * a + h * h,
                    p = l * l + c * c,
                    f = a * l + h * c,
                    g = n * Math.sqrt(d) / u,
                    m = n * Math.sqrt(p) / u,
                    y = g * f / d,
                    v = m * f / p,
                    x = g * c + m * h,
                    b = g * l + m * a,
                    _ = h * (m + y),
                    w = a * (m + y),
                    T = c * (g + v),
                    P = l * (g + v),
                    C = Math.atan2(w - b, _ - x),
                    S = Math.atan2(P - b, T - x);
                this.arc(x + t, b + e, n, C, S, h * l > c * a)
            }
            return this.dirty = !0, this._boundsDirty = !0, this
        }, t.Graphics.prototype.arc = function(t, e, i, s, n, r, o) {
            if (s === n) return this;
            void 0 === r && (r = !1), void 0 === o && (o = 40), !r && n <= s ? n += 2 * Math.PI : r && s <= n && (s += 2 * Math.PI);
            var a = r ? -1 * (s - n) : n - s,
                h = Math.ceil(Math.abs(a) / (2 * Math.PI)) * o;
            if (0 === a) return this;
            var l = t + Math.cos(s) * i,
                c = e + Math.sin(s) * i;
            r && this.filling ? this.moveTo(t, e) : this.moveTo(l, c);
            for (var u = this.currentPath.shape.points, d = a / (2 * h), p = 2 * d, f = Math.cos(d), g = Math.sin(d), m = h - 1, y = m % 1 / m, v = 0; v <= m; v++) {
                var x = d + s + p * (v + y * v),
                    b = Math.cos(x),
                    _ = -Math.sin(x);
                u.push((f * b + g * _) * i + t, (f * -_ + g * b) * i + e)
            }
            return this.dirty = !0, this._boundsDirty = !0, this
        }, t.Graphics.prototype.beginFill = function(t, e) {
            return this.filling = !0, this.fillColor = t || 0, this.fillAlpha = void 0 === e ? 1 : e, this.currentPath && this.currentPath.shape.points.length <= 2 && (this.currentPath.fill = this.filling, this.currentPath.fillColor = this.fillColor, this.currentPath.fillAlpha = this.fillAlpha), this
        }, t.Graphics.prototype.endFill = function() {
            return this.filling = !1, this.fillColor = null, this.fillAlpha = 1, this
        }, t.Graphics.prototype.drawRect = function(e, i, s, n) {
            return this.drawShape(new t.Rectangle(e, i, s, n)), this
        }, t.Graphics.prototype.drawRoundedRect = function(e, i, s, n, r) {
            return this.drawShape(new t.RoundedRectangle(e, i, s, n, r)), this
        }, t.Graphics.prototype.drawCircle = function(e, i, s) {
            return this.drawShape(new t.Circle(e, i, s)), this
        }, t.Graphics.prototype.drawEllipse = function(e, i, s, n) {
            return this.drawShape({
                x: e,
                y: i,
                width: s,
                height: n,
                type: t.ELLIPSE
            }), this
        }, t.Graphics.prototype.drawPolygon = function(e) {
            e instanceof t.Polygon && (e = e.points);
            var i = e;
            if (!Array.isArray(i)) {
                i = new Array(arguments.length);
                for (var s = 0; s < i.length; ++s) i[s] = arguments[s]
            }
            return this.drawShape(new t.Polygon(i)), this
        }, t.Graphics.prototype.clear = function() {
            return this.lineWidth = 0, this.filling = !1, this.dirty = !0, this._boundsDirty = !0, this.clearDirty = !0, this.graphicsData = [], this.updateLocalBounds(), this
        }, t.Graphics.prototype.generateTexture = function(t, e, i) {
            void 0 === t && (t = 1), void 0 === e && (e = PIXI.scaleModes.DEFAULT), void 0 === i && (i = 0);
            var s = this.getBounds();
            s.width += i, s.height += i;
            var n = new PIXI.CanvasBuffer(s.width * t, s.height * t),
                r = PIXI.Texture.fromCanvas(n.canvas, e);
            return r.baseTexture.resolution = t, n.context.scale(t, t), n.context.translate(-s.x, -s.y), PIXI.CanvasGraphics.renderGraphics(this, n.context), r
        }, t.Graphics.prototype._renderWebGL = function(t) {
            if (!1 !== this.visible && 0 !== this.alpha && !0 !== this.isMask) {
                if (this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), this._cachedSprite.worldAlpha = this.worldAlpha, void PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, t);
                if (t.spriteBatch.stop(), t.blendModeManager.setBlendMode(this.blendMode), this._mask && t.maskManager.pushMask(this._mask, t), this._filters && t.filterManager.pushFilter(this._filterBlock), this.blendMode !== t.spriteBatch.currentBlendMode) {
                    t.spriteBatch.currentBlendMode = this.blendMode;
                    var e = PIXI.blendModesWebGL[t.spriteBatch.currentBlendMode];
                    t.spriteBatch.gl.blendFunc(e[0], e[1])
                }
                if (this.webGLDirty && (this.dirty = !0, this.webGLDirty = !1), PIXI.WebGLGraphics.renderGraphics(this, t), this.children.length) {
                    t.spriteBatch.start();
                    for (var i = 0; i < this.children.length; i++) this.children[i]._renderWebGL(t);
                    t.spriteBatch.stop()
                }
                this._filters && t.filterManager.popFilter(), this._mask && t.maskManager.popMask(this.mask, t), t.drawCount++, t.spriteBatch.start()
            }
        }, t.Graphics.prototype._renderCanvas = function(t) {
            if (!1 !== this.visible && 0 !== this.alpha && !0 !== this.isMask) {
                if (this._prevTint !== this.tint && (this.dirty = !0, this._prevTint = this.tint), this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), this._cachedSprite.alpha = this.alpha, void PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, t);
                var e = t.context,
                    i = this.worldTransform;
                this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, e.globalCompositeOperation = PIXI.blendModesCanvas[t.currentBlendMode]), this._mask && t.maskManager.pushMask(this._mask, t);
                var s = t.resolution,
                    n = i.tx * t.resolution + t.shakeX,
                    r = i.ty * t.resolution + t.shakeY;
                e.setTransform(i.a * s, i.b * s, i.c * s, i.d * s, n, r), PIXI.CanvasGraphics.renderGraphics(this, e);
                for (var o = 0; o < this.children.length; o++) this.children[o]._renderCanvas(t);
                this._mask && t.maskManager.popMask(t)
            }
        }, t.Graphics.prototype.getBounds = function(e) {
            if (this._currentBounds) return this._currentBounds;
            if (this.isMask) return t.EmptyRectangle;
            this.dirty && (this.updateLocalBounds(), this.webGLDirty = !0, this.cachedSpriteDirty = !0, this.dirty = !1);
            var i = this._localBounds,
                s = i.x,
                n = i.width + i.x,
                r = i.y,
                o = i.height + i.y,
                a = e || this.worldTransform,
                h = a.a,
                l = a.b,
                c = a.c,
                u = a.d,
                d = a.tx,
                p = a.ty,
                f = h * n + c * o + d,
                g = u * o + l * n + p,
                m = h * s + c * o + d,
                y = u * o + l * s + p,
                v = h * s + c * r + d,
                x = u * r + l * s + p,
                b = h * n + c * r + d,
                _ = u * r + l * n + p,
                w = f,
                T = g,
                P = f,
                C = g;
            return P = b < (P = v < (P = m < P ? m : P) ? v : P) ? b : P, C = _ < (C = x < (C = y < C ? y : C) ? x : C) ? _ : C, w = b > (w = v > (w = m > w ? m : w) ? v : w) ? b : w, T = _ > (T = x > (T = y > T ? y : T) ? x : T) ? _ : T, this._bounds.x = P, this._bounds.width = w - P, this._bounds.y = C, this._bounds.height = T - C, this._currentBounds = this._bounds, this._currentBounds
        }, t.Graphics.prototype.getLocalBounds = function() {
            var e = this.worldTransform;
            this.worldTransform = t.identityMatrix;
            for (var i = 0; i < this.children.length; i++) this.children[i].updateTransform();
            var s = this.getBounds();
            for (this.worldTransform = e, i = 0; i < this.children.length; i++) this.children[i].updateTransform();
            return s
        }, t.Graphics.prototype.containsPoint = function(e, i) {
            void 0 === i && (i = new t.Point), this.worldTransform.applyInverse(e, i);
            for (var s = this.graphicsData, n = 0; n < s.length; n++) {
                var r = s[n];
                if (r.fill && r.shape && r.shape.contains(i.x, i.y)) return !0
            }
            return !1
        }, t.Graphics.prototype.getVisualBounds = function(t) {
            return this._boundsDirty && (this.updateLocalBounds(), this._boundsDirty = !1), this._localBounds.clone(t)
        }, t.Graphics.prototype.updateLocalBounds = function() {
            var e = 1 / 0,
                i = -1 / 0,
                s = 1 / 0,
                n = -1 / 0;
            if (this.graphicsData.length)
                for (var r, o, a, h, l, c, u = 0; u < this.graphicsData.length; u++) {
                    var d = this.graphicsData[u],
                        p = d.type,
                        f = d.lineWidth;
                    if (r = d.shape, p === t.RECTANGLE || p === t.ROUNDEDRECTANGLE) a = r.x - f / 2, h = r.y - f / 2, e = a < e ? a : e, i = a + (l = r.width + f) > i ? a + l : i, s = h < s ? h : s, n = h + (c = r.height + f) > n ? h + c : n;
                    else if (p === t.CIRCLE) a = r.x, h = r.y, e = a - (l = r.radius + f / 2) < e ? a - l : e, i = a + l > i ? a + l : i, s = h - (c = r.radius + f / 2) < s ? h - c : s, n = h + c > n ? h + c : n;
                    else if (p === t.ELLIPSE) a = r.x, h = r.y, e = a - (l = r.width + f / 2) < e ? a - l : e, i = a + l > i ? a + l : i, s = h - (c = r.height + f / 2) < s ? h - c : s, n = h + c > n ? h + c : n;
                    else {
                        o = r.points;
                        for (var g = 0; g < o.length; g++) o[g] instanceof t.Point ? (a = o[g].x, h = o[g].y) : (a = o[g], h = o[g + 1], g < o.length - 1 && g++), e = a - f < e ? a - f : e, i = a + f > i ? a + f : i, s = h - f < s ? h - f : s, n = h + f > n ? h + f : n
                    }
                } else e = 0, i = 0, s = 0, n = 0;
            var m = this.boundsPadding;
            this._localBounds.x = e - m, this._localBounds.width = i - e + 2 * m, this._localBounds.y = s - m, this._localBounds.height = n - s + 2 * m
        }, t.Graphics.prototype._generateCachedSprite = function() {
            var t = this.getLocalBounds();
            if (this._cachedSprite) this._cachedSprite.buffer.resize(t.width, t.height);
            else {
                var e = new PIXI.CanvasBuffer(t.width, t.height),
                    i = PIXI.Texture.fromCanvas(e.canvas);
                this._cachedSprite = new PIXI.Sprite(i), this._cachedSprite.buffer = e, this._cachedSprite.worldTransform = this.worldTransform
            }
            this._cachedSprite.anchor.x = -t.x / t.width, this._cachedSprite.anchor.y = -t.y / t.height, this._cachedSprite.buffer.context.translate(-t.x, -t.y), this.worldAlpha = 1, PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context), this._cachedSprite.alpha = this.alpha
        }, t.Graphics.prototype.updateCachedSpriteTexture = function() {
            var t = this._cachedSprite,
                e = t.texture,
                i = t.buffer.canvas;
            e.baseTexture.width = i.width, e.baseTexture.height = i.height, e.crop.width = e.frame.width = i.width, e.crop.height = e.frame.height = i.height, t._width = i.width, t._height = i.height, e.baseTexture.dirty()
        }, t.Graphics.prototype.destroyCachedSprite = function() {
            this._cachedSprite.texture.destroy(!0), this._cachedSprite = null
        }, t.Graphics.prototype.drawShape = function(e) {
            this.currentPath && this.currentPath.shape.points.length <= 2 && this.graphicsData.pop(), this.currentPath = null, e instanceof t.Polygon && (e = e.clone()).flatten();
            var i = new t.GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, e);
            return this.graphicsData.push(i), i.type === t.POLYGON && (i.shape.closed = this.filling, this.currentPath = i), this.dirty = !0, this._boundsDirty = !0, i
        }, Object.defineProperty(t.Graphics.prototype, "cacheAsBitmap", {
            get: function() {
                return this._cacheAsBitmap
            },
            set: function(t) {
                this._cacheAsBitmap = t, this._cacheAsBitmap ? this._generateCachedSprite() : this.destroyCachedSprite(), this.dirty = !0, this.webGLDirty = !0
            }
        }), t.RenderTexture = function(e, i, s, n, r, o, a, h) {
            if (void 0 === i && (i = 100), void 0 === s && (s = 100), void 0 === n && (n = ""), void 0 === r && (r = t.scaleModes.DEFAULT), void 0 === o && (o = 1), void 0 === a && (a = PIXI.defaultRenderer), void 0 === h && (h = 0), this.game = e, this.key = n, this.type = t.RENDERTEXTURE, this._tempMatrix = new t.Matrix, this.width = i, this.height = s, this.resolution = o, this.frame = new t.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), this.crop = this.frame.clone(), this.baseTexture = new PIXI.BaseTexture, this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution, this.baseTexture._glTextures = [], this.baseTexture.resolution = this.resolution, this.baseTexture.scaleMode = r, this.baseTexture.hasLoaded = !0, PIXI.Texture.call(this, this.baseTexture, this.frame.clone()), this.renderer = a, this.renderer.type === t.WEBGL) {
                var l = this.renderer.gl;
                this.baseTexture.textureIndex = h, this.baseTexture._dirty[l.id] = !1, this.textureBuffer = new PIXI.FilterTexture(l, this.width, this.height, this.baseTexture.scaleMode, h), this.baseTexture._glTextures[l.id] = this.textureBuffer.texture, this.projection = new t.Point(.5 * this.width, .5 * -this.height)
            } else this.textureBuffer = new PIXI.CanvasBuffer(this.width * this.resolution, this.height * this.resolution), this.baseTexture.source = this.textureBuffer.canvas;
            this.valid = !0, this.tempMatrix = new t.Matrix, this._updateUvs()
        }, t.RenderTexture.prototype = Object.create(PIXI.Texture.prototype), t.RenderTexture.prototype.constructor = t.RenderTexture, t.RenderTexture.prototype.renderXY = function(e, i, s, n) {
            e.updateTransform(), this._tempMatrix.copyFrom(e.worldTransform), this._tempMatrix.tx = i, this._tempMatrix.ty = s, this.renderer.type === t.WEBGL ? this._renderWebGL(e, this._tempMatrix, n) : this._renderCanvas(e, this._tempMatrix, n)
        }, t.RenderTexture.prototype.renderRawXY = function(e, i, s, n) {
            this._tempMatrix.identity().translate(i, s), this.renderer.type === t.WEBGL ? this._renderWebGL(e, this._tempMatrix, n) : this._renderCanvas(e, this._tempMatrix, n)
        }, t.RenderTexture.prototype.render = function(e, i, s) {
            null == i ? this._tempMatrix.copyFrom(e.worldTransform) : this._tempMatrix.copyFrom(i), this.renderer.type === t.WEBGL ? this._renderWebGL(e, this._tempMatrix, s) : this._renderCanvas(e, this._tempMatrix, s)
        }, t.RenderTexture.prototype.resize = function(e, i, s) {
            e === this.width && i === this.height || (this.valid = e > 0 && i > 0, this.width = e, this.height = i, this.frame.width = this.crop.width = e * this.resolution, this.frame.height = this.crop.height = i * this.resolution, s && (this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution), this.renderer.type === t.WEBGL && (this.projection.x = this.width / 2, this.projection.y = -this.height / 2), this.valid && this.textureBuffer.resize(this.width, this.height))
        }, t.RenderTexture.prototype.clear = function() {
            this.valid && (this.renderer.type === t.WEBGL && this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer), this.textureBuffer.clear())
        }, t.RenderTexture.prototype._renderWebGL = function(t, e, i) {
            if (this.valid && 0 !== t.alpha) {
                var s = t.worldTransform;
                s.identity(), s.translate(0, 2 * this.projection.y), e && s.append(e), s.scale(1, -1);
                for (var n = 0; n < t.children.length; n++) t.children[n].updateTransform();
                var r = this.renderer.gl;
                r.viewport(0, 0, this.width * this.resolution, this.height * this.resolution), r.bindFramebuffer(r.FRAMEBUFFER, this.textureBuffer.frameBuffer), i && this.textureBuffer.clear(), this.renderer.spriteBatch.dirty = !0, this.renderer.renderDisplayObject(t, this.projection, this.textureBuffer.frameBuffer, e), this.renderer.spriteBatch.dirty = !0, r.bindFramebuffer(r.FRAMEBUFFER, null)
            }
        }, t.RenderTexture.prototype._renderCanvas = function(t, e, i) {
            if (this.valid && 0 !== t.alpha) {
                var s = t.worldTransform;
                s.identity(), e && s.append(e);
                for (var n = 0; n < t.children.length; n++) t.children[n].updateTransform();
                i && this.textureBuffer.clear();
                var r = this.renderer.resolution;
                this.renderer.resolution = this.resolution, this.renderer.renderDisplayObject(t, this.textureBuffer.context, e), this.renderer.resolution = r
            }
        }, t.RenderTexture.prototype.getImage = function() {
            var t = new Image;
            return t.src = this.getBase64(), t
        }, t.RenderTexture.prototype.getBase64 = function() {
            return this.getCanvas().toDataURL()
        }, t.RenderTexture.prototype.getCanvas = function() {
            if (this.renderer.type === t.WEBGL) {
                var e = this.renderer.gl,
                    i = this.textureBuffer.width,
                    s = this.textureBuffer.height,
                    n = new Uint8Array(4 * i * s);
                e.bindFramebuffer(e.FRAMEBUFFER, this.textureBuffer.frameBuffer), e.readPixels(0, 0, i, s, e.RGBA, e.UNSIGNED_BYTE, n), e.bindFramebuffer(e.FRAMEBUFFER, null);
                var r = new PIXI.CanvasBuffer(i, s),
                    o = r.context.getImageData(0, 0, i, s);
                return o.data.set(n), r.context.putImageData(o, 0, 0), r.canvas
            }
            return this.textureBuffer.canvas
        }, t.Text = function(e, i, s, n, r) {
            i = i || 0, s = s || 0, n = null == n ? "" : n.toString(), this.canvas = t.CanvasPool.create(this), t.Sprite.call(this, e, i, s, PIXI.Texture.fromCanvas(this.canvas)), this.type = t.TEXT, this.physicsType = t.SPRITE, this.padding = new t.Point, this.textBounds = null, this.context = this.canvas.getContext("2d"), this.colors = [], this.strokeColors = [], this.fontStyles = [], this.fontWeights = [], this.autoRound = !1, this.useAdvancedWrap = !1, this.splitRegExp = /(?:\r\n|\r|\n)/, this.characterLimitSize = -1, this.characterLimitSuffix = "", this._testString = "|Mq", this._res = e.renderer.resolution, this._text = n, this._fontComponents = null, this._lineSpacing = 0, this._charCount = 0, this._width = 0, this._height = 0, this.style = {}, this.setStyle(r || {}), "" !== n && this.updateText()
        }, t.Text.prototype = Object.create(t.Sprite.prototype), t.Text.prototype.constructor = t.Text, t.Text.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, t.Text.prototype.update = function() {}, t.Text.prototype.destroy = function(e) {
            this.texture.destroy(!0), t.Component.Destroy.prototype.destroy.call(this, e)
        }, t.Text.prototype.setShadow = function(t, e, i, s, n, r) {
            return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = "rgba(0, 0, 0, 1)"), void 0 === s && (s = 0), void 0 === n && (n = !0), void 0 === r && (r = !0), this.style.shadowOffsetX = t, this.style.shadowOffsetY = e, this.style.shadowColor = i, this.style.shadowBlur = s, this.style.shadowStroke = n, this.style.shadowFill = r, this.dirty = !0, this
        }, t.Text.prototype.setStyle = function(t, e) {
            void 0 === e && (e = !1);
            var i = Object.assign({}, t);
            i.font = t.font || "bold 20pt Arial", i.backgroundColor = t.backgroundColor || null, i.fill = t.fill || "black", i.align = (t.align || "left").toLowerCase(), i.boundsAlignH = (t.boundsAlignH || "left").toLowerCase(), i.boundsAlignV = (t.boundsAlignV || "top").toLowerCase(), i.stroke = t.stroke || "black", i.strokeThickness = Number(t.strokeThickness) || 0, i.wordWrap = t.wordWrap || !1, i.wordWrapWidth = t.wordWrapWidth || 100, i.maxLines = t.maxLines || 0, i.shadowOffsetX = t.shadowOffsetX || 0, i.shadowOffsetY = t.shadowOffsetY || 0, i.shadowColor = t.shadowColor || "rgba(0,0,0,0)", i.shadowBlur = t.shadowBlur || 0, i.tabs = t.tabs || 0;
            var s = this.fontToComponents(i.font);
            return i.fontStyle && (s.fontStyle = i.fontStyle), i.fontVariant && (s.fontVariant = i.fontVariant), i.fontWeight && (s.fontWeight = i.fontWeight), i.fontSize && ("number" == typeof i.fontSize && (i.fontSize = i.fontSize + "px"), s.fontSize = i.fontSize), this._fontComponents = s, i.font = this.componentsToFont(this._fontComponents), this.style = i, this.dirty = !0, e && this.updateText(), this
        }, t.Text.prototype.updateText = function() {
            this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font;
            var t = this.text;
            this.characterLimitSize > -1 && this.characterLimitSize < t.length && (t = this.text.substring(0, this.characterLimitSize) + this.characterLimitSuffix), this.style.wordWrap && (t = this.runWordWrap(this.text));
            var e = t.split(this.splitRegExp),
                i = this.style.tabs,
                s = [],
                n = 0,
                r = this.determineFontProperties(this.style.font),
                o = e.length;
            this.style.maxLines > 0 && this.style.maxLines < e.length && (o = this.style.maxLines), this._charCount = 0;
            for (var a = 0; a < o; a++) {
                if (0 === i) l = this.style.strokeThickness + this.padding.x, this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? l += this.measureLine(e[a]) : l += this.context.measureText(e[a]).width, this.style.wordWrap && (l -= this.context.measureText(" ").width);
                else {
                    var h = e[a].split(/(?:\t)/),
                        l = this.padding.x + this.style.strokeThickness;
                    if (Array.isArray(i))
                        for (var c = 0, u = 0; u < h.length; u++) {
                            var d;
                            d = this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.measureLine(h[u]) : Math.ceil(this.context.measureText(h[u]).width), u > 0 && (c += i[u - 1]), l = c + d
                        } else
                            for (u = 0; u < h.length; u++) this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? l += this.measureLine(h[u]) : l += Math.ceil(this.context.measureText(h[u]).width), l += this.game.math.snapToCeil(l, i) - l
                }
                s[a] = Math.ceil(l), n = Math.max(n, s[a])
            }
            this.canvas.width = n * this._res;
            var p, f, g = r.fontSize + this.style.strokeThickness + this.padding.y,
                m = g * o,
                y = this._lineSpacing;
            for (y < 0 && Math.abs(y) > g && (y = -g), 0 !== y && (m += y > 0 ? y * e.length : y * (e.length - 1)), this.canvas.height = m * this._res, this.context.scale(this._res, this._res), navigator.isCocoonJS && this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), this.style.backgroundColor && (this.context.fillStyle = this.style.backgroundColor, this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)), this.context.fillStyle = this.style.fill, this.context.font = this.style.font, this.context.strokeStyle = this.style.stroke, this.context.textBaseline = "alphabetic", this.context.lineWidth = this.style.strokeThickness, this.context.lineCap = "round", this.context.lineJoin = "round", this._charCount = 0, a = 0; a < o; a++) p = this.style.strokeThickness / 2, f = this.style.strokeThickness / 2 + a * g + r.ascent, a > 0 && (f += y * a), "right" === this.style.align ? p += n - s[a] : "center" === this.style.align && (p += (n - s[a]) / 2), this.autoRound && (p = Math.round(p), f = Math.round(f)), this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.updateLine(e[a], p, f) : (this.style.stroke && this.style.strokeThickness && (this.updateShadow(this.style.shadowStroke), 0 === i ? this.context.strokeText(e[a], p, f) : this.renderTabLine(e[a], p, f, !1)), this.style.fill && (this.updateShadow(this.style.shadowFill), 0 === i ? this.context.fillText(e[a], p, f) : this.renderTabLine(e[a], p, f, !0)));
            this.updateTexture(), this.dirty = !1
        }, t.Text.prototype.renderTabLine = function(t, e, i, s) {
            var n = t.split(/(?:\t)/),
                r = this.style.tabs,
                o = 0;
            if (Array.isArray(r))
                for (var a = 0, h = 0; h < n.length; h++) h > 0 && (a += r[h - 1]), o = e + a, s ? this.context.fillText(n[h], o, i) : this.context.strokeText(n[h], o, i);
            else
                for (h = 0; h < n.length; h++) {
                    var l = Math.ceil(this.context.measureText(n[h]).width);
                    o = this.game.math.snapToCeil(e, r), s ? this.context.fillText(n[h], o, i) : this.context.strokeText(n[h], o, i), e = o + l
                }
        }, t.Text.prototype.updateShadow = function(t) {
            t ? (this.context.shadowOffsetX = this.style.shadowOffsetX, this.context.shadowOffsetY = this.style.shadowOffsetY, this.context.shadowColor = this.style.shadowColor, this.context.shadowBlur = this.style.shadowBlur) : (this.context.shadowOffsetX = 0, this.context.shadowOffsetY = 0, this.context.shadowColor = 0, this.context.shadowBlur = 0)
        }, t.Text.prototype.measureLine = function(t) {
            for (var e = 0, i = 0; i < t.length; i++) {
                var s = t[i];
                if (this.fontWeights.length > 0 || this.fontStyles.length > 0) {
                    var n = this.fontToComponents(this.context.font);
                    this.fontStyles[this._charCount] && (n.fontStyle = this.fontStyles[this._charCount]), this.fontWeights[this._charCount] && (n.fontWeight = this.fontWeights[this._charCount]), this.context.font = this.componentsToFont(n)
                }
                this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke)), this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill)), e += this.context.measureText(s).width, this._charCount++
            }
            return Math.ceil(e)
        }, t.Text.prototype.updateLine = function(t, e, i) {
            for (var s = 0; s < t.length; s++) {
                var n = t[s];
                if (this.fontWeights.length > 0 || this.fontStyles.length > 0) {
                    var r = this.fontToComponents(this.context.font);
                    this.fontStyles[this._charCount] && (r.fontStyle = this.fontStyles[this._charCount]), this.fontWeights[this._charCount] && (r.fontWeight = this.fontWeights[this._charCount]), this.context.font = this.componentsToFont(r)
                }
                this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke), this.context.strokeText(n, e, i)), this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill), this.context.fillText(n, e, i)), e += this.context.measureText(n).width, this._charCount++
            }
        }, t.Text.prototype.clearColors = function() {
            return this.colors = [], this.strokeColors = [], this.dirty = !0, this
        }, t.Text.prototype.clearFontValues = function() {
            return this.fontStyles = [], this.fontWeights = [], this.dirty = !0, this
        }, t.Text.prototype.addColor = function(t, e) {
            return this.colors[e] = t, this.dirty = !0, this
        }, t.Text.prototype.addStrokeColor = function(t, e) {
            return this.strokeColors[e] = t, this.dirty = !0, this
        }, t.Text.prototype.addFontStyle = function(t, e) {
            return this.fontStyles[e] = t, this.dirty = !0, this
        }, t.Text.prototype.addFontWeight = function(t, e) {
            return this.fontWeights[e] = t, this.dirty = !0, this
        }, t.Text.prototype.precalculateWordWrap = function(t) {
            return this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font, this.runWordWrap(t).split(/(?:\r\n|\r|\n)/)
        }, t.Text.prototype.runWordWrap = function(t) {
            return this.useAdvancedWrap ? this.advancedWordWrap(t) : this.basicWordWrap(t)
        }, t.Text.prototype.advancedWordWrap = function(t) {
            for (var e = this.context, i = this.style.wordWrapWidth, s = "", n = t.replace(/ +/gi, " ").split(/\r?\n/gi), r = n.length, o = 0; o < r; o++) {
                var a = n[o],
                    h = "";
                if (a = a.replace(/^ *|\s*$/gi, ""), e.measureText(a).width < i) s += a + "\n";
                else {
                    for (var l = i, c = a.split(" "), u = 0; u < c.length; u++) {
                        var d = c[u],
                            p = d + " ",
                            f = e.measureText(p).width;
                        if (f > l) {
                            if (0 === u) {
                                for (var g = p; g.length && (g = g.slice(0, -1), !((f = e.measureText(g).width) <= l)););
                                if (!g.length) throw new Error("This text's wordWrapWidth setting is less than a single character!");
                                var m = d.substr(g.length);
                                c[u] = m, h += g
                            }
                            var y = c[u].length ? u : u + 1,
                                v = c.slice(y).join(" ").replace(/[ \n]*$/gi, "");
                            n[o + 1] = v + " " + (n[o + 1] || ""), r = n.length;
                            break
                        }
                        h += p, l -= f
                    }
                    s += h.replace(/[ \n]*$/gi, "") + "\n"
                }
            }
            return s.replace(/[\s|\n]*$/gi, "")
        }, t.Text.prototype.basicWordWrap = function(t) {
            for (var e = "", i = t.split("\n"), s = 0; s < i.length; s++) {
                for (var n = this.style.wordWrapWidth, r = i[s].split(" "), o = 0; o < r.length; o++) {
                    var a = this.context.measureText(r[o]).width,
                        h = a + this.context.measureText(" ").width;
                    h > n ? (o > 0 && (e += "\n"), e += r[o] + " ", n = this.style.wordWrapWidth - a) : (n -= h, e += r[o] + " ")
                }
                s < i.length - 1 && (e += "\n")
            }
            return e
        }, t.Text.prototype.updateFont = function(t) {
            var e = this.componentsToFont(t);
            this.style.font !== e && (this.style.font = e, this.dirty = !0, this.parent && this.updateTransform())
        }, t.Text.prototype.fontToComponents = function(t) {
            var e = t.match(/^\s*(?:\b(normal|italic|oblique|inherit)?\b)\s*(?:\b(normal|small-caps|inherit)?\b)\s*(?:\b(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit)?\b)\s*(?:\b(xx-small|x-small|small|medium|large|x-large|xx-large|larger|smaller|0|\d*(?:[.]\d*)?(?:%|[a-z]{2,5}))?\b)\s*(.*)\s*$/);
            if (e) {
                var i = e[5].trim();
                return /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(i) || /['",]/.exec(i) || (i = "'" + i + "'"), {
                    font: t,
                    fontStyle: e[1] || "normal",
                    fontVariant: e[2] || "normal",
                    fontWeight: e[3] || "normal",
                    fontSize: e[4] || "medium",
                    fontFamily: i
                }
            }
            return console.warn("Phaser.Text - unparsable CSS font: " + t), {
                font: t
            }
        }, t.Text.prototype.componentsToFont = function(t) {
            var e, i = [];
            return (e = t.fontStyle) && "normal" !== e && i.push(e), (e = t.fontVariant) && "normal" !== e && i.push(e), (e = t.fontWeight) && "normal" !== e && i.push(e), (e = t.fontSize) && "medium" !== e && i.push(e), (e = t.fontFamily) && i.push(e), i.length || i.push(t.font), i.join(" ")
        }, t.Text.prototype.setText = function(t, e) {
            return void 0 === e && (e = !1), (t = t.toString() || "") === this._text ? this : (this.text = t, e ? this.updateText() : this.dirty = !0, this)
        }, t.Text.prototype.parseList = function(t) {
            if (!Array.isArray(t)) return this;
            for (var e = "", i = 0; i < t.length; i++) Array.isArray(t[i]) ? (e += t[i].join("\t"), i < t.length - 1 && (e += "\n")) : (e += t[i], i < t.length - 1 && (e += "\t"));
            return this.text = e, this.dirty = !0, this
        }, t.Text.prototype.setTextBounds = function(e, i, s, n) {
            return void 0 === e ? this.textBounds = null : (this.textBounds ? this.textBounds.setTo(e, i, s, n) : this.textBounds = new t.Rectangle(e, i, s, n), this.style.wordWrapWidth > s && (this.style.wordWrapWidth = s)), this.updateTexture(), this
        }, t.Text.prototype.updateTexture = function() {
            var t = this.texture.baseTexture,
                e = this.texture.crop,
                i = this.texture.frame,
                s = this.canvas.width,
                n = this.canvas.height;
            if (t.width = s, t.height = n, e.width = s, e.height = n, i.width = s, i.height = n, this.texture.width = s, this.texture.height = n, this._width = s, this._height = n, this.textBounds) {
                var r = this.textBounds.x,
                    o = this.textBounds.y;
                "right" === this.style.boundsAlignH ? r += this.textBounds.width - this.canvas.width / this.resolution : "center" === this.style.boundsAlignH && (r += this.textBounds.halfWidth - this.canvas.width / this.resolution / 2), "bottom" === this.style.boundsAlignV ? o += this.textBounds.height - this.canvas.height / this.resolution : "middle" === this.style.boundsAlignV && (o += this.textBounds.halfHeight - this.canvas.height / this.resolution / 2), this.pivot.x = -r, this.pivot.y = -o
            }
            this.renderable = 0 !== s && 0 !== n, this.texture.requiresReTint = !0, this.texture.baseTexture.dirty()
        }, t.Text.prototype._renderWebGL = function(t) {
            this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype._renderWebGL.call(this, t)
        }, t.Text.prototype._renderCanvas = function(t) {
            this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype._renderCanvas.call(this, t)
        }, t.Text.prototype.determineFontProperties = function(e) {
            var i = t.Text.fontPropertiesCache[e],
                s = this.testString || "|Mq";
            if (!i) {
                i = {};
                var n = t.Text.fontPropertiesCanvas,
                    r = t.Text.fontPropertiesContext;
                r.font = e;
                var o = Math.ceil(r.measureText(s).width),
                    a = Math.ceil(r.measureText(s).width),
                    h = 2 * a;
                if (a = 1.4 * a | 0, n.width = o, n.height = h, r.fillStyle = "#f00", r.fillRect(0, 0, o, h), r.font = e, r.textBaseline = "alphabetic", r.fillStyle = "#000", r.fillText(s, 0, a), !r.getImageData(0, 0, o, h)) return i.ascent = a, i.descent = a + 6, i.fontSize = i.ascent + i.descent, t.Text.fontPropertiesCache[e] = i, i;
                var l, c, u = r.getImageData(0, 0, o, h).data,
                    d = u.length,
                    p = 4 * o,
                    f = 0,
                    g = !1;
                for (l = 0; l < a; l++) {
                    for (c = 0; c < p; c += 4)
                        if (255 !== u[f + c]) {
                            g = !0;
                            break
                        }
                    if (g) break;
                    f += p
                }
                for (i.ascent = a - l, f = d - p, g = !1, l = h; l > a; l--) {
                    for (c = 0; c < p; c += 4)
                        if (255 !== u[f + c]) {
                            g = !0;
                            break
                        }
                    if (g) break;
                    f -= p
                }
                i.descent = l - a, i.descent += 6, i.fontSize = i.ascent + i.descent, t.Text.fontPropertiesCache[e] = i
            }
            return i
        }, t.Text.prototype.getBounds = function(t) {
            return this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype.getBounds.call(this, t)
        }, t.Text.prototype.setCharacterLimit = function(t, e) {
            this.characterLimitSuffix = void 0 === e ? "" : e, this.characterLimitSize = t, this.updateText()
        }, Object.defineProperty(t.Text.prototype, "text", {
            get: function() {
                return this._text
            },
            set: function(t) {
                t !== this._text && (this._text = t.toString() || "", this.dirty = !0, this.parent && this.updateTransform())
            }
        }), Object.defineProperty(t.Text.prototype, "cssFont", {
            get: function() {
                return this.componentsToFont(this._fontComponents)
            },
            set: function(t) {
                t = t || "bold 20pt Arial", this._fontComponents = this.fontToComponents(t), this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(t.Text.prototype, "font", {
            get: function() {
                return this._fontComponents.fontFamily
            },
            set: function(t) {
                t = (t = t || "Arial").trim(), /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(t) || /['",]/.exec(t) || (t = "'" + t + "'"), this._fontComponents.fontFamily = t, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(t.Text.prototype, "fontSize", {
            get: function() {
                var t = this._fontComponents.fontSize;
                return t && /(?:^0$|px$)/.exec(t) ? parseInt(t, 10) : t
            },
            set: function(t) {
                "number" == typeof(t = t || "0") && (t += "px"), this._fontComponents.fontSize = t, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(t.Text.prototype, "fontWeight", {
            get: function() {
                return this._fontComponents.fontWeight || "normal"
            },
            set: function(t) {
                t = t || "normal", this._fontComponents.fontWeight = t, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(t.Text.prototype, "fontStyle", {
            get: function() {
                return this._fontComponents.fontStyle || "normal"
            },
            set: function(t) {
                t = t || "normal", this._fontComponents.fontStyle = t, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(t.Text.prototype, "fontVariant", {
            get: function() {
                return this._fontComponents.fontVariant || "normal"
            },
            set: function(t) {
                t = t || "normal", this._fontComponents.fontVariant = t, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(t.Text.prototype, "fill", {
            get: function() {
                return this.style.fill
            },
            set: function(t) {
                t !== this.style.fill && (this.style.fill = t, this.dirty = !0)
            }
        }), Object.defineProperty(t.Text.prototype, "align", {
            get: function() {
                return this.style.align
            },
            set: function(t) {
                (t = t.toLowerCase()) !== this.style.align && (this.style.align = t, this.dirty = !0)
            }
        }), Object.defineProperty(t.Text.prototype, "resolution", {
            get: function() {
                return this._res
            },
            set: function(t) {
                t !== this._res && (this._res = t, this.dirty = !0)
            }
        }), Object.defineProperty(t.Text.prototype, "tabs", {
            get: function() {
                return this.style.tabs
            },
            set: function(t) {
                t !== this.style.tabs && (this.style.tabs = t, this.dirty = !0)
            }
        }), Object.defineProperty(t.Text.prototype, "boundsAlignH", {
            get: function() {
                return this.style.boundsAlignH
            },
            set: function(t) {
                (t = t.toLowerCase()) !== this.style.boundsAlignH && (this.style.boundsAlignH = t, this.dirty = !0)
            }
        }), Object.defineProperty(t.Text.prototype, "boundsAlignV", {
            get: function() {
                return this.style.boundsAlignV
            },
            set: function(t) {
                (t = t.toLowerCase()) !== this.style.boundsAlignV && (this.style.boundsAlignV = t, this.dirty = !0)
            }
        }), Object.defineProperty(t.Text.prototype, "stroke", {
            get: function() {
                return this.style.stroke
            },
            set: function(t) {
                t !== this.style.stroke && (this.style.stroke = t, this.dirty = !0)
            }
        }), Object.defineProperty(t.Text.prototype, "strokeThickness", {
            get: function() {
                return this.style.strokeThickness
            },
            set: function(t) {
                t !== this.style.strokeThickness && (this.style.strokeThickness = Number(t), this.dirty = !0)
            }
        }), Object.defineProperty(t.Text.prototype, "wordWrap", {
            get: function() {
                return this.style.wordWrap
            },
            set: function(t) {
                t !== this.style.wordWrap && (this.style.wordWrap = t, this.dirty = !0)
            }
        }), Object.defineProperty(t.Text.prototype, "wordWrapWidth", {
            get: function() {
                return this.style.wordWrapWidth
            },
            set: function(t) {
                t !== this.style.wordWrapWidth && (this.style.wordWrapWidth = t, this.dirty = !0)
            }
        }), Object.defineProperty(t.Text.prototype, "lineSpacing", {
            get: function() {
                return this._lineSpacing
            },
            set: function(t) {
                t !== this._lineSpacing && (this._lineSpacing = parseFloat(t), this.dirty = !0, this.parent && this.updateTransform())
            }
        }), Object.defineProperty(t.Text.prototype, "shadowOffsetX", {
            get: function() {
                return this.style.shadowOffsetX
            },
            set: function(t) {
                t !== this.style.shadowOffsetX && (this.style.shadowOffsetX = t, this.dirty = !0)
            }
        }), Object.defineProperty(t.Text.prototype, "shadowOffsetY", {
            get: function() {
                return this.style.shadowOffsetY
            },
            set: function(t) {
                t !== this.style.shadowOffsetY && (this.style.shadowOffsetY = t, this.dirty = !0)
            }
        }), Object.defineProperty(t.Text.prototype, "shadowColor", {
            get: function() {
                return this.style.shadowColor
            },
            set: function(t) {
                t !== this.style.shadowColor && (this.style.shadowColor = t, this.dirty = !0)
            }
        }), Object.defineProperty(t.Text.prototype, "shadowBlur", {
            get: function() {
                return this.style.shadowBlur
            },
            set: function(t) {
                t !== this.style.shadowBlur && (this.style.shadowBlur = t, this.dirty = !0)
            }
        }), Object.defineProperty(t.Text.prototype, "shadowStroke", {
            get: function() {
                return this.style.shadowStroke
            },
            set: function(t) {
                t !== this.style.shadowStroke && (this.style.shadowStroke = t, this.dirty = !0)
            }
        }), Object.defineProperty(t.Text.prototype, "shadowFill", {
            get: function() {
                return this.style.shadowFill
            },
            set: function(t) {
                t !== this.style.shadowFill && (this.style.shadowFill = t, this.dirty = !0)
            }
        }), Object.defineProperty(t.Text.prototype, "width", {
            get: function() {
                return this.dirty && (this.updateText(), this.dirty = !1), this.scale.x * (this.texture.frame.width / this.resolution)
            },
            set: function(t) {
                this.scale.x = t / this.texture.frame.width, this._width = t
            }
        }), Object.defineProperty(t.Text.prototype, "height", {
            get: function() {
                return this.dirty && (this.updateText(), this.dirty = !1), this.scale.y * (this.texture.frame.height / this.resolution)
            },
            set: function(t) {
                this.scale.y = t / this.texture.frame.height, this._height = t
            }
        }), Object.defineProperty(t.Text.prototype, "testString", {
            get: function() {
                return this._testString
            },
            set: function(t) {
                this._testString = t, this.updateText()
            }
        }), t.Text.fontPropertiesCache = {}, t.Text.fontPropertiesCanvas = document.createElement("canvas"), t.Text.fontPropertiesContext = t.Text.fontPropertiesCanvas.getContext("2d"), t.BitmapText = function(e, i, s, n, r, o, a) {
            i = i || 0, s = s || 0, n = n || "", r = r || "", o = o || 32, a = a || "left", PIXI.DisplayObjectContainer.call(this), this.type = t.BITMAPTEXT, this.physicsType = t.SPRITE, this.textWidth = 0, this.textHeight = 0, this.anchor = new t.Point, this._prevAnchor = new t.Point, this._glyphs = [], this._maxWidth = 0, this._text = r.toString() || "", this._data = e.cache.getBitmapFont(n), this._font = n, this._fontSize = o, this._align = a, this._letterSpacing = 0, this._tint = 16777215, this.updateText(), this.dirty = !1, t.Component.Core.init.call(this, e, i, s, "", null)
        }, t.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), t.BitmapText.prototype.constructor = t.BitmapText, t.Component.Core.install.call(t.BitmapText.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]), t.BitmapText.prototype.preUpdatePhysics = t.Component.PhysicsBody.preUpdate, t.BitmapText.prototype.preUpdateLifeSpan = t.Component.LifeSpan.preUpdate, t.BitmapText.prototype.preUpdateInWorld = t.Component.InWorld.preUpdate, t.BitmapText.prototype.preUpdateCore = t.Component.Core.preUpdate, t.BitmapText.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, t.BitmapText.prototype.postUpdate = function() {
            t.Component.PhysicsBody.postUpdate.call(this), t.Component.FixedToCamera.postUpdate.call(this), this.body && this.body.type === t.Physics.ARCADE && (this.textWidth === this.body.sourceWidth && this.textHeight === this.body.sourceHeight || this.body.setSize(this.textWidth, this.textHeight))
        }, t.BitmapText.prototype.setText = function(t) {
            this.text = t
        }, t.BitmapText.prototype.scanLine = function(t, e, i) {
            for (var s = 0, n = 0, r = -1, o = 0, a = null, h = this._maxWidth > 0 ? this._maxWidth : null, l = [], c = 0; c < i.length; c++) {
                var u = c === i.length - 1;
                if (/(?:\r\n|\r|\n)/.test(i.charAt(c))) return {
                    width: n,
                    text: i.substr(0, c),
                    end: u,
                    chars: l
                };
                var d, p = i.charCodeAt(c),
                    f = t.chars[p];
                void 0 === f && (p = 32, f = t.chars[p]);
                var g = a && f.kerning[a] ? f.kerning[a] : 0;
                if (/(\s)/.test(i.charAt(c)) && (r = c, o = n), d = (g + f.texture.width + f.xOffset) * e, h && n + d >= h && r > -1) return {
                    width: o || n,
                    text: i.substr(0, c - (c - r)),
                    end: !1,
                    chars: l
                };
                n += (f.xAdvance + g + this.letterSpacing) * e, l.push(s + (f.xOffset + g + this.letterSpacing) * e), s += (f.xAdvance + g + this.letterSpacing) * e, a = p
            }
            return {
                width: n,
                text: i,
                end: u,
                chars: l
            }
        }, t.BitmapText.prototype.cleanText = function(t, e) {
            void 0 === e && (e = "");
            var i = this._data.font;
            if (!i) return "";
            for (var s = t.replace(/\r\n|\n\r|\n|\r/g, "\n").split("\n"), n = 0; n < s.length; n++) {
                for (var r = "", o = s[n], a = 0; a < o.length; a++) r = i.chars[o.charCodeAt(a)] ? r.concat(o[a]) : r.concat(e);
                s[n] = r
            }
            return s.join("\n")
        }, t.BitmapText.prototype.updateText = function() {
            var t = this._data.font;
            if (t) {
                var e = this.text,
                    i = this._fontSize / t.size,
                    s = [],
                    n = 0;
                this.textWidth = 0;
                do {
                    (c = this.scanLine(t, i, e)).y = n, s.push(c), c.width > this.textWidth && (this.textWidth = c.width), n += t.lineHeight * i, e = e.substr(c.text.length + 1)
                } while (!1 === c.end);
                this.textHeight = n;
                for (var r = 0, o = 0, a = this.textWidth * this.anchor.x, h = this.textHeight * this.anchor.y, l = 0; l < s.length; l++) {
                    var c = s[l];
                    "right" === this._align ? o = this.textWidth - c.width : "center" === this._align && (o = (this.textWidth - c.width) / 2);
                    for (var u = 0; u < c.text.length; u++) {
                        var d = c.text.charCodeAt(u),
                            p = t.chars[d];
                        void 0 === p && (d = 32, p = t.chars[d]);
                        var f = this._glyphs[r];
                        f ? f.texture = p.texture : ((f = new PIXI.Sprite(p.texture)).name = c.text[u], this._glyphs.push(f)), f.position.x = c.chars[u] + o - a, f.position.y = c.y + p.yOffset * i - h, f.scale.set(i), f.tint = this.tint, f.texture.requiresReTint = !0, f.cachedTint = 16777215, f.parent || this.addChild(f), r++
                    }
                }
                for (l = r; l < this._glyphs.length; l++) this.removeChild(this._glyphs[l])
            }
        }, t.BitmapText.prototype.purgeGlyphs = function() {
            for (var t = this._glyphs.length, e = [], i = 0; i < this._glyphs.length; i++) this._glyphs[i].parent !== this ? this._glyphs[i].destroy() : e.push(this._glyphs[i]);
            return this._glyphs = [], this._glyphs = e, this.updateText(), t - e.length
        }, t.BitmapText.prototype.updateTransform = function() {
            !this.dirty && this.anchor.equals(this._prevAnchor) || (this.updateText(), this.dirty = !1, this._prevAnchor.copyFrom(this.anchor)), PIXI.DisplayObjectContainer.prototype.updateTransform.call(this)
        }, Object.defineProperty(t.BitmapText.prototype, "letterSpacing", {
            get: function() {
                return this._letterSpacing
            },
            set: function(t) {
                "number" == typeof t && (this._letterSpacing = t, this.updateText())
            }
        }), Object.defineProperty(t.BitmapText.prototype, "align", {
            get: function() {
                return this._align
            },
            set: function(t) {
                t === this._align || "left" !== t && "center" !== t && "right" !== t || (this._align = t, this.updateText())
            }
        }), Object.defineProperty(t.BitmapText.prototype, "tint", {
            get: function() {
                return this._tint
            },
            set: function(t) {
                t !== this._tint && (this._tint = t, this.updateText())
            }
        }), Object.defineProperty(t.BitmapText.prototype, "font", {
            get: function() {
                return this._font
            },
            set: function(t) {
                t !== this._font && (this._font = t.trim(), this._data = this.game.cache.getBitmapFont(this._font), this.updateText())
            }
        }), Object.defineProperty(t.BitmapText.prototype, "fontSize", {
            get: function() {
                return this._fontSize
            },
            set: function(t) {
                (t = parseInt(t, 10)) !== this._fontSize && t > 0 && (this._fontSize = t, this.updateText())
            }
        }), Object.defineProperty(t.BitmapText.prototype, "text", {
            get: function() {
                return this._text
            },
            set: function(t) {
                t !== this._text && (this._text = t.toString() || "", this.updateText())
            }
        }), Object.defineProperty(t.BitmapText.prototype, "maxWidth", {
            get: function() {
                return this._maxWidth
            },
            set: function(t) {
                t !== this._maxWidth && (this._maxWidth = t, this.updateText())
            }
        }), Object.defineProperty(t.BitmapText.prototype, "smoothed", {
            get: function() {
                return !this._data.base.scaleMode
            },
            set: function(t) {
                this._data.base.scaleMode = t ? 0 : 1, this._data.base.dirty()
            }
        }), t.RetroFont = function(e, i, s, n, r, o, a, h, l, c) {
            if (!e.cache.checkImageKey(i)) return !1;
            null != o || (o = e.cache.getImage(i).width / s), this.characterWidth = s, this.characterHeight = n, this.characterSpacingX = a || 0, this.characterSpacingY = h || 0, this.characterPerRow = o, this.offsetX = l || 0, this.offsetY = c || 0, this.align = "left", this.multiLine = !1, this.autoUpperCase = !0, this.customSpacingX = 0, this.customSpacingY = 0, this.fixedWidth = 0, this.fontSet = e.cache.getImage(i), this._text = "", this.grabData = [], this.frameData = new t.FrameData;
            for (var u = this.offsetX, d = this.offsetY, p = 0, f = 0; f < r.length; f++) {
                var g = this.frameData.addFrame(new t.Frame(f, u, d, this.characterWidth, this.characterHeight));
                this.grabData[r.charCodeAt(f)] = g.index, ++p === this.characterPerRow ? (p = 0, u = this.offsetX, d += this.characterHeight + this.characterSpacingY) : u += this.characterWidth + this.characterSpacingX
            }
            e.cache.updateFrameData(i, this.frameData), this.stamp = new t.Image(e, 0, 0, i, 0), t.RenderTexture.call(this, e, 100, 100, "", t.scaleModes.NEAREST), this.type = t.RETROFONT
        }, t.RetroFont.prototype = Object.create(t.RenderTexture.prototype), t.RetroFont.prototype.constructor = t.RetroFont, t.RetroFont.ALIGN_LEFT = "left", t.RetroFont.ALIGN_RIGHT = "right", t.RetroFont.ALIGN_CENTER = "center", t.RetroFont.TEXT_SET1 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", t.RetroFont.TEXT_SET2 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ", t.RetroFont.TEXT_SET3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ", t.RetroFont.TEXT_SET4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789", t.RetroFont.TEXT_SET5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789", t.RetroFont.TEXT_SET6 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' ", t.RetroFont.TEXT_SET7 = "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39", t.RetroFont.TEXT_SET8 = "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ", t.RetroFont.TEXT_SET9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!", t.RetroFont.TEXT_SET10 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ", t.RetroFont.TEXT_SET11 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789", t.RetroFont.prototype.setFixedWidth = function(t, e) {
            void 0 === e && (e = "left"), this.fixedWidth = t, this.align = e
        }, t.RetroFont.prototype.setText = function(t, e, i, s, n, r) {
            this.multiLine = e || !1, this.customSpacingX = i || 0, this.customSpacingY = s || 0, this.align = n || "left", this.autoUpperCase = !r, t.length > 0 && (this.text = t)
        }, t.RetroFont.prototype.buildRetroFontText = function() {
            var e = 0,
                i = 0;
            if (this.clear(), this.multiLine) {
                var s = this._text.split("\n");
                this.fixedWidth > 0 ? this.resize(this.fixedWidth, s.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0) : this.resize(this.getLongestLine() * (this.characterWidth + this.customSpacingX), s.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0);
                for (var n = 0; n < s.length; n++) e = 0, this.align === t.RetroFont.ALIGN_RIGHT ? e = this.width - s[n].length * (this.characterWidth + this.customSpacingX) : this.align === t.RetroFont.ALIGN_CENTER && (e = this.width / 2 - s[n].length * (this.characterWidth + this.customSpacingX) / 2, e += this.customSpacingX / 2), e < 0 && (e = 0), this.pasteLine(s[n], e, i, this.customSpacingX), i += this.characterHeight + this.customSpacingY
            } else this.fixedWidth > 0 ? this.resize(this.fixedWidth, this.characterHeight, !0) : this.resize(this._text.length * (this.characterWidth + this.customSpacingX), this.characterHeight, !0), e = 0, this.align === t.RetroFont.ALIGN_RIGHT ? e = this.width - this._text.length * (this.characterWidth + this.customSpacingX) : this.align === t.RetroFont.ALIGN_CENTER && (e = this.width / 2 - this._text.length * (this.characterWidth + this.customSpacingX) / 2, e += this.customSpacingX / 2), e < 0 && (e = 0), this.pasteLine(this._text, e, 0, this.customSpacingX);
            this.requiresReTint = !0
        }, t.RetroFont.prototype.pasteLine = function(t, e, i, s) {
            for (var n = 0; n < t.length; n++)
                if (" " === t.charAt(n)) e += this.characterWidth + s;
                else if (this.grabData[t.charCodeAt(n)] >= 0 && (this.stamp.frame = this.grabData[t.charCodeAt(n)], this.renderXY(this.stamp, e, i, !1), (e += this.characterWidth + s) > this.width)) break
        }, t.RetroFont.prototype.getLongestLine = function() {
            var t = 0;
            if (this._text.length > 0)
                for (var e = this._text.split("\n"), i = 0; i < e.length; i++) e[i].length > t && (t = e[i].length);
            return t
        }, t.RetroFont.prototype.removeUnsupportedCharacters = function(t) {
            for (var e = "", i = 0; i < this._text.length; i++) {
                var s = this._text[i],
                    n = s.charCodeAt(0);
                (this.grabData[n] >= 0 || !t && "\n" === s) && (e = e.concat(s))
            }
            return e
        }, t.RetroFont.prototype.updateOffset = function(t, e) {
            if (this.offsetX !== t || this.offsetY !== e) {
                for (var i = t - this.offsetX, s = e - this.offsetY, n = this.game.cache.getFrameData(this.stamp.key).getFrames(), r = n.length; r--;) n[r].x += i, n[r].y += s;
                this.buildRetroFontText()
            }
        }, Object.defineProperty(t.RetroFont.prototype, "text", {
            get: function() {
                return this._text
            },
            set: function(t) {
                var e;
                (e = this.autoUpperCase ? t.toUpperCase() : t) !== this._text && (this._text = e, this.removeUnsupportedCharacters(this.multiLine), this.buildRetroFontText())
            }
        }), Object.defineProperty(t.RetroFont.prototype, "smoothed", {
            get: function() {
                return this.stamp.smoothed
            },
            set: function(t) {
                this.stamp.smoothed = t, this.buildRetroFontText()
            }
        }), t.Rope = function(e, i, s, n, r, o) {
            this.points = o || [], this._hasUpdateAnimation = !1, this._updateAnimationCallback = null, i = i || 0, s = s || 0, n = n || null, r = r || null, this.type = t.ROPE, PIXI.DisplayObjectContainer.call(this), this.texture = t.Cache.DEFAULT, this.uvs = new Float32Array([0, 1, 1, 1, 1, 0, 0, 1]), this.vertices = new Float32Array([0, 0, 100, 0, 100, 100, 0, 100]), this.colors = new Float32Array([1, 1, 1, 1]), this.indices = new Uint16Array([0, 1, 2, 3]), o && (this.vertices = new Float32Array(4 * o.length), this.uvs = new Float32Array(4 * o.length), this.colors = new Float32Array(2 * o.length), this.indices = new Uint16Array(2 * o.length)), this.dirty = !0, this.canvasPadding = 0, this.drawMode = t.Rope.TRIANGLE_STRIP, t.Component.Core.init.call(this, e, i, s, n, r), this.refresh()
        }, t.Rope.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), t.Rope.prototype.constructor = t.Rope, t.Component.Core.install.call(t.Rope.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"]), t.Rope.prototype.preUpdatePhysics = t.Component.PhysicsBody.preUpdate, t.Rope.prototype.preUpdateLifeSpan = t.Component.LifeSpan.preUpdate, t.Rope.prototype.preUpdateInWorld = t.Component.InWorld.preUpdate, t.Rope.prototype.preUpdateCore = t.Component.Core.preUpdate, t.Rope.TRIANGLE_STRIP = 0, t.Rope.TRIANGLES = 1, t.Rope.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, t.Rope.prototype.update = function() {
            this._hasUpdateAnimation && this.updateAnimation.call(this)
        }, t.Rope.prototype.reset = function(e, i) {
            return t.Component.Reset.prototype.reset.call(this, e, i), this
        }, t.Rope.prototype.refresh = function() {
            var t = this.points;
            if (!(t.length < 1)) {
                var e = this.uvs,
                    i = this.indices,
                    s = this.colors;
                this.count -= .2, e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, s[0] = 1, s[1] = 1, i[0] = 0, i[1] = 1;
                for (var n, r, o = t.length, a = 1; a < o; a++) r = a / (o - 1), e[n = 4 * a] = r, e[n + 1] = 0, e[n + 2] = r, e[n + 3] = 1, s[n = 2 * a] = 1, s[n + 1] = 1, i[n = 2 * a] = n, i[n + 1] = n + 1
            }
        }, t.Rope.prototype.updateTransform = function() {
            var t = this.points;
            if (!(t.length < 1)) {
                var e, i = t[0],
                    s = {
                        x: 0,
                        y: 0
                    };
                this.count -= .2;
                for (var n, r, o, a, h = this.vertices, l = t.length, c = 0; c < l; c++) n = t[c], r = 4 * c, e = c < t.length - 1 ? t[c + 1] : n, s.y = -(e.x - i.x), s.x = e.y - i.y, o = Math.sqrt(s.x * s.x + s.y * s.y), a = this.texture.height / 2, s.x /= o, s.y /= o, s.x *= a, s.y *= a, h[r] = n.x + s.x, h[r + 1] = n.y + s.y, h[r + 2] = n.x - s.x, h[r + 3] = n.y - s.y, i = n;
                PIXI.DisplayObjectContainer.prototype.updateTransform.call(this)
            }
        }, t.Rope.prototype.setTexture = function(t) {
            this.texture = t
        }, t.Rope.prototype._renderWebGL = function(t) {
            !this.visible || this.alpha <= 0 || (t.spriteBatch.stop(), this._vertexBuffer || this._initWebGL(t), t.shaderManager.setShader(t.shaderManager.stripShader), this._renderStrip(t), t.spriteBatch.start())
        }, t.Rope.prototype._initWebGL = function(t) {
            var e = t.gl;
            this._vertexBuffer = e.createBuffer(), this._indexBuffer = e.createBuffer(), this._uvBuffer = e.createBuffer(), this._colorBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this._vertexBuffer), e.bufferData(e.ARRAY_BUFFER, this.vertices, e.DYNAMIC_DRAW), e.bindBuffer(e.ARRAY_BUFFER, this._uvBuffer), e.bufferData(e.ARRAY_BUFFER, this.uvs, e.STATIC_DRAW), e.bindBuffer(e.ARRAY_BUFFER, this._colorBuffer), e.bufferData(e.ARRAY_BUFFER, this.colors, e.STATIC_DRAW), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._indexBuffer), e.bufferData(e.ELEMENT_ARRAY_BUFFER, this.indices, e.STATIC_DRAW)
        }, t.Rope.prototype._renderStrip = function(e) {
            var i = e.gl,
                s = e.projection,
                n = e.offset,
                r = e.shaderManager.stripShader,
                o = this.drawMode === t.Rope.TRIANGLE_STRIP ? i.TRIANGLE_STRIP : i.TRIANGLES;
            e.blendModeManager.setBlendMode(this.blendMode), i.uniformMatrix3fv(r.translationMatrix, !1, this.worldTransform.toArray(!0)), i.uniform2f(r.projectionVector, s.x, -s.y), i.uniform2f(r.offsetVector, -n.x, -n.y), i.uniform1f(r.alpha, this.worldAlpha), this.dirty ? (this.dirty = !1, i.bindBuffer(i.ARRAY_BUFFER, this._vertexBuffer), i.bufferData(i.ARRAY_BUFFER, this.vertices, i.STATIC_DRAW), i.vertexAttribPointer(r.aVertexPosition, 2, i.FLOAT, !1, 0, 0), i.bindBuffer(i.ARRAY_BUFFER, this._uvBuffer), i.bufferData(i.ARRAY_BUFFER, this.uvs, i.STATIC_DRAW), i.vertexAttribPointer(r.aTextureCoord, 2, i.FLOAT, !1, 0, 0), i.activeTexture(i.TEXTURE0), this.texture.baseTexture._dirty[i.id] ? e.renderer.updateTexture(this.texture.baseTexture) : i.bindTexture(i.TEXTURE_2D, this.texture.baseTexture._glTextures[i.id]), i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, this._indexBuffer), i.bufferData(i.ELEMENT_ARRAY_BUFFER, this.indices, i.STATIC_DRAW)) : (i.bindBuffer(i.ARRAY_BUFFER, this._vertexBuffer), i.bufferSubData(i.ARRAY_BUFFER, 0, this.vertices), i.vertexAttribPointer(r.aVertexPosition, 2, i.FLOAT, !1, 0, 0), i.bindBuffer(i.ARRAY_BUFFER, this._uvBuffer), i.vertexAttribPointer(r.aTextureCoord, 2, i.FLOAT, !1, 0, 0), i.activeTexture(i.TEXTURE0), this.texture.baseTexture._dirty[i.id] ? e.renderer.updateTexture(this.texture.baseTexture) : i.bindTexture(i.TEXTURE_2D, this.texture.baseTexture._glTextures[i.id]), i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, this._indexBuffer)), i.drawElements(o, this.indices.length, i.UNSIGNED_SHORT, 0)
        }, t.Rope.prototype._renderCanvas = function(e) {
            var i = e.context,
                s = this.worldTransform,
                n = s.tx * e.resolution + e.shakeX,
                r = s.ty * e.resolution + e.shakeY;
            e.roundPixels ? i.setTransform(s.a, s.b, s.c, s.d, 0 | n, 0 | r) : i.setTransform(s.a, s.b, s.c, s.d, n, r), this.drawMode === t.Rope.TRIANGLE_STRIP ? this._renderCanvasTriangleStrip(i) : this._renderCanvasTriangles(i)
        }, t.Rope.prototype._renderCanvasTriangleStrip = function(t) {
            var e = this.vertices,
                i = this.uvs,
                s = e.length / 2;
            this.count++;
            for (var n = 0; n < s - 2; n++) {
                var r = 2 * n;
                this._renderCanvasDrawTriangle(t, e, i, r, r + 2, r + 4)
            }
        }, t.Rope.prototype._renderCanvasTriangles = function(t) {
            var e = this.vertices,
                i = this.uvs,
                s = this.indices,
                n = s.length;
            this.count++;
            for (var r = 0; r < n; r += 3) {
                var o = 2 * s[r],
                    a = 2 * s[r + 1],
                    h = 2 * s[r + 2];
                this._renderCanvasDrawTriangle(t, e, i, o, a, h)
            }
        }, t.Rope.prototype._renderCanvasDrawTriangle = function(t, e, i, s, n, r) {
            var o = this.texture.baseTexture.source,
                a = this.texture.width,
                h = this.texture.height,
                l = e[s],
                c = e[n],
                u = e[r],
                d = e[s + 1],
                p = e[n + 1],
                f = e[r + 1],
                g = i[s] * a,
                m = i[n] * a,
                y = i[r] * a,
                v = i[s + 1] * h,
                x = i[n + 1] * h,
                b = i[r + 1] * h;
            if (this.canvasPadding > 0) {
                var _ = this.canvasPadding / this.worldTransform.a,
                    w = this.canvasPadding / this.worldTransform.d,
                    T = (l + c + u) / 3,
                    P = (d + p + f) / 3,
                    C = l - T,
                    S = d - P,
                    A = Math.sqrt(C * C + S * S);
                l = T + C / A * (A + _), d = P + S / A * (A + w), S = p - P, c = T + (C = c - T) / (A = Math.sqrt(C * C + S * S)) * (A + _), p = P + S / A * (A + w), S = f - P, u = T + (C = u - T) / (A = Math.sqrt(C * C + S * S)) * (A + _), f = P + S / A * (A + w)
            }
            t.save(), t.beginPath(), t.moveTo(l, d), t.lineTo(c, p), t.lineTo(u, f), t.closePath(), t.clip();
            var E = g * x + v * y + m * b - x * y - v * m - g * b,
                M = l * x + v * u + c * b - x * u - v * c - l * b,
                R = g * c + l * y + m * u - c * y - l * m - g * u,
                L = g * x * u + v * c * y + l * m * b - l * x * y - v * m * u - g * c * b,
                B = d * x + v * f + p * b - x * f - v * p - d * b,
                I = g * p + d * y + m * f - p * y - d * m - g * f,
                O = g * x * f + v * p * y + d * m * b - d * x * y - v * m * f - g * p * b;
            t.transform(M / E, B / E, R / E, I / E, L / E, O / E), t.drawImage(o, 0, 0), t.restore()
        }, t.Rope.prototype.renderStripFlat = function(t) {
            var e = this.context,
                i = t.vertices,
                s = i.length / 2;
            this.count++, e.beginPath();
            for (var n = 1; n < s - 2; n++) {
                var r = 2 * n,
                    o = i[r],
                    a = i[r + 2],
                    h = i[r + 4],
                    l = i[r + 1],
                    c = i[r + 3],
                    u = i[r + 5];
                e.moveTo(o, l), e.lineTo(a, c), e.lineTo(h, u)
            }
            e.fillStyle = "#FF0000", e.fill(), e.closePath()
        }, t.Rope.prototype.getBounds = function(e) {
            for (var i = e || this.worldTransform, s = i.a, n = i.b, r = i.c, o = i.d, a = i.tx, h = i.ty, l = -1 / 0, c = -1 / 0, u = 1 / 0, d = 1 / 0, p = this.vertices, f = 0; f < p.length; f += 2) {
                var g = p[f],
                    m = p[f + 1],
                    y = s * g + r * m + a,
                    v = o * m + n * g + h;
                u = y < u ? y : u, d = v < d ? v : d, l = y > l ? y : l, c = v > c ? v : c
            }
            if (u === -1 / 0 || c === 1 / 0) return t.EmptyRectangle;
            var x = this._bounds;
            return x.x = u, x.width = l - u, x.y = d, x.height = c - d, this._currentBounds = x, x
        }, Object.defineProperty(t.Rope.prototype, "updateAnimation", {
            get: function() {
                return this._updateAnimation
            },
            set: function(t) {
                t && "function" == typeof t ? (this._hasUpdateAnimation = !0, this._updateAnimation = t) : (this._hasUpdateAnimation = !1, this._updateAnimation = null)
            }
        }), Object.defineProperty(t.Rope.prototype, "segments", {
            get: function() {
                for (var e, i, s, n, r, o, a, h, l = [], c = 0; c < this.points.length; c++) e = 4 * c, i = this.vertices[e] * this.scale.x, s = this.vertices[e + 1] * this.scale.y, n = this.vertices[e + 4] * this.scale.x, r = this.vertices[e + 3] * this.scale.y, o = t.Math.difference(i, n), a = t.Math.difference(s, r), i += this.world.x, s += this.world.y, h = new t.Rectangle(i, s, o, a), l.push(h);
                return l
            }
        }), t.TileSprite = function(e, i, s, n, r, o, a) {
            i = i || 0, s = s || 0, n = n || 256, r = r || 256, o = o || null, a = a || null, PIXI.Sprite.call(this, new PIXI.Texture(t.Cache.DEFAULT.baseTexture), n, r), this.type = t.TILESPRITE, this.physicsType = t.SPRITE, this._scroll = new t.Point, this.tileScale = new t.Point(1, 1), this.tileScaleOffset = new t.Point(1, 1), this.tilePosition = new t.Point, this.textureDebug = !1, this.canvasBuffer = null, this.tilingTexture = null, this.tilePattern = null, this.refreshTexture = !0, this.frameWidth = 0, this.frameHeight = 0, this._width = n, this._height = r, t.Component.Core.init.call(this, e, i, s, o, a)
        }, t.TileSprite.prototype = Object.create(PIXI.Sprite.prototype), t.TileSprite.prototype.constructor = t.TileSprite, t.Component.Core.install.call(t.TileSprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "Smoothed"]), t.TileSprite.prototype.preUpdatePhysics = t.Component.PhysicsBody.preUpdate, t.TileSprite.prototype.preUpdateLifeSpan = t.Component.LifeSpan.preUpdate, t.TileSprite.prototype.preUpdateInWorld = t.Component.InWorld.preUpdate, t.TileSprite.prototype.preUpdateCore = t.Component.Core.preUpdate, t.TileSprite.prototype.preUpdate = function() {
            return 0 !== this._scroll.x && (this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed), 0 !== this._scroll.y && (this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed), !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, t.TileSprite.prototype.autoScroll = function(t, e) {
            return this._scroll.set(t, e), this
        }, t.TileSprite.prototype.stopScroll = function() {
            return this._scroll.set(0, 0), this
        }, t.TileSprite.prototype.destroy = function(e) {
            t.Component.Destroy.prototype.destroy.call(this, e), PIXI.Sprite.prototype.destroy.call(this), this.canvasBuffer && (this.canvasBuffer.destroy(), this.canvasBuffer = null), this.tileScale = null, this.tileScaleOffset = null, this.tilePosition = null, this.tilingTexture && (this.tilingTexture.destroy(!0), this.tilingTexture = null)
        }, t.TileSprite.prototype.reset = function(e, i) {
            return t.Component.Reset.prototype.reset.call(this, e, i), this.tilePosition.x = 0, this.tilePosition.y = 0, this
        }, t.TileSprite.prototype.setTexture = function(t) {
            return this.texture !== t && (this.texture = t, this.refreshTexture = !0, this.cachedTint = 16777215), this
        }, t.TileSprite.prototype._renderWebGL = function(t) {
            if (this.visible && this.renderable && 0 !== this.alpha) {
                if (this._mask && (t.spriteBatch.stop(), t.maskManager.pushMask(this.mask, t), t.spriteBatch.start()), this._filters && (t.spriteBatch.flush(), t.filterManager.pushFilter(this._filterBlock)), this.refreshTexture) {
                    if (this.generateTilingTexture(!0, t), !this.tilingTexture) return;
                    this.tilingTexture.needsUpdate && (this.tilingTexture.baseTexture.textureIndex = this.texture.baseTexture.textureIndex, t.renderer.updateTexture(this.tilingTexture.baseTexture), this.tilingTexture.needsUpdate = !1)
                }
                t.spriteBatch.renderTilingSprite(this);
                for (var e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t);
                var i = !1;
                this._filters && (i = !0, t.spriteBatch.stop(), t.filterManager.popFilter()), this._mask && (i || t.spriteBatch.stop(), t.maskManager.popMask(this._mask, t)), i && t.spriteBatch.start()
            }
        }, t.TileSprite.prototype._renderCanvas = function(t) {
            if (this.visible && this.renderable && 0 !== this.alpha) {
                var e = t.context;
                this._mask && t.maskManager.pushMask(this._mask, t), e.globalAlpha = this.worldAlpha;
                var i = this.worldTransform,
                    s = t.resolution,
                    n = i.tx * s + t.shakeX,
                    r = i.ty * s + t.shakeY;
                if (e.setTransform(i.a * s, i.b * s, i.c * s, i.d * s, n, r), 16777215 === this.tint || !this.texture.requiresReTint && this.cachedTint === this.tint || (this.tintedTexture = PIXI.CanvasTinter.getTintedTexture(this, this.tint), this.cachedTint = this.tint, this.texture.requiresReTint = !1, this.refreshTexture = !0), this.refreshTexture) {
                    if (this.generateTilingTexture(!1, t), !this.tilingTexture) return;
                    this.tilePattern = e.createPattern(this.tilingTexture.baseTexture.source, "repeat")
                }
                var o = t.currentBlendMode;
                this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, e.globalCompositeOperation = PIXI.blendModesCanvas[t.currentBlendMode]);
                var a = this.tilePosition,
                    h = this.tileScale;
                a.x %= this.tilingTexture.baseTexture.width, a.y %= this.tilingTexture.baseTexture.height, e.scale(h.x, h.y), e.translate(a.x + this.anchor.x * -this._width, a.y + this.anchor.y * -this._height), e.fillStyle = this.tilePattern, n = -a.x, r = -a.y;
                var l = this._width / h.x,
                    c = this._height / h.y;
                t.roundPixels && (n |= 0, r |= 0, l |= 0, c |= 0), e.fillRect(n, r, l, c), e.scale(1 / h.x, 1 / h.y), e.translate(-a.x + this.anchor.x * this._width, -a.y + this.anchor.y * this._height), this._mask && t.maskManager.popMask(t);
                for (var u = 0; u < this.children.length; u++) this.children[u]._renderCanvas(t);
                o !== this.blendMode && (t.currentBlendMode = o, e.globalCompositeOperation = PIXI.blendModesCanvas[o])
            }
        }, t.TileSprite.prototype.onTextureUpdate = function() {}, t.TileSprite.prototype.generateTilingTexture = function(e) {
            if (this.texture.baseTexture.hasLoaded) {
                var i = this.texture,
                    s = i.frame,
                    n = this._frame.sourceSizeW || this._frame.width,
                    r = this._frame.sourceSizeH || this._frame.height,
                    o = 0,
                    a = 0;
                this._frame.trimmed && (o = this._frame.spriteSourceSizeX, a = this._frame.spriteSourceSizeY), e && (n = t.Math.getNextPowerOfTwo(n), r = t.Math.getNextPowerOfTwo(r)), this.canvasBuffer ? (this.canvasBuffer.resize(n, r), this.tilingTexture.baseTexture.width = n, this.tilingTexture.baseTexture.height = r, this.tilingTexture.needsUpdate = !0) : (this.canvasBuffer = new PIXI.CanvasBuffer(n, r), this.tilingTexture = PIXI.Texture.fromCanvas(this.canvasBuffer.canvas), this.tilingTexture.isTiling = !0, this.tilingTexture.needsUpdate = !0), this.textureDebug && (this.canvasBuffer.context.strokeStyle = "#00ff00", this.canvasBuffer.context.strokeRect(0, 0, n, r));
                var h = i.crop.width,
                    l = i.crop.height;
                h === n && l === r || (h = n, l = r);
                var c = this.tintedTexture ? this.tintedTexture : i.baseTexture.source;
                this.canvasBuffer.context.drawImage(c, i.crop.x, i.crop.y, i.crop.width, i.crop.height, o, a, h, l), this.tileScaleOffset.x = s.width / n, this.tileScaleOffset.y = s.height / r, this.refreshTexture = !1, this.tilingTexture.baseTexture._powerOf2 = !0
            }
        }, t.TileSprite.prototype.getBounds = function() {
            var t = this._width,
                e = this._height,
                i = t * (1 - this.anchor.x),
                s = t * -this.anchor.x,
                n = e * (1 - this.anchor.y),
                r = e * -this.anchor.y,
                o = this.worldTransform,
                a = o.a,
                h = o.b,
                l = o.c,
                c = o.d,
                u = o.tx,
                d = o.ty,
                p = a * s + l * r + u,
                f = c * r + h * s + d,
                g = a * i + l * r + u,
                m = c * r + h * i + d,
                y = a * i + l * n + u,
                v = c * n + h * i + d,
                x = a * s + l * n + u,
                b = c * n + h * s + d,
                _ = -1 / 0,
                w = -1 / 0,
                T = 1 / 0,
                P = 1 / 0;
            T = x < (T = y < (T = g < (T = p < T ? p : T) ? g : T) ? y : T) ? x : T, P = b < (P = v < (P = m < (P = f < P ? f : P) ? m : P) ? v : P) ? b : P, _ = x > (_ = y > (_ = g > (_ = p > _ ? p : _) ? g : _) ? y : _) ? x : _, w = b > (w = v > (w = m > (w = f > w ? f : w) ? m : w) ? v : w) ? b : w;
            var C = this._bounds;
            return C.x = T, C.width = _ - T, C.y = P, C.height = w - P, this._currentBounds = C, C
        }, Object.defineProperty(t.TileSprite.prototype, "width", {
            get: function() {
                return this._width
            },
            set: function(t) {
                this._width = t
            }
        }), Object.defineProperty(t.TileSprite.prototype, "height", {
            get: function() {
                return this._height
            },
            set: function(t) {
                this._height = t
            }
        }), t.CanvasPool = {
            create: function(e, i, s) {
                var n, r = t.CanvasPool.getFirst();
                if (-1 === r) {
                    var o = {
                        parent: e,
                        canvas: document.createElement("canvas")
                    };
                    t.CanvasPool.pool.push(o), n = o.canvas
                } else t.CanvasPool.pool[r].parent = e, n = t.CanvasPool.pool[r].canvas;
                return void 0 !== i && (n.width = i, n.height = s), n
            },
            getFirst: function() {
                for (var e = t.CanvasPool.pool, i = 0; i < e.length; i++)
                    if (!e[i].parent) return i;
                return -1
            },
            remove: function(e) {
                for (var i = t.CanvasPool.pool, s = 0; s < i.length; s++) i[s].parent === e && (i[s].parent = null, i[s].canvas.width = 1, i[s].canvas.height = 1)
            },
            removeByCanvas: function(e) {
                for (var i = t.CanvasPool.pool, s = 0; s < i.length; s++) i[s].canvas === e && (i[s].parent = null, i[s].canvas.width = 1, i[s].canvas.height = 1)
            },
            getTotal: function() {
                for (var e = t.CanvasPool.pool, i = 0, s = 0; s < e.length; s++) e[s].parent && i++;
                return i
            },
            getFree: function() {
                for (var e = t.CanvasPool.pool, i = 0, s = 0; s < e.length; s++) e[s].parent || i++;
                return i
            },
            log: function() {
                gradle.event("CanvasPool: %s used, %s free, %s total", this.getTotal(), this.getFree(), this.pool.length)
            }
        }, t.CanvasPool.pool = [], Object.defineProperty(t.CanvasPool, "length", {
            get: function() {
                return this.pool.length
            }
        }), t.Device = function() {
            this.deviceReadyAt = 0, this.initialized = !1, this.desktop = !1, this.iOS = !1, this.iOSVersion = 0, this.cocoonJS = !1, this.cocoonJSApp = !1, this.cordova = !1, this.node = !1, this.nodeWebkit = !1, this.electron = !1, this.ejecta = !1, this.crosswalk = !1, this.android = !1, this.chromeOS = !1, this.linux = !1, this.macOS = !1, this.windows = !1, this.windowsPhone = !1, this.canvas = !1, this.canvasBitBltShift = null, this.canHandleAlpha = !1, this.canUseMultiply = !1, this.webGL = !1, this.file = !1, this.fileSystem = !1, this.localStorage = !1, this.worker = !1, this.css3D = !1, this.pointerLock = !1, this.typedArray = !1, this.vibration = !1, this.getUserMedia = !0, this.quirksMode = !1, this.touch = !1, this.mspointer = !1, this.wheelEvent = null, this.arora = !1, this.chrome = !1, this.chromeVersion = 0, this.epiphany = !1, this.firefox = !1, this.firefoxVersion = 0, this.ie = !1, this.ieVersion = 0, this.trident = !1, this.tridentVersion = 0, this.edge = !1, this.mobileSafari = !1, this.midori = !1, this.opera = !1, this.safari = !1, this.safariVersion = 0, this.webApp = !1, this.silk = !1, this.audioData = !1, this.webAudio = !1, this.ogg = !1, this.opus = !1, this.mp3 = !1, this.wav = !1, this.m4a = !1, this.webm = !1, this.dolby = !1, this.oggVideo = !1, this.h264Video = !1, this.mp4Video = !1, this.webmVideo = !1, this.vp9Video = !1, this.hlsVideo = !1, this.iPhone = !1, this.iPhone4 = !1, this.iPad = !1, this.pixelRatio = 0, this.littleEndian = !1, this.LITTLE_ENDIAN = !1, this.support32bit = !1, this.fullscreen = !1, this.requestFullscreen = "", this.cancelFullscreen = "", this.fullscreenKeyboard = !1
        }, t.Device = new t.Device, t.Device.onInitialized = new t.Signal, t.Device.whenReady = function(t, e, i) {
            var s = this._readyCheck;
            if (this.deviceReadyAt || !s) t.call(e, this);
            else if (s._monitor || i) s._queue = s._queue || [], s._queue.push([t, e]);
            else {
                s._monitor = s.bind(this), s._queue = s._queue || [], s._queue.push([t, e]);
                var n = void 0 !== window.cordova,
                    r = navigator.isCocoonJS;
                "complete" === document.readyState || "interactive" === document.readyState ? window.setTimeout(s._monitor, 0) : n && !r ? document.addEventListener("deviceready", s._monitor, !1) : (document.addEventListener("DOMContentLoaded", s._monitor, !1), window.addEventListener("load", s._monitor, !1))
            }
        }, t.Device._readyCheck = function() {
            var t = this._readyCheck;
            if (document.body) {
                if (!this.deviceReadyAt) {
                    this.deviceReadyAt = Date.now(), document.removeEventListener("deviceready", t._monitor), document.removeEventListener("DOMContentLoaded", t._monitor), window.removeEventListener("load", t._monitor), this._initialize(), this.initialized = !0, this.onInitialized.dispatch(this);
                    for (var e; e = t._queue.shift();) {
                        var i = e[0],
                            s = e[1];
                        i.call(s, this)
                    }
                    this._readyCheck = null, this._initialize = null, this.onInitialized = null
                }
            } else window.setTimeout(t._monitor, 20)
        }, t.Device._initialize = function() {
            var e = this;
            ! function() {
                var t = navigator.userAgent;
                /Playstation Vita/.test(t) ? e.vita = !0 : /Kindle/.test(t) || /\bKF[A-Z][A-Z]+/.test(t) || /Silk.*Mobile Safari/.test(t) ? e.kindle = !0 : /Android/.test(t) ? e.android = !0 : /CrOS/.test(t) ? e.chromeOS = !0 : /iP[ao]d|iPhone/i.test(t) ? (e.iOS = !0, navigator.appVersion.match(/OS (\d+)/), e.iOSVersion = parseInt(RegExp.$1, 10)) : /Linux/.test(t) ? e.linux = !0 : /Mac OS/.test(t) ? e.macOS = !0 : /Windows/.test(t) && (e.windows = !0), (/Windows Phone/i.test(t) || /IEMobile/i.test(t)) && (e.android = !1, e.iOS = !1, e.macOS = !1, e.windows = !0, e.windowsPhone = !0);
                var i = /Silk/.test(t);
                (e.windows || e.macOS || e.linux && !i || e.chromeOS) && (e.desktop = !0), (e.windowsPhone || /Windows NT/i.test(t) && /Touch/i.test(t)) && (e.desktop = !1)
            }(),
            function() {
                var t = navigator.userAgent;
                if (/Arora/.test(t) ? e.arora = !0 : /Edge\/\d+/.test(t) ? e.edge = !0 : /Chrome\/(\d+)/.test(t) && !e.windowsPhone ? (e.chrome = !0, e.chromeVersion = parseInt(RegExp.$1, 10)) : /Epiphany/.test(t) ? e.epiphany = !0 : /Firefox\D+(\d+)/.test(t) ? (e.firefox = !0, e.firefoxVersion = parseInt(RegExp.$1, 10)) : /AppleWebKit/.test(t) && e.iOS ? e.mobileSafari = !0 : /MSIE (\d+\.\d+);/.test(t) ? (e.ie = !0, e.ieVersion = parseInt(RegExp.$1, 10)) : /Midori/.test(t) ? e.midori = !0 : /Opera/.test(t) ? e.opera = !0 : /Safari\/(\d+)/.test(t) && !e.windowsPhone ? (e.safari = !0, /Version\/(\d+)\./.test(t) && (e.safariVersion = parseInt(RegExp.$1, 10))) : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(t) && (e.ie = !0, e.trident = !0, e.tridentVersion = parseInt(RegExp.$1, 10), e.ieVersion = parseInt(RegExp.$3, 10)), /Silk/.test(t) && (e.silk = !0), navigator.standalone && (e.webApp = !0), void 0 !== window.cordova && (e.cordova = !0), "undefined" != typeof process && "undefined" != typeof require && (e.node = !0), e.node && "object" == typeof process.versions && (e.nodeWebkit = !!process.versions["node-webkit"], e.electron = !!process.versions.electron), navigator.isCocoonJS && (e.cocoonJS = !0), e.cocoonJS) try {
                    e.cocoonJSApp = "undefined" != typeof CocoonJS
                } catch (t) {
                    e.cocoonJSApp = !1
                }
                void 0 !== window.ejecta && (e.ejecta = !0), /Crosswalk/.test(t) && (e.crosswalk = !0)
            }(),
            function() {
                e.audioData = !!window.Audio, e.webAudio = !(!window.AudioContext && !window.webkitAudioContext);
                var t = document.createElement("audio");
                try {
                    if (t.canPlayType && (t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "") && (e.ogg = !0), (t.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "") || t.canPlayType("audio/opus;").replace(/^no$/, "")) && (e.opus = !0), t.canPlayType("audio/mpeg;").replace(/^no$/, "") && (e.mp3 = !0), t.canPlayType('audio/wav; codecs="1"').replace(/^no$/, "") && (e.wav = !0), (t.canPlayType("audio/x-m4a;") || t.canPlayType("audio/aac;").replace(/^no$/, "")) && (e.m4a = !0), t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "") && (e.webm = !0), "" !== t.canPlayType('audio/mp4;codecs="ec-3"')))
                        if (e.edge) e.dolby = !0;
                        else if (e.safari && e.safariVersion >= 9 && /Mac OS X (\d+)_(\d+)/.test(navigator.userAgent)) {
                        var i = parseInt(RegExp.$1, 10),
                            s = parseInt(RegExp.$2, 10);
                        (10 === i && s >= 11 || i > 10) && (e.dolby = !0)
                    }
                } catch (t) {}
            }(),
            function() {
                var t = document.createElement("video");
                try {
                    t.canPlayType && (t.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, "") && (e.oggVideo = !0), t.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, "") && (e.h264Video = !0, e.mp4Video = !0), t.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, "") && (e.webmVideo = !0), t.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, "") && (e.vp9Video = !0), t.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, "") && (e.hlsVideo = !0))
                } catch (t) {}
            }(),
            function() {
                var t, i = document.createElement("p"),
                    s = {
                        webkitTransform: "-webkit-transform",
                        OTransform: "-o-transform",
                        msTransform: "-ms-transform",
                        MozTransform: "-moz-transform",
                        transform: "transform"
                    };
                for (var n in document.body.insertBefore(i, null), s) void 0 !== i.style[n] && (i.style[n] = "translate3d(1px,1px,1px)", t = window.getComputedStyle(i).getPropertyValue(s[n]));
                document.body.removeChild(i), e.css3D = void 0 !== t && t.length > 0 && "none" !== t
            }(), e.pixelRatio = window.devicePixelRatio || 1, e.iPhone = -1 !== navigator.userAgent.toLowerCase().indexOf("iphone"), e.iPhone4 = 2 === e.pixelRatio && e.iPhone, e.iPad = -1 !== navigator.userAgent.toLowerCase().indexOf("ipad"), "undefined" != typeof Int8Array ? e.typedArray = !0 : e.typedArray = !1, "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array && "undefined" != typeof Uint32Array && (e.littleEndian = function() {
                    var t = new ArrayBuffer(4),
                        e = new Uint8Array(t),
                        i = new Uint32Array(t);
                    return e[0] = 161, e[1] = 178, e[2] = 195, e[3] = 212, 3569595041 === i[0] || 2712847316 !== i[0] && null
                }(), e.LITTLE_ENDIAN = e.littleEndian), e.support32bit = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8ClampedArray && "undefined" != typeof Int32Array && null !== e.littleEndian && function() {
                    if (void 0 === Uint8ClampedArray) return !1;
                    var e = t.CanvasPool.create(this, 1, 1).getContext("2d");
                    if (!e) return !1;
                    var i = e.createImageData(1, 1);
                    return t.CanvasPool.remove(this), i.data instanceof Uint8ClampedArray
                }(), navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate, navigator.vibrate && (e.vibration = !0),
                function() {
                    e.canvas = !!window.CanvasRenderingContext2D || e.cocoonJS;
                    try {
                        e.localStorage = !!localStorage.getItem
                    } catch (t) {
                        e.localStorage = !1
                    }
                    e.file = !!(window.File && window.FileReader && window.FileList && window.Blob), e.fileSystem = !!window.requestFileSystem, e.webGL = !!window.WebGLRenderingContext, e.worker = !!window.Worker, e.pointerLockElement = ("pointerLockElement" in document ? "pointerLockElement" : "mozPointerLockElement" in document && "mozPointerLockElement") || "webkitPointerLockElement" in document && "webkitPointerLockElement", e.pointerlockchange = ("onpointerlockchange" in document ? "pointerlockchange" : "onmozpointerlockchange" in document && "mozpointerlockchange") || "onwebkitpointerlockchange" in document && "webkitpointerlockchange", e.pointerlockerror = ("onpointerlockerror" in document ? "pointerlockerror" : "onmozpointerlockerror" in document && "mozpointerlockerror") || "onwebkitpointerlockerror" in document && "webkitpointerlockerror", e.pointerLock = !!e.pointerLockElement, e.quirksMode = "CSS1Compat" !== document.compatMode, navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia, window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL, e.getUserMedia = e.getUserMedia && !!navigator.getUserMedia && !!window.URL, e.firefox && e.firefoxVersion < 21 && (e.getUserMedia = !1), !e.iOS && (e.ie || e.firefox || e.chrome) && (e.canvasBitBltShift = !0), (e.safari || e.mobileSafari) && (e.canvasBitBltShift = !1)
                }(),
                function() {
                    var i = t.CanvasPool.create(this, 6, 1),
                        s = i.getContext("2d");
                    s.fillStyle = "rgba(10, 20, 30, 0.5)", s.fillRect(0, 0, 1, 1);
                    var n = s.getImageData(0, 0, 1, 1);
                    if (n) {
                        s.putImageData(n, 1, 0);
                        var r = s.getImageData(1, 0, 1, 1);
                        e.canHandleAlpha = r.data[0] === n.data[0] && r.data[1] === n.data[1] && r.data[2] === n.data[2] && r.data[3] === n.data[3]
                    }
                    s.globalCompositeOperation = "multiply", e.canUseMultiply = "multiply" === s.globalCompositeOperation, t.CanvasPool.removeByCanvas(i), PIXI.CanvasTinter.tintMethod = e.canUseMultiply ? PIXI.CanvasTinter.tintWithMultiply : PIXI.CanvasTinter.tintWithPerPixel
                }(),
                function() {
                    for (var t = ["requestFullscreen", "requestFullScreen", "webkitRequestFullscreen", "webkitRequestFullScreen", "msRequestFullscreen", "msRequestFullScreen", "mozRequestFullScreen", "mozRequestFullscreen"], i = document.createElement("div"), s = 0; s < t.length; s++)
                        if (i[t[s]]) {
                            e.fullscreen = !0, e.requestFullscreen = t[s];
                            break
                        }
                    var n = ["cancelFullScreen", "exitFullscreen", "webkitCancelFullScreen", "webkitExitFullscreen", "msCancelFullScreen", "msExitFullscreen", "mozCancelFullScreen", "mozExitFullscreen"];
                    if (e.fullscreen)
                        for (s = 0; s < n.length; s++)
                            if (document[n[s]]) {
                                e.cancelFullscreen = n[s];
                                break
                            }
                    window.Element && Element.ALLOW_KEYBOARD_INPUT && (e.fullscreenKeyboard = !0)
                }(), ("ontouchstart" in document.documentElement || window.navigator.maxTouchPoints && window.navigator.maxTouchPoints >= 1) && (e.touch = !0), (window.PointerEvent || window.MSPointerEvent || window.navigator.msPointerEnabled || window.navigator.pointerEnabled) && (e.mspointer = !0), e.cocoonJS || ("onwheel" in window || e.ie && "WheelEvent" in window ? e.wheelEvent = "wheel" : "onmousewheel" in window ? e.wheelEvent = "mousewheel" : e.firefox && "MouseScrollEvent" in window && (e.wheelEvent = "DOMMouseScroll"))
        }, t.Device.canPlayAudio = function(t) {
            return !!("mp3" === t && this.mp3 || "ogg" === t && (this.ogg || this.opus) || "m4a" === t && this.m4a || "opus" === t && this.opus || "wav" === t && this.wav || "webm" === t && this.webm || "mp4" === t && this.dolby)
        }, t.Device.canPlayVideo = function(t) {
            return !!("webm" === t && (this.webmVideo || this.vp9Video) || "mp4" === t && (this.mp4Video || this.h264Video) || ("ogg" === t || "ogv" === t) && this.oggVideo || "mpeg" === t && this.hlsVideo)
        }, t.Device.needsTouchUnlock = function() {
            return !!(!this.cocoonJS && (this.iOS || this.android) || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock)
        }, t.Device.isAndroidStockBrowser = function() {
            var t = window.navigator.userAgent.match(/Android.*AppleWebKit\/([\d.]+)/);
            return t && t[1] < 537
        }, t.Canvas = {
            create: function(e, i, s, n, r) {
                i = i || 256, s = s || 256;
                var o = r ? document.createElement("canvas") : t.CanvasPool.create(e, i, s);
                return "string" == typeof n && "" !== n && (o.id = n), o.width = i, o.height = s, o.style.display = "block", o
            },
            setBackgroundColor: function(t, e) {
                return e = e || "rgb(0,0,0)", t.style.backgroundColor = e, t
            },
            setTouchAction: function(t, e) {
                return e = e || "none", t.style.msTouchAction = e, t.style["ms-touch-action"] = e, t.style["touch-action"] = e, t
            },
            setUserSelect: function(t, e) {
                return e = e || "none", t.style["-webkit-touch-callout"] = e, t.style["-webkit-user-select"] = e, t.style["-khtml-user-select"] = e, t.style["-moz-user-select"] = e, t.style["-ms-user-select"] = e, t.style["user-select"] = e, t.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)", t
            },
            addToDOM: function(t, e, i) {
                var s;
                return void 0 === i && (i = !0), e && ("string" == typeof e ? s = document.getElementById(e) : "object" == typeof e && 1 === e.nodeType && (s = e)), s || (s = document.body), i && s.style && (s.style.overflow = "hidden"), s.appendChild(t), t
            },
            removeFromDOM: function(t) {
                t.parentNode && t.parentNode.removeChild(t)
            },
            setTransform: function(t, e, i, s, n, r, o) {
                return t.setTransform(s, r, o, n, e, i), t
            },
            setSmoothingEnabled: function(e, i) {
                var s = t.Canvas.getSmoothingPrefix(e);
                return s && (e[s] = i), e
            },
            getSmoothingPrefix: function(t) {
                var e = ["i", "webkitI", "msI", "mozI", "oI"];
                for (var i in e) {
                    var s = e[i] + "mageSmoothingEnabled";
                    if (s in t) return s
                }
                return null
            },
            getSmoothingEnabled: function(e) {
                var i = t.Canvas.getSmoothingPrefix(e);
                if (i) return e[i]
            },
            setImageRenderingCrisp: function(t) {
                for (var e = ["-webkit-optimize-contrast", "-moz-crisp-edges", "crisp-edges", "pixelated"], i = 0; i < e.length; i++) t.style["image-rendering"] = e[i];
                return t.style.msInterpolationMode = "nearest-neighbor", t
            },
            setImageRenderingBicubic: function(t) {
                return t.style["image-rendering"] = "auto", t.style.msInterpolationMode = "bicubic", t
            }
        }, t.RequestAnimationFrame = function(t, e) {
            void 0 === e && (e = !1), this.game = t, this.isRunning = !1, this.forceSetTimeOut = e;
            for (var i = ["ms", "moz", "webkit", "o"], s = 0; s < i.length && !window.requestAnimationFrame; s++) window.requestAnimationFrame = window[i[s] + "RequestAnimationFrame"], window.cancelAnimationFrame = window[i[s] + "CancelAnimationFrame"] || window[i[s] + "CancelRequestAnimationFrame"];
            this._isSetTimeOut = !1, this._onLoop = null, this._timeOutID = null
        }, t.RequestAnimationFrame.prototype = {
            start: function() {
                this.isRunning = !0;
                var t = this;
                !window.requestAnimationFrame || this.forceSetTimeOut ? (this._isSetTimeOut = !0, this._onLoop = function() {
                    return t.updateSetTimeout()
                }, this._timeOutID = window.setTimeout(this._onLoop, 0)) : (this._isSetTimeOut = !1, this._onLoop = function(e) {
                    return t.updateRAF(e)
                }, this._timeOutID = window.requestAnimationFrame(this._onLoop))
            },
            updateRAF: function(t) {
                this.isRunning && (this.game.update(Math.floor(t)), this._timeOutID = window.requestAnimationFrame(this._onLoop))
            },
            updateSetTimeout: function() {
                this.isRunning && (this.game.update(Date.now()), this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall))
            },
            stop: function() {
                this._isSetTimeOut ? clearTimeout(this._timeOutID) : window.cancelAnimationFrame(this._timeOutID), this.isRunning = !1
            },
            isSetTimeOut: function() {
                return this._isSetTimeOut
            },
            isRAF: function() {
                return !1 === this._isSetTimeOut
            }
        }, t.RequestAnimationFrame.prototype.constructor = t.RequestAnimationFrame, t.Math = {
            PI2: 2 * Math.PI,
            HALF_PI: .5 * Math.PI,
            DEG_TO_RAD: Math.PI / 180,
            RAD_TO_DEG: 180 / Math.PI,
            degToRad: function(e) {
                return e * t.Math.DEG_TO_RAD
            },
            radToDeg: function(e) {
                return e * t.Math.RAD_TO_DEG
            },
            getNextPowerOfTwo: function(t) {
                if (t > 0 && 0 == (t & t - 1)) return t;
                for (var e = 1; e < t;) e <<= 1;
                return e
            },
            isPowerOfTwo: function(t, e) {
                return t > 0 && 0 == (t & t - 1) && e > 0 && 0 == (e & e - 1)
            },
            random: function(t, e) {
                if (void 0 === t && (t = 0), void 0 === e && (e = 1), t === e) return t;
                if (t > e) {
                    var i = t;
                    t = e, e = i
                }
                return Math.random() * (e - t) + t
            },
            between: function(t, e) {
                if (void 0 === t && (t = 0), void 0 === e && (e = 1), t === e) return t;
                if (t > e) {
                    var i = t;
                    t = e, e = i
                }
                return t = Math.ceil(t), e = Math.floor(e), Math.floor(Math.random() * (e - t + 1)) + t
            },
            fuzzyEqual: function(t, e, i) {
                return void 0 === i && (i = 1e-4), Math.abs(t - e) < i
            },
            fuzzyLessThan: function(t, e, i) {
                return void 0 === i && (i = 1e-4), t < e + i
            },
            fuzzyGreaterThan: function(t, e, i) {
                return void 0 === i && (i = 1e-4), t > e - i
            },
            fuzzyCeil: function(t, e) {
                return void 0 === e && (e = 1e-4), Math.ceil(t - e)
            },
            fuzzyFloor: function(t, e) {
                return void 0 === e && (e = 1e-4), Math.floor(t + e)
            },
            average: function() {
                for (var t = 0, e = arguments.length, i = 0; i < e; i++) t += +arguments[i];
                return t / e
            },
            shear: function(t) {
                return t % 1
            },
            snapTo: function(t, e, i) {
                return void 0 === i && (i = 0), 0 === e ? t : (t -= i, i + (t = e * Math.round(t / e)))
            },
            snapToFloor: function(t, e, i) {
                return void 0 === i && (i = 0), 0 === e ? t : (t -= i, i + (t = e * Math.floor(t / e)))
            },
            snapToCeil: function(t, e, i) {
                return void 0 === i && (i = 0), 0 === e ? t : (t -= i, i + (t = e * Math.ceil(t / e)))
            },
            roundTo: function(t, e, i) {
                void 0 === e && (e = 0), void 0 === i && (i = 10);
                var s = Math.pow(i, -e);
                return Math.round(t * s) / s
            },
            floorTo: function(t, e, i) {
                void 0 === e && (e = 0), void 0 === i && (i = 10);
                var s = Math.pow(i, -e);
                return Math.floor(t * s) / s
            },
            ceilTo: function(t, e, i) {
                void 0 === e && (e = 0), void 0 === i && (i = 10);
                var s = Math.pow(i, -e);
                return Math.ceil(t * s) / s
            },
            trunc: function(t) {
                return isFinite(t) ? t - t % 1 || (t < 0 ? -0 : 0 === t ? t : 0) : t
            },
            rotateToAngle: function(e, i, s) {
                return void 0 === s && (s = .05), e === i ? e : (Math.abs(i - e) <= s || Math.abs(i - e) >= t.Math.PI2 - s ? e = i : (Math.abs(i - e) > Math.PI && (i < e ? i += t.Math.PI2 : i -= t.Math.PI2), i > e ? e += s : i < e && (e -= s)), e)
            },
            getShortestAngle: function(t, e) {
                var i = e - t;
                return 0 === i ? 0 : i - 360 * Math.floor((i - -180) / 360)
            },
            angleBetween: function(t, e, i, s) {
                return Math.atan2(s - e, i - t)
            },
            angleBetweenY: function(t, e, i, s) {
                return Math.atan2(i - t, s - e)
            },
            angleBetweenPoints: function(t, e) {
                return Math.atan2(e.y - t.y, e.x - t.x)
            },
            angleBetweenPointsY: function(t, e) {
                return Math.atan2(e.x - t.x, e.y - t.y)
            },
            reverseAngle: function(t) {
                return this.normalizeAngle(t + Math.PI, !0)
            },
            normalizeAngle: function(t) {
                return (t %= 2 * Math.PI) >= 0 ? t : t + 2 * Math.PI
            },
            maxAdd: function(t, e, i) {
                return Math.min(t + e, i)
            },
            minSub: function(t, e, i) {
                return Math.max(t - e, i)
            },
            wrap: function(t, e, i) {
                var s = i - e;
                if (s <= 0) return 0;
                var n = (t - e) % s;
                return n < 0 && (n += s), n + e
            },
            wrapValue: function(t, e, i) {
                return ((t = Math.abs(t)) + (e = Math.abs(e))) % (i = Math.abs(i))
            },
            isOdd: function(t) {
                return !!(1 & t)
            },
            isEven: function(t) {
                return !(1 & t)
            },
            min: function() {
                if (1 === arguments.length && "object" == typeof arguments[0]) t = arguments[0];
                else var t = arguments;
                for (var e = 1, i = 0, s = t.length; e < s; e++) t[e] < t[i] && (i = e);
                return t[i]
            },
            max: function() {
                if (1 === arguments.length && "object" == typeof arguments[0]) t = arguments[0];
                else var t = arguments;
                for (var e = 1, i = 0, s = t.length; e < s; e++) t[e] > t[i] && (i = e);
                return t[i]
            },
            minProperty: function(t) {
                if (2 === arguments.length && "object" == typeof arguments[1]) e = arguments[1];
                else var e = arguments.slice(1);
                for (var i = 1, s = 0, n = e.length; i < n; i++) e[i][t] < e[s][t] && (s = i);
                return e[s][t]
            },
            maxProperty: function(t) {
                if (2 === arguments.length && "object" == typeof arguments[1]) e = arguments[1];
                else var e = arguments.slice(1);
                for (var i = 1, s = 0, n = e.length; i < n; i++) e[i][t] > e[s][t] && (s = i);
                return e[s][t]
            },
            wrapAngle: function(t, e) {
                return e ? this.wrap(t, -Math.PI, Math.PI) : this.wrap(t, -180, 180)
            },
            linearInterpolation: function(t, e) {
                var i = t.length - 1,
                    s = i * e,
                    n = Math.floor(s);
                return e < 0 ? this.linear(t[0], t[1], s) : e > 1 ? this.linear(t[i], t[i - 1], i - s) : this.linear(t[n], t[n + 1 > i ? i : n + 1], s - n)
            },
            bezierInterpolation: function(t, e) {
                for (var i = 0, s = t.length - 1, n = 0; n <= s; n++) i += Math.pow(1 - e, s - n) * Math.pow(e, n) * t[n] * this.bernstein(s, n);
                return i
            },
            catmullRomInterpolation: function(t, e) {
                var i = t.length - 1,
                    s = i * e,
                    n = Math.floor(s);
                return t[0] === t[i] ? (e < 0 && (n = Math.floor(s = i * (1 + e))), this.catmullRom(t[(n - 1 + i) % i], t[n], t[(n + 1) % i], t[(n + 2) % i], s - n)) : e < 0 ? t[0] - (this.catmullRom(t[0], t[0], t[1], t[1], -s) - t[0]) : e > 1 ? t[i] - (this.catmullRom(t[i], t[i], t[i - 1], t[i - 1], s - i) - t[i]) : this.catmullRom(t[n ? n - 1 : 0], t[n], t[i < n + 1 ? i : n + 1], t[i < n + 2 ? i : n + 2], s - n)
            },
            linear: function(t, e, i) {
                return (e - t) * i + t
            },
            bernstein: function(t, e) {
                return this.factorial(t) / this.factorial(e) / this.factorial(t - e)
            },
            factorial: function(t) {
                if (0 === t) return 1;
                for (var e = t; --t;) e *= t;
                return e
            },
            catmullRom: function(t, e, i, s, n) {
                var r = .5 * (i - t),
                    o = .5 * (s - e),
                    a = n * n;
                return (2 * e - 2 * i + r + o) * (n * a) + (-3 * e + 3 * i - 2 * r - o) * a + r * n + e
            },
            difference: function(t, e) {
                return Math.abs(t - e)
            },
            roundAwayFromZero: function(t) {
                return t > 0 ? Math.ceil(t) : Math.floor(t)
            },
            sinCosGenerator: function(t, e, i, s) {
                void 0 === e && (e = 1), void 0 === i && (i = 1), void 0 === s && (s = 1);
                for (var n = e, r = i, o = s * Math.PI / t, a = [], h = [], l = 0; l < t; l++) n += (r -= n * o) * o, a[l] = r, h[l] = n;
                return {
                    sin: h,
                    cos: a,
                    length: t
                }
            },
            hypot: function(t, e) {
                return Math.sqrt(t * t + e * e)
            },
            distance: function(t, e, i, s) {
                var n = t - i,
                    r = e - s;
                return Math.sqrt(n * n + r * r)
            },
            distanceSq: function(t, e, i, s) {
                var n = t - i,
                    r = e - s;
                return n * n + r * r
            },
            distancePow: function(t, e, i, s, n) {
                return void 0 === n && (n = 2), Math.sqrt(Math.pow(i - t, n) + Math.pow(s - e, n))
            },
            clamp: function(t, e, i) {
                return t < e ? e : i < t ? i : t
            },
            clampBottom: function(t, e) {
                return t < e ? e : t
            },
            within: function(t, e, i) {
                return Math.abs(t - e) <= i
            },
            mapLinear: function(t, e, i, s, n) {
                return s + (t - e) * (n - s) / (i - e)
            },
            smoothstep: function(t, e, i) {
                return (t = Math.max(0, Math.min(1, (t - e) / (i - e)))) * t * (3 - 2 * t)
            },
            smootherstep: function(t, e, i) {
                return (t = Math.max(0, Math.min(1, (t - e) / (i - e)))) * t * t * (t * (6 * t - 15) + 10)
            },
            sign: function(t) {
                return t < 0 ? -1 : t > 0 ? 1 : 0
            },
            percent: function(t, e, i) {
                return void 0 === i && (i = 0), t > e || i > e ? 1 : t < i || i > t ? 0 : (t - i) / e
            }
        }, t.RandomDataGenerator = function(t) {
            void 0 === t && (t = []), this.c = 1, this.s0 = 0, this.s1 = 0, this.s2 = 0, "string" == typeof t ? this.state(t) : this.sow(t)
        }, t.RandomDataGenerator.prototype = {
            rnd: function() {
                var t = 2091639 * this.s0 + 2.3283064365386963e-10 * this.c;
                return this.c = 0 | t, this.s0 = this.s1, this.s1 = this.s2, this.s2 = t - this.c, this.s2
            },
            sow: function(t) {
                if (this.s0 = this.hash(" "), this.s1 = this.hash(this.s0), this.s2 = this.hash(this.s1), this.c = 1, t)
                    for (var e = 0; e < t.length && null != t[e]; e++) {
                        var i = t[e];
                        this.s0 -= this.hash(i), this.s0 += ~~(this.s0 < 0), this.s1 -= this.hash(i), this.s1 += ~~(this.s1 < 0), this.s2 -= this.hash(i), this.s2 += ~~(this.s2 < 0)
                    }
            },
            hash: function(t) {
                var e, i, s;
                for (s = 4022871197, t = t.toString(), i = 0; i < t.length; i++) e = .02519603282416938 * (s += t.charCodeAt(i)), e -= s = e >>> 0, s = (e *= s) >>> 0, s += 4294967296 * (e -= s);
                return 2.3283064365386963e-10 * (s >>> 0)
            },
            integer: function() {
                return 4294967296 * this.rnd.apply(this)
            },
            frac: function() {
                return this.rnd.apply(this) + 1.1102230246251565e-16 * (2097152 * this.rnd.apply(this) | 0)
            },
            real: function() {
                return this.integer() + this.frac()
            },
            integerInRange: function(t, e) {
                return Math.floor(this.realInRange(0, e - t + 1) + t)
            },
            between: function(t, e) {
                return this.integerInRange(t, e)
            },
            realInRange: function(t, e) {
                return this.frac() * (e - t) + t
            },
            normal: function() {
                return 1 - 2 * this.frac()
            },
            uuid: function() {
                var t = "",
                    e = "";
                for (e = t = ""; t++ < 36; e += ~t % 5 | 3 * t & 4 ? (15 ^ t ? 8 ^ this.frac() * (20 ^ t ? 16 : 4) : 4).toString(16) : "-");
                return e
            },
            pick: function(t) {
                return t[this.integerInRange(0, t.length - 1)]
            },
            sign: function() {
                return this.pick([-1, 1])
            },
            weightedPick: function(t) {
                return t[~~(Math.pow(this.frac(), 2) * (t.length - 1) + .5)]
            },
            timestamp: function(t, e) {
                return this.realInRange(t || 9466848e5, e || 1577862e6)
            },
            angle: function() {
                return this.integerInRange(-180, 180)
            },
            state: function(t) {
                return "string" == typeof t && t.match(/^!rnd/) && (t = t.split(","), this.c = parseFloat(t[1]), this.s0 = parseFloat(t[2]), this.s1 = parseFloat(t[3]), this.s2 = parseFloat(t[4])), ["!rnd", this.c, this.s0, this.s1, this.s2].join(",")
            }
        }, t.RandomDataGenerator.prototype.constructor = t.RandomDataGenerator, t.QuadTree = function(t, e, i, s, n, r, o) {
            this.maxObjects = 10, this.maxLevels = 4, this.level = 0, this.bounds = {}, this.objects = [], this.nodes = [], this._empty = [], this.reset(t, e, i, s, n, r, o)
        }, t.QuadTree.prototype = {
            reset: function(t, e, i, s, n, r, o) {
                this.maxObjects = n || 10, this.maxLevels = r || 4, this.level = o || 0, this.bounds = {
                    x: Math.round(t),
                    y: Math.round(e),
                    width: i,
                    height: s,
                    subWidth: Math.floor(i / 2),
                    subHeight: Math.floor(s / 2),
                    right: Math.round(t) + Math.floor(i / 2),
                    bottom: Math.round(e) + Math.floor(s / 2)
                }, this.objects.length = 0, this.nodes.length = 0
            },
            populate: function(t) {
                t.forEach(this.populateHandler, this, !0)
            },
            populateHandler: function(t) {
                t.body && t.exists && this.insert(t.body)
            },
            split: function() {
                this.nodes[0] = new t.QuadTree(this.bounds.right, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[1] = new t.QuadTree(this.bounds.x, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[2] = new t.QuadTree(this.bounds.x, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[3] = new t.QuadTree(this.bounds.right, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1)
            },
            insert: function(t) {
                var e, i = 0;
                if (null == this.nodes[0] || -1 === (e = this.getIndex(t))) {
                    if (this.objects.push(t), this.objects.length > this.maxObjects && this.level < this.maxLevels)
                        for (null == this.nodes[0] && this.split(); i < this.objects.length;) - 1 !== (e = this.getIndex(this.objects[i])) ? this.nodes[e].insert(this.objects.splice(i, 1)[0]) : i++
                } else this.nodes[e].insert(t)
            },
            getIndex: function(t) {
                var e = -1;
                return t.x < this.bounds.right && t.right < this.bounds.right ? t.y < this.bounds.bottom && t.bottom < this.bounds.bottom ? e = 1 : t.y > this.bounds.bottom && (e = 2) : t.x > this.bounds.right && (t.y < this.bounds.bottom && t.bottom < this.bounds.bottom ? e = 0 : t.y > this.bounds.bottom && (e = 3)), e
            },
            retrieve: function(e) {
                if (e instanceof t.Rectangle) var i = this.objects,
                    s = this.getIndex(e);
                else {
                    if (!e.body) return this._empty;
                    i = this.objects, s = this.getIndex(e.body)
                }
                return this.nodes[0] && (i = -1 !== s ? i.concat(this.nodes[s].retrieve(e)) : (i = (i = (i = i.concat(this.nodes[0].retrieve(e))).concat(this.nodes[1].retrieve(e))).concat(this.nodes[2].retrieve(e))).concat(this.nodes[3].retrieve(e))), i
            },
            clear: function() {
                this.objects.length = 0;
                for (var t = this.nodes.length; t--;) this.nodes[t].clear(), this.nodes.splice(t, 1);
                this.nodes.length = 0
            }
        }, t.QuadTree.prototype.constructor = t.QuadTree, t.Net = function(t) {
            this.game = t
        }, t.Net.prototype = {
            getHostName: function() {
                return window.location && window.location.hostname ? window.location.hostname : null
            },
            checkDomainName: function(t) {
                return -1 !== window.location.hostname.indexOf(t)
            },
            updateQueryString: function(t, e, i, s) {
                void 0 === i && (i = !1), void 0 !== s && "" !== s || (s = window.location.href);
                var n = "",
                    r = new RegExp("([?|&])" + t + "=.*?(&|#|$)(.*)", "gi");
                if (r.test(s)) n = null != e ? s.replace(r, "$1" + t + "=" + e + "$2$3") : s.replace(r, "$1$3").replace(/(&|\?)$/, "");
                else if (null != e) {
                    var o = -1 !== s.indexOf("?") ? "&" : "?",
                        a = s.split("#");
                    s = a[0] + o + t + "=" + e, a[1] && (s += "#" + a[1]), n = s
                } else n = s;
                if (!i) return n;
                window.location.href = n
            },
            getQueryString: function(t) {
                void 0 === t && (t = "");
                var e = {},
                    i = location.search.substring(1).split("&");
                for (var s in i) {
                    var n = i[s].split("=");
                    if (n.length > 1) {
                        if (t && t === this.decodeURI(n[0])) return this.decodeURI(n[1]);
                        e[this.decodeURI(n[0])] = this.decodeURI(n[1])
                    }
                }
                return e
            },
            decodeURI: function(t) {
                return decodeURIComponent(t.replace(/\+/g, " "))
            }
        }, t.Net.prototype.constructor = t.Net, t.TweenManager = function(e) {
            this.game = e, this.frameBased = !1, this._tweens = [], this._add = [], this.easeMap = {
                Power0: t.Easing.Power0,
                Power1: t.Easing.Power1,
                Power2: t.Easing.Power2,
                Power3: t.Easing.Power3,
                Power4: t.Easing.Power4,
                Linear: t.Easing.Linear.None,
                Quad: t.Easing.Quadratic.Out,
                Cubic: t.Easing.Cubic.Out,
                Quart: t.Easing.Quartic.Out,
                Quint: t.Easing.Quintic.Out,
                Sine: t.Easing.Sinusoidal.Out,
                Expo: t.Easing.Exponential.Out,
                Circ: t.Easing.Circular.Out,
                Elastic: t.Easing.Elastic.Out,
                Back: t.Easing.Back.Out,
                Bounce: t.Easing.Bounce.Out,
                "Quad.easeIn": t.Easing.Quadratic.In,
                "Cubic.easeIn": t.Easing.Cubic.In,
                "Quart.easeIn": t.Easing.Quartic.In,
                "Quint.easeIn": t.Easing.Quintic.In,
                "Sine.easeIn": t.Easing.Sinusoidal.In,
                "Expo.easeIn": t.Easing.Exponential.In,
                "Circ.easeIn": t.Easing.Circular.In,
                "Elastic.easeIn": t.Easing.Elastic.In,
                "Back.easeIn": t.Easing.Back.In,
                "Bounce.easeIn": t.Easing.Bounce.In,
                "Quad.easeOut": t.Easing.Quadratic.Out,
                "Cubic.easeOut": t.Easing.Cubic.Out,
                "Quart.easeOut": t.Easing.Quartic.Out,
                "Quint.easeOut": t.Easing.Quintic.Out,
                "Sine.easeOut": t.Easing.Sinusoidal.Out,
                "Expo.easeOut": t.Easing.Exponential.Out,
                "Circ.easeOut": t.Easing.Circular.Out,
                "Elastic.easeOut": t.Easing.Elastic.Out,
                "Back.easeOut": t.Easing.Back.Out,
                "Bounce.easeOut": t.Easing.Bounce.Out,
                "Quad.easeInOut": t.Easing.Quadratic.InOut,
                "Cubic.easeInOut": t.Easing.Cubic.InOut,
                "Quart.easeInOut": t.Easing.Quartic.InOut,
                "Quint.easeInOut": t.Easing.Quintic.InOut,
                "Sine.easeInOut": t.Easing.Sinusoidal.InOut,
                "Expo.easeInOut": t.Easing.Exponential.InOut,
                "Circ.easeInOut": t.Easing.Circular.InOut,
                "Elastic.easeInOut": t.Easing.Elastic.InOut,
                "Back.easeInOut": t.Easing.Back.InOut,
                "Bounce.easeInOut": t.Easing.Bounce.InOut
            }, this.game.onPause.add(this._pauseAll, this), this.game.onResume.add(this._resumeAll, this)
        }, t.TweenManager.prototype = {
            getAll: function() {
                return this._tweens
            },
            removeAll: function() {
                for (var t = 0; t < this._tweens.length; t++) this._tweens[t].pendingDelete = !0;
                this._add = []
            },
            removeFrom: function(e, i) {
                if (void 0 === i && (i = !0), Array.isArray(e))
                    for (s = 0, n = e.length; s < n; s++) this.removeFrom(e[s]);
                else if (e.type === t.GROUP && i)
                    for (var s = 0, n = e.children.length; s < n; s++) this.removeFrom(e.children[s]);
                else {
                    for (s = 0, n = this._tweens.length; s < n; s++) e === this._tweens[s].target && this.remove(this._tweens[s]);
                    for (s = 0, n = this._add.length; s < n; s++) e === this._add[s].target && this.remove(this._add[s])
                }
            },
            add: function(t) {
                t._manager = this, this._add.push(t)
            },
            create: function(e) {
                return new t.Tween(e, this.game, this)
            },
            remove: function(t) {
                var e = this._tweens.indexOf(t); - 1 !== e ? this._tweens[e].pendingDelete = !0 : -1 !== (e = this._add.indexOf(t)) && (this._add[e].pendingDelete = !0)
            },
            update: function() {
                var t = this._add.length,
                    e = this._tweens.length;
                if (0 === e && 0 === t) return !1;
                for (var i = 0; i < e;) this._tweens[i].update(this.game.time.time) ? i++ : (this._tweens.splice(i, 1), e--);
                return t > 0 && (this._tweens = this._tweens.concat(this._add), this._add.length = 0), !0
            },
            isTweening: function(t, e) {
                return e || (e = !1), this._tweens.some(function(i) {
                    return i.target === t && (!e || i.isRunning && !i.pendingDelete)
                })
            },
            _pauseAll: function() {
                for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t]._pause()
            },
            _resumeAll: function() {
                for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t]._resume()
            },
            pauseAll: function() {
                for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t].pause()
            },
            resumeAll: function() {
                for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t].resume(!0)
            },
            destroy: function() {
                this.game.onPause.remove(this._pauseAll, this), this.game.onResume.remove(this._resumeAll, this), this.game = null, this._add = null, this._tweens = null
            }
        }, t.TweenManager.prototype.constructor = t.TweenManager, t.Tween = function(e, i, s) {
            this.game = i, this.target = e, this.manager = s, this.timeline = [], this.reverse = !1, this.timeScale = 1, this.repeatCounter = 0, this.pendingDelete = !1, this.onStart = new t.Signal, this.onLoop = new t.Signal, this.onRepeat = new t.Signal, this.onChildComplete = new t.Signal, this.onComplete = new t.Signal, this.isRunning = !1, this.current = 0, this.properties = {}, this.chainedTween = null, this.isPaused = !1, this.frameBased = s.frameBased, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, this._pausedTime = 0, this._codePaused = !1, this._hasStarted = !1
        }, t.Tween.updateColor = function(e) {
            t.Color.updateColor(e.target)
        }, t.Tween.prototype = {
            to: function(e, i, s, n, r, o, a) {
                return (void 0 === i || i <= 0) && (i = 1e3), null != s || (s = t.Easing.Default), void 0 === n && (n = !1), void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === a && (a = !1), "string" == typeof s && this.manager.easeMap[s] && (s = this.manager.easeMap[s]), this.isRunning ? (console.warn("Phaser.Tween.to cannot be called after Tween.start"), this) : (this.timeline.push(new t.TweenData(this).to(e, i, s, r, o, a)), n && this.start(), this)
            },
            from: function(e, i, s, n, r, o, a) {
                return void 0 === i && (i = 1e3), null != s || (s = t.Easing.Default), void 0 === n && (n = !1), void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === a && (a = !1), "string" == typeof s && this.manager.easeMap[s] && (s = this.manager.easeMap[s]), this.isRunning ? (console.warn("Phaser.Tween.from cannot be called after Tween.start"), this) : (this.timeline.push(new t.TweenData(this).from(e, i, s, r, o, a)), n && this.start(), this)
            },
            start: function(t) {
                if (void 0 === t && (t = 0), this.pendingDelete) return console.warn("Phaser.Tween.start cannot be called after Tween.stop"), this;
                if (null === this.game || null === this.target || 0 === this.timeline.length || this.isRunning) return this;
                for (i = 0; i < this.timeline.length; i++)
                    for (var e in this.timeline[i].vEnd) this.properties[e] = this.target[e] || 0, Array.isArray(this.properties[e]) || (this.properties[e] *= 1);
                for (var i = 0; i < this.timeline.length; i++) this.timeline[i].loadValues();
                return this.manager.add(this), this.isRunning = !0, (t < 0 || t > this.timeline.length - 1) && (t = 0), this.current = t, this.timeline[this.current].start(), this
            },
            stop: function(t) {
                return void 0 === t && (t = !1), this.isRunning = !1, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, t && (this.onComplete.dispatch(this.target, this), this._hasStarted = !1, this.chainedTween && this.chainedTween.start()), this.manager.remove(this), this
            },
            updateTweenData: function(t, e, i) {
                if (0 === this.timeline.length) return this;
                if (void 0 === i && (i = 0), -1 === i)
                    for (var s = 0; s < this.timeline.length; s++) this.timeline[s][t] = e;
                else this.timeline[i][t] = e;
                return this
            },
            delay: function(t, e) {
                return this.updateTweenData("delay", t, e)
            },
            repeat: function(t, e, i) {
                return void 0 === e && (e = 0), this.updateTweenData("repeatCounter", t, i), this.updateTweenData("repeatTotal", t, i), this.updateTweenData("repeatDelay", e, i)
            },
            repeatDelay: function(t, e) {
                return this.updateTweenData("repeatDelay", t, e)
            },
            yoyo: function(t, e, i) {
                return void 0 === e && (e = 0), this.updateTweenData("yoyo", t, i), this.updateTweenData("yoyoDelay", e, i)
            },
            yoyoDelay: function(t, e) {
                return this.updateTweenData("yoyoDelay", t, e)
            },
            easing: function(t, e) {
                return "string" == typeof t && this.manager.easeMap[t] && (t = this.manager.easeMap[t]), this.updateTweenData("easingFunction", t, e)
            },
            interpolation: function(e, i, s) {
                return void 0 === i && (i = t.Math), this.updateTweenData("interpolationFunction", e, s), this.updateTweenData("interpolationContext", i, s)
            },
            repeatAll: function(t) {
                return void 0 === t && (t = 0), this.repeatCounter = t, this
            },
            chain: function() {
                for (var t = arguments.length; t--;) t > 0 ? arguments[t - 1].chainedTween = arguments[t] : this.chainedTween = arguments[t];
                return this
            },
            loop: function(t) {
                return void 0 === t && (t = !0), this.repeatCounter = t ? -1 : 0, this
            },
            onUpdateCallback: function(t, e) {
                return this._onUpdateCallback = t, this._onUpdateCallbackContext = e, this
            },
            pause: function() {
                this.isPaused = !0, this._codePaused = !0, this._pausedTime = this.game.time.time
            },
            _pause: function() {
                this._codePaused || (this.isPaused = !0, this._pausedTime = this.game.time.time)
            },
            resume: function() {
                if (this.isPaused) {
                    this.isPaused = !1, this._codePaused = !1;
                    for (var t = 0; t < this.timeline.length; t++) this.timeline[t].isRunning || (this.timeline[t].startTime += this.game.time.time - this._pausedTime)
                }
            },
            _resume: function() {
                this._codePaused || this.resume()
            },
            update: function(e) {
                if (this.pendingDelete || !this.target) return !1;
                if (this.isPaused) return !0;
                var i = this.timeline[this.current].update(e);
                if (i === t.TweenData.PENDING) return !0;
                if (i === t.TweenData.RUNNING) return this._hasStarted || (this.onStart.dispatch(this.target, this), this._hasStarted = !0), null !== this._onUpdateCallback && this._onUpdateCallback.call(this._onUpdateCallbackContext, this, this.timeline[this.current].value, this.timeline[this.current]), this.isRunning;
                if (i === t.TweenData.LOOPED) return -1 === this.timeline[this.current].repeatCounter ? this.onLoop.dispatch(this.target, this) : this.onRepeat.dispatch(this.target, this), !0;
                if (i === t.TweenData.COMPLETE) {
                    var s = !1;
                    return this.reverse ? --this.current < 0 && (this.current = this.timeline.length - 1, s = !0) : ++this.current === this.timeline.length && (this.current = 0, s = !0), s ? -1 === this.repeatCounter ? (this.timeline[this.current].start(), this.onLoop.dispatch(this.target, this), !0) : this.repeatCounter > 0 ? (this.repeatCounter--, this.timeline[this.current].start(), this.onRepeat.dispatch(this.target, this), !0) : (this.isRunning = !1, this.onComplete.dispatch(this.target, this), this._hasStarted = !1, this.chainedTween && this.chainedTween.start(), !1) : (this.onChildComplete.dispatch(this.target, this), this.timeline[this.current].start(), !0)
                }
            },
            generateData: function(t, e) {
                if (null === this.game || null === this.target) return null;
                for (void 0 === t && (t = 60), void 0 === e && (e = []), s = 0; s < this.timeline.length; s++)
                    for (var i in this.timeline[s].vEnd) this.properties[i] = this.target[i] || 0, Array.isArray(this.properties[i]) || (this.properties[i] *= 1);
                for (s = 0; s < this.timeline.length; s++) this.timeline[s].loadValues();
                for (var s = 0; s < this.timeline.length; s++) e = e.concat(this.timeline[s].generateData(t));
                return e
            }
        }, Object.defineProperty(t.Tween.prototype, "totalDuration", {
            get: function() {
                for (var t = 0, e = 0; e < this.timeline.length; e++) t += this.timeline[e].duration;
                return t
            }
        }), t.Tween.prototype.constructor = t.Tween, t.TweenData = function(e) {
            this.parent = e, this.game = e.game, this.vStart = {}, this.vStartCache = {}, this.vEnd = {}, this.vEndCache = {}, this.duration = 1e3, this.percent = 0, this.value = 0, this.repeatCounter = 0, this.repeatDelay = 0, this.repeatTotal = 0, this.interpolate = !1, this.yoyo = !1, this.yoyoDelay = 0, this.inReverse = !1, this.delay = 0, this.dt = 0, this.startTime = null, this.easingFunction = t.Easing.Default, this.interpolationFunction = t.Math.linearInterpolation, this.interpolationContext = t.Math, this.isRunning = !1, this.isFrom = !1
        }, t.TweenData.PENDING = 0, t.TweenData.RUNNING = 1, t.TweenData.LOOPED = 2, t.TweenData.COMPLETE = 3, t.TweenData.prototype = {
            to: function(t, e, i, s, n, r) {
                return this.vEnd = t, this.duration = e, this.easingFunction = i, this.delay = s, this.repeatTotal = n, this.yoyo = r, this.isFrom = !1, this
            },
            from: function(t, e, i, s, n, r) {
                return this.vEnd = t, this.duration = e, this.easingFunction = i, this.delay = s, this.repeatTotal = n, this.yoyo = r, this.isFrom = !0, this
            },
            start: function() {
                if (this.startTime = this.game.time.time + this.delay, this.parent.reverse ? this.dt = this.duration : this.dt = 0, this.delay > 0 ? this.isRunning = !1 : this.isRunning = !0, this.isFrom)
                    for (var t in this.vStartCache) this.vStart[t] = this.vEndCache[t], this.vEnd[t] = this.vStartCache[t], this.parent.target[t] = this.vStart[t];
                return this.value = 0, this.repeatCounter = this.repeatTotal, this
            },
            loadValues: function() {
                for (var t in this.parent.properties) {
                    if (this.vStart[t] = this.parent.properties[t], Array.isArray(this.vEnd[t])) {
                        if (0 === this.vEnd[t].length) continue;
                        0 === this.percent && (this.vEnd[t] = [this.vStart[t]].concat(this.vEnd[t]))
                    }
                    void 0 !== this.vEnd[t] ? ("string" == typeof this.vEnd[t] && (this.vEnd[t] = this.vStart[t] + parseFloat(this.vEnd[t])), this.parent.properties[t] = this.vEnd[t]) : this.vEnd[t] = this.vStart[t], this.vStartCache[t] = this.vStart[t], this.vEndCache[t] = this.vEnd[t]
                }
                return this
            },
            update: function(e) {
                if (this.isRunning) {
                    if (e < this.startTime) return t.TweenData.RUNNING
                } else {
                    if (!(e >= this.startTime)) return t.TweenData.PENDING;
                    this.isRunning = !0
                }
                var i = this.parent.frameBased ? this.game.time.physicsElapsedMS : this.game.time.elapsedMS;
                for (var s in this.parent.reverse ? (this.dt -= i * this.parent.timeScale, this.dt = Math.max(this.dt, 0)) : (this.dt += i * this.parent.timeScale, this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, this.value = this.easingFunction(this.percent), this.vEnd) {
                    var n = this.vStart[s],
                        r = this.vEnd[s];
                    Array.isArray(r) ? this.parent.target[s] = this.interpolationFunction.call(this.interpolationContext, r, this.value) : this.parent.target[s] = n + (r - n) * this.value
                }
                return !this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent ? this.repeat() : t.TweenData.RUNNING
            },
            generateData: function(t) {
                this.parent.reverse ? this.dt = this.duration : this.dt = 0;
                var e = [],
                    i = !1,
                    s = 1 / t * 1e3;
                do {
                    this.parent.reverse ? (this.dt -= s, this.dt = Math.max(this.dt, 0)) : (this.dt += s, this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, this.value = this.easingFunction(this.percent);
                    var n = {};
                    for (var r in this.vEnd) {
                        var o = this.vStart[r],
                            a = this.vEnd[r];
                        Array.isArray(a) ? n[r] = this.interpolationFunction.call(this.interpolationContext, a, this.value) : n[r] = o + (a - o) * this.value
                    }
                    e.push(n), (!this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent) && (i = !0)
                } while (!i);
                if (this.yoyo) {
                    var h = e.slice();
                    h.reverse(), e = e.concat(h)
                }
                return e
            },
            repeat: function() {
                if (this.yoyo) {
                    if (this.inReverse && 0 === this.repeatCounter) {
                        for (var e in this.vStartCache) this.vStart[e] = this.vStartCache[e], this.vEnd[e] = this.vEndCache[e];
                        return this.inReverse = !1, t.TweenData.COMPLETE
                    }
                    this.inReverse = !this.inReverse
                } else if (0 === this.repeatCounter) return t.TweenData.COMPLETE;
                if (this.inReverse)
                    for (var e in this.vStartCache) this.vStart[e] = this.vEndCache[e], this.vEnd[e] = this.vStartCache[e];
                else {
                    for (var e in this.vStartCache) this.vStart[e] = this.vStartCache[e], this.vEnd[e] = this.vEndCache[e];
                    this.repeatCounter > 0 && this.repeatCounter--
                }
                return this.startTime = this.game.time.time, this.yoyo && this.inReverse ? this.startTime += this.yoyoDelay : this.inReverse || (this.startTime += this.repeatDelay), this.parent.reverse ? this.dt = this.duration : this.dt = 0, t.TweenData.LOOPED
            }
        }, t.TweenData.prototype.constructor = t.TweenData, t.Easing = {
            Linear: {
                None: function(t) {
                    return t
                }
            },
            Quadratic: {
                In: function(t) {
                    return t * t
                },
                Out: function(t) {
                    return t * (2 - t)
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
                }
            },
            Cubic: {
                In: function(t) {
                    return t * t * t
                },
                Out: function(t) {
                    return --t * t * t + 1
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
                }
            },
            Quartic: {
                In: function(t) {
                    return t * t * t * t
                },
                Out: function(t) {
                    return 1 - --t * t * t * t
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
                }
            },
            Quintic: {
                In: function(t) {
                    return t * t * t * t * t
                },
                Out: function(t) {
                    return --t * t * t * t * t + 1
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
                }
            },
            Sinusoidal: {
                In: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : 1 - Math.cos(t * Math.PI / 2)
                },
                Out: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : Math.sin(t * Math.PI / 2)
                },
                InOut: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : .5 * (1 - Math.cos(Math.PI * t))
                }
            },
            Exponential: {
                In: function(t) {
                    return 0 === t ? 0 : Math.pow(1024, t - 1)
                },
                Out: function(t) {
                    return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
                },
                InOut: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
                }
            },
            Circular: {
                In: function(t) {
                    return 1 - Math.sqrt(1 - t * t)
                },
                Out: function(t) {
                    return Math.sqrt(1 - --t * t)
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
                }
            },
            Elastic: {
                In: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : -1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - .1) * (2 * Math.PI) / .4)
                },
                Out: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : 1 * Math.pow(2, -10 * t) * Math.sin((t - .1) * (2 * Math.PI) / .4) + 1
                },
                InOut: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? 1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - .1) * (2 * Math.PI) / .4) * -.5 : 1 * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - .1) * (2 * Math.PI) / .4) * .5 + 1
                }
            },
            Back: {
                In: function(t) {
                    var e = 1.70158;
                    return t * t * ((e + 1) * t - e)
                },
                Out: function(t) {
                    var e = 1.70158;
                    return --t * t * ((e + 1) * t + e) + 1
                },
                InOut: function(t) {
                    var e = 2.5949095;
                    return (t *= 2) < 1 ? t * t * ((e + 1) * t - e) * .5 : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2)
                }
            },
            Bounce: {
                In: function(e) {
                    return 1 - t.Easing.Bounce.Out(1 - e)
                },
                Out: function(t) {
                    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
                },
                InOut: function(e) {
                    return e < .5 ? .5 * t.Easing.Bounce.In(2 * e) : .5 * t.Easing.Bounce.Out(2 * e - 1) + .5
                }
            }
        }, t.Easing.Default = t.Easing.Linear.None, t.Easing.Power0 = t.Easing.Linear.None, t.Easing.Power1 = t.Easing.Quadratic.Out, t.Easing.Power2 = t.Easing.Cubic.Out, t.Easing.Power3 = t.Easing.Quartic.Out, t.Easing.Power4 = t.Easing.Quintic.Out, t.Time = function(e) {
            this.game = e, this.time = 0, this.prevTime = 0, this.now = 0, this.elapsed = 0, this.elapsedMS = 0, this.physicsElapsed = 1 / 60, this.physicsElapsedMS = 1 / 60 * 1e3, this.desiredFpsMult = 1 / 60, this._desiredFps = 60, this.suggestedFps = this.desiredFps, this.slowMotion = 1, this.advancedTiming = !1, this.frames = 0, this.updates = 0, this.renders = 0, this.fps = 0, this.ups = 0, this.rps = 0, this.fpsMin = 1e3, this.fpsMax = 0, this.msMin = 1e3, this.msMax = 0, this.pauseDuration = 0, this.timeToCall = 0, this.timeExpected = 0, this.events = new t.Timer(this.game, !1), this._frameCount = 0, this._elapsedAccumulator = 0, this._started = 0, this._timeLastSecond = 0, this._pauseStarted = 0, this._justResumed = !1, this._timers = []
        }, t.Time.prototype = {
            boot: function() {
                this._started = Date.now(), this.time = Date.now(), this.events.start(), this.timeExpected = this.time
            },
            add: function(t) {
                return this._timers.push(t), t
            },
            create: function(e) {
                void 0 === e && (e = !0);
                var i = new t.Timer(this.game, e);
                return this._timers.push(i), i
            },
            removeAll: function() {
                for (var t = 0; t < this._timers.length; t++) this._timers[t].destroy();
                this._timers = [], this.events.removeAll()
            },
            refresh: function() {
                var t = this.time;
                this.time = Date.now(), this.elapsedMS = this.time - t
            },
            update: function(t) {
                var e = this.time;
                this.time = Date.now(), this.elapsedMS = this.time - e, this.prevTime = this.now, this.now = t, this.elapsed = this.now - this.prevTime, this.game.raf._isSetTimeOut && (this.timeToCall = Math.floor(Math.max(0, 1e3 / this._desiredFps - (this.timeExpected - t))), this.timeExpected = t + this.timeToCall), this.advancedTiming && this.updateAdvancedTiming(), this.game.paused || (this.events.update(this.time), this._timers.length && this.updateTimers())
            },
            updateTimers: function() {
                for (var t = 0, e = this._timers.length; t < e;) this._timers[t].update(this.time) ? t++ : (this._timers.splice(t, 1), e--)
            },
            updateAdvancedTiming: function() {
                if (this._frameCount++, this._elapsedAccumulator += this.elapsed, this._frameCount >= 2 * this._desiredFps && (this.suggestedFps = 5 * Math.floor(200 / (this._elapsedAccumulator / this._frameCount)), this._frameCount = 0, this._elapsedAccumulator = 0), this.msMin = Math.min(this.msMin, this.elapsed), this.msMax = Math.max(this.msMax, this.elapsed), this.frames++, this.now > this._timeLastSecond + 1e3) {
                    var t = this.now - this._timeLastSecond;
                    this.fps = Math.round(1e3 * this.frames / t), this.ups = Math.round(1e3 * this.updates / t), this.rps = Math.round(1e3 * this.renders / t), this.fpsMin = Math.min(this.fpsMin, this.fps), this.fpsMax = Math.max(this.fpsMax, this.fps), this._timeLastSecond = this.now, this.frames = 0, this.updates = 0, this.renders = 0
                }
            },
            countUpdate: function() {
                this.advancedTiming && this.updates++
            },
            countRender: function() {
                this.advancedTiming && this.renders++
            },
            gamePaused: function() {
                this._pauseStarted = Date.now(), this.events.pause();
                for (var t = this._timers.length; t--;) this._timers[t]._pause()
            },
            gameResumed: function() {
                this.time = Date.now(), this.pauseDuration = this.time - this._pauseStarted, this.events.resume();
                for (var t = this._timers.length; t--;) this._timers[t]._resume()
            },
            totalElapsedSeconds: function() {
                return .001 * (this.time - this._started)
            },
            elapsedSince: function(t) {
                return this.time - t
            },
            elapsedSecondsSince: function(t) {
                return .001 * (this.time - t)
            },
            reset: function() {
                this._started = this.time, this.removeAll()
            }
        }, Object.defineProperty(t.Time.prototype, "desiredFps", {
            get: function() {
                return this._desiredFps
            },
            set: function(t) {
                this._desiredFps = t, this.physicsElapsed = 1 / t, this.physicsElapsedMS = 1e3 * this.physicsElapsed, this.desiredFpsMult = 1 / t
            }
        }), t.Time.prototype.constructor = t.Time, t.Timer = function(e, i) {
            void 0 === i && (i = !0), this.game = e, this.running = !1, this.autoDestroy = i, this.expired = !1, this.elapsed = 0, this.events = [], this.onComplete = new t.Signal, this.nextTick = 0, this.timeCap = 1e3, this.paused = !1, this._codePaused = !1, this._started = 0, this._pauseStarted = 0, this._pauseTotal = 0, this._now = Date.now(), this._len = 0, this._marked = 0, this._i = 0, this._diff = 0, this._newTick = 0
        }, t.Timer.MINUTE = 6e4, t.Timer.SECOND = 1e3, t.Timer.HALF = 500, t.Timer.QUARTER = 250, t.Timer.prototype = {
            create: function(e, i, s, n, r, o) {
                var a = e = Math.round(e);
                0 === this._now ? a += this.game.time.time : a += this._now;
                var h = new t.TimerEvent(this, e, a, s, i, n, r, o);
                return this.events.push(h), this.order(), this.expired = !1, h
            },
            add: function(t, e, i) {
                return this.create(t, !1, 0, e, i, Array.prototype.slice.call(arguments, 3))
            },
            repeat: function(t, e, i, s) {
                return this.create(t, !1, e, i, s, Array.prototype.slice.call(arguments, 4))
            },
            loop: function(t, e, i) {
                return this.create(t, !0, 0, e, i, Array.prototype.slice.call(arguments, 3))
            },
            start: function(t) {
                if (!this.running) {
                    this._started = this.game.time.time + (t || 0), this.running = !0;
                    for (var e = 0; e < this.events.length; e++) this.events[e].tick = this.events[e].delay + this._started
                }
            },
            stop: function(t) {
                this.running = !1, void 0 === t && (t = !0), t && (this.events.length = 0)
            },
            remove: function(t) {
                for (var e = 0; e < this.events.length; e++)
                    if (this.events[e] === t) return this.events[e].pendingDelete = !0, !0;
                return !1
            },
            order: function() {
                this.events.length > 0 && (this.events.sort(this.sortHandler), this.nextTick = this.events[0].tick)
            },
            sortHandler: function(t, e) {
                return t.tick < e.tick ? -1 : t.tick > e.tick ? 1 : 0
            },
            clearPendingEvents: function() {
                for (this._i = this.events.length; this._i--;) this.events[this._i].pendingDelete && this.events.splice(this._i, 1);
                this._len = this.events.length, this._i = 0
            },
            update: function(t) {
                if (this.paused) return !0;
                if (this.elapsed = t - this._now, this._now = t, this.elapsed > this.timeCap && this.adjustEvents(t - this.elapsed), this._marked = 0, this.clearPendingEvents(), this.running && this._now >= this.nextTick && this._len > 0) {
                    for (; this._i < this._len && this.running;) {
                        var e = this.events[this._i];
                        if (!(this._now >= e.tick) || e.pendingDelete) break;
                        this._newTick = this._now + e.delay - (this._now - e.tick), this._newTick < 0 && (this._newTick = this._now + e.delay), !0 === e.loop ? (e.tick = this._newTick, e.callback.apply(e.callbackContext, e.args)) : e.repeatCount > 0 ? (e.repeatCount--, e.tick = this._newTick, e.callback.apply(e.callbackContext, e.args)) : (this._marked++, e.pendingDelete = !0, e.callback.apply(e.callbackContext, e.args)), this._i++
                    }
                    this.events.length > this._marked ? this.order() : (this.expired = !0, this.onComplete.dispatch(this))
                }
                return !this.expired || !this.autoDestroy
            },
            pause: function() {
                this.running && (this._codePaused = !0, this.paused || (this._pauseStarted = this.game.time.time, this.paused = !0))
            },
            _pause: function() {
                !this.paused && this.running && (this._pauseStarted = this.game.time.time, this.paused = !0)
            },
            adjustEvents: function(t) {
                for (var e = 0; e < this.events.length; e++)
                    if (!this.events[e].pendingDelete) {
                        var i = this.events[e].tick - t;
                        i < 0 && (i = 0), this.events[e].tick = this._now + i
                    }
                var s = this.nextTick - t;
                this.nextTick = s < 0 ? this._now : this._now + s
            },
            resume: function() {
                if (this.paused) {
                    var t = this.game.time.time;
                    this._pauseTotal += t - this._now, this._now = t, this.adjustEvents(this._pauseStarted), this.paused = !1, this._codePaused = !1
                }
            },
            _resume: function() {
                this._codePaused || this.resume()
            },
            removeAll: function() {
                this.onComplete.removeAll(), this.events.length = 0, this._len = 0, this._i = 0
            },
            destroy: function() {
                this.onComplete.removeAll(), this.running = !1, this.expired = !0, this.events = [], this._len = 0, this._i = 0
            }
        }, Object.defineProperty(t.Timer.prototype, "next", {
            get: function() {
                return this.nextTick
            }
        }), Object.defineProperty(t.Timer.prototype, "duration", {
            get: function() {
                return this.running && this.nextTick > this._now ? this.nextTick - this._now : 0
            }
        }), Object.defineProperty(t.Timer.prototype, "length", {
            get: function() {
                return this.events.length
            }
        }), Object.defineProperty(t.Timer.prototype, "ms", {
            get: function() {
                return this.running ? this._now - this._started - this._pauseTotal : 0
            }
        }), Object.defineProperty(t.Timer.prototype, "seconds", {
            get: function() {
                return this.running ? .001 * this.ms : 0
            }
        }), t.Timer.prototype.constructor = t.Timer, t.TimerEvent = function(t, e, i, s, n, r, o, a) {
            this.timer = t, this.delay = e, this.tick = i, this.repeatCount = s - 1, this.loop = n, this.callback = r, this.callbackContext = o, this.args = a, this.pendingDelete = !1
        }, t.TimerEvent.prototype.constructor = t.TimerEvent, t.AnimationManager = function(t) {
            this.sprite = t, this.game = t.game, this.currentFrame = null, this.currentAnim = null, this.updateIfVisible = !0, this.isLoaded = !1, this._frameData = null, this._anims = {}, this._outputFrames = []
        }, t.AnimationManager.prototype = {
            loadFrameData: function(t, e) {
                if (void 0 === t) return !1;
                if (this.isLoaded)
                    for (var i in this._anims) this._anims[i].updateFrameData(t);
                return this._frameData = t, null == e ? this.frame = 0 : "string" == typeof e ? this.frameName = e : this.frame = e, this.isLoaded = !0, !0
            },
            copyFrameData: function(t, e) {
                if (this._frameData = t.clone(), this.isLoaded)
                    for (var i in this._anims) this._anims[i].updateFrameData(this._frameData);
                return null == e ? this.frame = 0 : "string" == typeof e ? this.frameName = e : this.frame = e, this.isLoaded = !0, !0
            },
            add: function(e, i, s, n, r) {
                return i = i || [], s = s || 60, void 0 === n && (n = !1), void 0 === r && (r = !(!i || "number" != typeof i[0])), this._outputFrames = [], this._frameData.getFrameIndexes(i, r, this._outputFrames), this._anims[e] = new t.Animation(this.game, this.sprite, e, this._frameData, this._outputFrames, s, n), this.currentAnim = this._anims[e], this.sprite.tilingTexture && (this.sprite.refreshTexture = !0), this._anims[e]
            },
            validateFrames: function(t, e) {
                void 0 === e && (e = !0);
                for (var i = 0; i < t.length; i++)
                    if (!0 === e) {
                        if (t[i] > this._frameData.total) return !1
                    } else if (!1 === this._frameData.checkFrameName(t[i])) return !1;
                return !0
            },
            play: function(t, e, i, s) {
                if (this._anims[t]) return this.currentAnim === this._anims[t] ? !1 === this.currentAnim.isPlaying ? (this.currentAnim.paused = !1, this.currentAnim.play(e, i, s)) : this.currentAnim : (this.currentAnim && this.currentAnim.isPlaying && this.currentAnim.stop(), this.currentAnim = this._anims[t], this.currentAnim.paused = !1, this.currentFrame = this.currentAnim.currentFrame, this.currentAnim.play(e, i, s))
            },
            stop: function(t, e) {
                void 0 === e && (e = !1), !this.currentAnim || "string" == typeof t && t !== this.currentAnim.name || this.currentAnim.stop(e)
            },
            update: function() {
                return !(this.updateIfVisible && !this.sprite.visible || !this.currentAnim || !this.currentAnim.update() || (this.currentFrame = this.currentAnim.currentFrame, 0))
            },
            next: function(t) {
                this.currentAnim && (this.currentAnim.next(t), this.currentFrame = this.currentAnim.currentFrame)
            },
            previous: function(t) {
                this.currentAnim && (this.currentAnim.previous(t), this.currentFrame = this.currentAnim.currentFrame)
            },
            getAnimation: function(t) {
                return "string" == typeof t && this._anims[t] ? this._anims[t] : null
            },
            refreshFrame: function() {},
            destroy: function() {
                for (var t in t = null, this._anims) this._anims.hasOwnProperty(t) && this._anims[t].destroy();
                this._anims = {}, this._outputFrames = [], this._frameData = null, this.currentAnim = null, this.currentFrame = null, this.sprite = null, this.game = null
            }
        }, t.AnimationManager.prototype.constructor = t.AnimationManager, Object.defineProperty(t.AnimationManager.prototype, "frameData", {
            get: function() {
                return this._frameData
            }
        }), Object.defineProperty(t.AnimationManager.prototype, "frameTotal", {
            get: function() {
                return this._frameData.total
            }
        }), Object.defineProperty(t.AnimationManager.prototype, "paused", {
            get: function() {
                return this.currentAnim.isPaused
            },
            set: function(t) {
                this.currentAnim.paused = t
            }
        }), Object.defineProperty(t.AnimationManager.prototype, "name", {
            get: function() {
                return this.currentAnim ? this.currentAnim.name : void 0
            }
        }), Object.defineProperty(t.AnimationManager.prototype, "frame", {
            get: function() {
                return this.currentFrame ? this.currentFrame.index : void 0
            },
            set: function(t) {
                var e;
                "number" == typeof t && this._frameData && (e = this._frameData.getFrame(t)) && (this.currentFrame = e, this.sprite.setFrame(this.currentFrame))
            }
        }), Object.defineProperty(t.AnimationManager.prototype, "frameName", {
            get: function() {
                return this.currentFrame ? this.currentFrame.name : void 0
            },
            set: function(t) {
                var e;
                "string" == typeof t && this._frameData && (e = this._frameData.getFrameByName(t)) ? (this.currentFrame = e, this._frameIndex = this.currentFrame.index, this.sprite.setFrame(this.currentFrame)) : console.warn("Cannot set frameName: " + t)
            }
        }), t.Animation = function(e, i, s, n, r, o, a) {
            void 0 === a && (a = !1), this.game = e, this._parent = i, this._frameData = n, this.name = s, this._frames = [], this._frames = this._frames.concat(r), this.delay = 1e3 / o, this.loop = a, this.loopCount = 0, this.killOnComplete = !1, this.isFinished = !1, this.isPlaying = !1, this.isPaused = !1, this._pauseStartTime = 0, this._frameIndex = 0, this._frameDiff = 0, this._frameSkip = 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.onStart = new t.Signal, this.onUpdate = null, this.onComplete = new t.Signal, this.onLoop = new t.Signal, this.isReversed = !1, this.game.onPause.add(this.onPause, this), this.game.onResume.add(this.onResume, this)
        }, t.Animation.prototype = {
            play: function(t, e, i) {
                return "number" == typeof t && (this.delay = 1e3 / t), "boolean" == typeof e && (this.loop = e), void 0 !== i && (this.killOnComplete = i), this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.time, this._timeNextFrame = this.game.time.time + this.delay, this._frameIndex = this.isReversed ? this._frames.length - 1 : 0, this.updateCurrentFrame(!1, !0), this._parent.events.onAnimationStart$dispatch(this._parent, this), this.onStart.dispatch(this._parent, this), this._parent.animations.currentAnim = this, this._parent.animations.currentFrame = this.currentFrame, this
            },
            restart: function() {
                this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.time, this._timeNextFrame = this.game.time.time + this.delay, this._frameIndex = 0, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this._parent.setFrame(this.currentFrame), this._parent.animations.currentAnim = this, this._parent.animations.currentFrame = this.currentFrame, this.onStart.dispatch(this._parent, this)
            },
            reverse: function() {
                return this.reversed = !this.reversed, this
            },
            reverseOnce: function() {
                return this.onComplete.addOnce(this.reverse, this), this.reverse()
            },
            setFrame: function(t, e) {
                var i;
                if (void 0 === e && (e = !1), "string" == typeof t)
                    for (s = 0; s < this._frames.length; s++) this._frameData.getFrame(this._frames[s]).name === t && (i = s);
                else if ("number" == typeof t)
                    if (e) i = t;
                    else
                        for (var s = 0; s < this._frames.length; s++) this._frames[s] === t && (i = s);
                if (i) {
                    var n = this.isReversed ? -1 : 1;
                    this._frameIndex = i - n, this._timeNextFrame = this.game.time.time, this.update()
                }
            },
            stop: function(t, e) {
                void 0 === t && (t = !1), void 0 === e && (e = !1), this.isPlaying = !1, this.isFinished = !0, this.paused = !1, t && (this.currentFrame = this._frameData.getFrame(this._frames[0]), this._parent.setFrame(this.currentFrame)), e && (this._parent.events.onAnimationComplete$dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this))
            },
            onPause: function() {
                this.isPlaying && (this._frameDiff = this._timeNextFrame - this.game.time.time)
            },
            onResume: function() {
                this.isPlaying && (this._timeNextFrame = this.game.time.time + this._frameDiff)
            },
            update: function() {
                if (this.isPaused) return !1;
                var t = this.game.time.time,
                    e = t - this._timeNextFrame;
                return !!(this.isPlaying && e >= 0) && (this._frameSkip = 1, this._frameDiff = e, this._timeLastFrame = t, this._frameDiff > this.delay && (this._frameSkip = Math.floor(this._frameDiff / this.delay), this._frameDiff -= this._frameSkip * this.delay), this._timeNextFrame = t + (this.delay - this._frameDiff), this.isReversed ? this._frameIndex -= this._frameSkip : this._frameIndex += this._frameSkip, !this.isReversed && this._frameIndex >= this._frames.length || this.isReversed && this._frameIndex <= -1 ? this.loop ? (this._frameIndex = Math.abs(this._frameIndex) % this._frames.length, this.isReversed && (this._frameIndex = this._frames.length - 1 - this._frameIndex), this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && this._parent.setFrame(this.currentFrame), this.loopCount++, this._parent.events.onAnimationLoop$dispatch(this._parent, this), this.onLoop.dispatch(this._parent, this), !this.onUpdate || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData)) : (this.complete(), !1) : this.updateCurrentFrame(!0))
            },
            updateCurrentFrame: function(t, e) {
                if (void 0 === e && (e = !1), !this._frameData) return !1;
                var i = this.currentFrame.index;
                return this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && (e || i !== this.currentFrame.index) && this._parent.setFrame(this.currentFrame), !this.onUpdate || !t || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData)
            },
            next: function(t) {
                void 0 === t && (t = 1);
                var e = this._frameIndex + t;
                e >= this._frames.length && (this.loop ? e %= this._frames.length : e = this._frames.length - 1), e !== this._frameIndex && (this._frameIndex = e, this.updateCurrentFrame(!0))
            },
            previous: function(t) {
                void 0 === t && (t = 1);
                var e = this._frameIndex - t;
                e < 0 && (this.loop ? e = this._frames.length + e : e++), e !== this._frameIndex && (this._frameIndex = e, this.updateCurrentFrame(!0))
            },
            updateFrameData: function(t) {
                this._frameData = t, this.currentFrame = this._frameData ? this._frameData.getFrame(this._frames[this._frameIndex % this._frames.length]) : null
            },
            destroy: function() {
                this._frameData && (this.game.onPause.remove(this.onPause, this), this.game.onResume.remove(this.onResume, this), this.game = null, this._parent = null, this._frames = null, this._frameData = null, this.currentFrame = null, this.isPlaying = !1, this.onStart.dispose(), this.onLoop.dispose(), this.onComplete.dispose(), this.onUpdate && this.onUpdate.dispose())
            },
            complete: function() {
                this._frameIndex = this._frames.length - 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.updateCurrentFrame(!1), this.isPlaying = !1, this.isFinished = !0, this.paused = !1, this._parent.events.onAnimationComplete$dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this), this.killOnComplete && this._parent.kill()
            }
        }, t.Animation.prototype.constructor = t.Animation, Object.defineProperty(t.Animation.prototype, "paused", {
            get: function() {
                return this.isPaused
            },
            set: function(t) {
                this.isPaused = t, t ? this._pauseStartTime = this.game.time.time : this.isPlaying && (this._timeNextFrame = this.game.time.time + this.delay)
            }
        }), Object.defineProperty(t.Animation.prototype, "reversed", {
            get: function() {
                return this.isReversed
            },
            set: function(t) {
                this.isReversed = t
            }
        }), Object.defineProperty(t.Animation.prototype, "frameTotal", {
            get: function() {
                return this._frames.length
            }
        }), Object.defineProperty(t.Animation.prototype, "frame", {
            get: function() {
                return null !== this.currentFrame ? this.currentFrame.index : this._frameIndex
            },
            set: function(t) {
                this.currentFrame = this._frameData.getFrame(this._frames[t]), null !== this.currentFrame && (this._frameIndex = t, this._parent.setFrame(this.currentFrame), this.onUpdate && this.onUpdate.dispatch(this, this.currentFrame))
            }
        }), Object.defineProperty(t.Animation.prototype, "speed", {
            get: function() {
                return 1e3 / this.delay
            },
            set: function(t) {
                t > 0 && (this.delay = 1e3 / t)
            }
        }), Object.defineProperty(t.Animation.prototype, "enableUpdate", {
            get: function() {
                return null !== this.onUpdate
            },
            set: function(e) {
                e && null === this.onUpdate ? this.onUpdate = new t.Signal : e || null === this.onUpdate || (this.onUpdate.dispose(), this.onUpdate = null)
            }
        }), t.Animation.generateFrameNames = function(e, i, s, n, r) {
            void 0 === n && (n = "");
            var o = [],
                a = "";
            if (i < s)
                for (h = i; h <= s; h++) a = e + (a = "number" == typeof r ? t.Utils.pad(h.toString(), r, "0", 1) : h.toString()) + n, o.push(a);
            else
                for (var h = i; h >= s; h--) a = e + (a = "number" == typeof r ? t.Utils.pad(h.toString(), r, "0", 1) : h.toString()) + n, o.push(a);
            return o
        }, t.Frame = function(e, i, s, n, r, o) {
            this.index = e, this.x = i, this.y = s, this.width = n, this.height = r, 0 !== this.width && 0 !== this.height || console.warn('Phaser.Frame: Frame "' + this.name + '" has a width or height of zero'), this.name = o, this.centerX = Math.floor(n / 2), this.centerY = Math.floor(r / 2), this.distance = t.Math.distance(0, 0, n, r), this.rotated = !1, this.trimmed = !1, this.sourceSizeW = n, this.sourceSizeH = r, this.spriteSourceSizeX = 0, this.spriteSourceSizeY = 0, this.spriteSourceSizeW = 0, this.spriteSourceSizeH = 0, this.right = this.x + this.width, this.bottom = this.y + this.height
        }, t.Frame.prototype = {
            resize: function(e, i) {
                this.width = e, this.height = i, this.centerX = Math.floor(e / 2), this.centerY = Math.floor(i / 2), this.distance = t.Math.distance(0, 0, e, i), this.sourceSizeW = e, this.sourceSizeH = i, this.right = this.x + e, this.bottom = this.y + i
            },
            setTrim: function(t, e, i, s, n, r, o) {
                this.trimmed = t, t && (this.sourceSizeW = e, this.sourceSizeH = i, this.centerX = Math.floor(e / 2), this.centerY = Math.floor(i / 2), this.spriteSourceSizeX = s, this.spriteSourceSizeY = n, this.spriteSourceSizeW = r, this.spriteSourceSizeH = o)
            },
            clone: function() {
                var e = new t.Frame(this.index, this.x, this.y, this.width, this.height, this.name);
                for (var i in this) this.hasOwnProperty(i) && (e[i] = this[i]);
                return e
            },
            getRect: function(e) {
                return void 0 === e ? e = new t.Rectangle(this.x, this.y, this.width, this.height) : e.setTo(this.x, this.y, this.width, this.height), e
            }
        }, t.Frame.prototype.constructor = t.Frame, t.FrameData = function() {
            this._frames = [], this._frameNames = []
        }, t.FrameData.prototype = {
            addFrame: function(t) {
                return t.index = this._frames.length, this._frames.push(t), "" !== t.name && (this._frameNames[t.name] = t.index), t
            },
            getFrame: function(t) {
                return t >= this._frames.length && (t = 0), this._frames[t]
            },
            getFrameByName: function(t) {
                return "number" == typeof this._frameNames[t] ? this._frames[this._frameNames[t]] : null
            },
            checkFrameName: function(t) {
                return null != this._frameNames[t]
            },
            clone: function() {
                for (var e = new t.FrameData, i = 0; i < this._frames.length; i++) e._frames.push(this._frames[i].clone());
                for (var s in this._frameNames) this._frameNames.hasOwnProperty(s) && e._frameNames.push(this._frameNames[s]);
                return e
            },
            getFrameRange: function(t, e, i) {
                void 0 === i && (i = []);
                for (var s = t; s <= e; s++) i.push(this._frames[s]);
                return i
            },
            getFrames: function(t, e, i) {
                if (void 0 === e && (e = !0), void 0 === i && (i = []), void 0 === t || 0 === t.length)
                    for (s = 0; s < this._frames.length; s++) i.push(this._frames[s]);
                else
                    for (var s = 0; s < t.length; s++) e ? i.push(this.getFrame(t[s])) : i.push(this.getFrameByName(t[s]));
                return i
            },
            getFrameIndexes: function(t, e, i) {
                if (void 0 === e && (e = !0), void 0 === i && (i = []), void 0 === t || 0 === t.length)
                    for (s = 0; s < this._frames.length; s++) i.push(this._frames[s].index);
                else
                    for (var s = 0; s < t.length; s++) e && this._frames[t[s]] ? i.push(this._frames[t[s]].index) : this.getFrameByName(t[s]) && i.push(this.getFrameByName(t[s]).index);
                return i
            },
            destroy: function() {
                this._frames = null, this._frameNames = null
            }
        }, t.FrameData.prototype.constructor = t.FrameData, Object.defineProperty(t.FrameData.prototype, "total", {
            get: function() {
                return this._frames.length
            }
        }), t.AnimationParser = {
            spriteSheet: function(e, i, s, n, r, o, a, h) {
                void 0 === r && (r = -1), void 0 === o && (o = 0), void 0 === a && (a = 0), void 0 === h && (h = 0);
                var l = i;
                if ("string" == typeof i ? l = e.cache.getImage(i) : i = l.name, null === l) return null;
                if (s <= 0 || n <= 0) return console.warn("Phaser.AnimationParser.spriteSheet: '%s' frameWidth (%s) or frameHeight (%s) must be positive", i, s, n), null;
                var c = l.width,
                    u = l.height;
                if (0 === c || 0 === u) return console.warn("Phaser.AnimationParser.spriteSheet: '%s' width (%s) or height (%s) is zero", i, c, u), null;
                if (c < s || u < n) return console.warn("Phaser.AnimationParser.spriteSheet: '%s' width (%s) or height (%s) is less than the given frameWidth (%s) or frameHeight (%s)", i, c, u, s, n), null;
                var d = Math.floor((c - o) / (s + a)),
                    p = Math.floor((u - o) / (n + a)),
                    f = d * p,
                    g = f,
                    m = f - 1,
                    y = 0,
                    v = m;
                if (h > f || h < -f) return console.warn("Phaser.AnimationParser.spriteSheet: '%s' skipFrames = %s is larger than the frame total %s", i, h, f), null;
                if (r > -1 && (v = (f = r) - 1), d < 1 && console.warn("Phaser.AnimationParser.spriteSheet: image '%s' has width %d, but it should be at least %d (frameWidth=%s, margin=%s, spacing=%s)", i, c, s + o + a, s, o, a), p < 1 && console.warn("Phaser.AnimationParser.spriteSheet: image '%s' has height %d, but it should be at least %d (frameHeight=%s, margin=%s, spacing=%s)", i, u, n + o + a, n, o, a), 0 === g) return console.warn("Phaser.AnimationParser.spriteSheet: '%s' zero frames were produced", i), null;
                if (h > 0 ? v = (y = h) + (f = Math.min(f, g - h)) - 1 : h < 0 && (y = (v = m + h) - (f = Math.min(f, g + h)) + 1), y < 0) return console.warn("First frame index %s is outside of range [0, %d]", y, m), null;
                if (v > m) return console.warn("Last frame index %s is outside of range [0, %d]", v, m), null;
                for (var x = new t.FrameData, b = o, _ = o, w = 0, T = 0; T < g && !(T > v); T++) T >= y && x.addFrame(new t.Frame(w++, b, _, s, n, "")), (b += s + a) + s > c && (b = o, _ += n + a);
                return x
            },
            JSONData: function(e, i) {
                if (!i.frames) return console.warn("Phaser.AnimationParser.JSONData: Invalid Texture Atlas JSON given, missing 'frames' array"), void gradle.event(i);
                for (var s, n = new t.FrameData, r = i.frames, o = 0; o < r.length; o++) s = n.addFrame(new t.Frame(o, r[o].frame.x, r[o].frame.y, r[o].frame.w, r[o].frame.h, r[o].filename)), r[o].trimmed && s.setTrim(r[o].trimmed, r[o].sourceSize.w, r[o].sourceSize.h, r[o].spriteSourceSize.x, r[o].spriteSourceSize.y, r[o].spriteSourceSize.w, r[o].spriteSourceSize.h), r[o].rotated && (s.rotated = !0);
                return n
            },
            JSONDataPyxel: function(e, i) {
                if (["layers", "tilewidth", "tileheight", "tileswide", "tileshigh"].forEach(function(t) {
                        if (!i[t]) return console.warn('Phaser.AnimationParser.JSONDataPyxel: Invalid Pyxel Tilemap JSON given, missing "' + t + '" key.'), void gradle.event(i)
                    }), 1 !== i.layers.length) return console.warn("Phaser.AnimationParser.JSONDataPyxel: Too many layers, this parser only supports flat Tilemaps."), void gradle.event(i);
                for (var s = new t.FrameData, n = i.tileheight, r = i.tilewidth, o = i.layers[0].tiles, a = 0; a < o.length; a++) s.addFrame(new t.Frame(a, o[a].x, o[a].y, r, n, "frame_" + a)).setTrim(!1);
                return s
            },
            JSONDataHash: function(e, i) {
                if (!i.frames) return console.warn("Phaser.AnimationParser.JSONDataHash: Invalid Texture Atlas JSON given, missing 'frames' object"), void gradle.event(i);
                var s, n = new t.FrameData,
                    r = i.frames,
                    o = 0;
                for (var a in r) s = n.addFrame(new t.Frame(o, r[a].frame.x, r[a].frame.y, r[a].frame.w, r[a].frame.h, a)), r[a].trimmed && s.setTrim(r[a].trimmed, r[a].sourceSize.w, r[a].sourceSize.h, r[a].spriteSourceSize.x, r[a].spriteSourceSize.y, r[a].spriteSourceSize.w, r[a].spriteSourceSize.h), r[a].rotated && (s.rotated = !0), o++;
                return n
            },
            XMLData: function(e, i) {
                if (i.getElementsByTagName("TextureAtlas")) {
                    for (var s, n, r, o, a, h, l, c, u, d, p, f = new t.FrameData, g = i.getElementsByTagName("SubTexture"), m = 0; m < g.length; m++) n = (r = g[m].attributes).name.value, o = parseInt(r.x.value, 10), a = parseInt(r.y.value, 10), h = parseInt(r.width.value, 10), l = parseInt(r.height.value, 10), c = null, u = null, r.frameX && (c = Math.abs(parseInt(r.frameX.value, 10)), u = Math.abs(parseInt(r.frameY.value, 10)), d = parseInt(r.frameWidth.value, 10), p = parseInt(r.frameHeight.value, 10)), s = f.addFrame(new t.Frame(m, o, a, h, l, n)), null === c && null === u || s.setTrim(!0, h, l, c, u, d, p);
                    return f
                }
                console.warn("Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag")
            }
        }, t.Cache = function(e) {
            this.game = e, this.autoResolveURL = !1, this._cache = {
                canvas: {},
                image: {},
                texture: {},
                sound: {},
                video: {},
                text: {},
                json: {},
                xml: {},
                physics: {},
                tilemap: {},
                binary: {},
                bitmapData: {},
                bitmapFont: {},
                shader: {},
                renderTexture: {},
                compressedTexture: {}
            }, this._urlMap = {}, this._urlResolver = new Image, this._urlTemp = null, this.onSoundUnlock = new t.Signal, this._cacheMap = [], this._cacheMap[t.Cache.CANVAS] = this._cache.canvas, this._cacheMap[t.Cache.IMAGE] = this._cache.image, this._cacheMap[t.Cache.TEXTURE] = this._cache.texture, this._cacheMap[t.Cache.SOUND] = this._cache.sound, this._cacheMap[t.Cache.TEXT] = this._cache.text, this._cacheMap[t.Cache.PHYSICS] = this._cache.physics, this._cacheMap[t.Cache.TILEMAP] = this._cache.tilemap, this._cacheMap[t.Cache.BINARY] = this._cache.binary, this._cacheMap[t.Cache.BITMAPDATA] = this._cache.bitmapData, this._cacheMap[t.Cache.BITMAPFONT] = this._cache.bitmapFont, this._cacheMap[t.Cache.JSON] = this._cache.json, this._cacheMap[t.Cache.XML] = this._cache.xml, this._cacheMap[t.Cache.VIDEO] = this._cache.video, this._cacheMap[t.Cache.SHADER] = this._cache.shader, this._cacheMap[t.Cache.RENDER_TEXTURE] = this._cache.renderTexture, this._pendingCount = 0, this.onReady = new t.Signal, this._addImages()
        }, t.Cache.CANVAS = 1, t.Cache.IMAGE = 2, t.Cache.TEXTURE = 3, t.Cache.SOUND = 4, t.Cache.TEXT = 5, t.Cache.PHYSICS = 6, t.Cache.TILEMAP = 7, t.Cache.BINARY = 8, t.Cache.BITMAPDATA = 9, t.Cache.BITMAPFONT = 10, t.Cache.JSON = 11, t.Cache.XML = 12, t.Cache.VIDEO = 13, t.Cache.SHADER = 14, t.Cache.RENDER_TEXTURE = 15, t.Cache.DEFAULT = null, t.Cache.DEFAULT_KEY = "__default", t.Cache.DEFAULT_SRC = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==", t.Cache.MISSING = null, t.Cache.MISSING_KEY = "__missing", t.Cache.MISSING_SRC = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==", t.Cache.READY_TIMEOUT = 1e3, t.Cache.prototype = {
            addCompressedTextureMetaData: function(e, i, s, n) {
                this.checkImageKey(e) && this.removeImage(e);
                var r = s in t.LoaderParser ? t.LoaderParser[s](n) : n,
                    o = {
                        key: e,
                        url: i,
                        data: r,
                        base: new PIXI.BaseTexture(r, null, this.game.resolution),
                        frame: new t.Frame(0, 0, 0, r.width, r.height, e),
                        frameData: new t.FrameData,
                        fileFormat: s
                    };
                return o.frameData.addFrame(new t.Frame(0, 0, 0, r.width, r.height, i)), this._cache.image[e] = o, this._resolveURL(i, o), o
            },
            addCanvas: function(t, e, i) {
                void 0 === i && (i = e.getContext("2d")), this._cache.canvas[t] = {
                    canvas: e,
                    context: i
                }
            },
            addImage: function(e, i, s) {
                this.checkImageKey(e) && this.removeImage(e), !1 === s.complete && console.warn('Phaser.Cache.addImage: Image "%s" is not complete', e);
                var n = {
                    key: e,
                    url: i,
                    data: s,
                    base: new PIXI.BaseTexture(s, null, this.game.resolution),
                    frame: new t.Frame(0, 0, 0, s.width, s.height, e),
                    frameData: new t.FrameData
                };
                return n.frameData.addFrame(new t.Frame(0, 0, 0, s.width, s.height, i)), this._cache.image[e] = n, this._resolveURL(i, n), "__default" === e ? t.Cache.DEFAULT = new PIXI.Texture(n.base) : "__missing" === e && (t.Cache.MISSING = new PIXI.Texture(n.base)), n
            },
            addImageAsync: function(t, e, i) {
                var s = this,
                    n = new Image;
                n.onload = function() {
                    i.call(this, s.addImage(t, null, n)), s._removePending(), n.onload = null
                }, this._addPending(), n.src = e
            },
            addDefaultImage: function() {
                this.addImageAsync(t.Cache.DEFAULT_KEY, t.Cache.DEFAULT_SRC, function(e) {
                    e.base.skipRender = !0, t.Cache.DEFAULT = new PIXI.Texture(e.base)
                })
            },
            addMissingImage: function() {
                this.addImageAsync(t.Cache.MISSING_KEY, t.Cache.MISSING_SRC, function(e) {
                    t.Cache.MISSING = new PIXI.Texture(e.base)
                })
            },
            addSound: function(t, e, i, s, n) {
                void 0 === s && (s = !0, n = !1), void 0 === n && (s = !1, n = !0);
                var r = !1;
                n && (r = !0), this._cache.sound[t] = {
                    url: e,
                    data: i,
                    isDecoding: !1,
                    decoded: r,
                    webAudio: s,
                    audioTag: n,
                    locked: this.game.sound.touchLocked
                }, this._resolveURL(e, this._cache.sound[t])
            },
            addText: function(t, e, i) {
                this._cache.text[t] = {
                    url: e,
                    data: i
                }, this._resolveURL(e, this._cache.text[t])
            },
            addPhysicsData: function(t, e, i, s) {
                this._cache.physics[t] = {
                    url: e,
                    data: i,
                    format: s
                }, this._resolveURL(e, this._cache.physics[t])
            },
            addTilemap: function(t, e, i, s) {
                this._cache.tilemap[t] = {
                    url: e,
                    data: i,
                    format: s
                }, this._resolveURL(e, this._cache.tilemap[t])
            },
            addBinary: function(t, e) {
                this._cache.binary[t] = e
            },
            addBitmapData: function(e, i, s) {
                return i.key = e, void 0 === s && (s = new t.FrameData).addFrame(i.textureFrame), this._cache.bitmapData[e] = {
                    data: i,
                    frameData: s
                }, i
            },
            addBitmapFont: function(e, i, s, n, r, o, a) {
                var h = {
                    url: i,
                    data: s,
                    font: null,
                    base: new PIXI.BaseTexture(s, null, this.game.resolution)
                };
                void 0 === o && (o = 0), void 0 === a && (a = 0), h.font = "json" === r ? t.LoaderParser.jsonBitmapFont(n, h.base, o, a, !1, this.game.resolution) : t.LoaderParser.xmlBitmapFont(n, h.base, o, a, !1, this.game.resolution), this._cache.bitmapFont[e] = h, this._resolveURL(i, h)
            },
            addBitmapFontFromAtlas: function(e, i, s, n, r, o, a) {
                var h = this.getFrameByName(i, s);
                if (h) {
                    var l, c = {
                        font: null,
                        base: this.getBaseTexture(i),
                        frame: h
                    };
                    void 0 === o && (o = 0), void 0 === a && (a = 0), "json" === r ? (l = this.getJSON(n), c.font = t.LoaderParser.jsonBitmapFont(l, c.base, o, a, h, this.game.resolution)) : (l = this.getXML(n), c.font = t.LoaderParser.xmlBitmapFont(l, c.base, o, a, h, this.game.resolution)), this._cache.bitmapFont[e] = c
                }
            },
            addJSON: function(t, e, i) {
                this._cache.json[t] = {
                    url: e,
                    data: i
                }, this._resolveURL(e, this._cache.json[t])
            },
            addXML: function(t, e, i) {
                this._cache.xml[t] = {
                    url: e,
                    data: i
                }, this._resolveURL(e, this._cache.xml[t])
            },
            addVideo: function(t, e, i, s) {
                this._cache.video[t] = {
                    url: e,
                    data: i,
                    isBlob: s,
                    locked: !0
                }, this._resolveURL(e, this._cache.video[t])
            },
            addShader: function(t, e, i) {
                this._cache.shader[t] = {
                    url: e,
                    data: i
                }, this._resolveURL(e, this._cache.shader[t])
            },
            addRenderTexture: function(e, i) {
                this._cache.renderTexture[e] = {
                    texture: i,
                    frame: new t.Frame(0, 0, 0, i.width, i.height, "", "")
                }
            },
            addSpriteSheet: function(e, i, s, n, r, o, a, h, l) {
                void 0 === o && (o = -1), void 0 === a && (a = 0), void 0 === h && (h = 0);
                var c = {
                    key: e,
                    url: i,
                    data: s,
                    frameWidth: n,
                    frameHeight: r,
                    margin: a,
                    spacing: h,
                    base: new PIXI.BaseTexture(s, null, this.game.resolution),
                    frameData: t.AnimationParser.spriteSheet(this.game, s, n, r, o, a, h, l)
                };
                this._cache.image[e] = c, this._resolveURL(i, c)
            },
            addTextureAtlas: function(e, i, s, n, r) {
                var o = {
                    key: e,
                    url: i,
                    data: s,
                    base: new PIXI.BaseTexture(s, null, this.game.resolution)
                };
                r === t.Loader.TEXTURE_ATLAS_XML_STARLING ? o.frameData = t.AnimationParser.XMLData(this.game, n, e) : r === t.Loader.TEXTURE_ATLAS_JSON_PYXEL ? o.frameData = t.AnimationParser.JSONDataPyxel(this.game, n, e) : Array.isArray(n.frames) ? o.frameData = t.AnimationParser.JSONData(this.game, n, e) : o.frameData = t.AnimationParser.JSONDataHash(this.game, n, e), this._cache.image[e] = o, this._resolveURL(i, o)
            },
            reloadSound: function(t) {
                var e = this,
                    i = this.getSound(t);
                i && (i.data.src = i.url, i.data.addEventListener("canplaythrough", function() {
                    return e.reloadSoundComplete(t)
                }, !1), i.data.load())
            },
            reloadSoundComplete: function(t) {
                var e = this.getSound(t);
                e && (e.locked = !1, this.onSoundUnlock.dispatch(t))
            },
            updateSound: function(t, e, i) {
                var s = this.getSound(t);
                s && (s[e] = i)
            },
            decodedSound: function(t, e) {
                var i = this.getSound(t);
                i.data = e, i.decoded = !0, i.isDecoding = !1
            },
            isSoundDecoded: function(e) {
                var i = this.getItem(e, t.Cache.SOUND, "isSoundDecoded");
                if (i) return i.decoded
            },
            isSoundReady: function(e) {
                var i = this.getItem(e, t.Cache.SOUND, "isSoundDecoded");
                if (i) return i.decoded && !this.game.sound.touchLocked
            },
            checkKey: function(t, e) {
                return !!this._cacheMap[t][e]
            },
            checkURL: function(t) {
                return !!this._urlMap[this._resolveURL(t)]
            },
            checkCanvasKey: function(e) {
                return this.checkKey(t.Cache.CANVAS, e)
            },
            checkImageKey: function(e) {
                return this.checkKey(t.Cache.IMAGE, e)
            },
            checkTextureKey: function(e) {
                return this.checkKey(t.Cache.TEXTURE, e)
            },
            checkSoundKey: function(e) {
                return this.checkKey(t.Cache.SOUND, e)
            },
            checkTextKey: function(e) {
                return this.checkKey(t.Cache.TEXT, e)
            },
            checkPhysicsKey: function(e) {
                return this.checkKey(t.Cache.PHYSICS, e)
            },
            checkTilemapKey: function(e) {
                return this.checkKey(t.Cache.TILEMAP, e)
            },
            checkBinaryKey: function(e) {
                return this.checkKey(t.Cache.BINARY, e)
            },
            checkBitmapDataKey: function(e) {
                return this.checkKey(t.Cache.BITMAPDATA, e)
            },
            checkBitmapFontKey: function(e) {
                return this.checkKey(t.Cache.BITMAPFONT, e)
            },
            checkJSONKey: function(e) {
                return this.checkKey(t.Cache.JSON, e)
            },
            checkXMLKey: function(e) {
                return this.checkKey(t.Cache.XML, e)
            },
            checkVideoKey: function(e) {
                return this.checkKey(t.Cache.VIDEO, e)
            },
            checkShaderKey: function(e) {
                return this.checkKey(t.Cache.SHADER, e)
            },
            checkRenderTextureKey: function(e) {
                return this.checkKey(t.Cache.RENDER_TEXTURE, e)
            },
            getItem: function(t, e, i, s) {
                return this.checkKey(e, t) ? void 0 === s ? this._cacheMap[e][t] : this._cacheMap[e][t][s] : (i && console.warn("Phaser.Cache." + i + ': Key "' + t + '" not found in Cache.'), null)
            },
            getCanvas: function(e) {
                return this.getItem(e, t.Cache.CANVAS, "getCanvas", "canvas")
            },
            getImage: function(e, i) {
                null != e || (e = "__default"), void 0 === i && (i = !1);
                var s = this.getItem(e, t.Cache.IMAGE, "getImage");
                return null === s && (s = this.getItem("__missing", t.Cache.IMAGE, "getImage")), i ? s : s.data
            },
            getTextureFrame: function(e) {
                return this.getItem(e, t.Cache.TEXTURE, "getTextureFrame", "frame")
            },
            getSound: function(e) {
                return this.getItem(e, t.Cache.SOUND, "getSound")
            },
            getSoundData: function(e) {
                return this.getItem(e, t.Cache.SOUND, "getSoundData", "data")
            },
            getText: function(e) {
                return this.getItem(e, t.Cache.TEXT, "getText", "data")
            },
            getPhysicsData: function(e, i, s) {
                var n = this.getItem(e, t.Cache.PHYSICS, "getPhysicsData", "data");
                if (null === n || null == i) return n;
                if (n[i]) {
                    var r = n[i];
                    if (!r || !s) return r;
                    for (var o in r)
                        if ((o = r[o]).fixtureKey === s) return o;
                    console.warn('Phaser.Cache.getPhysicsData: Could not find given fixtureKey: "' + s + " in " + e + '"')
                } else console.warn('Phaser.Cache.getPhysicsData: Invalid key/object: "' + e + " / " + i + '"');
                return null
            },
            getTilemapData: function(e) {
                return this.getItem(e, t.Cache.TILEMAP, "getTilemapData")
            },
            getBinary: function(e) {
                return this.getItem(e, t.Cache.BINARY, "getBinary")
            },
            getBitmapData: function(e) {
                return this.getItem(e, t.Cache.BITMAPDATA, "getBitmapData", "data")
            },
            getBitmapFont: function(e) {
                return this.getItem(e, t.Cache.BITMAPFONT, "getBitmapFont")
            },
            getJSON: function(e, i) {
                var s = this.getItem(e, t.Cache.JSON, "getJSON", "data");
                return s ? i ? t.Utils.extend(!0, Array.isArray(s) ? [] : {}, s) : s : null
            },
            getXML: function(e) {
                return this.getItem(e, t.Cache.XML, "getXML", "data")
            },
            getVideo: function(e) {
                return this.getItem(e, t.Cache.VIDEO, "getVideo")
            },
            getShader: function(e) {
                return this.getItem(e, t.Cache.SHADER, "getShader", "data")
            },
            getRenderTexture: function(e) {
                return this.getItem(e, t.Cache.RENDER_TEXTURE, "getRenderTexture")
            },
            getBaseTexture: function(e, i) {
                return void 0 === i && (i = t.Cache.IMAGE), this.getItem(e, i, "getBaseTexture", "base")
            },
            getFrame: function(e, i) {
                return void 0 === i && (i = t.Cache.IMAGE), this.getItem(e, i, "getFrame", "frame")
            },
            getFrameCount: function(t, e) {
                var i = this.getFrameData(t, e);
                return i ? i.total : 0
            },
            getFrameData: function(e, i) {
                return void 0 === i && (i = t.Cache.IMAGE), this.getItem(e, i, "getFrameData", "frameData")
            },
            hasFrameData: function(e, i) {
                return void 0 === i && (i = t.Cache.IMAGE), null !== this.getItem(e, i, "", "frameData")
            },
            updateFrameData: function(e, i, s) {
                void 0 === s && (s = t.Cache.IMAGE), this._cacheMap[s][e] && (this._cacheMap[s][e].frameData = i)
            },
            getFrameByIndex: function(t, e, i) {
                var s = this.getFrameData(t, i);
                return s ? s.getFrame(e) : null
            },
            getFrameByName: function(t, e, i) {
                var s = this.getFrameData(t, i);
                return s ? s.getFrameByName(e) : null
            },
            getURL: function(t) {
                return (t = this._resolveURL(t)) ? this._urlMap[t] : (console.warn('Phaser.Cache.getUrl: Invalid url: "' + t + '" or Cache.autoResolveURL was false'), null)
            },
            getKeys: function(e) {
                void 0 === e && (e = t.Cache.IMAGE);
                var i = [];
                if (this._cacheMap[e])
                    for (var s in this._cacheMap[e]) "__default" !== s && "__missing" !== s && i.push(s);
                return i
            },
            removeCanvas: function(t) {
                delete this._cache.canvas[t]
            },
            removeImage: function(t, e) {
                void 0 === e && (e = !0);
                var i = this.getImage(t, !0);
                e && i.base && i.base.destroy(), delete this._cache.image[t]
            },
            removeSound: function(t) {
                delete this._cache.sound[t]
            },
            removeText: function(t) {
                delete this._cache.text[t]
            },
            removePhysics: function(t) {
                delete this._cache.physics[t]
            },
            removeTilemap: function(t) {
                delete this._cache.tilemap[t]
            },
            removeBinary: function(t) {
                delete this._cache.binary[t]
            },
            removeBitmapData: function(t) {
                delete this._cache.bitmapData[t]
            },
            removeBitmapFont: function(t) {
                delete this._cache.bitmapFont[t]
            },
            removeJSON: function(t) {
                delete this._cache.json[t]
            },
            removeXML: function(t) {
                delete this._cache.xml[t]
            },
            removeVideo: function(t) {
                delete this._cache.video[t]
            },
            removeShader: function(t) {
                delete this._cache.shader[t]
            },
            removeRenderTexture: function(t) {
                delete this._cache.renderTexture[t]
            },
            removeSpriteSheet: function(t) {
                delete this._cache.spriteSheet[t]
            },
            removeTextureAtlas: function(t) {
                delete this._cache.image[t]
            },
            clearGLTextures: function() {
                for (var t in this._cache.image) this._cache.image[t].base._glTextures = []
            },
            _resolveURL: function(t, e) {
                return this.autoResolveURL ? (this._urlResolver.src = this.game.load.baseURL + t, this._urlTemp = this._urlResolver.src, this._urlResolver.src = "", e && (this._urlMap[this._urlTemp] = e), this._urlTemp) : null
            },
            destroy: function() {
                for (var t = 0; t < this._cacheMap.length; t++) {
                    var e = this._cacheMap[t];
                    for (var i in e) "__default" !== i && "__missing" !== i && (this.destroyItem(e[i]), delete e[i])
                }
                this._urlMap = null, this._urlResolver = null, this._urlTemp = null
            },
            destroyItem: function(t) {
                t.destroy ? t.destroy() : (t.base && t.base.destroy && t.base.destroy(), t.data && t.data.destroy && t.data.destroy(), t.frameData && t.frameData.destroy && t.frameData.destroy(), t.texture && t.texture.destroy && t.texture.destroy(!0))
            },
            _addImages: function() {
                this._pendingCount = 0, this.addDefaultImage(), this.addMissingImage();
                var e = this,
                    i = t.Cache.READY_TIMEOUT;
                t.Cache.READY_TIMEOUT > 0 ? setTimeout(function() {
                    e.isReady || (console.warn("Phaser.Cache: Still waiting for images after %s ms.", i), e._ready())
                }, t.Cache.READY_TIMEOUT) : this._ready()
            },
            _addPending: function() {
                this._pendingCount += 1
            },
            _removePending: function() {
                this._pendingCount -= 1, this._checkReady()
            },
            _checkReady: function() {
                this.isReady && this._ready()
            },
            _ready: function() {
                this._pendingCount = 0, this.onReady.dispatch(this)
            }
        }, t.Cache.prototype.constructor = t.Cache, Object.defineProperty(t.Cache.prototype, "isReady", {
            get: function() {
                return this._pendingCount <= 0
            }
        }), t.Loader = function(e) {
            this.game = e, this.cache = e.cache, this.resetLocked = !1, this.isLoading = !1, this.hasLoaded = !1, this.preloadSprite = null, this.crossOrigin = !1, this.baseURL = "", this.path = "", this.headers = {
                requestedWith: !1,
                json: "application/json",
                xml: "application/xml"
            }, this.onLoadStart = new t.Signal, this.onBeforeLoadComplete = new t.Signal, this.onLoadComplete = new t.Signal, this.onPackComplete = new t.Signal, this.onFileStart = new t.Signal, this.onFileComplete = new t.Signal, this.onFileError = new t.Signal, this.enableParallel = !0, this.maxParallelDownloads = 4, this._withSyncPointDepth = 0, this._fileList = [], this._flightQueue = [], this._processingHead = 0, this._fileLoadStarted = !1, this._totalPackCount = 0, this._totalFileCount = 0, this._loadedPackCount = 0, this._loadedFileCount = 0
        }, t.Loader.TEXTURE_ATLAS_JSON_ARRAY = 0, t.Loader.TEXTURE_ATLAS_JSON_HASH = 1, t.Loader.TEXTURE_ATLAS_XML_STARLING = 2, t.Loader.PHYSICS_LIME_CORONA_JSON = 3, t.Loader.PHYSICS_PHASER_JSON = 4, t.Loader.TEXTURE_ATLAS_JSON_PYXEL = 5, t.Loader.prototype = {
            setPreloadSprite: function(e, i) {
                i = i || 0, this.preloadSprite = {
                    sprite: e,
                    direction: i,
                    width: e.width,
                    height: e.height,
                    rect: null
                }, this.preloadSprite.rect = 0 === i ? new t.Rectangle(0, 0, 1, e.height) : new t.Rectangle(0, 0, e.width, 1), e.crop(this.preloadSprite.rect), e.visible = !0
            },
            resize: function() {
                this.preloadSprite && this.preloadSprite.height !== this.preloadSprite.sprite.height && (this.preloadSprite.rect.height = this.preloadSprite.sprite.height)
            },
            checkKeyExists: function(t, e) {
                return this.getAssetIndex(t, e) > -1
            },
            getAssetIndex: function(t, e) {
                for (var i = -1, s = 0; s < this._fileList.length; s++) {
                    var n = this._fileList[s];
                    if (n.type === t && n.key === e && (i = s, !n.loaded && !n.loading)) break
                }
                return i
            },
            getAsset: function(t, e) {
                var i = this.getAssetIndex(t, e);
                return i > -1 && {
                    index: i,
                    file: this._fileList[i]
                }
            },
            reset: function(t, e) {
                void 0 === e && (e = !1), this.resetLocked || (t && (this.preloadSprite = null), this.isLoading = !1, this._processingHead = 0, this._fileList.length = 0, this._flightQueue.length = 0, this._fileLoadStarted = !1, this._totalFileCount = 0, this._totalPackCount = 0, this._loadedPackCount = 0, this._loadedFileCount = 0, e && (this.onLoadStart.removeAll(), this.onLoadComplete.removeAll(), this.onPackComplete.removeAll(), this.onFileStart.removeAll(), this.onFileComplete.removeAll(), this.onFileError.removeAll()))
            },
            addToFileList: function(t, e, i, s, n, r) {
                if (void 0 === n && (n = !1), void 0 === e || "" === e) return console.warn("Phaser.Loader: Invalid or no key given of type " + t), this;
                if (null == i) {
                    if (!r) return console.warn("Phaser.Loader: No URL given for file type: " + t + " key: " + e), this;
                    i = e + r
                }
                var o = {
                    type: t,
                    key: e,
                    path: this.path,
                    url: i,
                    syncPoint: this._withSyncPointDepth > 0,
                    data: null,
                    loading: !1,
                    loaded: !1,
                    error: !1
                };
                if (s)
                    for (var a in s) o[a] = s[a];
                var h = this.getAssetIndex(t, e);
                if (n && h > -1) {
                    var l = this._fileList[h];
                    l.loading || l.loaded ? (this._fileList.push(o), this._totalFileCount++) : this._fileList[h] = o
                } else -1 === h && (this._fileList.push(o), this._totalFileCount++);
                return this
            },
            replaceInFileList: function(t, e, i, s) {
                return this.addToFileList(t, e, i, s, !0)
            },
            pack: function(t, e, i, s) {
                if (void 0 === e && (e = null), void 0 === i && (i = null), void 0 === s && (s = null), !e && !i) return console.warn("Phaser.Loader.pack - Both url and data are null. One must be set."), this;
                var n = {
                    type: "packfile",
                    key: t,
                    url: e,
                    path: this.path,
                    syncPoint: !0,
                    data: null,
                    loading: !1,
                    loaded: !1,
                    error: !1,
                    callbackContext: s
                };
                i && ("string" == typeof i && (i = JSON.parse(i)), n.data = i || {}, n.loaded = !0);
                for (var r = 0; r < this._fileList.length + 1; r++) {
                    var o = this._fileList[r];
                    if (!o || !o.loaded && !o.loading && "packfile" !== o.type) {
                        this._fileList.splice(r, 0, n), this._totalPackCount++;
                        break
                    }
                }
                return this
            },
            image: function(t, e, i) {
                return "object" == typeof e ? this.texture(t, e, i) : this.addToFileList("image", t, e, void 0, i, ".png")
            },
            imageFromBitmapData: function(t, e, i) {
                return this.image(t, e.canvas.toDataURL("image/png"), i)
            },
            imageFromGrid: function(t, e, i, s, n, r) {
                return this.imageFromBitmapData(t, this.game.create.grid(t, e, i, s, n, r, !1))
            },
            imageFromTexture: function(t, e, i, s, n) {
                return this.imageFromBitmapData(t, this.game.create.texture(t, e, i, s, n, !1))
            },
            texture: function(e, i, s) {
                if (this.game.renderType === t.WEBGL) {
                    var n, r = this.game.renderer.extensions.compression;
                    for (n in i)
                        if (n.toUpperCase() in r) return this.addToFileList("texture", e, i[n], void 0, s, ".pvr")
                }
                return i.truecolor && this.addToFileList("image", e, i.truecolor, void 0, s, ".png"), this
            },
            images: function(t, e) {
                if (Array.isArray(e))
                    for (i = 0; i < t.length; i++) this.image(t[i], e[i]);
                else
                    for (var i = 0; i < t.length; i++) this.image(t[i]);
                return this
            },
            text: function(t, e, i) {
                return this.addToFileList("text", t, e, void 0, i, ".txt")
            },
            json: function(t, e, i) {
                return this.addToFileList("json", t, e, void 0, i, ".json")
            },
            shader: function(t, e, i) {
                return this.addToFileList("shader", t, e, void 0, i, ".frag")
            },
            xml: function(t, e, i) {
                return this.addToFileList("xml", t, e, void 0, i, ".xml")
            },
            script: function(t, e, i, s) {
                return void 0 === i && (i = !1), !1 !== i && void 0 === s && (s = this), this.addToFileList("script", t, e, {
                    syncPoint: !0,
                    callback: i,
                    callbackContext: s
                }, !1, ".js")
            },
            binary: function(t, e, i, s) {
                return void 0 === i && (i = !1), !1 !== i && void 0 === s && (s = i), this.addToFileList("binary", t, e, {
                    callback: i,
                    callbackContext: s
                }, !1, ".bin")
            },
            spritesheet: function(t, e, i, s, n, r, o, a) {
                return void 0 === n && (n = -1), void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === a && (a = 0), this.addToFileList("spritesheet", t, e, {
                    frameWidth: i,
                    frameHeight: s,
                    frameMax: n,
                    margin: r,
                    spacing: o,
                    skipFrames: a
                }, !1, ".png")
            },
            audio: function(t, e, i) {
                return this.game.sound.noAudio ? this : (void 0 === i && (i = !0), "string" == typeof e && (e = [e]), this.addToFileList("audio", t, e, {
                    buffer: null,
                    autoDecode: i
                }))
            },
            audioSprite: function(t, e, i, s, n) {
                return this.game.sound.noAudio ? this : (void 0 === i && (i = null), void 0 === s && (s = null), void 0 === n && (n = !0), this.audio(t, e, n), i ? this.json(t + "-audioatlas", i) : s ? ("string" == typeof s && (s = JSON.parse(s)), this.cache.addJSON(t + "-audioatlas", "", s)) : console.warn("Phaser.Loader.audiosprite - You must specify either a jsonURL or provide a jsonData object"), this)
            },
            audiosprite: function(t, e, i, s, n) {
                return this.audioSprite(t, e, i, s, n)
            },
            video: function(t, e, i, s) {
                return void 0 === i && (i = this.game.device.firefox ? "loadeddata" : "canplaythrough"), void 0 === s && (s = !1), "string" == typeof e && (e = [e]), this.addToFileList("video", t, e, {
                    buffer: null,
                    asBlob: s,
                    loadEvent: i
                })
            },
            tilemap: function(e, i, s, n) {
                if (void 0 === i && (i = null), void 0 === s && (s = null), void 0 === n && (n = t.Tilemap.CSV), i || s || (i = n === t.Tilemap.CSV ? e + ".csv" : e + ".json"), s) {
                    switch (n) {
                        case t.Tilemap.CSV:
                            break;
                        case t.Tilemap.TILED_JSON:
                            "string" == typeof s && (s = JSON.parse(s))
                    }
                    this.cache.addTilemap(e, null, s, n)
                } else this.addToFileList("tilemap", e, i, {
                    format: n
                });
                return this
            },
            tilemapCSV: function(e, i, s) {
                return this.tilemap(e, i, s, t.Tilemap.CSV)
            },
            tilemapTiledJSON: function(e, i, s) {
                return this.tilemap(e, i, s, t.Tilemap.TILED_JSON)
            },
            physics: function(e, i, s, n) {
                return void 0 === i && (i = null), void 0 === s && (s = null), void 0 === n && (n = t.Physics.LIME_CORONA_JSON), i || s || (i = e + ".json"), s ? ("string" == typeof s && (s = JSON.parse(s)), this.cache.addPhysicsData(e, null, s, n)) : this.addToFileList("physics", e, i, {
                    format: n
                }), this
            },
            bitmapFont: function(t, e, i, s, n, r) {
                if (null != e || (e = t + ".png"), void 0 === i && (i = null), void 0 === s && (s = null), null === i && null === s && (i = t + ".xml"), void 0 === n && (n = 0), void 0 === r && (r = 0), i) this.addToFileList("bitmapfont", t, e, {
                    atlasURL: i,
                    xSpacing: n,
                    ySpacing: r
                });
                else if ("string" == typeof s) {
                    var o, a;
                    try {
                        o = JSON.parse(s)
                    } catch (t) {
                        a = this.parseXml(s)
                    }
                    if (!a && !o) throw new Error("Phaser.Loader. Invalid Bitmap Font atlas given");
                    this.addToFileList("bitmapfont", t, e, {
                        atlasURL: null,
                        atlasData: o || a,
                        atlasType: o ? "json" : "xml",
                        xSpacing: n,
                        ySpacing: r
                    })
                }
                return this
            },
            atlasJSONArray: function(e, i, s, n) {
                return this.atlas(e, i, s, n, t.Loader.TEXTURE_ATLAS_JSON_ARRAY)
            },
            atlasJSONHash: function(e, i, s, n) {
                return this.atlas(e, i, s, n, t.Loader.TEXTURE_ATLAS_JSON_HASH)
            },
            atlasXML: function(e, i, s, n) {
                return void 0 === s && (s = null), void 0 === n && (n = null), s || n || (s = e + ".xml"), this.atlas(e, i, s, n, t.Loader.TEXTURE_ATLAS_XML_STARLING)
            },
            atlas: function(e, i, s, n, r) {
                if (null != i || (i = e + ".png"), void 0 === s && (s = null), void 0 === n && (n = null), void 0 === r && (r = t.Loader.TEXTURE_ATLAS_JSON_ARRAY), s || n || (s = r === t.Loader.TEXTURE_ATLAS_XML_STARLING ? e + ".xml" : e + ".json"), s) this.addToFileList("textureatlas", e, i, {
                    atlasURL: s,
                    format: r
                });
                else {
                    switch (r) {
                        case t.Loader.TEXTURE_ATLAS_JSON_ARRAY:
                            "string" == typeof n && (n = JSON.parse(n));
                            break;
                        case t.Loader.TEXTURE_ATLAS_XML_STARLING:
                            if ("string" == typeof n) {
                                var o = this.parseXml(n);
                                if (!o) throw new Error("Phaser.Loader. Invalid Texture Atlas XML given");
                                n = o
                            }
                    }
                    this.addToFileList("textureatlas", e, i, {
                        atlasURL: null,
                        atlasData: n,
                        format: r
                    })
                }
                return this
            },
            withSyncPoint: function(t, e) {
                this._withSyncPointDepth++;
                try {
                    t.call(e || this, this)
                } finally {
                    this._withSyncPointDepth--
                }
                return this
            },
            addSyncPoint: function(t, e) {
                var i = this.getAsset(t, e);
                return i && (i.file.syncPoint = !0), this
            },
            removeFile: function(t, e) {
                var i = this.getAsset(t, e);
                i && (i.loaded || i.loading || this._fileList.splice(i.index, 1))
            },
            removeAll: function() {
                this._fileList.length = 0, this._flightQueue.length = 0
            },
            start: function() {
                this.isLoading || (this.hasLoaded = !1, this.isLoading = !0, this.updateProgress(), this.processLoadQueue())
            },
            processLoadQueue: function() {
                if (!this.isLoading) return console.warn("Phaser.Loader - active loading canceled / reset"), void this.finishedLoading(!0);
                for (i = 0; i < this._flightQueue.length; i++)((s = this._flightQueue[i]).loaded || s.error) && (this._flightQueue.splice(i, 1), i--, s.loading = !1, s.requestUrl = null, s.requestObject = null, s.error && this.onFileError.dispatch(s.key, s), "packfile" !== s.type ? (this._loadedFileCount++, this.onFileComplete.dispatch(this.progress, s.key, !s.error, this._loadedFileCount, this._totalFileCount)) : "packfile" === s.type && s.error && (this._loadedPackCount++, this.onPackComplete.dispatch(s.key, !s.error, this._loadedPackCount, this._totalPackCount)));
                for (var t = !1, e = this.enableParallel ? Math.max(1, this.maxParallelDownloads) : 1, i = this._processingHead; i < this._fileList.length; i++) {
                    var s = this._fileList[i];
                    if ("packfile" === s.type && !s.error && s.loaded && i === this._processingHead && (this.processPack(s), this._loadedPackCount++, this.onPackComplete.dispatch(s.key, !s.error, this._loadedPackCount, this._totalPackCount)), s.loaded || s.error ? i === this._processingHead && (this._processingHead = i + 1) : !s.loading && this._flightQueue.length < e && ("packfile" !== s.type || s.data ? t || (this._fileLoadStarted || (this._fileLoadStarted = !0, this.onLoadStart.dispatch()), this._flightQueue.push(s), s.loading = !0, this.onFileStart.dispatch(this.progress, s.key, s.url), this.loadFile(s)) : (this._flightQueue.push(s), s.loading = !0, this.loadFile(s))), !s.loaded && s.syncPoint && (t = !0), this._flightQueue.length >= e || t && this._loadedPackCount === this._totalPackCount) break
                }
                if (this.updateProgress(), this._processingHead >= this._fileList.length) this.finishedLoading();
                else if (!this._flightQueue.length) {
                    console.warn("Phaser.Loader - aborting: processing queue empty, loading may have stalled");
                    var n = this;
                    setTimeout(function() {
                        n.finishedLoading(!0)
                    }, 2e3)
                }
            },
            finishedLoading: function(t) {
                this.hasLoaded || (this.hasLoaded = !0, this.isLoading = !1, t || this._fileLoadStarted || (this._fileLoadStarted = !0, this.onLoadStart.dispatch()), this.game.state.loadUpdate(), this.onBeforeLoadComplete.dispatch(), this.reset(), this.onLoadComplete.dispatch(), this.game.state && this.game.state.loadComplete())
            },
            asyncComplete: function(t, e) {
                void 0 === e && (e = ""), t.loaded = !0, t.error = !!e, e && (t.errorMessage = e, console.warn("Phaser.Loader - " + t.type + "[" + t.key + "]: " + e)), this.processLoadQueue()
            },
            processPack: function(e) {
                var i = e.data[e.key];
                if (i)
                    for (var s = 0; s < i.length; s++) {
                        var n = i[s];
                        switch (n.type) {
                            case "image":
                                this.image(n.key, n.url, n.overwrite);
                                break;
                            case "text":
                                this.text(n.key, n.url, n.overwrite);
                                break;
                            case "json":
                                this.json(n.key, n.url, n.overwrite);
                                break;
                            case "xml":
                                this.xml(n.key, n.url, n.overwrite);
                                break;
                            case "script":
                                this.script(n.key, n.url, n.callback, e.callbackContext || this);
                                break;
                            case "binary":
                                this.binary(n.key, n.url, n.callback, e.callbackContext || this);
                                break;
                            case "spritesheet":
                                this.spritesheet(n.key, n.url, n.frameWidth, n.frameHeight, n.frameMax, n.margin, n.spacing, n.skipFrames);
                                break;
                            case "video":
                                this.video(n.key, n.urls);
                                break;
                            case "audio":
                                this.audio(n.key, n.urls, n.autoDecode);
                                break;
                            case "audiosprite":
                                this.audiosprite(n.key, n.urls, n.jsonURL, n.jsonData, n.autoDecode);
                                break;
                            case "tilemap":
                                this.tilemap(n.key, n.url, n.data, t.Tilemap[n.format]);
                                break;
                            case "physics":
                                this.physics(n.key, n.url, n.data, t.Loader[n.format]);
                                break;
                            case "bitmapFont":
                                this.bitmapFont(n.key, n.textureURL, n.atlasURL, n.atlasData, n.xSpacing, n.ySpacing);
                                break;
                            case "atlasJSONArray":
                                this.atlasJSONArray(n.key, n.textureURL, n.atlasURL, n.atlasData);
                                break;
                            case "atlasJSONHash":
                                this.atlasJSONHash(n.key, n.textureURL, n.atlasURL, n.atlasData);
                                break;
                            case "atlasXML":
                                this.atlasXML(n.key, n.textureURL, n.atlasURL, n.atlasData);
                                break;
                            case "atlas":
                                this.atlas(n.key, n.textureURL, n.atlasURL, n.atlasData, t.Loader[n.format]);
                                break;
                            case "shader":
                                this.shader(n.key, n.url, n.overwrite)
                        }
                    } else console.warn("Phaser.Loader - " + e.key + ": pack has data, but not for pack key")
            },
            transformUrl: function(t, e) {
                return !!t && (t.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) ? t : this.baseURL + e.path + t)
            },
            loadFile: function(e) {
                switch (e.type) {
                    case "packfile":
                        this.xhrLoad(e, this.transformUrl(e.url, e), "text", this.fileComplete);
                        break;
                    case "image":
                    case "spritesheet":
                    case "textureatlas":
                    case "bitmapfont":
                        this.loadImageTag(e);
                        break;
                    case "audio":
                        e.url = this.getAudioURL(e.url), e.url ? this.game.sound.usingWebAudio ? this.xhrLoad(e, this.transformUrl(e.url, e), "arraybuffer", this.fileComplete) : this.game.sound.usingAudioTag && this.loadAudioTag(e) : this.fileError(e, null, "No supported audio URL specified or device does not have audio playback support");
                        break;
                    case "video":
                        e.url = this.getVideoURL(e.url), e.url ? e.asBlob ? this.xhrLoad(e, this.transformUrl(e.url, e), "blob", this.fileComplete) : this.loadVideoTag(e) : this.fileError(e, null, "No supported video URL specified or device does not have video playback support");
                        break;
                    case "json":
                        this.xhrLoad(e, this.transformUrl(e.url, e), "text", this.jsonLoadComplete);
                        break;
                    case "xml":
                        this.xhrLoad(e, this.transformUrl(e.url, e), "text", this.xmlLoadComplete);
                        break;
                    case "tilemap":
                        e.format === t.Tilemap.TILED_JSON ? this.xhrLoad(e, this.transformUrl(e.url, e), "text", this.jsonLoadComplete) : e.format === t.Tilemap.CSV ? this.xhrLoad(e, this.transformUrl(e.url, e), "text", this.csvLoadComplete) : this.asyncComplete(e, "invalid Tilemap format: " + e.format);
                        break;
                    case "text":
                    case "script":
                    case "shader":
                    case "physics":
                        this.xhrLoad(e, this.transformUrl(e.url, e), "text", this.fileComplete);
                        break;
                    case "texture":
                        "truecolor" === e.key.split("_").pop() ? this.loadImageTag(e) : this.xhrLoad(e, this.transformUrl(e.url, e), "arraybuffer", this.fileComplete);
                        break;
                    case "binary":
                        this.xhrLoad(e, this.transformUrl(e.url, e), "arraybuffer", this.fileComplete)
                }
            },
            loadImageTag: function(t) {
                var e = this;
                t.data = new Image, t.data.name = t.key, this.crossOrigin && (t.data.crossOrigin = this.crossOrigin), t.data.onload = function() {
                    t.data.onload && (t.data.onload = null, t.data.onerror = null, e.fileComplete(t))
                }, t.data.onerror = function() {
                    t.data.onload && (t.data.onload = null, t.data.onerror = null, e.fileError(t))
                }, t.data.src = this.transformUrl(t.url, t), !this.game.device.firefox && t.data.complete && t.data.width && t.data.height && (t.data.onload = null, t.data.onerror = null, this.fileComplete(t))
            },
            loadVideoTag: function(e) {
                var i = this;
                e.data = document.createElement("video"), e.data.name = e.key, e.data.controls = !1, e.data.autoplay = !1, e.data.playsInline = !0;
                var s = function() {
                    e.data.removeEventListener(e.loadEvent, s, !1), e.data.onerror = null, e.data.canplay = !0, t.GAMES[i.game.id].load.fileComplete(e)
                };
                e.data.onerror = function() {
                    e.data.removeEventListener(e.loadEvent, s, !1), e.data.onerror = null, e.data.canplay = !1, i.fileError(e)
                }, e.data.addEventListener(e.loadEvent, s, !1), e.data.src = this.transformUrl(e.url, e), e.data.load()
            },
            loadAudioTag: function(t) {
                var e = this;
                if (this.game.sound.touchLocked) t.data = new Audio, t.data.name = t.key, t.data.preload = "auto", t.data.src = this.transformUrl(t.url, t), this.fileComplete(t);
                else {
                    t.data = new Audio, t.data.name = t.key;
                    var i = function() {
                        t.data.removeEventListener("canplaythrough", i, !1), t.data.onerror = null, e.fileComplete(t)
                    };
                    t.data.onerror = function() {
                        t.data.removeEventListener("canplaythrough", i, !1), t.data.onerror = null, e.fileError(t)
                    }, t.data.preload = "auto", t.data.src = this.transformUrl(t.url, t), t.data.addEventListener("canplaythrough", i, !1), t.data.load()
                }
            },
            xhrLoad: function(t, e, i, s, n) {
                var r = new XMLHttpRequest;
                r.open("GET", e, !0), r.responseType = i, !1 !== this.headers.requestedWith && r.setRequestHeader("X-Requested-With", this.headers.requestedWith), this.headers[t.type] && r.setRequestHeader("Accept", this.headers[t.type]), n = n || this.fileError;
                var o = this;
                r.onload = function() {
                    try {
                        return 4 === r.readyState && r.status >= 400 && r.status <= 599 ? n.call(o, t, r) : s.call(o, t, r)
                    } catch (e) {
                        o.hasLoaded ? window.console && console.error(e) : o.asyncComplete(t, e.message || "Exception")
                    }
                }, r.onerror = function() {
                    try {
                        return n.call(o, t, r)
                    } catch (e) {
                        o.hasLoaded ? window.console && console.error(e) : o.asyncComplete(t, e.message || "Exception")
                    }
                }, t.requestObject = r, t.requestUrl = e, r.send()
            },
            getVideoURL: function(t) {
                for (var e = 0; e < t.length; e++) {
                    var i, s = t[e];
                    if (s.uri) {
                        if (i = s.type, s = s.uri, this.game.device.canPlayVideo(i)) return s
                    } else {
                        if (0 === s.indexOf("blob:") || 0 === s.indexOf("data:")) return s;
                        if (s.indexOf("?") >= 0 && (s = s.substr(0, s.indexOf("?"))), i = s.substr((Math.max(0, s.lastIndexOf(".")) || 1 / 0) + 1).toLowerCase(), this.game.device.canPlayVideo(i)) return t[e]
                    }
                }
                return null
            },
            getAudioURL: function(t) {
                if (this.game.sound.noAudio) return null;
                for (var e = 0; e < t.length; e++) {
                    var i, s = t[e];
                    if (s.uri) {
                        if (i = s.type, s = s.uri, this.game.device.canPlayAudio(i)) return s
                    } else {
                        if (0 === s.indexOf("blob:") || 0 === s.indexOf("data:")) return s;
                        if (s.indexOf("?") >= 0 && (s = s.substr(0, s.indexOf("?"))), i = s.substr((Math.max(0, s.lastIndexOf(".")) || 1 / 0) + 1).toLowerCase(), this.game.device.canPlayAudio(i)) return t[e]
                    }
                }
                return null
            },
            fileError: function(t, e, i) {
                var s = "error loading asset from URL " + (t.requestUrl || this.transformUrl(t.url, t));
                !i && e && (i = e.status), i && (s = s + " (" + i + ")"), this.asyncComplete(t, s)
            },
            fileComplete: function(e, i) {
                var s = !0;
                switch (e.type) {
                    case "packfile":
                        r = JSON.parse(i.responseText), e.data = r || {};
                        break;
                    case "texture":
                        var n = /\.([^.]+)$/.exec(e.url.split("?", 1)[0])[1].toLowerCase();
                        null !== e.data ? this.cache.addCompressedTextureMetaData(e.key, e.url, n, e.data) : this.cache.addCompressedTextureMetaData(e.key, e.url, n, i.response);
                        break;
                    case "image":
                        this.cache.addImage(e.key, e.url, e.data);
                        break;
                    case "spritesheet":
                        this.cache.addSpriteSheet(e.key, e.url, e.data, e.frameWidth, e.frameHeight, e.frameMax, e.margin, e.spacing, e.skipFrames);
                        break;
                    case "textureatlas":
                        if (null == e.atlasURL) this.cache.addTextureAtlas(e.key, e.url, e.data, e.atlasData, e.format);
                        else if (s = !1, e.format === t.Loader.TEXTURE_ATLAS_JSON_ARRAY || e.format === t.Loader.TEXTURE_ATLAS_JSON_HASH || e.format === t.Loader.TEXTURE_ATLAS_JSON_PYXEL) this.xhrLoad(e, this.transformUrl(e.atlasURL, e), "text", this.jsonLoadComplete);
                        else {
                            if (e.format !== t.Loader.TEXTURE_ATLAS_XML_STARLING) throw new Error("Phaser.Loader. Invalid Texture Atlas format: " + e.format);
                            this.xhrLoad(e, this.transformUrl(e.atlasURL, e), "text", this.xmlLoadComplete)
                        }
                        break;
                    case "bitmapfont":
                        e.atlasURL ? (s = !1, this.xhrLoad(e, this.transformUrl(e.atlasURL, e), "text", function(t, e) {
                            var i;
                            try {
                                i = JSON.parse(e.responseText)
                            } catch (t) {}
                            i ? (t.atlasType = "json", this.jsonLoadComplete(t, e)) : (t.atlasType = "xml", this.xmlLoadComplete(t, e))
                        })) : this.cache.addBitmapFont(e.key, e.url, e.data, e.atlasData, e.atlasType, e.xSpacing, e.ySpacing);
                        break;
                    case "video":
                        if (e.asBlob) try {
                            e.data = i.response
                        } catch (t) {
                            throw new Error("Phaser.Loader. Unable to parse video file as Blob: " + e.key)
                        }
                        this.cache.addVideo(e.key, e.url, e.data, e.asBlob);
                        break;
                    case "audio":
                        this.game.sound.usingWebAudio ? (e.data = i.response, this.cache.addSound(e.key, e.url, e.data, !0, !1), e.autoDecode && this.game.sound.decode(e.key)) : this.cache.addSound(e.key, e.url, e.data, !1, !0);
                        break;
                    case "text":
                        e.data = i.responseText, this.cache.addText(e.key, e.url, e.data);
                        break;
                    case "shader":
                        e.data = i.responseText, this.cache.addShader(e.key, e.url, e.data);
                        break;
                    case "physics":
                        var r = JSON.parse(i.responseText);
                        this.cache.addPhysicsData(e.key, e.url, r, e.format);
                        break;
                    case "script":
                        e.data = document.createElement("script"), e.data.language = "javascript", e.data.type = "text/javascript", e.data.defer = !1, e.data.text = i.responseText, document.head.appendChild(e.data), e.callback && (e.data = e.callback.call(e.callbackContext, e.key, i.responseText));
                        break;
                    case "binary":
                        e.callback ? e.data = e.callback.call(e.callbackContext, e.key, i.response) : e.data = i.response, this.cache.addBinary(e.key, e.data)
                }
                s && this.asyncComplete(e)
            },
            jsonLoadComplete: function(t, e) {
                var i = JSON.parse(e.responseText);
                "tilemap" === t.type ? this.cache.addTilemap(t.key, t.url, i, t.format) : "bitmapfont" === t.type ? this.cache.addBitmapFont(t.key, t.url, t.data, i, t.atlasType, t.xSpacing, t.ySpacing) : "json" === t.type ? this.cache.addJSON(t.key, t.url, i) : this.cache.addTextureAtlas(t.key, t.url, t.data, i, t.format), this.asyncComplete(t)
            },
            csvLoadComplete: function(t, e) {
                var i = e.responseText;
                this.cache.addTilemap(t.key, t.url, i, t.format), this.asyncComplete(t)
            },
            xmlLoadComplete: function(t, e) {
                var i = e.responseText,
                    s = this.parseXml(i);
                if (!s) {
                    var n = e.responseType || e.contentType;
                    return console.warn("Phaser.Loader - " + t.key + ": invalid XML (" + n + ")"), void this.asyncComplete(t, "invalid XML")
                }
                "bitmapfont" === t.type ? this.cache.addBitmapFont(t.key, t.url, t.data, s, t.atlasType, t.xSpacing, t.ySpacing) : "textureatlas" === t.type ? this.cache.addTextureAtlas(t.key, t.url, t.data, s, t.format) : "xml" === t.type && this.cache.addXML(t.key, t.url, s), this.asyncComplete(t)
            },
            parseXml: function(t) {
                var e;
                try {
                    if (window.DOMParser) e = (new DOMParser).parseFromString(t, "text/xml");
                    else(e = new ActiveXObject("Microsoft.XMLDOM")).async = "false", e.loadXML(t)
                } catch (t) {
                    e = null
                }
                return e && e.documentElement && !e.getElementsByTagName("parsererror").length ? e : null
            },
            updateProgress: function() {
                this.preloadSprite && (0 === this.preloadSprite.direction ? this.preloadSprite.rect.width = Math.floor(this.preloadSprite.width / 100 * this.progress) : this.preloadSprite.rect.height = Math.floor(this.preloadSprite.height / 100 * this.progress), this.preloadSprite.sprite ? this.preloadSprite.sprite.updateCrop() : this.preloadSprite = null)
            },
            totalLoadedFiles: function() {
                return this._loadedFileCount
            },
            totalQueuedFiles: function() {
                return this._totalFileCount - this._loadedFileCount
            },
            totalLoadedPacks: function() {
                return this._totalPackCount
            },
            totalQueuedPacks: function() {
                return this._totalPackCount - this._loadedPackCount
            }
        }, Object.defineProperty(t.Loader.prototype, "progressFloat", {
            get: function() {
                var e = this._loadedFileCount / this._totalFileCount * 100;
                return t.Math.clamp(e || 0, 0, 100)
            }
        }), Object.defineProperty(t.Loader.prototype, "progress", {
            get: function() {
                return Math.round(this.progressFloat)
            }
        }), t.Loader.prototype.constructor = t.Loader, t.LoaderParser = {
            bitmapFont: function(t, e, i, s, n, r) {
                return this.xmlBitmapFont(t, e, i, s, n, r)
            },
            xmlBitmapFont: function(t, e, i, s, n, r) {
                null == r && (r = 1);
                var o = {},
                    a = t.getElementsByTagName("info")[0],
                    h = t.getElementsByTagName("common")[0];
                o.font = a.getAttribute("face"), o.size = parseInt(a.getAttribute("size"), 10), o.lineHeight = parseInt(h.getAttribute("lineHeight"), 10) + s, o.chars = {};
                for (var l = t.getElementsByTagName("char"), c = n ? n.x : 0, u = n ? n.y : 0, d = 0; d < l.length; d++) {
                    var p = parseInt(l[d].getAttribute("id"), 10),
                        f = o.chars[p] = {
                            x: parseInt(l[d].getAttribute("x"), 10),
                            y: parseInt(l[d].getAttribute("y"), 10),
                            width: parseInt(l[d].getAttribute("width"), 10),
                            height: parseInt(l[d].getAttribute("height"), 10),
                            xOffset: parseInt(l[d].getAttribute("xoffset"), 10) / r,
                            yOffset: parseInt(l[d].getAttribute("yoffset"), 10) / r,
                            xAdvance: (parseInt(l[d].getAttribute("xadvance"), 10) + i) / r,
                            kerning: {}
                        };
                    if (n && n.trimmed && (f.x + f.width > n.spriteSourceSizeX + n.spriteSourceSizeW && (f.width -= f.x + f.width - n.spriteSourceSizeX - n.spriteSourceSizeW), f.y + f.height > n.spriteSourceSizeY + n.spriteSourceSizeH && (f.height -= f.y + f.height - n.spriteSourceSizeY - n.spriteSourceSizeH), f.x < n.spriteSourceSizeX && (g = n.spriteSourceSizeX - f.x, f.x = 0, f.width -= g, f.xOffset += g), f.y < n.spriteSourceSizeY)) {
                        var g = n.spriteSourceSizeY - f.y;
                        f.y = 0, f.height -= g, f.yOffset += g
                    }
                    f.x += c, f.y += u
                }
                var m = t.getElementsByTagName("kerning");
                for (d = 0; d < m.length; d++) {
                    var y = parseInt(m[d].getAttribute("first"), 10),
                        v = parseInt(m[d].getAttribute("second"), 10),
                        x = parseInt(m[d].getAttribute("amount"), 10) / r;
                    o.chars[v] && (o.chars[v].kerning[y] = x)
                }
                return this.finalizeBitmapFont(e, o)
            },
            jsonBitmapFont: function(t, e, i, s, n, r) {
                null == r && (r = 1);
                var o = {
                        font: t.font.info._face,
                        size: parseInt(t.font.info._size, 10),
                        lineHeight: parseInt(t.font.common._lineHeight, 10) + s,
                        chars: {}
                    },
                    a = n ? n.x : 0,
                    h = n ? n.y : 0;
                return t.font.chars.char.forEach(function(t) {
                    var e = parseInt(t._id, 10),
                        s = o.chars[e] = {
                            x: parseInt(t._x, 10),
                            y: parseInt(t._y, 10),
                            width: parseInt(t._width, 10),
                            height: parseInt(t._height, 10),
                            xOffset: parseInt(t._xoffset, 10) / r,
                            yOffset: parseInt(t._yoffset, 10) / r,
                            xAdvance: (parseInt(t._xadvance, 10) + i) / r,
                            kerning: {}
                        };
                    if (n && n.trimmed && (s.x + s.width > n.spriteSourceSizeX + n.spriteSourceSizeW && (s.width -= s.x + s.width - n.spriteSourceSizeX - n.spriteSourceSizeW), s.y + s.height > n.spriteSourceSizeY + n.spriteSourceSizeH && (s.height -= s.y + s.height - n.spriteSourceSizeY - n.spriteSourceSizeH), s.x < n.spriteSourceSizeX && (l = n.spriteSourceSizeX - s.x, s.x = 0, s.width -= l, s.xOffset += l), s.y < n.spriteSourceSizeY)) {
                        var l = n.spriteSourceSizeY - s.y;
                        s.y = 0, s.height -= l, s.yOffset += l
                    }
                    s.x += a, s.y += h
                }), t.font.kernings && t.font.kernings.kerning && t.font.kernings.kerning.forEach(function(t) {
                    o.chars[t._second] && (o.chars[t._second].kerning[t._first] = parseInt(t._amount, 10) / r)
                }), this.finalizeBitmapFont(e, o)
            },
            finalizeBitmapFont: function(e, i) {
                return Object.keys(i.chars).forEach(function(s) {
                    var n = i.chars[s];
                    n.texture = new PIXI.Texture(e, new t.Rectangle(n.x, n.y, n.width, n.height))
                }), i
            },
            pvr: function(t) {
                var e, i = new Uint32Array(t.slice(0, 52)),
                    s = new Uint8Array(t),
                    n = null,
                    r = i[3] << 32 | i[2],
                    o = 0;
                if (55727696 === i[0] && [0, 1, 2, 3, 6, 7, 9, 11].indexOf(r) >= 0) {
                    switch (r >= 0 && r <= 3 ? e = "PVRTC" : r >= 7 && r <= 11 ? e = "S3TC" : 6 === r && (e = "ETC1"), r) {
                        case 0:
                            o = 35841;
                            break;
                        case 1:
                            o = 35843;
                            break;
                        case 2:
                            o = 35840;
                            break;
                        case 3:
                            o = 35842;
                            break;
                        case 6:
                            o = 36196;
                            break;
                        case 7:
                            o = 33777;
                            break;
                        case 9:
                            o = 33778;
                            break;
                        case 11:
                            o = 33779;
                            break;
                        default:
                            o = -1
                    }
                    n = {
                        complete: !0,
                        fileFormat: "PVR",
                        compressionAlgorithm: e,
                        flags: i[1],
                        pixelFormat: r,
                        colorSpace: i[4],
                        channelType: i[5],
                        height: i[6],
                        width: i[7],
                        depth: i[8],
                        numberOfSurfaces: i[9],
                        numberOfFaces: i[10],
                        numberOfMipmaps: i[11],
                        metaDataSize: i[12],
                        textureData: s.subarray(52 + i[12], s.byteLength),
                        glExtensionFormat: o
                    }
                }
                return n
            },
            dds: function(t) {
                var e = new Uint8Array(t),
                    i = new Uint32Array(t),
                    s = null;
                return 68 === e[0] && 68 === e[1] && 83 === e[2] && 32 === e[3] && ("DX10" === (s = {
                    complete: !0,
                    fileFormat: "DDS",
                    compressionAlgorithm: "S3TC",
                    size: i[1],
                    flags: i[2],
                    height: i[3],
                    width: i[4],
                    pitch: i[5],
                    depth: i[6],
                    mipmapCount: i[7],
                    formatSize: i[19],
                    formatFlag: i[19],
                    formatFourCC: [String.fromCharCode(e[84]), String.fromCharCode(e[85]), String.fromCharCode(e[86]), String.fromCharCode(e[87])].join(""),
                    formatBitCount: i[21],
                    formatRBitMask: i[22],
                    formatGBitMask: i[23],
                    formatBBitMask: i[24],
                    formatABitMask: i[25],
                    caps1: i[26],
                    caps2: i[27],
                    caps3: i[28],
                    caps4: i[29],
                    reserved2: i[30],
                    DXGIFormat: null,
                    resourceDimension: null,
                    miscFlag: null,
                    arraySize: null,
                    textureData: e.subarray(i[1] + 4, e.byteLength)
                }).formatFourCC ? (s.DXGIFormat = i[31], s.resourceDimension = i[32], s.miscFlag = i[33], s.arraySize = i[34], s.miscFlag = i[35]) : "DXT5" === s.formatFourCC ? s.glExtensionFormat = 33779 : "DXT3" === s.formatFourCC && (s.glExtensionFormat = 33778)), s
            },
            ktx: function(t) {
                var e = new Uint8Array(t),
                    i = new Uint32Array(t),
                    s = null,
                    n = 16 + i[15] / 4 | 0,
                    r = i[n],
                    o = i[7],
                    a = 0;
                if (171 === e[0] && 75 === e[1] && 84 === e[2] && 88 === e[3] && 32 === e[4] && 49 === e[5] && 49 === e[6] && 187 === e[7] && 13 === e[8] && 10 === e[9] && 26 === e[10] && 10 === e[11] && [36196, 35840, 35841, 35842, 35843, 33776, 33777, 33778, 33779].indexOf(o) >= 0) {
                    switch (o) {
                        case 36196:
                            a = "ETC1";
                            break;
                        case 35840:
                        case 35841:
                        case 35842:
                        case 35843:
                            a = "PVRTC";
                            break;
                        case 33776:
                        case 33777:
                        case 33778:
                        case 33779:
                            a = "S3TC"
                    }
                    s = {
                        complete: !0,
                        fileFormat: "KTX",
                        compressionAlgorithm: a,
                        endianness: i[3],
                        glType: i[4],
                        glTypeSize: i[5],
                        glFormat: i[6],
                        glInternalFormat: i[7],
                        glBaseInternalFormat: i[8],
                        width: i[9],
                        height: i[10],
                        pixelDepth: i[11],
                        numberOfArrayElements: i[12],
                        numberOfFaces: i[13],
                        numberOfMipmapLevels: i[14],
                        bytesOfKeyValueData: i[15],
                        keyAndValueByteSize: i[16],
                        imageSize: r,
                        textureData: e.subarray(4 * (n + 1), r + 100)
                    }
                }
                return s
            },
            pkm: function(t) {
                var e = new Uint8Array(t),
                    i = null;
                return 80 === e[0] && 75 === e[1] && 77 === e[2] && 32 === e[3] && (i = {
                    complete: !0,
                    fileFormat: "PKM",
                    compressionAlgorithm: "ETC1",
                    format: 65535 & (e[6] << 8 | e[7]),
                    width: 65535 & (e[8] << 8 | e[9]),
                    height: 65535 & (e[10] << 8 | e[11]),
                    originalWidth: 65535 & (e[12] << 8 | e[13]),
                    originalHeight: 65535 & (e[14] << 8 | e[15]),
                    textureData: e.subarray(16, e.length)
                }), i
            }
        }, t.AudioSprite = function(t, e) {
            for (var i in this.game = t, this.key = e, this.config = this.game.cache.getJSON(e + "-audioatlas"), this.autoplayKey = null, this.autoplay = !1, this.sounds = {}, this.config.spritemap) {
                var s = this.config.spritemap[i],
                    n = this.game.add.sound(this.key);
                n.addMarker(i, s.start, s.end - s.start, null, s.loop), this.sounds[i] = n
            }
            this.config.autoplay && (this.autoplayKey = this.config.autoplay, this.play(this.autoplayKey), this.autoplay = this.sounds[this.autoplayKey])
        }, t.AudioSprite.prototype = {
            play: function(t, e) {
                return void 0 === e && (e = 1), this.sounds[t].play(t, null, e)
            },
            stop: function(t) {
                if (t) this.sounds[t].stop();
                else
                    for (var e in this.sounds) this.sounds[e].stop()
            },
            get: function(t) {
                return this.sounds[t]
            }
        }, t.AudioSprite.prototype.constructor = t.AudioSprite, t.Sound = function(e, i, s, n, r) {
            void 0 === s && (s = 1), void 0 === n && (n = !1), void 0 === r && (r = e.sound.connectToMaster), this.game = e, this.name = i, this.key = i, this.loop = n, this.markers = {}, this.context = null, this.autoplay = !1, this.totalDuration = 0, this.startTime = 0, this.currentTime = 0, this.duration = 0, this.durationMS = 0, this.position = 0, this.stopTime = 0, this.paused = !1, this.pausedPosition = 0, this.pausedTime = 0, this.isPlaying = !1, this.currentMarker = "", this.fadeTween = null, this.pendingPlayback = !1, this.override = !1, this.allowMultiple = !1, this.playOnce = !1, this.usingWebAudio = this.game.sound.usingWebAudio, this.usingAudioTag = this.game.sound.usingAudioTag, this.externalNode = null, this.masterGainNode = null, this.gainNode = null, this._sound = null, this._globalVolume = 1, this._markedToDelete = !1, this._pendingStart = !1, this._removeFromSoundManager = !1, this._sourceId = 0, this.usingWebAudio ? (this.context = this.game.sound.context, this.masterGainNode = this.game.sound.masterGain, void 0 === this.context.createGain ? this.gainNode = this.context.createGainNode() : this.gainNode = this.context.createGain(), this.gainNode.gain.value = s, r && this.gainNode.connect(this.masterGainNode)) : this.usingAudioTag && (this.game.cache.getSound(i) && this.game.cache.isSoundReady(i) ? (this._sound = this.game.cache.getSoundData(i), this.totalDuration = 0, this._sound.duration && (this.totalDuration = this._sound.duration)) : this.game.cache.onSoundUnlock.add(this.soundHasUnlocked, this)), this.onDecoded = new t.Signal, this.onPlay = new t.Signal, this.onPause = new t.Signal, this.onResume = new t.Signal, this.onLoop = new t.Signal, this.onStop = new t.Signal, this.onMute = new t.Signal, this.onMarkerComplete = new t.Signal, this.onFadeComplete = new t.Signal, this._volume = s, this._buffer = null, this._muted = !1, this._tempMarker = 0, this._tempPosition = 0, this._tempVolume = 0, this._tempPause = 0, this._muteVolume = 0, this._tempLoop = 0, this._paused = !1, this._onDecodedEventDispatched = !1
        }, t.Sound.prototype = {
            soundHasUnlocked: function(t) {
                t === this.key && (this._sound = this.game.cache.getSoundData(this.key), this.totalDuration = this._sound.duration)
            },
            addMarker: function(t, e, i, s, n) {
                null != i || (i = 1), null != s || (s = 1), void 0 === n && (n = !1), this.markers[t] = {
                    name: t,
                    start: e,
                    stop: e + i,
                    volume: s,
                    duration: i,
                    durationMS: 1e3 * i,
                    loop: n
                }
            },
            removeMarker: function(t) {
                delete this.markers[t]
            },
            onEndedHandler: function() {
                this._removeOnEndedHandler(), this.isPlaying = !1, this.currentTime = this.durationMS, this.stop(), this.playOnce && (this._markedToDelete = !0, this._removeFromSoundManager = !0), this._markedToDelete && (this._disconnectSource(), this._removeFromSoundManager ? this.game.sound.remove(this) : (this.markers = {}, this.context = null, this._buffer = null, this.externalNode = null, this.onDecoded.dispose(), this.onPlay.dispose(), this.onPause.dispose(), this.onResume.dispose(), this.onLoop.dispose(), this.onStop.dispose(), this.onMute.dispose(), this.onMarkerComplete.dispose()))
            },
            update: function() {
                if (this.game.cache.checkSoundKey(this.key)) {
                    this.isDecoded && !this._onDecodedEventDispatched && (this.onDecoded.dispatch(this), this._onDecodedEventDispatched = !0), this.pendingPlayback && this.game.cache.isSoundReady(this.key) && (this.pendingPlayback = !1, this.play(this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop));
                    var t = this.game.time.time;
                    if (this.isPlaying) {
                        if (this._pendingStart) {
                            var e = this._sound.currentTime;
                            if (!(e > ((this.paused ? this._tempPause : 0) || this.position || 0))) return;
                            this._pendingStart = !1, this.startTime = t - 1e3 * e, this.stopTime = this.startTime + this.durationMS
                        }
                        this.currentTime = t - this.startTime, this.currentTime >= this.durationMS && (this.usingWebAudio ? this.loop ? (this.onLoop.dispatch(this), this.isPlaying = !1, "" === this.currentMarker ? (this.currentTime = 0, this.startTime = t, this.isPlaying = !0) : (this.onMarkerComplete.dispatch(this.currentMarker, this), this.play(this.currentMarker, 0, this.volume, !0, !0))) : "" !== this.currentMarker && this.stop() : this.loop ? (this.onLoop.dispatch(this), "" === this.currentMarker && (this.currentTime = 0, this.startTime = t), this.isPlaying = !1, this.play(this.currentMarker, 0, this.volume, !0, !0)) : this.stop())
                    }
                } else this.destroy()
            },
            loopFull: function(t) {
                return this.play(null, 0, t, !0)
            },
            play: function(t, e, i, s, n) {
                if (void 0 !== t && !1 !== t && null !== t || (t = ""), void 0 === n && (n = !0), this.isPlaying && !this.allowMultiple && !n && !this.override) return this;
                if (this._sound && this.isPlaying && !this.allowMultiple && (this.override || n) && (this.usingWebAudio ? this._stopSourceAndDisconnect() : this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0), this.isPlaying = !1), "" === t && Object.keys(this.markers).length > 0) return this;
                if ("" !== t) {
                    if (!this.markers[t]) return console.warn("Phaser.Sound.play: audio marker " + t + " doesn't exist"), this;
                    this.currentMarker = t, this.position = this.markers[t].start, this.volume = this.markers[t].volume, this.loop = this.markers[t].loop, this.duration = this.markers[t].duration, this.durationMS = this.markers[t].durationMS, void 0 !== i && (this.volume = i), void 0 !== s && (this.loop = s), this._tempMarker = t, this._tempPosition = this.position, this._tempVolume = this.volume, this._tempLoop = this.loop
                } else e = e || 0, void 0 === i && (i = this._volume), void 0 === s && (s = this.loop), this.position = Math.max(0, e), this.volume = i, this.loop = s, this.duration = 0, this.durationMS = 0, this._tempMarker = t, this._tempPosition = e, this._tempVolume = i, this._tempLoop = s;
                return this.usingWebAudio ? this.game.cache.isSoundDecoded(this.key) ? (this._createSourceAndConnect(), this.loop && "" === t && (this._sound.loop = !0), this.loop || "" !== t || this._addOnEndedHandler(), this.totalDuration = this._sound.buffer.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = Math.ceil(1e3 * this.totalDuration)), this.loop && "" === t ? this._startSource(0, 0) : this._startSource(0, this.position, this.duration), this.isPlaying = !0, this.paused = !1, this.startTime = this.game.time.time, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : (this.pendingPlayback = !0, this.game.cache.getSound(this.key) && !1 === this.game.cache.getSound(this.key).isDecoding && this.game.sound.decode(this.key, this)) : this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).locked ? (this.game.cache.reloadSound(this.key), this.pendingPlayback = !0) : this._sound && (this.game.device.cocoonJS || 4 === this._sound.readyState) ? (this._sound.play(), this._sound.loop = this.loop, this.totalDuration = this._sound.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = 1e3 * this.totalDuration), this._globalVolume = this.game.sound.volume, this._sound.currentTime = this.position, this._sound.muted = this._muted, this._muted || this.game.sound.mute ? this._sound.volume = 0 : this._sound.volume = this._volume * this._globalVolume, this._pendingStart = !0, this.isPlaying = !0, this.paused = !1, this._tempPause = 0, this.startTime = this.game.time.time, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : this.pendingPlayback = !0, this.playOnce && (this.loop && console.warn("Phaser.Sound.play: audio clip " + this.name + " cannot be deleted while looping."), this._markedToDelete = !0, this._removeFromSoundManager = !0), this
            },
            restart: function(t, e, i, s) {
                t = t || "", e = e || 0, i = i || 1, void 0 === s && (s = !1), this.play(t, e, i, s, !0)
            },
            pause: function() {
                this.isPlaying && (this.paused = !0, this.pausedPosition = this.currentTime, this.pausedTime = this.game.time.time, this._tempPause = this._sound.currentTime, this.onPause.dispatch(this), this.stop())
            },
            resume: function() {
                if (this.paused) {
                    if (this.usingWebAudio) {
                        var t = Math.max(0, this.position + this.pausedPosition / 1e3);
                        this._createSourceAndConnect(), "" === this.currentMarker && (this.loop ? this._sound.loop = !0 : this._addOnEndedHandler());
                        var e = this.duration - this.pausedPosition / 1e3;
                        this.loop && "" === this.currentMarker ? this._startSource(0, t) : this._startSource(0, t, e)
                    } else this._pendingStart = !0, this._sound.currentTime = this._tempPause, this._tempPause = 0, this._sound.play();
                    this.isPlaying = !0, this.paused = !1, this.startTime += this.game.time.time - this.pausedTime, this.onResume.dispatch(this)
                }
            },
            stop: function() {
                if (this.isPlaying && this._sound && (this.usingWebAudio ? this._stopSourceAndDisconnect() : this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0)), this.pendingPlayback = !1, this.isPlaying = !1, !this.paused) {
                    var t = this.currentMarker;
                    "" !== this.currentMarker && this.onMarkerComplete.dispatch(this.currentMarker, this), this.currentMarker = "", null !== this.fadeTween && this.fadeTween.stop(), this.onStop.dispatch(this, t)
                }
            },
            fadeIn: function(t, e, i) {
                void 0 === e && (e = !1), void 0 === i && (i = this.currentMarker), this.paused || (this.play(i, 0, 0, e), this.fadeTo(t, 1))
            },
            fadeOut: function(t) {
                this.fadeTo(t, 0)
            },
            fadeTo: function(e, i) {
                this.isPlaying && !this.paused && i !== this.volume && (void 0 === e && (e = 1e3), void 0 !== i ? (this.fadeTween = this.game.add.tween(this).to({
                    volume: i
                }, e, t.Easing.Linear.None, !0), this.fadeTween.onComplete.add(this.fadeComplete, this)) : console.warn("Phaser.Sound.fadeTo: No Volume Specified."))
            },
            fadeComplete: function() {
                this.onFadeComplete.dispatch(this, this.volume), 0 === this.volume && this.stop()
            },
            updateGlobalVolume: function(t) {
                this.usingAudioTag && this._sound && (this._globalVolume = t, this._sound.volume = this._globalVolume * this._volume)
            },
            destroy: function(t) {
                void 0 === t && (t = !0), this._markedToDelete = !0, this._removeFromSoundManager = t, this.stop(), t ? this.game.sound.remove(this) : (this.markers = {}, this.context = null, this._buffer = null, this.externalNode = null, this.onDecoded.dispose(), this.onPlay.dispose(), this.onPause.dispose(), this.onResume.dispose(), this.onLoop.dispose(), this.onStop.dispose(), this.onMute.dispose(), this.onMarkerComplete.dispose())
            },
            _createSourceAndConnect: function() {
                this._sound = this.context.createBufferSource(), this._sound.connect(this.externalNode || this.gainNode), this._buffer = this.game.cache.getSoundData(this.key), this._sound.buffer = this._buffer, this._sourceId++
            },
            _disconnectSource: function() {
                this._sound.disconnect(this.externalNode || this.gainNode)
            },
            _startSource: function(t, e, i) {
                this._sound.start(t || 0, e || 0, i)
            },
            _stopSourceAndDisconnect: function() {
                this._removeOnEndedHandler();
                try {
                    this._sound.stop(0)
                } catch (t) {}
                this._disconnectSource(), this._sound = null
            },
            _addOnEndedHandler: function() {
                this._sound.onended = this.onEndedHandler.bind(this)
            },
            _removeOnEndedHandler: function() {
                this._sound.onended = null
            }
        }, t.Sound.prototype.constructor = t.Sound, Object.defineProperty(t.Sound.prototype, "isDecoding", {
            get: function() {
                return this.game.cache.getSound(this.key).isDecoding
            }
        }), Object.defineProperty(t.Sound.prototype, "isDecoded", {
            get: function() {
                return this.game.cache.isSoundDecoded(this.key)
            }
        }), Object.defineProperty(t.Sound.prototype, "mute", {
            get: function() {
                return this._muted || this.game.sound.mute
            },
            set: function(t) {
                (t = t || !1) !== this._muted && (t ? (this._muted = !0, this._muteVolume = this._tempVolume, this.usingWebAudio ? this.gainNode.gain.value = 0 : this.usingAudioTag && this._sound && (this._sound.volume = 0)) : (this._muted = !1, this.usingWebAudio ? this.gainNode.gain.value = this._muteVolume : this.usingAudioTag && this._sound && (this._sound.volume = this._muteVolume)), this.onMute.dispatch(this))
            }
        }), Object.defineProperty(t.Sound.prototype, "volume", {
            get: function() {
                return this._volume
            },
            set: function(t) {
                this.usingAudioTag && (t = this.game.math.clamp(t, 0, 1)), this._muted ? this._muteVolume = t : (this._tempVolume = t, this._volume = t, this.usingWebAudio ? this.gainNode.gain.value = t : this.usingAudioTag && this._sound && (this._sound.volume = this._globalVolume * t))
            }
        }), Object.defineProperty(t.Sound.prototype, "sourceId", {
            get: function() {
                return this._sound ? this._sourceId : null
            }
        }), t.SoundManager = function(e) {
            this.game = e, this.onSoundDecode = new t.Signal, this.onVolumeChange = new t.Signal, this.onMute = new t.Signal, this.onUnMute = new t.Signal, this.onTouchUnlock = new t.Signal, this.context = null, this.baseLatency = null, this.usingWebAudio = !1, this.usingAudioTag = !1, this.noAudio = !1, this.connectToMaster = !0, this.touchLocked = !1, this.channels = 32, this.muteOnPause = !0, this._codeMuted = !1, this._muted = !1, this._unlockSource = null, this._volume = 1, this._sounds = [], this._watchList = new t.ArraySet, this._watching = !1, this._watchCallback = null, this._watchContext = null, this._resumeWebAudioOnClick = this._resumeWebAudioOnClick.bind(this)
        }, t.SoundManager.prototype = {
            boot: function() {
                var t = this.game.device,
                    e = window.PhaserGlobal;
                if (t.iOS && !1 === t.webAudio && (this.channels = 1), e) {
                    if (!0 === e.disableAudio) return this.noAudio = !0, void(this.touchLocked = !1);
                    if (!0 === e.disableWebAudio) return this.usingAudioTag = !0, void(this.touchLocked = !1)
                }
                if (e && e.audioContext) this.context = e.audioContext;
                else {
                    var i = window.AudioContext || window.webkitAudioContext;
                    if (i) try {
                        this.context = new i
                    } catch (t) {
                        this.context = null, this.usingWebAudio = !1, this.touchLocked = !1, console.warn(t)
                    }
                }
                if (null === this.context) {
                    if (void 0 === window.Audio) return void(this.noAudio = !0);
                    this.usingAudioTag = !0
                } else this.usingWebAudio = !0, this.baseLatency = this.context.baseLatency || 256 / (this.context.sampleRate || 44100), void 0 === this.context.createGain ? this.masterGain = this.context.createGainNode() : this.masterGain = this.context.createGain(), this.masterGain.gain.value = 1, this.masterGain.connect(this.context.destination), "suspended" === this.context.state && this.game.canvas.addEventListener("click", this._resumeWebAudioOnClick);
                this.noAudio || t.needsTouchUnlock() && this.setTouchLock(), this.usingWebAudio && t.chrome && t.chromeVersion <= 65 && gradle.event('A "GainNode.gain.value setter smoothing is deprecated" notice in Chrome is normal. <https://github.com/photonstorm/phaser-ce/issues/385>')
            },
            setTouchLock: function() {
                this.noAudio || window.PhaserGlobal && !0 === window.PhaserGlobal.disableAudio || (this.game.input.addTouchLockCallback(this.unlock, this, !0), this.touchLocked = !0)
            },
            setTouchUnlock: function() {
                this.touchLocked = !1, this._unlockSource = null, this.onTouchUnlock.dispatch()
            },
            resumeWebAudio: function() {
                if (this.usingWebAudio && "suspended" === this.context.state) return this.context.resume()
            },
            unlock: function() {
                if (this.noAudio || !this.touchLocked || null !== this._unlockSource) return !0;
                if (this.usingAudioTag) this.setTouchUnlock();
                else if (this.usingWebAudio) {
                    var t = this.context.createBuffer(1, 1, 22050);
                    this._unlockSource = this.context.createBufferSource(), this._unlockSource.buffer = t, this._unlockSource.connect(this.context.destination);
                    var e = this;
                    this._unlockSource.onended = function() {
                        e.setTouchUnlock(), e.resumeWebAudio()
                    }, void 0 === this._unlockSource.start ? this._unlockSource.noteOn(0) : this._unlockSource.start(0), this.resumeWebAudio()
                }
                return !0
            },
            stopAll: function() {
                if (!this.noAudio)
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].stop()
            },
            pauseAll: function() {
                if (!this.noAudio)
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].pause()
            },
            resumeAll: function() {
                if (!this.noAudio)
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].resume()
            },
            decode: function(t, e) {
                e = e || null;
                var i = this.game.cache.getSoundData(t);
                if (i && !1 === this.game.cache.isSoundDecoded(t)) {
                    this.game.cache.updateSound(t, "isDecoding", !0);
                    var s = this;
                    try {
                        this.context.decodeAudioData(i, function(i) {
                            i && (s.game.cache.decodedSound(t, i), s.onSoundDecode.dispatch(t, e))
                        })
                    } catch (t) {}
                }
            },
            setDecodedCallback: function(e, i, s) {
                "string" == typeof e && (e = [e]), this._watchList.reset();
                for (var n = 0; n < e.length; n++) e[n] instanceof t.Sound ? this.game.cache.isSoundDecoded(e[n].key) || this._watchList.add(e[n].key) : this.game.cache.isSoundDecoded(e[n]) || this._watchList.add(e[n]);
                0 === this._watchList.total ? (this._watching = !1, i.call(s)) : (this._watching = !0, this._watchCallback = i, this._watchContext = s)
            },
            update: function() {
                if (!this.noAudio) {
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t].update();
                    if (this._watching) {
                        for (var e = this._watchList.first; e;) this.game.cache.isSoundDecoded(e) && this._watchList.remove(e), e = this._watchList.next;
                        0 === this._watchList.total && (this._watching = !1, this._watchCallback.call(this._watchContext))
                    }
                }
            },
            add: function(e, i, s, n) {
                void 0 === i && (i = 1), void 0 === s && (s = !1), void 0 === n && (n = this.connectToMaster);
                var r = new t.Sound(this.game, e, i, s, n);
                return this._sounds.push(r), r
            },
            addSprite: function(e) {
                return new t.AudioSprite(this.game, e)
            },
            remove: function(t) {
                for (var e = this._sounds.length; e--;)
                    if (this._sounds[e] === t) return this._sounds[e].destroy(!1), this._sounds.splice(e, 1), !0;
                return !1
            },
            removeAll: function() {
                this.stopAll();
                for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].destroy();
                this._sounds.length = 0
            },
            removeByKey: function(t) {
                for (var e = this._sounds.length, i = 0; e--;) this._sounds[e].key === t && (this._sounds[e].destroy(!1), this._sounds.splice(e, 1), i++);
                return i
            },
            play: function(t, e, i) {
                if (!this.noAudio) {
                    var s = this.add(t, e, i);
                    return s.play(), s
                }
            },
            setMute: function() {
                if (!this._muted) {
                    this._muted = !0, this.usingWebAudio && (this._muteVolume = this.masterGain.gain.value, this.masterGain.gain.value = 0);
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t].usingAudioTag && (this._sounds[t].mute = !0);
                    this.onMute.dispatch()
                }
            },
            unsetMute: function() {
                if (this._muted && !this._codeMuted) {
                    this._muted = !1, this.usingWebAudio && (this.masterGain.gain.value = this._muteVolume);
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t].usingAudioTag && (this._sounds[t].mute = !1);
                    this.onUnMute.dispatch()
                }
            },
            destroy: function() {
                this.removeAll(), this.onSoundDecode.dispose(), this.game.canvas.removeEventListener("click", this._resumeWebAudioOnClick), this.context && (window.PhaserGlobal ? window.PhaserGlobal.audioContext = this.context : this.context.close && this.context.close())
            },
            _resumeWebAudioOnClick: function() {
                this.resumeWebAudio(), this.game.canvas.removeEventListener("click", this._resumeWebAudioOnClick)
            }
        }, t.SoundManager.prototype.constructor = t.SoundManager, Object.defineProperty(t.SoundManager.prototype, "mute", {
            get: function() {
                return this._muted
            },
            set: function(t) {
                if (t = t || !1) {
                    if (this._muted) return;
                    this._codeMuted = !0, this.setMute()
                } else {
                    if (!this._muted) return;
                    this._codeMuted = !1, this.unsetMute()
                }
            }
        }), Object.defineProperty(t.SoundManager.prototype, "volume", {
            get: function() {
                return this._volume
            },
            set: function(t) {
                if (t < 0 ? t = 0 : t > 1 && (t = 1), this._volume !== t) {
                    if (this._volume = t, this.usingWebAudio) this.masterGain.gain.value = t;
                    else
                        for (var e = 0; e < this._sounds.length; e++) this._sounds[e].usingAudioTag && this._sounds[e].updateGlobalVolume(t);
                    this.onVolumeChange.dispatch(t)
                }
            }
        }), t.ScaleManager = function(e, i, s) {
            this.game = e, this.dom = t.DOM, this.grid = null, this.width = 0, this.height = 0, this.minWidth = null, this.maxWidth = null, this.minHeight = null, this.maxHeight = null, this.offset = new t.Point, this.forceLandscape = !1, this.forcePortrait = !1, this.incorrectOrientation = !1, this._pageAlignHorizontally = !1, this._pageAlignVertically = !1, this.onOrientationChange = new t.Signal, this.enterIncorrectOrientation = new t.Signal, this.leaveIncorrectOrientation = new t.Signal, this.hasPhaserSetFullScreen = !1, this.fullScreenTarget = null, this._createdFullScreenTarget = null, this.onFullScreenInit = new t.Signal, this.onFullScreenChange = new t.Signal, this.onFullScreenError = new t.Signal, this.screenOrientation = this.dom.getScreenOrientation(), this.scaleFactor = new t.Point(1, 1), this.scaleFactorInversed = new t.Point(1, 1), this.margin = {
                left: 0,
                top: 0,
                right: 0,
                bottom: 0,
                x: 0,
                y: 0
            }, this.bounds = new t.Rectangle, this.aspectRatio = 0, this.sourceAspectRatio = 0, this.event = null, this.windowConstraints = {
                right: "layout",
                bottom: ""
            }, this.compatibility = {
                supportsFullScreen: !1,
                orientationFallback: null,
                noMargins: !1,
                scrollTo: null,
                forceMinimumDocumentHeight: !1,
                canExpandParent: !0,
                clickTrampoline: ""
            }, this._scaleMode = t.ScaleManager.NO_SCALE, this._fullScreenScaleMode = t.ScaleManager.NO_SCALE, this.parentIsWindow = !1, this.parentNode = null, this.parentScaleFactor = new t.Point(1, 1), this.trackParentInterval = 2e3, this.onSizeChange = new t.Signal, this.onResize = null, this.onResizeContext = null, this._pendingScaleMode = null, this._fullScreenRestore = null, this._gameSize = new t.Rectangle, this._userScaleFactor = new t.Point(1, 1), this._userScaleTrim = new t.Point(0, 0), this._lastUpdate = 0, this._updateThrottle = 0, this._updateThrottleReset = 100, this._parentBounds = new t.Rectangle, this._tempBounds = new t.Rectangle, this._lastReportedCanvasSize = new t.Rectangle, this._lastReportedGameSize = new t.Rectangle, this._booted = !1, e.config && this.parseConfig(e.config), this.setupScale(i, s)
        }, t.ScaleManager.EXACT_FIT = 0, t.ScaleManager.NO_SCALE = 1, t.ScaleManager.SHOW_ALL = 2, t.ScaleManager.RESIZE = 3, t.ScaleManager.USER_SCALE = 4, t.ScaleManager.MODES = ["EXACT_FIT", "NO_SCALE", "SHOW_ALL", "RESIZE", "USER_SCALE"], t.ScaleManager.prototype = {
            boot: function() {
                var e = this.compatibility;
                e.supportsFullScreen = this.game.device.fullscreen && !this.game.device.cocoonJS, this.game.device.iPad || this.game.device.webApp || this.game.device.desktop || (this.game.device.android && !this.game.device.chrome ? e.scrollTo = new t.Point(0, 1) : e.scrollTo = new t.Point(0, 0)), this.game.device.desktop ? (e.orientationFallback = "screen", e.clickTrampoline = "when-not-mouse") : (e.orientationFallback = "", e.clickTrampoline = "");
                var i = this;
                this._orientationChange = function(t) {
                    return i.orientationChange(t)
                }, this._windowResize = function(t) {
                    return i.windowResize(t)
                }, window.addEventListener("orientationchange", this._orientationChange, !1), window.addEventListener("resize", this._windowResize, !1), this.compatibility.supportsFullScreen && (this._fullScreenChange = function(t) {
                    return i.fullScreenChange(t)
                }, this._fullScreenError = function(t) {
                    return i.fullScreenError(t)
                }, document.addEventListener("webkitfullscreenchange", this._fullScreenChange, !1), document.addEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.addEventListener("MSFullscreenChange", this._fullScreenChange, !1), document.addEventListener("fullscreenchange", this._fullScreenChange, !1), document.addEventListener("webkitfullscreenerror", this._fullScreenError, !1), document.addEventListener("mozfullscreenerror", this._fullScreenError, !1), document.addEventListener("MSFullscreenError", this._fullScreenError, !1), document.addEventListener("fullscreenerror", this._fullScreenError, !1)), this.game.onResume.add(this._gameResumed, this), this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), this.setGameSize(this.game.width, this.game.height), this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), t.FlexGrid && (this.grid = new t.FlexGrid(this, this.width, this.height)), this._booted = !0, null !== this._pendingScaleMode && (this.scaleMode = this._pendingScaleMode, this._pendingScaleMode = null)
            },
            parseConfig: function(t) {
                void 0 !== t.scaleMode && (this._booted ? this.scaleMode = t.scaleMode : this._pendingScaleMode = t.scaleMode), void 0 !== t.fullScreenScaleMode && (this.fullScreenScaleMode = t.fullScreenScaleMode), t.fullScreenTarget && (this.fullScreenTarget = t.fullScreenTarget), this.pageAlignHorizontally = t.alignH || !1, this.pageAlignVertically = t.alignV || !1, t.scaleH && t.scaleV && this.setUserScale(t.scaleH, t.scaleV, t.trimH, t.trimV)
            },
            setupScale: function(e, i) {
                var s, n = new t.Rectangle;
                "" !== this.game.parent && ("string" == typeof this.game.parent ? s = document.getElementById(this.game.parent) : this.game.parent && 1 === this.game.parent.nodeType && (s = this.game.parent)), s ? (this.parentNode = s, this.parentIsWindow = !1, this.getParentBounds(this._parentBounds, this.parentNode), n.width = this._parentBounds.width, n.height = this._parentBounds.height, this.offset.set(this._parentBounds.x, this._parentBounds.y)) : (this.parentNode = null, this.parentIsWindow = !0, n.width = this.dom.visualBounds.width, n.height = this.dom.visualBounds.height, this.offset.set(0, 0));
                var r = 0,
                    o = 0;
                "number" == typeof e ? r = e : (this.parentScaleFactor.x = parseInt(e, 10) / 100, r = n.width * this.parentScaleFactor.x), "number" == typeof i ? o = i : (this.parentScaleFactor.y = parseInt(i, 10) / 100, o = n.height * this.parentScaleFactor.y), r = Math.floor(r), o = Math.floor(o), this._gameSize.setTo(0, 0, r, o), this.updateDimensions(r, o, !1)
            },
            _gameResumed: function() {
                this.queueUpdate(!0)
            },
            setGameSize: function(e, i) {
                this._gameSize.setTo(0, 0, e, i), this.currentScaleMode !== t.ScaleManager.RESIZE && this.updateDimensions(e, i, !0), this.queueUpdate(!0)
            },
            setUserScale: function(t, e, i, s, n, r) {
                this._userScaleFactor.setTo(t, e), this._userScaleTrim.setTo(0 | i, 0 | s), void 0 === n && (n = !0), void 0 === r && (r = !0), n && this.queueUpdate(r)
            },
            setResizeCallback: function(t, e) {
                this.onResize = t, this.onResizeContext = e
            },
            signalSizeChange: function() {
                if (!t.Rectangle.sameDimensions(this, this._lastReportedCanvasSize) || !t.Rectangle.sameDimensions(this.game, this._lastReportedGameSize)) {
                    var e = this.width,
                        i = this.height;
                    this._lastReportedCanvasSize.setTo(0, 0, e, i), this._lastReportedGameSize.setTo(0, 0, this.game.width, this.game.height), this.grid && this.grid.onResize(e, i), this.onSizeChange.dispatch(this, e, i), this.currentScaleMode === t.ScaleManager.RESIZE && (this.game.state.resize(e, i), this.game.load.resize(e, i))
                }
            },
            setMinMax: function(t, e, i, s) {
                this.minWidth = t, this.minHeight = e, void 0 !== i && (this.maxWidth = i), void 0 !== s && (this.maxHeight = s)
            },
            preUpdate: function() {
                if (!(this.game.time.time < this._lastUpdate + this._updateThrottle)) {
                    var e = this._updateThrottle;
                    this._updateThrottleReset = e >= 400 ? 0 : 100, this.dom.getOffset(this.game.canvas, this.offset);
                    var i = this._parentBounds.width,
                        s = this._parentBounds.height,
                        n = this.getParentBounds(this._parentBounds),
                        r = n.width !== i || n.height !== s,
                        o = this.updateOrientationState();
                    (r || o) && (this.onResize && this.onResize.call(this.onResizeContext, this, n), this.updateLayout(), this.signalSizeChange());
                    var a = 2 * this._updateThrottle;
                    this._updateThrottle < e && (a = Math.min(e, this._updateThrottleReset)), this._updateThrottle = t.Math.clamp(a, 25, this.trackParentInterval), this._lastUpdate = this.game.time.time
                }
            },
            pauseUpdate: function() {
                this.preUpdate(), this._updateThrottle = this.trackParentInterval
            },
            updateDimensions: function(t, e, i) {
                this.width = t * this.parentScaleFactor.x, this.height = e * this.parentScaleFactor.y, this.game.width = this.width, this.game.height = this.height, this.sourceAspectRatio = this.width / this.height, this.updateScalingAndBounds(), i && (this.game.renderer.resize(this.width, this.height), this.game.camera.setSize(this.width, this.height), this.game.world.resize(this.width, this.height))
            },
            updateScalingAndBounds: function() {
                this.scaleFactor.x = this.game.width / this.width, this.scaleFactor.y = this.game.height / this.height, this.scaleFactorInversed.x = this.width / this.game.width, this.scaleFactorInversed.y = this.height / this.game.height, this.aspectRatio = this.width / this.height, this.game.canvas && this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), this.game.input && this.game.input.scale && this.game.input.scale.setTo(this.scaleFactor.x, this.scaleFactor.y)
            },
            forceOrientation: function(t, e) {
                void 0 === e && (e = !1), !0 !== t || !0 !== e ? (this.forceLandscape = t, this.forcePortrait = e, this.queueUpdate(!0)) : console.warn("Phaser.ScaleManager: forceLandscape and forcePortrait cannot both be true.")
            },
            classifyOrientation: function(t) {
                return "portrait-primary" === t || "portrait-secondary" === t ? "portrait" : "landscape-primary" === t || "landscape-secondary" === t ? "landscape" : null
            },
            updateOrientationState: function() {
                var t = this.screenOrientation,
                    e = this.incorrectOrientation;
                this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), this.incorrectOrientation = this.forceLandscape && !this.isLandscape || this.forcePortrait && !this.isPortrait;
                var i = t !== this.screenOrientation,
                    s = e !== this.incorrectOrientation;
                return s && (this.incorrectOrientation ? this.enterIncorrectOrientation.dispatch() : this.leaveIncorrectOrientation.dispatch()), (i || s) && this.onOrientationChange.dispatch(this, t, e), i || s
            },
            orientationChange: function(t) {
                this.event = t, this.queueUpdate(!0)
            },
            windowResize: function(t) {
                this.event = t, this.queueUpdate(!0)
            },
            scrollTop: function() {
                var t = this.compatibility.scrollTo;
                t && window.scrollTo(t.x, t.y)
            },
            refresh: function() {
                this.scrollTop(), this.queueUpdate(!0)
            },
            updateLayout: function() {
                var e = this.currentScaleMode;
                if (e !== t.ScaleManager.RESIZE) {
                    if (this.scrollTop(), this.compatibility.forceMinimumDocumentHeight && (document.documentElement.style.minHeight = window.innerHeight + "px"), this.incorrectOrientation ? this.setMaximum() : e === t.ScaleManager.EXACT_FIT ? this.setExactFit() : e === t.ScaleManager.SHOW_ALL ? !this.isFullScreen && this.boundingParent && this.compatibility.canExpandParent ? (this.setShowAll(!0), this.resetCanvas(), this.setShowAll()) : this.setShowAll() : e === t.ScaleManager.NO_SCALE ? (this.width = this.game.width, this.height = this.game.height) : e === t.ScaleManager.USER_SCALE && (this.width = this.game.width * this._userScaleFactor.x - this._userScaleTrim.x, this.height = this.game.height * this._userScaleFactor.y - this._userScaleTrim.y), !this.compatibility.canExpandParent && (e === t.ScaleManager.SHOW_ALL || e === t.ScaleManager.USER_SCALE)) {
                        var i = this.getParentBounds(this._tempBounds);
                        this.width = Math.min(this.width, i.width), this.height = Math.min(this.height, i.height)
                    }
                    this.width = 0 | this.width, this.height = 0 | this.height, this.reflowCanvas()
                } else this.reflowGame()
            },
            getParentBounds: function(e, i) {
                var s = e || new t.Rectangle,
                    n = i || this.boundingParent,
                    r = this.dom.visualBounds,
                    o = this.dom.layoutBounds;
                if (n) {
                    var a = n.getBoundingClientRect(),
                        h = n.offsetParent ? n.offsetParent.getBoundingClientRect() : n.getBoundingClientRect();
                    s.setTo(a.left - h.left, a.top - h.top, a.width, a.height);
                    var l = this.windowConstraints;
                    if (l.right && (c = "layout" === l.right ? o : r, s.right = Math.min(s.right, c.width)), l.bottom) {
                        var c = "layout" === l.bottom ? o : r;
                        s.bottom = Math.min(s.bottom, c.height)
                    }
                } else s.setTo(0, 0, r.width, r.height);
                return s.setTo(Math.round(s.x), Math.round(s.y), Math.round(s.width), Math.round(s.height)), s
            },
            align: function(t, e) {
                null != t && (this.pageAlignHorizontally = t), null != e && (this.pageAlignVertically = e)
            },
            alignCanvas: function(t, e) {
                var i = this.getParentBounds(this._tempBounds),
                    s = this.game.canvas,
                    n = this.margin;
                if (t) {
                    if (n.left = n.right = 0, h = s.getBoundingClientRect(), this.width < i.width && !this.incorrectOrientation) {
                        var r = h.left - i.x,
                            o = i.width / 2 - this.width / 2,
                            a = (o = Math.max(o, 0)) - r;
                        n.left = Math.round(a)
                    }
                    s.style.marginLeft = n.left + "px", 0 !== n.left && (n.right = -(i.width - h.width - n.left), s.style.marginRight = n.right + "px")
                }
                if (e) {
                    n.top = n.bottom = 0;
                    var h = s.getBoundingClientRect();
                    if (this.height < i.height && !this.incorrectOrientation) {
                        r = h.top - i.y, o = i.height / 2 - this.height / 2, a = (o = Math.max(o, 0)) - r;
                        n.top = Math.round(a)
                    }
                    s.style.marginTop = n.top + "px", 0 !== n.top && (n.bottom = -(i.height - h.height - n.top), s.style.marginBottom = n.bottom + "px")
                }
                n.x = n.left, n.y = n.top
            },
            reflowGame: function() {
                this.resetCanvas("", "");
                var t = this.getParentBounds(this._tempBounds);
                this.updateDimensions(t.width, t.height, !0)
            },
            reflowCanvas: function() {
                this.incorrectOrientation || (this.width = t.Math.clamp(this.width, this.minWidth || 0, this.maxWidth || this.width), this.height = t.Math.clamp(this.height, this.minHeight || 0, this.maxHeight || this.height)), this.resetCanvas(), this.compatibility.noMargins || (this.isFullScreen && this._createdFullScreenTarget ? this.alignCanvas(!0, !0) : this.alignCanvas(this.pageAlignHorizontally, this.pageAlignVertically)), this.updateScalingAndBounds()
            },
            resetCanvas: function(t, e) {
                void 0 === t && (t = this.width + "px"), void 0 === e && (e = this.height + "px");
                var i = this.game.canvas;
                this.compatibility.noMargins || (i.style.marginLeft = "", i.style.marginTop = "", i.style.marginRight = "", i.style.marginBottom = ""), i.style.width = t, i.style.height = e
            },
            queueUpdate: function(t) {
                t && (this._parentBounds.width = 0, this._parentBounds.height = 0), this._updateThrottle = this._updateThrottleReset
            },
            reset: function(t) {
                t && this.grid && this.grid.reset()
            },
            setMaximum: function() {
                this.width = this.dom.visualBounds.width, this.height = this.dom.visualBounds.height
            },
            setShowAll: function(t) {
                var e, i = this.getParentBounds(this._tempBounds),
                    s = i.width,
                    n = i.height;
                e = t ? Math.max(n / this.game.height, s / this.game.width) : Math.min(n / this.game.height, s / this.game.width), this.width = Math.round(this.game.width * e), this.height = Math.round(this.game.height * e)
            },
            setExactFit: function() {
                var t = this.getParentBounds(this._tempBounds);
                this.width = t.width, this.height = t.height, this.isFullScreen || (this.maxWidth && (this.width = Math.min(this.width, this.maxWidth)), this.maxHeight && (this.height = Math.min(this.height, this.maxHeight)))
            },
            createFullScreenTarget: function() {
                var t = document.createElement("div");
                return t.style.margin = "0", t.style.padding = "0", t.style.background = "#000", t
            },
            startFullScreen: function(e, i, s) {
                if (this.isFullScreen) return !1;
                if (this.compatibility.supportsFullScreen) {
                    if ("when-not-mouse" === this.compatibility.clickTrampoline) {
                        var n = this.game.input;
                        if (n.activePointer && n.activePointer !== n.mousePointer && (i || !1 !== i)) return void n.activePointer.addClickTrampoline("startFullScreen", this.startFullScreen, this, [e, !1])
                    }
                    void 0 !== e && this.game.renderType === t.CANVAS && (this.game.stage.smoothed = e);
                    var r = this.fullScreenTarget;
                    r || (this.cleanupCreatedTarget(), this._createdFullScreenTarget = this.createFullScreenTarget(), r = this._createdFullScreenTarget);
                    var o = {
                        targetElement: r
                    };
                    if (this.hasPhaserSetFullScreen = !0, this.onFullScreenInit.dispatch(this, o), this._createdFullScreenTarget) {
                        var a = this.game.canvas;
                        a.parentNode.insertBefore(r, a), r.appendChild(a)
                    }
                    return void 0 === s && (s = {
                        navigationUI: "hide"
                    }), this.game.device.fullscreenKeyboard ? r[this.game.device.requestFullscreen](Element.ALLOW_KEYBOARD_INPUT) : r[this.game.device.requestFullscreen](s), !0
                }
                var h = this;
                setTimeout(function() {
                    h.fullScreenError()
                }, 10)
            },
            stopFullScreen: function() {
                return !(!this.isFullScreen || !this.compatibility.supportsFullScreen || (this.hasPhaserSetFullScreen = !1, document[this.game.device.cancelFullscreen](), 0))
            },
            cleanupCreatedTarget: function() {
                var t = this._createdFullScreenTarget;
                if (t && t.parentNode) {
                    var e = t.parentNode;
                    e.insertBefore(this.game.canvas, t), e.removeChild(t)
                }
                this._createdFullScreenTarget = null
            },
            prepScreenMode: function(e) {
                var i = !!this._createdFullScreenTarget,
                    s = this._createdFullScreenTarget || this.fullScreenTarget;
                e ? (i || this.fullScreenScaleMode === t.ScaleManager.EXACT_FIT) && s !== this.game.canvas && (this._fullScreenRestore = {
                    targetWidth: s.style.width,
                    targetHeight: s.style.height
                }, s.style.width = "100%", s.style.height = "100%") : (this._fullScreenRestore && (s.style.width = this._fullScreenRestore.targetWidth, s.style.height = this._fullScreenRestore.targetHeight, this._fullScreenRestore = null), this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.resetCanvas())
            },
            fullScreenChange: function(t) {
                this.event = t, this.isFullScreen ? (this.prepScreenMode(!0), this.updateLayout(), this.queueUpdate(!0)) : (this.prepScreenMode(!1), this.cleanupCreatedTarget(), this.updateLayout(), this.queueUpdate(!0)), this.onFullScreenChange.dispatch(this, this.width, this.height)
            },
            fullScreenError: function(t) {
                this.event = t, this.cleanupCreatedTarget(), console.warn("Phaser.ScaleManager: requestFullscreen failed or device does not support the Fullscreen API"), this.onFullScreenError.dispatch(this)
            },
            scaleSprite: function(t, e, i, s) {
                if (void 0 === e && (e = this.width), void 0 === i && (i = this.height), void 0 === s && (s = !1), !t || !t.scale) return t;
                if (t.scale.x = 1, t.scale.y = 1, t.width <= 0 || t.height <= 0 || e <= 0 || i <= 0) return t;
                var n = e,
                    r = t.height * e / t.width,
                    o = t.width * i / t.height,
                    a = i,
                    h = o > e;
                return (h = h ? s : !s) ? (t.width = Math.floor(n), t.height = Math.floor(r)) : (t.width = Math.floor(o), t.height = Math.floor(a)), t
            },
            destroy: function() {
                this.game.onResume.remove(this._gameResumed, this), window.removeEventListener("orientationchange", this._orientationChange, !1), window.removeEventListener("resize", this._windowResize, !1), this.compatibility.supportsFullScreen && (document.removeEventListener("webkitfullscreenchange", this._fullScreenChange, !1), document.removeEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.removeEventListener("MSFullscreenChange", this._fullScreenChange, !1), document.removeEventListener("fullscreenchange", this._fullScreenChange, !1), document.removeEventListener("webkitfullscreenerror", this._fullScreenError, !1), document.removeEventListener("mozfullscreenerror", this._fullScreenError, !1), document.removeEventListener("MSFullscreenError", this._fullScreenError, !1), document.removeEventListener("fullscreenerror", this._fullScreenError, !1))
            }
        }, t.ScaleManager.prototype.constructor = t.ScaleManager, Object.defineProperty(t.ScaleManager.prototype, "boundingParent", {
            get: function() {
                return this.parentIsWindow || this.isFullScreen && this.hasPhaserSetFullScreen && !this._createdFullScreenTarget ? null : this.game.canvas && this.game.canvas.parentNode || null
            }
        }), Object.defineProperty(t.ScaleManager.prototype, "scaleMode", {
            get: function() {
                return this._scaleMode
            },
            set: function(t) {
                return t !== this._scaleMode && (this.isFullScreen || (this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.queueUpdate(!0)), this._scaleMode = t), this._scaleMode
            }
        }), Object.defineProperty(t.ScaleManager.prototype, "fullScreenScaleMode", {
            get: function() {
                return this._fullScreenScaleMode
            },
            set: function(t) {
                return t !== this._fullScreenScaleMode && (this.isFullScreen ? (this.prepScreenMode(!1), this._fullScreenScaleMode = t, this.prepScreenMode(!0), this.queueUpdate(!0)) : this._fullScreenScaleMode = t), this._fullScreenScaleMode
            }
        }), Object.defineProperty(t.ScaleManager.prototype, "currentScaleMode", {
            get: function() {
                return this.isFullScreen ? this._fullScreenScaleMode : this._scaleMode
            }
        }), Object.defineProperty(t.ScaleManager.prototype, "pageAlignHorizontally", {
            get: function() {
                return this._pageAlignHorizontally
            },
            set: function(t) {
                t !== this._pageAlignHorizontally && (this._pageAlignHorizontally = t, this.queueUpdate(!0))
            }
        }), Object.defineProperty(t.ScaleManager.prototype, "pageAlignVertically", {
            get: function() {
                return this._pageAlignVertically
            },
            set: function(t) {
                t !== this._pageAlignVertically && (this._pageAlignVertically = t, this.queueUpdate(!0))
            }
        }), Object.defineProperty(t.ScaleManager.prototype, "isFullScreen", {
            get: function() {
                return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)
            }
        }), Object.defineProperty(t.ScaleManager.prototype, "isPortrait", {
            get: function() {
                return "portrait" === this.classifyOrientation(this.screenOrientation)
            }
        }), Object.defineProperty(t.ScaleManager.prototype, "isLandscape", {
            get: function() {
                return "landscape" === this.classifyOrientation(this.screenOrientation)
            }
        }), Object.defineProperty(t.ScaleManager.prototype, "isGamePortrait", {
            get: function() {
                return this.height > this.width
            }
        }), Object.defineProperty(t.ScaleManager.prototype, "isGameLandscape", {
            get: function() {
                return this.width > this.height
            }
        }), t.Utils.Debug = function(t) {
            this.game = t, this.sprite = null, this.bmd = null, this.canvas = null, this.context = null, this.font = "14px monospace", this.columnWidth = 100, this.lineHeight = 16, this.lineWidth = 1, this.renderShadow = !0, this.currentColor = null, this.currentX = 0, this.currentY = 0, this.currentAlpha = 1, this.dirty = !1, this.isDisabled = !1, this._line = null, this._rect = null
        }, t.Utils.Debug.GEOM_AUTO = 0, t.Utils.Debug.GEOM_RECTANGLE = 1, t.Utils.Debug.GEOM_CIRCLE = 2, t.Utils.Debug.GEOM_POINT = 3, t.Utils.Debug.GEOM_LINE = 4, t.Utils.Debug.GEOM_ELLIPSE = 5, t.Utils.Debug.prototype = {
            boot: function() {
                this.game.renderType === t.CANVAS ? this.context = this.game.context : (this.bmd = new t.BitmapData(this.game, "__DEBUG", this.game.width, this.game.height, !0), this.sprite = this.game.make.image(0, 0, this.bmd), this.game.stage.addChild(this.sprite), this.game.scale.onSizeChange.add(this.resize, this), this.canvas = t.CanvasPool.create(this, this.game.width, this.game.height), this.context = this.canvas.getContext("2d")), this._line = new t.Line, this._rect = new t.Rectangle
            },
            resize: function() {
                this.bmd.resize(this.game.width, this.game.height), this.canvas.width = this.game.width, this.canvas.height = this.game.height
            },
            preUpdate: function() {
                this.dirty && this.sprite && (this.bmd.clear(), this.bmd.draw(this.canvas, 0, 0), this.context.clearRect(0, 0, this.game.width, this.game.height), this.dirty = !1)
            },
            reset: function() {
                this.context && this.context.clearRect(0, 0, this.game.width, this.game.height), this.sprite && this.bmd.clear()
            },
            start: function(t, e, i, s) {
                "number" != typeof t && (t = 0), "number" != typeof e && (e = 0), i = i || "rgb(255,255,255)", void 0 === s && (s = 0), this.currentX = t, this.currentY = e, this.currentColor = i, this.columnWidth = s, this.dirty = !0, this.context.save(), this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.strokeStyle = i, this.context.fillStyle = i, this.context.font = this.font, this.context.globalAlpha = this.currentAlpha
            },
            stop: function() {
                this.context.restore()
            },
            line: function() {
                for (var t = this.currentX, e = 0; e < arguments.length; e++) this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(arguments[e], t + 1, this.currentY + 1), this.context.fillStyle = this.currentColor), this.context.fillText(arguments[e], t, this.currentY), t += this.columnWidth;
                this.currentY += this.lineHeight
            },
            sound: function(t, e, i) {
                var s = this.game.sound;
                this.start(t, e, i), s.noAudio ? this.line("Audio is disabled") : (this.line("Volume: " + s.volume.toFixed(2) + (s.mute ? " (Mute)" : "")), this.line("Mute on pause: " + s.muteOnPause), this.line("Using: " + (s.usingWebAudio ? "Web Audio - " + s.context.state : "Audio Tag")), this.line("Touch locked: " + s.touchLocked), this.line("Sounds: " + s._sounds.length)), this.stop()
            },
            soundInfo: function(t, e, i, s) {
                this.start(e, i, s), this.line("Sound: " + t.key + "  Touch locked: " + t.game.sound.touchLocked), this.line("Is Ready?: " + this.game.cache.isSoundReady(t.key) + "  Pending Playback: " + t.pendingPlayback), this.line("Decoded: " + t.isDecoded + "  Decoding: " + t.isDecoding), this.line("Playing: " + t.isPlaying + "  Loop: " + t.loop), this.line("Time: " + (t.currentTime / 1e3).toFixed(3) + "s  Total: " + t.totalDuration.toFixed(3) + "s"), this.line("Volume: " + t.volume.toFixed(2) + (t.mute ? " (Mute)" : "")), this.line("Using: " + (t.usingWebAudio ? "Web Audio" : "Audio Tag") + "  " + (t.usingWebAudio ? "Source: " + (t.sourceId || "none") : "")), "" !== t.currentMarker && (this.line("Marker: " + t.currentMarker + "  Duration: " + t.duration.toFixed(3) + "s (" + t.durationMS + "ms)"), this.line("Start: " + t.markers[t.currentMarker].start + "  Stop: " + t.markers[t.currentMarker].stop), this.line("Position: " + t.position)), this.stop()
            },
            camera: function(t, e, i) {
                var s = t.deadzone,
                    n = t.target,
                    r = t.view;
                s && (this._rect.setTo(r.x + s.x, r.y + s.y, s.width, s.height), this.rectangle(this._rect, e, i)), n && (this._line.setTo(r.centerX, r.centerY, n.x, n.y), this.geom(this._line, e, i), this.geom(n, e, !1, 3))
            },
            cameraInfo: function(t, e, i, s) {
                var n = t.bounds,
                    r = t.deadzone,
                    o = t.target,
                    a = t.view;
                this.start(e, i, s), this.line("Camera (" + t.width + " x " + t.height + ")"), this.line("x: " + t.x + " y: " + t.y), this.line("Bounds: " + (n ? "x: " + n.x + " y: " + n.y + " w: " + n.width + " h: " + n.height : "none")), this.line("View: x: " + a.x + " y: " + a.y + " w: " + a.width + " h: " + a.height), this.line("Center: x: " + t.centerX + " y: " + t.centerY), this.line("Deadzone: " + (r ? "x: " + r.x + " y: " + r.y + " w: " + r.width + " h: " + r.height : r)), this.line("Total in view: " + t.totalInView), this.line("At limit: x: " + t.atLimit.x + " y: " + t.atLimit.y), this.line("Target: " + (o ? o.name || o : "none")), this.stop()
            },
            timer: function(t, e, i, s) {
                this.start(e, i, s), this.line("Timer (running: " + t.running + " expired: " + t.expired + ")"), this.line("Next Tick: " + t.next + " Duration: " + t.duration), this.line("Paused: " + t.paused + " Length: " + t.length), this.stop()
            },
            pointer: function(t, e, i, s, n, r) {
                if (null != t && (void 0 === e && (e = !1), i = i || "rgba(0,255,0,0.5)", s = s || "rgba(255,255,0,0.5)", r = r || "rgba(255,0,0,0.5)", !0 !== e || !0 !== t.isUp)) {
                    this.start(t.x, t.y - 150, n), this.context.beginPath(), this.context.arc(t.x, t.y, t.circle.radius, 0, 2 * Math.PI), t.active ? this.context.fillStyle = t.isDown ? i : s : this.context.fillStyle = r, this.context.fill(), this.context.closePath(), this.context.beginPath(), this.context.moveTo(t.positionDown.x, t.positionDown.y), this.context.lineTo(t.position.x, t.position.y), this.context.lineWidth = 2, this.context.stroke(), this.context.closePath();
                    var o = t.movementX,
                        a = t.movementY;
                    (o || a) && (this.context.beginPath(), this.context.moveTo(o + t.position.x, a + t.position.y), this.context.lineTo(t.position.x, t.position.y), this.context.lineWidth = 2, this.context.stroke(), this.context.closePath()), this.line("ID: " + t.id + " Active: " + t.active), this.line("World X: " + t.worldX.toFixed(1) + " World Y: " + t.worldY.toFixed(1)), this.line("Screen X: " + t.x.toFixed(1) + " Screen Y: " + t.y.toFixed(1) + " In: " + t.withinGame), this.line("Movement: X: " + o + " Y: " + a), this.line("Duration: " + t.duration + " ms"), this.line("is Down: " + t.isDown + " is Up: " + t.isUp), t.isMouse && this.line("Buttons: " + this._pointerButtonIcon(t.leftButton) + " " + this._pointerButtonIcon(t.middleButton) + " " + this._pointerButtonIcon(t.rightButton)), this.stop()
                }
            },
            _pointerButtonIcon: function(t) {
                return t.isDown ? "x" : t.isUp ? "o" : "-"
            },
            spriteInputInfo: function(t, e, i, s) {
                this.start(e, i, s), this.line("Sprite Input: (" + t.width + " x " + t.height + ")"), this.line("x: " + t.input.pointerX().toFixed(1) + " y: " + t.input.pointerY().toFixed(1)), this.line("over: " + t.input.pointerOver() + " duration: " + t.input.overDuration().toFixed(0)), this.line("down: " + t.input.pointerDown() + " duration: " + t.input.downDuration().toFixed(0)), this.line("just over: " + t.input.justOver() + " just out: " + t.input.justOut()), this.stop()
            },
            key: function(t, e, i, s) {
                this.start(e, i, s, 150), this.line("Key:", t.keyCode, "isDown:", t.isDown), this.line("justDown:", t.justDown, "justUp:", t.justUp), this.line("Time Down:", t.timeDown.toFixed(0), "duration:", t.duration.toFixed(0)), this.stop()
            },
            inputInfo: function(e, i, s, n) {
                var r = this.game.input;
                if (void 0 === n && (n = !0), this.start(e, i, s), this.line("Input"), this.line("X: " + r.x + " Y: " + r.y), this.line("World X: " + r.worldX + " World Y: " + r.worldY), this.line("Scale X: " + r.scale.x.toFixed(2) + " Scale Y: " + r.scale.x.toFixed(2)), this.line("Screen X: " + r.activePointer.screenX.toFixed(1) + " Screen Y: " + r.activePointer.screenY.toFixed(1)), n) {
                    this.line("Sources:"), this.line("  " + this._inputHandler(r.mouse, "mouse")), this.line("  " + this._inputHandler(r.mspointer, "mspointer")), this.line("  " + this._inputHandler(r.touch, "touch"));
                    var o = r.pointers,
                        a = r.mousePointer,
                        h = t.PointerModes;
                    this.line("Pointers: (Max: " + r.maxPointers + ")"), this.line("  " + (a.isDown ? "x" : "o") + " " + h[a.pointerMode] + " " + a.identifier);
                    for (var l = 0; l < o.length; l++) {
                        var c = o[l];
                        this.line("  " + (c.active ? "+" : "-") + " " + h[c.pointerMode] + " " + c.identifier)
                    }
                    this.stop()
                } else this.stop()
            },
            _inputHandler: function(t, e) {
                return this._inputHandlerStatusIcon(t) + " " + e + " " + this._inputHandlerCaptureIcon(t)
            },
            _inputHandlerStatusIcon: function(t) {
                return t.active ? t.enabled ? "+" : "-" : " "
            },
            _inputHandlerCaptureIcon: function(t) {
                return t.active && (t.capture || t.preventDefault) ? "*" : " "
            },
            spriteBounds: function(t, e, i) {
                var s = t.getBounds();
                s.x += this.game.camera.x, s.y += this.game.camera.y, this.rectangle(s, e, i)
            },
            ropeSegments: function(t, e, i) {
                var s = this;
                t.segments.forEach(function(t) {
                    s.rectangle(t, e, i)
                }, this)
            },
            spriteInfo: function(t, e, i, s) {
                this.start(e, i, s), this.line("Sprite: " + (t.name || "") + " (" + t.width + " x " + t.height + ") anchor: " + t.anchor.x + " x " + t.anchor.y), this.line("x: " + t.x.toFixed(1) + " y: " + t.y.toFixed(1)), this.line("angle: " + t.angle.toFixed(1) + " rotation: " + t.rotation.toFixed(1)), this.line("visible: " + t.visible + " in camera: " + t.inCamera), this.line("bounds x: " + t._bounds.x.toFixed(1) + " y: " + t._bounds.y.toFixed(1) + " w: " + t._bounds.width.toFixed(1) + " h: " + t._bounds.height.toFixed(1)), this.line("parent: " + (t.parent ? t.parent.name || "(DisplayObject)" : "(none)")), this.stop()
            },
            spriteCoords: function(t, e, i, s) {
                this.start(e, i, s, 100), t.name && this.line(t.name), this.line("x:", t.x.toFixed(2), "y:", t.y.toFixed(2)), this.line("pos x:", t.position.x.toFixed(2), "pos y:", t.position.y.toFixed(2)), this.line("world x:", t.world.x.toFixed(2), "world y:", t.world.y.toFixed(2)), this.stop()
            },
            lineInfo: function(t, e, i, s) {
                this.start(e, i, s, 80), this.line("start.x:", t.start.x.toFixed(2), "start.y:", t.start.y.toFixed(2)), this.line("end.x:", t.end.x.toFixed(2), "end.y:", t.end.y.toFixed(2)), this.line("length:", t.length.toFixed(2), "angle:", t.angle), this.stop()
            },
            pixel: function(t, e, i, s) {
                s = s || 2, this.start(), this.context.fillStyle = i, this.context.fillRect(t, e, s, s), this.stop()
            },
            geom: function(e, i, s, n) {
                void 0 === s && (s = !0), void 0 === n && (n = 0), i = i || "rgba(0,255,0,0.4)", this.start(), this.context.fillStyle = i, this.context.strokeStyle = i, this.context.lineWidth = this.lineWidth;
                var r = t.Utils.Debug;
                n === r.GEOM_RECTANGLE || e instanceof t.Rectangle ? s ? this.context.fillRect(e.x - this.game.camera.x, e.y - this.game.camera.y, e.width, e.height) : this.context.strokeRect(e.x - this.game.camera.x, e.y - this.game.camera.y, e.width, e.height) : n === r.GEOM_CIRCLE || e instanceof t.Circle ? (this.context.beginPath(), this.context.arc(e.x - this.game.camera.x, e.y - this.game.camera.y, e.radius, 0, 2 * Math.PI, !1), this.context.closePath(), s ? this.context.fill() : this.context.stroke()) : n === r.GEOM_POINT || e instanceof t.Point ? this.context.fillRect(e.x - this.game.camera.x, e.y - this.game.camera.y, 4, 4) : n === r.GEOM_LINE || e instanceof t.Line ? (this.context.beginPath(), this.context.moveTo(e.start.x + .5 - this.game.camera.x, e.start.y + .5 - this.game.camera.y), this.context.lineTo(e.end.x + .5 - this.game.camera.x, e.end.y + .5 - this.game.camera.y), this.context.closePath(), this.context.stroke()) : (n === r.GEOM_ELLIPSE || e instanceof t.Ellipse) && (this.context.beginPath(), this.context.ellipse(e.centerX - this.game.camera.x, e.centerY - this.game.camera.y, e.width / 2, e.height / 2, 0, 2 * Math.PI, !1), this.context.closePath(), s ? this.context.fill() : this.context.stroke()), this.stop()
            },
            rectangle: function(t, e, i) {
                void 0 === i && (i = !0), e = e || "rgba(0, 255, 0, 0.4)", this.start(), i ? (this.context.fillStyle = e, this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height)) : (this.context.lineWidth = this.lineWidth, this.context.strokeStyle = e, this.context.strokeRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height)), this.stop()
            },
            text: function(t, e, i, s, n) {
                s = s || "rgb(255,255,255)", n = n || this.font, this.start(), this.context.font = n, this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(t, e + 1, i + 1)), this.context.fillStyle = s, this.context.fillText(t, e, i), this.stop()
            },
            quadTree: function(t, e) {
                e = e || "rgba(255,0,0,0.3)", this.start();
                var i = t.bounds;
                if (0 === t.nodes.length)
                    for (this.context.strokeStyle = e, this.context.strokeRect(i.x, i.y, i.width, i.height), this.text("size: " + t.objects.length, i.x + 4, i.y + 16, "rgb(0,200,0)", "12px Courier"), this.context.strokeStyle = "rgb(0,255,0)", s = 0; s < t.objects.length; s++) this.context.strokeRect(t.objects[s].x, t.objects[s].y, t.objects[s].width, t.objects[s].height);
                else
                    for (var s = 0; s < t.nodes.length; s++) this.quadTree(t.nodes[s]);
                this.stop()
            },
            body: function(e, i, s) {
                e.body && (this.start(), e.body.type === t.Physics.ARCADE ? t.Physics.Arcade.Body.render(this.context, e.body, i, s, this.lineWidth) : e.body.type === t.Physics.NINJA ? t.Physics.Ninja.Body.render(this.context, e.body, i, s) : e.body.type === t.Physics.BOX2D && t.Physics.Box2D.renderBody(this.context, e.body, i), this.stop())
            },
            bodyInfo: function(e, i, s, n) {
                e.body && (this.start(i, s, n, 210), e.body.type === t.Physics.ARCADE ? t.Physics.Arcade.Body.renderBodyInfo(this, e.body) : e.body.type === t.Physics.BOX2D && this.game.physics.box2d.renderBodyInfo(this, e.body), this.stop())
            },
            box2dWorld: function() {
                this.start(), this.context.translate(-this.game.camera.view.x, -this.game.camera.view.y, 0), this.game.physics.box2d.renderDebugDraw(this.context), this.stop()
            },
            box2dBody: function(e, i) {
                this.start(), t.Physics.Box2D.renderBody(this.context, e, i), this.stop()
            },
            displayList: function(t) {
                if (void 0 === t && (t = this.game.world), t.hasOwnProperty("renderOrderID") ? gradle.event("[" + t.renderOrderID + "]", t) : gradle.event("[]", t), t.children && t.children.length > 0)
                    for (var e = 0; e < t.children.length; e++) this.game.debug.displayList(t.children[e])
            },
            renderer: function(t, e, i) {
                var s = this.game.renderer,
                    n = s.renderSession;
                if (this.start(t, e, i), this.line((s.gl ? "WebGL" : "Canvas") + " Renderer (" + s.width + " x " + s.height + ")"), this.line("autoResize: " + s.autoResize), this.line("clearBeforeRender: " + s.clearBeforeRender), this.line("resolution: " + s.resolution), this.line("transparent: " + s.transparent), this.line("renderSession:"), s.gl) {
                    this.line("  currentBatchedTextures: (" + s.currentBatchedTextures.length + ")");
                    for (var r = 0; r < s.currentBatchedTextures.length; r++) this.line("    " + s.currentBatchedTextures[r]);
                    this.line("  drawCount: " + n.drawCount), this.line("  maxTextures: " + s.maxTextures), this.line("  maxTextureSize: " + s.maxTextureSize), this.line("  maxTextureAvailableSpace: " + n.maxTextureAvailableSpace), this.line("  roundPixels: " + n.roundPixels)
                } else this.line("  roundPixels: " + n.roundPixels), this.line("  scaleMode: " + (0 === n.scaleMode ? "LINEAR" : 1 === n.scaleMode ? "NEAREST" : n.scaleMode));
                this.stop()
            },
            canvasPool: function(e, i, s, n) {
                var r = t.CanvasPool;
                this.start(e, i, s, n || 100), this.line("Canvas Pool"), this.line("Used:", r.getTotal()), this.line("Free:", r.getFree()), this.line("Total:", r.length), this.stop()
            },
            physicsGroup: function(t, e, i, s) {
                t.forEach(this.body, this, s, e, i)
            },
            phaser: function(e, i, s) {
                this.text("Phaser v" + t.VERSION + " " + (this.game.renderType === t.WEBGL ? "WebGL" : "Canvas") + " " + (this.game.device.webAudio ? "WebAudio" : "HTML Audio"), e, i, s, this.font)
            },
            scale: function(e, i, s) {
                this.start(e, i, s);
                var n = this.game.scale,
                    r = n.scaleFactorInversed,
                    o = n._parentBounds;
                e = " x ";
                this.line("Game: " + this.game.width + e + this.game.height), this.line("Canvas: " + n.width + e + n.height + " (" + r.x.toFixed(2) + e + r.y.toFixed(2) + ") [" + n.aspectRatio.toFixed(2) + "]"), this.line("Mode: " + t.ScaleManager.MODES[n.currentScaleMode] + (n.currentScaleMode === t.ScaleManager.USER_SCALE ? " (" + n._userScaleFactor.x + e + n._userScaleFactor.y + ")" : "")), this.line("Parent: " + (n.parentIsWindow ? "window" : n.parentNode) + (o.empty ? "" : " (" + o.width + e + o.height + ")")), this.line("Screen: " + n.classifyOrientation(n.screenOrientation) + (n.incorrectOrientation ? " (incorrect)" : "")), this.stop()
            },
            loader: function(e, i, s, n) {
                var r = t.Utils.pad;
                this.start(i, s, n), e.hasLoaded ? this.line("Complete" + (e.resetLocked ? " [locked]" : "")) : e.isLoading ? this.line("Loading") : this.line("Not started"), e.hasLoaded && !e.resetLocked || (this.line("Progress: " + r(e.progress, 3) + "%"), this.line("Files: " + e._loadedFileCount + " of " + e._totalFileCount), this.line("Packs: " + e._loadedPackCount + " of " + e._loadedPackCount)), this.stop()
            },
            device: function(t, e, i) {
                var s = this.game.device;
                this.start(t, e, i), this.line("Device"), this.line("Pointer Events: " + s.mspointer), this.line("Touch: " + s.touch), this.line("Web Audio: " + s.webAudio), this.line("WebGL: " + s.webGL), this.stop()
            },
            destroy: function() {
                t.CanvasPool.remove(this)
            }
        }, t.Utils.Debug.prototype.constructor = t.Utils.Debug, t.DOM = {
            getOffset: function(e, i) {
                i = i || new t.Point;
                var s = e.getBoundingClientRect(),
                    n = t.DOM.scrollY,
                    r = t.DOM.scrollX,
                    o = document.documentElement.clientTop,
                    a = document.documentElement.clientLeft;
                return i.x = s.left + r - a, i.y = s.top + n - o, i
            },
            getBounds: function(t, e) {
                return void 0 === e && (e = 0), !(!(t = t && !t.nodeType ? t[0] : t) || 1 !== t.nodeType) && this.calibrate(t.getBoundingClientRect(), e)
            },
            calibrate: function(t, e) {
                e = +e || 0;
                var i = {
                    width: 0,
                    height: 0,
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0
                };
                return i.width = (i.right = t.right + e) - (i.left = t.left - e), i.height = (i.bottom = t.bottom + e) - (i.top = t.top - e), i
            },
            getAspectRatio: function(t) {
                var e = (t = null == t ? this.visualBounds : 1 === t.nodeType ? this.getBounds(t) : t).width,
                    i = t.height;
                return "function" == typeof e && (e = e.call(t)), "function" == typeof i && (i = i.call(t)), e / i
            },
            inLayoutViewport: function(t, e) {
                var i = this.getBounds(t, e);
                return !!i && i.bottom >= 0 && i.right >= 0 && i.top <= this.layoutBounds.width && i.left <= this.layoutBounds.height
            },
            getScreenOrientation: function(t) {
                var e = window.screen,
                    i = e.orientation || e.mozOrientation || e.msOrientation;
                if (i && "string" == typeof i.type) return i.type;
                if ("string" == typeof i) return i;
                var s = "portrait-primary",
                    n = "landscape-primary";
                if ("screen" === t) return e.height > e.width ? s : n;
                if ("viewport" === t) return this.visualBounds.height > this.visualBounds.width ? s : n;
                if ("window.orientation" === t && "number" == typeof window.orientation) return 0 === window.orientation || 180 === window.orientation ? s : n;
                if (window.matchMedia) {
                    if (window.matchMedia("(orientation: portrait)").matches) return s;
                    if (window.matchMedia("(orientation: landscape)").matches) return n
                }
                return this.visualBounds.height > this.visualBounds.width ? s : n
            },
            visualBounds: new t.Rectangle,
            layoutBounds: new t.Rectangle,
            documentBounds: new t.Rectangle
        }, t.Device.whenReady(function(e) {
            var i = window && "pageXOffset" in window ? function() {
                    return window.pageXOffset
                } : function() {
                    return document.documentElement.scrollLeft
                },
                s = window && "pageYOffset" in window ? function() {
                    return window.pageYOffset
                } : function() {
                    return document.documentElement.scrollTop
                };
            if (Object.defineProperty(t.DOM, "scrollX", {
                    get: i
                }), Object.defineProperty(t.DOM, "scrollY", {
                    get: s
                }), Object.defineProperty(t.DOM.visualBounds, "x", {
                    get: i
                }), Object.defineProperty(t.DOM.visualBounds, "y", {
                    get: s
                }), Object.defineProperty(t.DOM.layoutBounds, "x", {
                    value: 0
                }), Object.defineProperty(t.DOM.layoutBounds, "y", {
                    value: 0
                }), e.desktop && document.documentElement.clientWidth <= window.innerWidth && document.documentElement.clientHeight <= window.innerHeight) {
                var n = function() {
                        return Math.max(window.innerWidth, document.documentElement.clientWidth)
                    },
                    r = function() {
                        return Math.max(window.innerHeight, document.documentElement.clientHeight)
                    };
                Object.defineProperty(t.DOM.visualBounds, "width", {
                    get: n
                }), Object.defineProperty(t.DOM.visualBounds, "height", {
                    get: r
                }), Object.defineProperty(t.DOM.layoutBounds, "width", {
                    get: n
                }), Object.defineProperty(t.DOM.layoutBounds, "height", {
                    get: r
                })
            } else Object.defineProperty(t.DOM.visualBounds, "width", {
                get: function() {
                    return window.innerWidth
                }
            }), Object.defineProperty(t.DOM.visualBounds, "height", {
                get: function() {
                    return window.innerHeight
                }
            }), Object.defineProperty(t.DOM.layoutBounds, "width", {
                get: function() {
                    var t = document.documentElement.clientWidth,
                        e = window.innerWidth;
                    return t < e ? e : t
                }
            }), Object.defineProperty(t.DOM.layoutBounds, "height", {
                get: function() {
                    var t = document.documentElement.clientHeight,
                        e = window.innerHeight;
                    return t < e ? e : t
                }
            });
            Object.defineProperty(t.DOM.documentBounds, "x", {
                value: 0
            }), Object.defineProperty(t.DOM.documentBounds, "y", {
                value: 0
            }), Object.defineProperty(t.DOM.documentBounds, "width", {
                get: function() {
                    var t = document.documentElement;
                    return Math.max(t.clientWidth, t.offsetWidth, t.scrollWidth)
                }
            }), Object.defineProperty(t.DOM.documentBounds, "height", {
                get: function() {
                    var t = document.documentElement;
                    return Math.max(t.clientHeight, t.offsetHeight, t.scrollHeight)
                }
            })
        }, null, !0), t.ArraySet = function(t) {
            this.position = 0, this.list = t || []
        }, t.ArraySet.prototype = {
            add: function(t) {
                return this.exists(t) || this.list.push(t), t
            },
            getIndex: function(t) {
                return this.list.indexOf(t)
            },
            getByKey: function(t, e) {
                for (var i = this.list.length; i--;)
                    if (this.list[i][t] === e) return this.list[i];
                return null
            },
            exists: function(t) {
                return this.list.indexOf(t) > -1
            },
            reset: function() {
                this.list.length = 0
            },
            remove: function(t) {
                var e = this.list.indexOf(t);
                if (e > -1) return this.list.splice(e, 1), t
            },
            setAll: function(t, e) {
                for (var i = this.list.length; i--;) this.list[i] && (this.list[i][t] = e)
            },
            callAll: function(t) {
                for (var e = Array.prototype.slice.call(arguments, 1), i = this.list.length; i--;) this.list[i] && this.list[i][t] && this.list[i][t].apply(this.list[i], e)
            },
            removeAll: function(t) {
                void 0 === t && (t = !1);
                for (var e = this.list.length; e--;)
                    if (this.list[e]) {
                        var i = this.remove(this.list[e]);
                        t && i.destroy()
                    }
                this.position = 0, this.list = []
            }
        }, Object.defineProperty(t.ArraySet.prototype, "total", {
            get: function() {
                return this.list.length
            }
        }), Object.defineProperty(t.ArraySet.prototype, "first", {
            get: function() {
                return this.position = 0, this.list.length > 0 ? this.list[0] : null
            }
        }), Object.defineProperty(t.ArraySet.prototype, "next", {
            get: function() {
                return this.position < this.list.length ? (this.position++, this.list[this.position]) : null
            }
        }), t.ArraySet.prototype.constructor = t.ArraySet, t.ArrayUtils = {
            getRandomItem: function(t, e, i) {
                if (null === t) return null;
                void 0 === e && (e = 0), void 0 === i && (i = t.length);
                var s = e + Math.floor(Math.random() * i);
                return void 0 === t[s] ? null : t[s]
            },
            removeRandomItem: function(t, e, i) {
                if (null == t) return null;
                void 0 === e && (e = 0), void 0 === i && (i = t.length);
                var s = e + Math.floor(Math.random() * i);
                if (s < t.length) {
                    var n = t.splice(s, 1);
                    return void 0 === n[0] ? null : n[0]
                }
                return null
            },
            remove: function(t, e, i) {
                var s = t.length;
                if (!(e >= s || 0 === i)) {
                    null == i && (i = 1);
                    for (var n = s - i, r = e; r < n; ++r) t[r] = t[r + i];
                    t.length = n
                }
            },
            shuffle: function(t) {
                for (var e = t.length - 1; e > 0; e--) {
                    var i = Math.floor(Math.random() * (e + 1)),
                        s = t[e];
                    t[e] = t[i], t[i] = s
                }
                return t
            },
            transposeMatrix: function(t) {
                for (var e = t.length, i = t[0].length, s = new Array(i), n = 0; n < i; n++) {
                    s[n] = new Array(e);
                    for (var r = e - 1; r > -1; r--) s[n][r] = t[r][n]
                }
                return s
            },
            rotateMatrix: function(e, i) {
                if ("string" != typeof i && (i = (i % 360 + 360) % 360), 90 === i || -270 === i || "rotateLeft" === i) e = (e = t.ArrayUtils.transposeMatrix(e)).reverse();
                else if (-90 === i || 270 === i || "rotateRight" === i) e = e.reverse(), e = t.ArrayUtils.transposeMatrix(e);
                else if (180 === Math.abs(i) || "rotate180" === i) {
                    for (var s = 0; s < e.length; s++) e[s].reverse();
                    e = e.reverse()
                }
                return e
            },
            findClosest: function(t, e) {
                if (!e.length) return NaN;
                if (1 === e.length || t < e[0]) return e[0];
                for (var i = 1; e[i] < t;) i++;
                var s = e[i - 1],
                    n = i < e.length ? e[i] : Number.POSITIVE_INFINITY;
                return n - t <= t - s ? n : s
            },
            rotateRight: function(t) {
                var e = t.pop();
                return t.unshift(e), e
            },
            rotateLeft: function(t) {
                var e = t.shift();
                return t.push(e), e
            },
            numberArray: function(t, e) {
                null != e || (e = t, t = 0);
                for (var i = [], s = t; s <= e; s++) i.push(s);
                return i
            },
            numberArrayStep: function(e, i, s) {
                null != e || (e = 0), null != i || (i = e, e = 0), void 0 === s && (s = 1);
                for (var n = [], r = Math.max(t.Math.roundAwayFromZero((i - e) / (s || 1)), 0), o = 0; o < r; o++) n.push(e), e += s;
                return n
            }
        }, t.LinkedList = function() {
            this.next = null, this.prev = null, this.first = null, this.last = null, this.total = 0
        }, t.LinkedList.prototype = {
            add: function(t) {
                return 0 === this.total && null === this.first && null === this.last ? (this.first = t, this.last = t, this.next = t, t.prev = this, this.total++, t) : (this.last.next = t, t.prev = this.last, this.last = t, this.total++, t)
            },
            reset: function() {
                this.first = null, this.last = null, this.next = null, this.prev = null, this.total = 0
            },
            remove: function(t) {
                if (1 === this.total) return this.reset(), void(t.next = t.prev = null);
                t === this.first ? this.first = this.first.next : t === this.last && (this.last = this.last.prev), t.prev && (t.prev.next = t.next), t.next && (t.next.prev = t.prev), t.next = t.prev = null, null === this.first && (this.last = null), this.total--
            },
            callAll: function(t) {
                if (this.first && this.last) {
                    var e = this.first;
                    do {
                        e && e[t] && e[t].call(e), e = e.next
                    } while (e !== this.last.next)
                }
            }
        }, t.LinkedList.prototype.constructor = t.LinkedList, t.Create = function(t) {
            this.game = t, this.bmd = null, this.canvas = null, this.ctx = null, this.palettes = [{
                0: "#000",
                1: "#9D9D9D",
                2: "#FFF",
                3: "#BE2633",
                4: "#E06F8B",
                5: "#493C2B",
                6: "#A46422",
                7: "#EB8931",
                8: "#F7E26B",
                9: "#2F484E",
                A: "#44891A",
                B: "#A3CE27",
                C: "#1B2632",
                D: "#005784",
                E: "#31A2F2",
                F: "#B2DCEF"
            }, {
                0: "#000",
                1: "#191028",
                2: "#46af45",
                3: "#a1d685",
                4: "#453e78",
                5: "#7664fe",
                6: "#833129",
                7: "#9ec2e8",
                8: "#dc534b",
                9: "#e18d79",
                A: "#d6b97b",
                B: "#e9d8a1",
                C: "#216c4b",
                D: "#d365c8",
                E: "#afaab9",
                F: "#f5f4eb"
            }, {
                0: "#000",
                1: "#2234d1",
                2: "#0c7e45",
                3: "#44aacc",
                4: "#8a3622",
                5: "#5c2e78",
                6: "#aa5c3d",
                7: "#b5b5b5",
                8: "#5e606e",
                9: "#4c81fb",
                A: "#6cd947",
                B: "#7be2f9",
                C: "#eb8a60",
                D: "#e23d69",
                E: "#ffd93f",
                F: "#fff"
            }, {
                0: "#000",
                1: "#fff",
                2: "#8b4131",
                3: "#7bbdc5",
                4: "#8b41ac",
                5: "#6aac41",
                6: "#3931a4",
                7: "#d5de73",
                8: "#945a20",
                9: "#5a4100",
                A: "#bd736a",
                B: "#525252",
                C: "#838383",
                D: "#acee8b",
                E: "#7b73de",
                F: "#acacac"
            }, {
                0: "#000",
                1: "#191028",
                2: "#46af45",
                3: "#a1d685",
                4: "#453e78",
                5: "#7664fe",
                6: "#833129",
                7: "#9ec2e8",
                8: "#dc534b",
                9: "#e18d79",
                A: "#d6b97b",
                B: "#e9d8a1",
                C: "#216c4b",
                D: "#d365c8",
                E: "#afaab9",
                F: "#fff"
            }]
        }, t.Create.PALETTE_ARNE = 0, t.Create.PALETTE_JMP = 1, t.Create.PALETTE_CGA = 2, t.Create.PALETTE_C64 = 3, t.Create.PALETTE_JAPANESE_MACHINE = 4, t.Create.prototype = {
            texture: function(t, e, i, s, n, r, o, a) {
                void 0 === i && (i = 8), void 0 === s && (s = i), void 0 === n && (n = 0), void 0 === r && (r = !0);
                var h = e[0].length * i,
                    l = e.length * s;
                null === this.bmd && (this.bmd = this.game.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context), this.bmd.resize(h, l), this.bmd.clear();
                for (var c = 0; c < e.length; c++)
                    for (var u = e[c], d = 0; d < u.length; d++) {
                        var p = u[d];
                        "." !== p && " " !== p && (this.ctx.fillStyle = this.palettes[n][p], this.ctx.fillRect(d * i, c * s, i, s))
                    }
                return r ? this.bmd.generateTexture(t, o, a) : this.copy()
            },
            grid: function(t, e, i, s, n, r, o, a, h) {
                void 0 === o && (o = !0), null === this.bmd && (this.bmd = this.game.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context), this.bmd.resize(e, i), this.ctx.fillStyle = r;
                for (var l = 0; l < i; l += n) this.ctx.fillRect(0, l, e, 1);
                for (var c = 0; c < e; c += s) this.ctx.fillRect(c, 0, 1, i);
                return o ? this.bmd.generateTexture(t, a, h) : this.copy()
            },
            copy: function(t, e, i, s, n, r, o) {
                return null == t && (t = this.game.make.bitmapData()), t.resize(this.bmd.width, this.bmd.height), t.draw(this.bmd, e, i, s, n, r, o)
            }
        }, t.Create.prototype.constructor = t.Create, t.FlexGrid = function(e, i, s) {
            this.game = e.game, this.manager = e, this.width = i, this.height = s, this.boundsCustom = new t.Rectangle(0, 0, i, s), this.boundsFluid = new t.Rectangle(0, 0, i, s), this.boundsFull = new t.Rectangle(0, 0, i, s), this.boundsNone = new t.Rectangle(0, 0, i, s), this.positionCustom = new t.Point(0, 0), this.positionFluid = new t.Point(0, 0), this.positionFull = new t.Point(0, 0), this.positionNone = new t.Point(0, 0), this.scaleCustom = new t.Point(1, 1), this.scaleFluid = new t.Point(1, 1), this.scaleFluidInversed = new t.Point(1, 1), this.scaleFull = new t.Point(1, 1), this.scaleNone = new t.Point(1, 1), this.customWidth = 0, this.customHeight = 0, this.customOffsetX = 0, this.customOffsetY = 0, this.ratioH = i / s, this.ratioV = s / i, this.multiplier = 0, this.layers = []
        }, t.FlexGrid.prototype = {
            setSize: function(e, i) {
                this.width = e, this.height = i, this.ratioH = e / i, this.ratioV = i / e, this.scaleNone = new t.Point(1, 1), this.boundsNone.width = this.width, this.boundsNone.height = this.height, this.refresh()
            },
            createCustomLayer: function(e, i, s, n) {
                void 0 === n && (n = !0), this.customWidth = e, this.customHeight = i, this.boundsCustom.width = e, this.boundsCustom.height = i;
                var r = new t.FlexLayer(this, this.positionCustom, this.boundsCustom, this.scaleCustom);
                return n && this.game.world.add(r), this.layers.push(r), s && r.addMultiple(s), r
            },
            createFluidLayer: function(e, i) {
                void 0 === i && (i = !0);
                var s = new t.FlexLayer(this, this.positionFluid, this.boundsFluid, this.scaleFluid);
                return i && this.game.world.add(s), this.layers.push(s), e && s.addMultiple(e), s
            },
            createFullLayer: function(e) {
                var i = new t.FlexLayer(this, this.positionFull, this.boundsFull, this.scaleFluid);
                return this.game.world.add(i), this.layers.push(i), void 0 !== e && i.addMultiple(e), i
            },
            createFixedLayer: function(e) {
                var i = new t.FlexLayer(this, this.positionNone, this.boundsNone, this.scaleNone);
                return this.game.world.add(i), this.layers.push(i), void 0 !== e && i.addMultiple(e), i
            },
            reset: function() {
                for (var t = this.layers.length; t--;) this.layers[t].persist || (this.layers[t].position = null, this.layers[t].scale = null, this.layers.slice(t, 1))
            },
            onResize: function(t, e) {
                this.ratioH = t / e, this.ratioV = e / t, this.refresh(t, e)
            },
            refresh: function() {
                this.multiplier = Math.min(this.manager.height / this.height, this.manager.width / this.width), this.boundsFluid.width = Math.round(this.width * this.multiplier), this.boundsFluid.height = Math.round(this.height * this.multiplier), this.scaleFluid.set(this.boundsFluid.width / this.width, this.boundsFluid.height / this.height), this.scaleFluidInversed.set(this.width / this.boundsFluid.width, this.height / this.boundsFluid.height), this.scaleFull.set(this.boundsFull.width / this.width, this.boundsFull.height / this.height), this.boundsFull.width = Math.round(this.manager.width * this.scaleFluidInversed.x), this.boundsFull.height = Math.round(this.manager.height * this.scaleFluidInversed.y), this.boundsFluid.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY), this.boundsNone.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY), this.positionFluid.set(this.boundsFluid.x, this.boundsFluid.y), this.positionNone.set(this.boundsNone.x, this.boundsNone.y)
            },
            fitSprite: function(t) {
                this.manager.scaleSprite(t), t.x = this.manager.bounds.centerX, t.y = this.manager.bounds.centerY
            },
            debug: function() {
                this.game.debug.text(this.boundsFluid.width + " x " + this.boundsFluid.height, this.boundsFluid.x + 4, this.boundsFluid.y + 16), this.game.debug.geom(this.boundsFluid, "rgba(255,0,0,0.9", !1)
            }
        }, t.FlexGrid.prototype.constructor = t.FlexGrid, t.FlexLayer = function(e, i, s, n) {
            t.Group.call(this, e.game, null, "__flexLayer" + e.game.rnd.uuid(), !1), this.manager = e.manager, this.grid = e, this.persist = !1, this.position = i, this.bounds = s, this.scale = n, this.topLeft = s.topLeft, this.topMiddle = new t.Point(s.halfWidth, 0), this.topRight = s.topRight, this.bottomLeft = s.bottomLeft, this.bottomMiddle = new t.Point(s.halfWidth, s.bottom), this.bottomRight = s.bottomRight
        }, t.FlexLayer.prototype = Object.create(t.Group.prototype), t.FlexLayer.prototype.constructor = t.FlexLayer, t.FlexLayer.prototype.resize = function() {}, t.FlexLayer.prototype.debug = function() {
            this.game.debug.text(this.bounds.width + " x " + this.bounds.height, this.bounds.x + 4, this.bounds.y + 16), this.game.debug.geom(this.bounds, "rgba(0,0,255,0.9", !1), this.game.debug.geom(this.topLeft, "rgba(255,255,255,0.9"), this.game.debug.geom(this.topMiddle, "rgba(255,255,255,0.9"), this.game.debug.geom(this.topRight, "rgba(255,255,255,0.9")
        }, t.Color = {
            RED: 16711680,
            ORANGE: 16750848,
            YELLOW: 16776960,
            GREEN: 65280,
            AQUA: 65535,
            BLUE: 255,
            VIOLET: 16711935,
            WHITE: 16777215,
            BLACK: 0,
            GRAY: 6710886,
            packPixel: function(e, i, s, n) {
                return t.Device.LITTLE_ENDIAN ? (n << 24 | s << 16 | i << 8 | e) >>> 0 : (e << 24 | i << 16 | s << 8 | n) >>> 0
            },
            unpackPixel: function(e, i, s, n) {
                return null != i || (i = t.Color.createColor()), null != s || (s = !1), null != n || (n = !1), t.Device.LITTLE_ENDIAN ? (i.a = (4278190080 & e) >>> 24, i.b = (16711680 & e) >>> 16, i.g = (65280 & e) >>> 8, i.r = 255 & e) : (i.r = (4278190080 & e) >>> 24, i.g = (16711680 & e) >>> 16, i.b = (65280 & e) >>> 8, i.a = 255 & e), i.color = e, i.rgba = "rgba(" + i.r + "," + i.g + "," + i.b + "," + i.a / 255 + ")", s && t.Color.RGBtoHSL(i.r, i.g, i.b, i), n && t.Color.RGBtoHSV(i.r, i.g, i.b, i), i
            },
            fromRGBA: function(e, i) {
                return i || (i = t.Color.createColor()), i.r = (4278190080 & e) >>> 24, i.g = (16711680 & e) >>> 16, i.b = (65280 & e) >>> 8, i.a = 255 & e, i.rgba = "rgba(" + i.r + "," + i.g + "," + i.b + "," + i.a + ")", i
            },
            toRGBA: function(t, e, i, s) {
                return t << 24 | e << 16 | i << 8 | s
            },
            toABGR: function(t, e, i, s) {
                return (s << 24 | i << 16 | e << 8 | t) >>> 0
            },
            hexToRGBArray: function(t) {
                return [(t >> 16 & 255) / 255, (t >> 8 & 255) / 255, (255 & t) / 255]
            },
            RGBArrayToHex: function(t) {
                return (255 * t[0] << 16) + (255 * t[1] << 8) + 255 * t[2]
            },
            RGBtoHSL: function(e, i, s, n) {
                n || (n = t.Color.createColor(e, i, s, 1)), e /= 255, i /= 255, s /= 255;
                var r = Math.min(e, i, s),
                    o = Math.max(e, i, s);
                if (n.h = 0, n.s = 0, n.l = (o + r) / 2, o !== r) {
                    var a = o - r;
                    n.s = n.l > .5 ? a / (2 - o - r) : a / (o + r), o === e ? n.h = (i - s) / a + (i < s ? 6 : 0) : o === i ? n.h = (s - e) / a + 2 : o === s && (n.h = (e - i) / a + 4), n.h /= 6
                }
                return n
            },
            HSLtoRGB: function(e, i, s, n) {
                if (n ? (n.r = s, n.g = s, n.b = s) : n = t.Color.createColor(s, s, s), 0 !== i) {
                    var r = s < .5 ? s * (1 + i) : s + i - s * i,
                        o = 2 * s - r;
                    n.r = t.Color.hueToColor(o, r, e + 1 / 3), n.g = t.Color.hueToColor(o, r, e), n.b = t.Color.hueToColor(o, r, e - 1 / 3)
                }
                return n.r = Math.floor(255 * n.r | 0), n.g = Math.floor(255 * n.g | 0), n.b = Math.floor(255 * n.b | 0), t.Color.updateColor(n), n
            },
            RGBtoHSV: function(e, i, s, n) {
                n || (n = t.Color.createColor(e, i, s, 255)), e /= 255, i /= 255, s /= 255;
                var r = Math.min(e, i, s),
                    o = Math.max(e, i, s),
                    a = o - r;
                return n.h = 0, n.s = 0 === o ? 0 : a / o, n.v = o, o !== r && (o === e ? n.h = (i - s) / a + (i < s ? 6 : 0) : o === i ? n.h = (s - e) / a + 2 : o === s && (n.h = (e - i) / a + 4), n.h /= 6), n
            },
            HSVtoRGB: function(e, i, s, n) {
                void 0 === n && (n = t.Color.createColor(0, 0, 0, 1, e, i, 0, s));
                var r, o, a, h = Math.floor(6 * e),
                    l = 6 * e - h,
                    c = s * (1 - i),
                    u = s * (1 - l * i),
                    d = s * (1 - (1 - l) * i);
                switch (h % 6) {
                    case 0:
                        r = s, o = d, a = c;
                        break;
                    case 1:
                        r = u, o = s, a = c;
                        break;
                    case 2:
                        r = c, o = s, a = d;
                        break;
                    case 3:
                        r = c, o = u, a = s;
                        break;
                    case 4:
                        r = d, o = c, a = s;
                        break;
                    case 5:
                        r = s, o = c, a = u
                }
                return n.r = Math.floor(255 * r), n.g = Math.floor(255 * o), n.b = Math.floor(255 * a), t.Color.updateColor(n), n
            },
            hueToColor: function(t, e, i) {
                return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + (e - t) * (2 / 3 - i) * 6 : t
            },
            createColor: function(e, i, s, n, r, o, a, h) {
                var l = {
                    r: e || 0,
                    g: i || 0,
                    b: s || 0,
                    a: n || 1,
                    h: r || 0,
                    s: o || 0,
                    l: a || 0,
                    v: h || 0,
                    color: 0,
                    color32: 0,
                    rgba: ""
                };
                return t.Color.updateColor(l)
            },
            updateColor: function(e) {
                return e.rgba = "rgba(" + e.r.toFixed() + "," + e.g.toFixed() + "," + e.b.toFixed() + "," + e.a.toString() + ")", e.color = t.Color.getColor(e.r, e.g, e.b), e.color32 = t.Color.getColor32(255 * e.a, e.r, e.g, e.b), e
            },
            getColor32: function(t, e, i, s) {
                return t << 24 | e << 16 | i << 8 | s
            },
            getColor: function(t, e, i) {
                return t << 16 | e << 8 | i
            },
            RGBtoString: function(e, i, s, n, r) {
                return void 0 === n && (n = 255), void 0 === r && (r = "#"), "#" === r ? "#" + ((1 << 24) + (e << 16) + (i << 8) + s).toString(16).slice(1) : "0x" + t.Color.componentToHex(n) + t.Color.componentToHex(e) + t.Color.componentToHex(i) + t.Color.componentToHex(s)
            },
            hexToRGB: function(e) {
                var i = t.Color.hexToColor(e);
                if (i) return t.Color.getColor32(i.a, i.r, i.g, i.b)
            },
            hexToColor: function(e, i) {
                e = e.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(t, e, i, s) {
                    return e + e + i + i + s + s
                });
                var s = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);
                if (s) {
                    var n = parseInt(s[1], 16),
                        r = parseInt(s[2], 16),
                        o = parseInt(s[3], 16);
                    i ? (i.r = n, i.g = r, i.b = o) : i = t.Color.createColor(n, r, o)
                }
                return i
            },
            webToColor: function(e, i) {
                i || (i = t.Color.createColor());
                var s = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(e);
                return s && (i.r = ~~Number(s[1]), i.g = ~~Number(s[2]), i.b = ~~Number(s[3]), i.a = void 0 !== s[4] ? Number(s[4]) : 1, t.Color.updateColor(i)), i
            },
            valueToColor: function(e, i) {
                if (i || (i = t.Color.createColor()), "string" == typeof e) return 0 === e.indexOf("rgb") ? t.Color.webToColor(e, i) : (i.a = 1, t.Color.hexToColor(e, i));
                if ("number" == typeof e) {
                    var s = t.Color.getRGB(e);
                    return i.r = s.r, i.g = s.g, i.b = s.b, i.a = s.a / 255, i
                }
                return i
            },
            componentToHex: function(t) {
                var e = t.toString(16);
                return 1 === e.length ? "0" + e : e
            },
            HSVColorWheel: function(e, i) {
                void 0 === e && (e = 1), void 0 === i && (i = 1);
                for (var s = [], n = 0; n <= 359; n++) s.push(t.Color.HSVtoRGB(n / 359, e, i));
                return s
            },
            HSLColorWheel: function(e, i) {
                void 0 === e && (e = .5), void 0 === i && (i = .5);
                for (var s = [], n = 0; n <= 359; n++) s.push(t.Color.HSLtoRGB(n / 359, e, i));
                return s
            },
            interpolateColor: function(e, i, s, n, r, o) {
                void 0 === r && (r = 255), void 0 === o && (o = 0);
                var a = t.Color.getRGB(e),
                    h = t.Color.getRGB(i);
                if (0 === o) var l = (h.red - a.red) * n / s + a.red,
                    c = (h.green - a.green) * n / s + a.green,
                    u = (h.blue - a.blue) * n / s + a.blue;
                if (1 === o) {
                    var d, p = t.Color.RGBtoHSV(a.r, a.g, a.b),
                        f = t.Color.RGBtoHSV(h.r, h.g, h.b),
                        g = f.h - p.h;
                    if (p.h > f.h) {
                        var m = f.h;
                        f.h = p.h, p.h = m, g = -g, n = s - n
                    }
                    g > .5 && (p.h = p.h + 1, d = ((f.h - p.h) * n / s + p.h) % 1), g <= .5 && (d = (f.h - p.h) * n / s + p.h);
                    var y = (f.s - p.s) * n / s + p.s,
                        v = (f.v - p.v) * n / s + p.v,
                        x = t.Color.HSVtoRGB(d, y, v, x);
                    l = x.r, c = x.g, u = x.b
                }
                return t.Color.getColor32(r, l, c, u)
            },
            interpolateColorWithRGB: function(e, i, s, n, r, o) {
                var a = t.Color.getRGB(e),
                    h = (i - a.red) * o / r + a.red,
                    l = (s - a.green) * o / r + a.green,
                    c = (n - a.blue) * o / r + a.blue;
                return t.Color.getColor(h, l, c)
            },
            interpolateRGB: function(e, i, s, n, r, o, a, h) {
                var l = (n - e) * h / a + e,
                    c = (r - i) * h / a + i,
                    u = (o - s) * h / a + s;
                return t.Color.getColor(l, c, u)
            },
            linear: function(t, e, i) {
                return this.interpolateColor(t, e, 1, i)
            },
            linearInterpolation: function(e, i) {
                var s = t.Math.linear(0, e.length - 1, i),
                    n = e[Math.floor(s)],
                    r = e[Math.ceil(s)];
                return this.linear(n, r, s % 1)
            },
            getRandomColor: function(e, i, s) {
                if (void 0 === e && (e = 0), void 0 === i && (i = 255), void 0 === s && (s = 255), i > 255 || e > i) return t.Color.getColor(255, 255, 255);
                var n = e + Math.round(Math.random() * (i - e)),
                    r = e + Math.round(Math.random() * (i - e)),
                    o = e + Math.round(Math.random() * (i - e));
                return t.Color.getColor32(s, n, r, o)
            },
            getRGB: function(t) {
                return t > 16777215 ? {
                    alpha: t >>> 24,
                    red: t >> 16 & 255,
                    green: t >> 8 & 255,
                    blue: 255 & t,
                    a: t >>> 24,
                    r: t >> 16 & 255,
                    g: t >> 8 & 255,
                    b: 255 & t
                } : {
                    alpha: 255,
                    red: t >> 16 & 255,
                    green: t >> 8 & 255,
                    blue: 255 & t,
                    a: 255,
                    r: t >> 16 & 255,
                    g: t >> 8 & 255,
                    b: 255 & t
                }
            },
            getWebRGB: function(e) {
                if ("object" == typeof e) return "rgba(" + e.r.toString() + "," + e.g.toString() + "," + e.b.toString() + "," + (e.a / 255).toString() + ")";
                var i = t.Color.getRGB(e);
                return "rgba(" + i.r.toString() + "," + i.g.toString() + "," + i.b.toString() + "," + (i.a / 255).toString() + ")"
            },
            getAlpha: function(t) {
                return t >>> 24
            },
            getAlphaFloat: function(t) {
                return (t >>> 24) / 255
            },
            getRed: function(t) {
                return t >> 16 & 255
            },
            getGreen: function(t) {
                return t >> 8 & 255
            },
            getBlue: function(t) {
                return 255 & t
            },
            blendNormal: function(t) {
                return t
            },
            blendLighten: function(t, e) {
                return e > t ? e : t
            },
            blendDarken: function(t, e) {
                return e > t ? t : e
            },
            blendMultiply: function(t, e) {
                return t * e / 255
            },
            blendAverage: function(t, e) {
                return (t + e) / 2
            },
            blendAdd: function(t, e) {
                return Math.min(255, t + e)
            },
            blendSubtract: function(t, e) {
                return Math.max(0, t + e - 255)
            },
            blendDifference: function(t, e) {
                return Math.abs(t - e)
            },
            blendNegation: function(t, e) {
                return 255 - Math.abs(255 - t - e)
            },
            blendScreen: function(t, e) {
                return 255 - ((255 - t) * (255 - e) >> 8)
            },
            blendExclusion: function(t, e) {
                return t + e - 2 * t * e / 255
            },
            blendOverlay: function(t, e) {
                return e < 128 ? 2 * t * e / 255 : 255 - 2 * (255 - t) * (255 - e) / 255
            },
            blendSoftLight: function(t, e) {
                return e < 128 ? 2 * (64 + (t >> 1)) * (e / 255) : 255 - 2 * (255 - (64 + (t >> 1))) * (255 - e) / 255
            },
            blendHardLight: function(e, i) {
                return t.Color.blendOverlay(i, e)
            },
            blendColorDodge: function(t, e) {
                return 255 === e ? e : Math.min(255, (t << 8) / (255 - e))
            },
            blendColorBurn: function(t, e) {
                return 0 === e ? e : Math.max(0, 255 - (255 - t << 8) / e)
            },
            blendLinearDodge: function(e, i) {
                return t.Color.blendAdd(e, i)
            },
            blendLinearBurn: function(e, i) {
                return t.Color.blendSubtract(e, i)
            },
            blendLinearLight: function(e, i) {
                return i < 128 ? t.Color.blendLinearBurn(e, 2 * i) : t.Color.blendLinearDodge(e, 2 * (i - 128))
            },
            blendVividLight: function(e, i) {
                return i < 128 ? t.Color.blendColorBurn(e, 2 * i) : t.Color.blendColorDodge(e, 2 * (i - 128))
            },
            blendPinLight: function(e, i) {
                return i < 128 ? t.Color.blendDarken(e, 2 * i) : t.Color.blendLighten(e, 2 * (i - 128))
            },
            blendHardMix: function(e, i) {
                return t.Color.blendVividLight(e, i) < 128 ? 0 : 255
            },
            blendReflect: function(t, e) {
                return 255 === e ? e : Math.min(255, t * t / (255 - e))
            },
            blendGlow: function(e, i) {
                return t.Color.blendReflect(i, e)
            },
            blendPhoenix: function(t, e) {
                return Math.min(t, e) - Math.max(t, e) + 255
            }
        }, t.Physics = function(t, e) {
            e = e || {}, this.game = t, this.config = e, this.arcade = null, this.p2 = null, this.ninja = null, this.box2d = null, this.chipmunk = null, this.matter = null, this.parseConfig()
        }, t.Physics.ARCADE = 0, t.Physics.P2JS = 1, t.Physics.NINJA = 2, t.Physics.BOX2D = 3, t.Physics.CHIPMUNK = 4, t.Physics.MATTERJS = 5, t.Physics.prototype = {
            parseConfig: function() {
                this.config.hasOwnProperty("arcade") && !0 !== this.config.arcade || !t.Physics.hasOwnProperty("Arcade") || (this.arcade = new t.Physics.Arcade(this.game)), this.config.hasOwnProperty("ninja") && !0 === this.config.ninja && t.Physics.hasOwnProperty("Ninja") && (this.ninja = new t.Physics.Ninja(this.game)), this.config.hasOwnProperty("p2") && !0 === this.config.p2 && t.Physics.hasOwnProperty("P2") && (this.p2 = new t.Physics.P2(this.game, this.config)), this.config.hasOwnProperty("box2d") && !0 === this.config.box2d && t.Physics.hasOwnProperty("BOX2D") && (this.box2d = new t.Physics.Box2D(this.game, this.config)), this.config.hasOwnProperty("matter") && !0 === this.config.matter && t.Physics.hasOwnProperty("Matter") && (this.matter = new t.Physics.Matter(this.game, this.config))
            },
            startSystem: function(e) {
                e === t.Physics.ARCADE ? this.arcade = new t.Physics.Arcade(this.game) : e === t.Physics.P2JS ? null === this.p2 ? this.p2 = new t.Physics.P2(this.game, this.config) : this.p2.reset() : e === t.Physics.NINJA ? this.ninja = new t.Physics.Ninja(this.game) : e === t.Physics.BOX2D ? null === this.box2d ? this.box2d = new t.Physics.Box2D(this.game, this.config) : this.box2d.reset() : e === t.Physics.MATTERJS && (null === this.matter ? this.matter = new t.Physics.Matter(this.game, this.config) : this.matter.reset())
            },
            enable: function(e, i, s) {
                void 0 === i && (i = t.Physics.ARCADE), void 0 === s && (s = !1), i === t.Physics.ARCADE ? this.arcade.enable(e) : i === t.Physics.P2JS && this.p2 ? this.p2.enable(e, s) : i === t.Physics.NINJA && this.ninja ? this.ninja.enableAABB(e) : i === t.Physics.BOX2D && this.box2d ? this.box2d.enable(e) : i === t.Physics.MATTERJS && this.matter ? this.matter.enable(e) : console.warn(e.key + " is attempting to enable a physics body using an unknown physics system.")
            },
            preUpdate: function() {
                this.p2 && this.p2.preUpdate(), this.box2d && this.box2d.preUpdate(), this.matter && this.matter.preUpdate()
            },
            update: function() {
                this.p2 && this.p2.update(), this.box2d && this.box2d.update(), this.matter && this.matter.update()
            },
            setBoundsToWorld: function() {
                this.arcade && this.arcade.setBoundsToWorld(), this.ninja && this.ninja.setBoundsToWorld(), this.p2 && this.p2.setBoundsToWorld(), this.box2d && this.box2d.setBoundsToWorld(), this.matter && this.matter.setBoundsToWorld()
            },
            clear: function() {
                this.p2 && this.p2.clear(), this.box2d && this.box2d.clear(), this.matter && this.matter.clear()
            },
            reset: function() {
                this.p2 && this.p2.reset(), this.box2d && this.box2d.reset(), this.matter && this.matter.reset()
            },
            destroy: function() {
                this.p2 && this.p2.destroy(), this.box2d && this.box2d.destroy(), this.matter && this.matter.destroy(), this.arcade = null, this.ninja = null, this.p2 = null, this.box2d = null, this.matter = null
            }
        }, t.Physics.prototype.constructor = t.Physics, t.Physics.Arcade = function(e) {
            this.game = e, this.gravity = new t.Point, this.bounds = new t.Rectangle(0, 0, e.world.width, e.world.height), this.checkCollision = {
                up: !0,
                down: !0,
                left: !0,
                right: !0
            }, this.maxObjects = 10, this.maxLevels = 4, this.OVERLAP_BIAS = 4, this.forceX = !1, this.sortDirection = t.Physics.Arcade.LEFT_RIGHT, this.skipQuadTree = !0, this.isPaused = !1, this.quadTree = new t.QuadTree(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this._total = 0, this.setBoundsToWorld()
        }, t.Physics.Arcade.prototype.constructor = t.Physics.Arcade, t.Physics.Arcade.SORT_NONE = 0, t.Physics.Arcade.LEFT_RIGHT = 1, t.Physics.Arcade.RIGHT_LEFT = 2, t.Physics.Arcade.TOP_BOTTOM = 3, t.Physics.Arcade.BOTTOM_TOP = 4, t.Physics.Arcade.prototype = {
            setBounds: function(t, e, i, s) {
                this.bounds.setTo(t, e, i, s)
            },
            setBoundsToWorld: function() {
                this.bounds.copyFrom(this.game.world.bounds)
            },
            enable: function(e, i) {
                void 0 === i && (i = !0);
                var s = 1;
                if (Array.isArray(e))
                    for (s = e.length; s--;) e[s] instanceof t.Group ? this.enable(e[s].children, i) : (this.enableBody(e[s]), i && e[s].hasOwnProperty("children") && e[s].children.length > 0 && this.enable(e[s], !0));
                else e instanceof t.Group ? this.enable(e.children, i) : (this.enableBody(e), i && e.hasOwnProperty("children") && e.children.length > 0 && this.enable(e.children, !0))
            },
            enableBody: function(e) {
                e.hasOwnProperty("body") && null === e.body && (e.body = new t.Physics.Arcade.Body(e), e.parent && e.parent instanceof t.Group && e.parent.addToHash(e))
            },
            updateMotion: function(t) {
                if (t.allowRotation) {
                    var e = this.computeVelocity(0, t, t.angularVelocity, t.angularAcceleration, t.angularDrag, t.maxAngular) - t.angularVelocity;
                    t.angularVelocity += e, t.rotation += t.angularVelocity * this.game.time.physicsElapsed
                }
                t.velocity.x = this.computeVelocity(1, t, t.velocity.x, t.acceleration.x, t.drag.x, t.maxVelocity.x), t.velocity.y = this.computeVelocity(2, t, t.velocity.y, t.acceleration.y, t.drag.y, t.maxVelocity.y)
            },
            computeVelocity: function(t, e, i, s, n, r) {
                return void 0 === r && (r = 1e4), 1 === t && e.allowGravity ? i += (this.gravity.x + e.gravity.x) * this.game.time.physicsElapsed : 2 === t && e.allowGravity && (i += (this.gravity.y + e.gravity.y) * this.game.time.physicsElapsed), s ? i += s * this.game.time.physicsElapsed : n && e.allowDrag && (i - (n *= this.game.time.physicsElapsed) > 0 ? i -= n : i + n < 0 ? i += n : i = 0), i > r ? i = r : i < -r && (i = -r), i
            },
            overlap: function(t, e, i, s, n) {
                return i = i || null, s = s || null, n = n || i, this._total = 0, this.collideObjects(t, e, i, s, n, !0), this._total > 0
            },
            collide: function(t, e, i, s, n) {
                return i = i || null, s = s || null, n = n || i, this._total = 0, this.collideObjects(t, e, i, s, n, !1), this._total > 0
            },
            sortLeftRight: function(t, e) {
                return t.body && e.body ? t.body.x - e.body.x : 0
            },
            sortRightLeft: function(t, e) {
                return t.body && e.body ? e.body.x - t.body.x : 0
            },
            sortTopBottom: function(t, e) {
                return t.body && e.body ? t.body.y - e.body.y : 0
            },
            sortBottomTop: function(t, e) {
                return t.body && e.body ? e.body.y - t.body.y : 0
            },
            sort: function(e, i) {
                null !== e.physicsSortDirection ? i = e.physicsSortDirection : void 0 === i && (i = this.sortDirection), i === t.Physics.Arcade.LEFT_RIGHT ? e.hash.sort(this.sortLeftRight) : i === t.Physics.Arcade.RIGHT_LEFT ? e.hash.sort(this.sortRightLeft) : i === t.Physics.Arcade.TOP_BOTTOM ? e.hash.sort(this.sortTopBottom) : i === t.Physics.Arcade.BOTTOM_TOP && e.hash.sort(this.sortBottomTop)
            },
            collideObjects: function(t, e, i, s, n, r) {
                if (!Array.isArray(t) && Array.isArray(e))
                    for (o = 0; o < e.length; o++) e[o] && this.collideHandler(t, e[o], i, s, n, r);
                else if (Array.isArray(t) && !Array.isArray(e))
                    for (o = 0; o < t.length; o++) t[o] && this.collideHandler(t[o], e, i, s, n, r);
                else if (Array.isArray(t) && Array.isArray(e)) {
                    for (var o = 0; o < t.length; o++)
                        if (t[o])
                            for (var a = 0; a < e.length; a++) e[a] && this.collideHandler(t[o], e[a], i, s, n, r)
                } else this.collideHandler(t, e, i, s, n, r)
            },
            collideHandler: function(e, i, s, n, r, o) {
                if (void 0 === i && e.physicsType === t.GROUP) return this.sort(e), void this.collideGroupVsSelf(e, s, n, r, o);
                e && i && e.exists && i.exists && (this.sortDirection !== t.Physics.Arcade.SORT_NONE && (e.physicsType === t.GROUP && this.sort(e), i.physicsType === t.GROUP && this.sort(i)), e.physicsType === t.SPRITE ? i.physicsType === t.SPRITE ? this.collideSpriteVsSprite(e, i, s, n, r, o) : i.physicsType === t.GROUP ? this.collideSpriteVsGroup(e, i, s, n, r, o) : i.physicsType === t.TILEMAPLAYER && this.collideSpriteVsTilemapLayer(e, i, s, n, r, o) : e.physicsType === t.GROUP ? i.physicsType === t.SPRITE ? this.collideSpriteVsGroup(i, e, s, n, r, o) : i.physicsType === t.GROUP ? this.collideGroupVsGroup(e, i, s, n, r, o) : i.physicsType === t.TILEMAPLAYER && this.collideGroupVsTilemapLayer(e, i, s, n, r, o) : e.physicsType === t.TILEMAPLAYER && (i.physicsType === t.SPRITE ? this.collideSpriteVsTilemapLayer(i, e, s, n, r, o) : i.physicsType === t.GROUP && this.collideGroupVsTilemapLayer(i, e, s, n, r, o)))
            },
            collideSpriteVsSprite: function(t, e, i, s, n, r) {
                return !(!t.body || !e.body || (this.separate(t.body, e.body, s, n, r) && (i && i.call(n, t, e), this._total++), 0))
            },
            collideSpriteVsGroup: function(e, i, s, n, r, o) {
                if (0 !== i.length && e.body)
                    if (this.skipQuadTree || e.body.skipQuadTree)
                        for (var a = {}, h = 0; h < i.hash.length; h++) {
                            var l = i.hash[h];
                            if (l && l.exists && l.body) {
                                if (a = l.body.getBounds(a), this.sortDirection === t.Physics.Arcade.LEFT_RIGHT) {
                                    if (e.body.right < a.x) break;
                                    if (a.right < e.body.x) continue
                                } else if (this.sortDirection === t.Physics.Arcade.RIGHT_LEFT) {
                                    if (e.body.x > a.right) break;
                                    if (a.x > e.body.right) continue
                                } else if (this.sortDirection === t.Physics.Arcade.TOP_BOTTOM) {
                                    if (e.body.bottom < a.y) break;
                                    if (a.bottom < e.body.y) continue
                                } else if (this.sortDirection === t.Physics.Arcade.BOTTOM_TOP) {
                                    if (e.body.y > a.bottom) break;
                                    if (a.y > e.body.bottom) continue
                                }
                                this.collideSpriteVsSprite(e, l, s, n, r, o)
                            }
                        } else {
                            this.quadTree.clear(), this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this.quadTree.populate(i);
                            var c = this.quadTree.retrieve(e);
                            for (h = 0; h < c.length; h++) this.separate(e.body, c[h], n, r, o) && (s && s.call(r, e, c[h].sprite), this._total++)
                        }
            },
            collideGroupVsSelf: function(e, i, s, n, r) {
                if (0 !== e.length)
                    for (var o = 0; o < e.hash.length; o++) {
                        var a = {},
                            h = e.hash[o];
                        if (h && h.exists && h.body) {
                            a = h.body.getBounds(a);
                            for (var l = o + 1; l < e.hash.length; l++) {
                                var c = {},
                                    u = e.hash[l];
                                if (u && u.exists && u.body) {
                                    if (c = u.body.getBounds(c), this.sortDirection === t.Physics.Arcade.LEFT_RIGHT) {
                                        if (a.right < c.x) break;
                                        if (c.right < a.x) continue
                                    } else if (this.sortDirection === t.Physics.Arcade.RIGHT_LEFT) {
                                        if (a.x > c.right) continue;
                                        if (c.x > a.right) break
                                    } else if (this.sortDirection === t.Physics.Arcade.TOP_BOTTOM) {
                                        if (a.bottom < c.y) continue;
                                        if (c.bottom < a.y) break
                                    } else if (this.sortDirection === t.Physics.Arcade.BOTTOM_TOP) {
                                        if (a.y > c.bottom) continue;
                                        if (c.y > h.body.bottom) break
                                    }
                                    this.collideSpriteVsSprite(h, u, i, s, n, r)
                                }
                            }
                        }
                    }
            },
            collideGroupVsGroup: function(e, i, s, n, r, o) {
                if (0 !== e.length && 0 !== i.length)
                    for (var a = 0; a < e.children.length; a++) e.children[a].exists && (e.children[a].physicsType === t.GROUP ? this.collideGroupVsGroup(e.children[a], i, s, n, r, o) : this.collideSpriteVsGroup(e.children[a], i, s, n, r, o))
            },
            separate: function(t, e, i, s, n) {
                if (!t.enable || !e.enable || t.checkCollision.none || e.checkCollision.none || !this.intersects(t, e)) return !1;
                if (i && !1 === i.call(s, t.sprite, e.sprite)) return !1;
                if (t.isCircle && e.isCircle) return this.separateCircle(t, e, n);
                if (t.isCircle !== e.isCircle) {
                    var r = t.isCircle ? e : t,
                        o = t.isCircle ? t : e,
                        a = {
                            x: r.x,
                            y: r.y,
                            right: r.right,
                            bottom: r.bottom
                        },
                        h = o.center;
                    if ((h.y < a.y || h.y > a.bottom) && (h.x < a.x || h.x > a.right)) return this.separateCircle(t, e, n)
                }
                var l = !1,
                    c = !1;
                this.forceX || Math.abs(this.gravity.y + t.gravity.y) < Math.abs(this.gravity.x + t.gravity.x) ? (l = this.separateX(t, e, n), this.intersects(t, e) && (c = this.separateY(t, e, n))) : (c = this.separateY(t, e, n), this.intersects(t, e) && (l = this.separateX(t, e, n)));
                var u = l || c;
                return u && (n ? (t.onOverlap && t.onOverlap.dispatch(t.sprite, e.sprite), e.onOverlap && e.onOverlap.dispatch(e.sprite, t.sprite)) : (t.onCollide && t.onCollide.dispatch(t.sprite, e.sprite), e.onCollide && e.onCollide.dispatch(e.sprite, t.sprite))), u
            },
            intersects: function(e, i) {
                return e !== i && (e.isCircle ? i.isCircle ? t.Math.distance(e.center.x, e.center.y, i.center.x, i.center.y) <= e.halfWidth + i.halfWidth : this.circleBodyIntersects(e, i) : i.isCircle ? this.circleBodyIntersects(i, e) : !(e.right <= i.position.x || e.bottom <= i.position.y || e.position.x >= i.right || e.position.y >= i.bottom))
            },
            circleBodyIntersects: function(e, i) {
                var s = t.Math.clamp(e.center.x, i.left, i.right),
                    n = t.Math.clamp(e.center.y, i.top, i.bottom);
                return (e.center.x - s) * (e.center.x - s) + (e.center.y - n) * (e.center.y - n) <= e.halfWidth * e.halfWidth
            },
            separateCircle: function(e, i, s) {
                this.getOverlapX(e, i), this.getOverlapY(e, i);
                var n = i.center.x - e.center.x,
                    r = i.center.y - e.center.y,
                    o = Math.atan2(r, n),
                    a = 0;
                if (e.isCircle !== i.isCircle) {
                    var h = {
                            x: i.isCircle ? e.position.x : i.position.x,
                            y: i.isCircle ? e.position.y : i.position.y,
                            right: i.isCircle ? e.right : i.right,
                            bottom: i.isCircle ? e.bottom : i.bottom
                        },
                        l = {
                            x: e.isCircle ? e.center.x : i.center.x,
                            y: e.isCircle ? e.center.y : i.center.y,
                            radius: e.isCircle ? e.halfWidth : i.halfWidth
                        };
                    l.y < h.y ? l.x < h.x ? a = t.Math.distance(l.x, l.y, h.x, h.y) - l.radius : l.x > h.right && (a = t.Math.distance(l.x, l.y, h.right, h.y) - l.radius) : l.y > h.bottom && (l.x < h.x ? a = t.Math.distance(l.x, l.y, h.x, h.bottom) - l.radius : l.x > h.right && (a = t.Math.distance(l.x, l.y, h.right, h.bottom) - l.radius)), a *= -1
                } else a = e.halfWidth + i.halfWidth - t.Math.distance(e.center.x, e.center.y, i.center.x, i.center.y);
                if (s || 0 === a || e.immovable && i.immovable || e.customSeparateX || i.customSeparateX) return 0 !== a && (e.onOverlap && e.onOverlap.dispatch(e.sprite, i.sprite), i.onOverlap && i.onOverlap.dispatch(i.sprite, e.sprite)), 0 !== a;
                var c = e.velocity.x * Math.cos(o) + e.velocity.y * Math.sin(o),
                    u = -e.velocity.x * Math.sin(o) + e.velocity.y * Math.cos(o),
                    d = i.velocity.x * Math.cos(o) + i.velocity.y * Math.sin(o),
                    p = -i.velocity.x * Math.sin(o) + i.velocity.y * Math.cos(o),
                    f = ((e.mass - i.mass) * c + 2 * i.mass * d) / (e.mass + i.mass),
                    g = (2 * e.mass * c + (i.mass - e.mass) * d) / (e.mass + i.mass);
                return e.immovable || (e.velocity.x = (f * Math.cos(o) - u * Math.sin(o)) * e.bounce.x, e.velocity.y = (u * Math.cos(o) + f * Math.sin(o)) * e.bounce.y), i.immovable || (i.velocity.x = (g * Math.cos(o) - p * Math.sin(o)) * i.bounce.x, i.velocity.y = (p * Math.cos(o) + g * Math.sin(o)) * i.bounce.y), Math.abs(o) < Math.PI / 2 ? e.velocity.x > 0 && !e.immovable && i.velocity.x > e.velocity.x ? e.velocity.x *= -1 : i.velocity.x < 0 && !i.immovable && e.velocity.x < i.velocity.x ? i.velocity.x *= -1 : e.velocity.y > 0 && !e.immovable && i.velocity.y > e.velocity.y ? e.velocity.y *= -1 : i.velocity.y < 0 && !i.immovable && e.velocity.y < i.velocity.y && (i.velocity.y *= -1) : Math.abs(o) > Math.PI / 2 && (e.velocity.x < 0 && !e.immovable && i.velocity.x < e.velocity.x ? e.velocity.x *= -1 : i.velocity.x > 0 && !i.immovable && e.velocity.x > i.velocity.x ? i.velocity.x *= -1 : e.velocity.y < 0 && !e.immovable && i.velocity.y < e.velocity.y ? e.velocity.y *= -1 : i.velocity.y > 0 && !i.immovable && e.velocity.x > i.velocity.y && (i.velocity.y *= -1)), e.immovable || (e.x += e.velocity.x * this.game.time.physicsElapsed - a * Math.cos(o), e.y += e.velocity.y * this.game.time.physicsElapsed - a * Math.sin(o)), i.immovable || (i.x += i.velocity.x * this.game.time.physicsElapsed + a * Math.cos(o), i.y += i.velocity.y * this.game.time.physicsElapsed + a * Math.sin(o)), e.onCollide && e.onCollide.dispatch(e.sprite, i.sprite), i.onCollide && i.onCollide.dispatch(i.sprite, e.sprite), !0
            },
            getOverlapX: function(t, e, i) {
                var s = 0,
                    n = t.deltaAbsX() + e.deltaAbsX() + this.OVERLAP_BIAS;
                return 0 === t.deltaX() && 0 === e.deltaX() ? (t.embedded = !0, e.embedded = !0) : t.deltaX() > e.deltaX() ? (s = t.right - e.x) > n && !i || !1 === t.checkCollision.right || !1 === e.checkCollision.left ? s = 0 : (t.touching.none = !1, t.touching.right = !0, e.touching.none = !1, e.touching.left = !0) : t.deltaX() < e.deltaX() && (-(s = t.x - e.width - e.x) > n && !i || !1 === t.checkCollision.left || !1 === e.checkCollision.right ? s = 0 : (t.touching.none = !1, t.touching.left = !0, e.touching.none = !1, e.touching.right = !0)), t.overlapX = s, e.overlapX = s, s
            },
            getOverlapY: function(t, e, i) {
                var s = 0,
                    n = t.deltaAbsY() + e.deltaAbsY() + this.OVERLAP_BIAS;
                return 0 === t.deltaY() && 0 === e.deltaY() ? (t.embedded = !0, e.embedded = !0) : t.deltaY() > e.deltaY() ? (s = t.bottom - e.y) > n && !i || !1 === t.checkCollision.down || !1 === e.checkCollision.up ? s = 0 : (t.touching.none = !1, t.touching.down = !0, e.touching.none = !1, e.touching.up = !0) : t.deltaY() < e.deltaY() && (-(s = t.y - e.bottom) > n && !i || !1 === t.checkCollision.up || !1 === e.checkCollision.down ? s = 0 : (t.touching.none = !1, t.touching.up = !0, e.touching.none = !1, e.touching.down = !0)), t.overlapY = s, e.overlapY = s, s
            },
            separateX: function(t, e, i) {
                var s = this.getOverlapX(t, e, i);
                if (i || 0 === s || t.immovable && e.immovable || t.customSeparateX || e.customSeparateX) return 0 !== s || t.embedded && e.embedded;
                var n = t.velocity.x,
                    r = e.velocity.x;
                if (t.immovable || e.immovable) t.immovable ? (e.x += s, e.velocity.x = n - r * e.bounce.x, t.moves && (e.y += (t.y - t.prev.y) * t.friction.y)) : (t.x -= s, t.velocity.x = r - n * t.bounce.x, e.moves && (t.y += (e.y - e.prev.y) * e.friction.y));
                else {
                    s *= .5, t.x -= s, e.x += s;
                    var o = Math.sqrt(r * r * e.mass / t.mass) * (r > 0 ? 1 : -1),
                        a = Math.sqrt(n * n * t.mass / e.mass) * (n > 0 ? 1 : -1),
                        h = .5 * (o + a);
                    o -= h, a -= h, t.velocity.x = h + o * t.bounce.x, e.velocity.x = h + a * e.bounce.x
                }
                return !0
            },
            separateY: function(t, e, i) {
                var s = this.getOverlapY(t, e, i);
                if (i || 0 === s || t.immovable && e.immovable || t.customSeparateY || e.customSeparateY) return 0 !== s || t.embedded && e.embedded;
                var n = t.velocity.y,
                    r = e.velocity.y;
                if (t.immovable || e.immovable) t.immovable ? (e.y += s, e.velocity.y = n - r * e.bounce.y, t.moves && (e.x += (t.x - t.prev.x) * t.friction.x)) : (t.y -= s, t.velocity.y = r - n * t.bounce.y, e.moves && (t.x += (e.x - e.prev.x) * e.friction.x));
                else {
                    s *= .5, t.y -= s, e.y += s;
                    var o = Math.sqrt(r * r * e.mass / t.mass) * (r > 0 ? 1 : -1),
                        a = Math.sqrt(n * n * t.mass / e.mass) * (n > 0 ? 1 : -1),
                        h = .5 * (o + a);
                    o -= h, a -= h, t.velocity.y = h + o * t.bounce.y, e.velocity.y = h + a * e.bounce.y
                }
                return !0
            },
            getObjectsUnderPointer: function(t, e, i, s) {
                if (0 !== e.length && t.exists) return this.getObjectsAtLocation(t.x, t.y, e, i, s, t)
            },
            getObjectsAtLocation: function(e, i, s, n, r, o) {
                this.quadTree.clear(), this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this.quadTree.populate(s);
                for (var a = new t.Rectangle(e, i, 1, 1), h = [], l = this.quadTree.retrieve(a), c = 0; c < l.length; c++) l[c].hitTest(e, i) && (n && n.call(r, o, l[c].sprite), h.push(l[c].sprite));
                return h
            },
            moveToObject: function(e, i, s, n) {
                void 0 === s && (s = 60), void 0 === n && (n = 0);
                var r = t.Point.angle(i, e);
                return n > 0 && (s = this.distanceBetween(e, i) / (n / 1e3)), e.body.velocity.setToPolar(r, s), r
            },
            moveToPointer: function(t, e, i, s) {
                void 0 === e && (e = 60), i = i || this.game.input.activePointer, void 0 === s && (s = 0);
                var n = this.angleToPointer(t, i);
                return s > 0 && (e = this.distanceToPointer(t, i) / (s / 1e3)), t.body.velocity.setToPolar(n, e), n
            },
            moveToXY: function(t, e, i, s, n) {
                void 0 === s && (s = 60), void 0 === n && (n = 0);
                var r = Math.atan2(i - t.y, e - t.x);
                return n > 0 && (s = this.distanceToXY(t, e, i) / (n / 1e3)), t.body.velocity.setToPolar(r, s), r
            },
            velocityFromAngle: function(e, i, s) {
                return void 0 === i && (i = 60), (s = s || new t.Point).setToPolar(e, i, !0)
            },
            velocityFromRotation: function(e, i, s) {
                return void 0 === i && (i = 60), (s = s || new t.Point).setToPolar(e, i)
            },
            accelerationFromRotation: function(e, i, s) {
                return void 0 === i && (i = 60), (s = s || new t.Point).setToPolar(e, i)
            },
            accelerateToObject: function(t, e, i, s, n) {
                void 0 === i && (i = 60), void 0 === s && (s = 1e3), void 0 === n && (n = 1e3);
                var r = this.angleBetween(t, e);
                return t.body.acceleration.setToPolar(r, i), t.body.maxVelocity.setTo(s, n), r
            },
            accelerateToPointer: function(t, e, i, s, n) {
                void 0 === i && (i = 60), void 0 === e && (e = this.game.input.activePointer), void 0 === s && (s = 1e3), void 0 === n && (n = 1e3);
                var r = this.angleToPointer(t, e);
                return t.body.acceleration.setToPolar(r, i), t.body.maxVelocity.setTo(s, n), r
            },
            accelerateToXY: function(t, e, i, s, n, r) {
                void 0 === s && (s = 60), void 0 === n && (n = 1e3), void 0 === r && (r = 1e3);
                var o = this.angleToXY(t, e, i);
                return t.body.acceleration.setTo(o, s), t.body.maxVelocity.setTo(n, r), o
            },
            distanceBetween: function(t, e, i, s) {
                var n, r;
                return void 0 === i && (i = !1), s ? (n = t.centerX - e.centerX, r = t.centerY - e.centerY) : i ? (n = t.world.x - e.world.x, r = t.world.y - e.world.y) : (n = t.x - e.x, r = t.y - e.y), Math.sqrt(n * n + r * r)
            },
            distanceToXY: function(t, e, i, s) {
                void 0 === s && (s = !1);
                var n = s ? t.world.x - e : t.x - e,
                    r = s ? t.world.y - i : t.y - i;
                return Math.sqrt(n * n + r * r)
            },
            distanceToPointer: function(t, e, i) {
                void 0 === e && (e = this.game.input.activePointer), void 0 === i && (i = !1);
                var s = i ? t.world.x - e.worldX : t.x - e.worldX,
                    n = i ? t.world.y - e.worldY : t.y - e.worldY;
                return Math.sqrt(s * s + n * n)
            },
            closest: function(t, e, i, s) {
                for (var n = 1 / 0, r = null, o = 0, a = e.length; o < a; o++) {
                    var h = e[o],
                        l = this.distanceBetween(t, h, i, s);
                    l < n && (r = h, n = l)
                }
                return r
            },
            farthest: function(t, e, i, s) {
                for (var n = -1, r = null, o = 0, a = e.length; o < a; o++) {
                    var h = e[o],
                        l = this.distanceBetween(t, h, i, s);
                    l > n && (r = h, n = l)
                }
                return r
            },
            angleBetween: function(e, i, s) {
                return void 0 === s && (s = !1), s ? t.Point.angle(i.world, e.world) : t.Point.angle(i, e)
            },
            angleBetweenCenters: function(t, e) {
                var i = e.centerX - t.centerX,
                    s = e.centerY - t.centerY;
                return Math.atan2(s, i)
            },
            angleToXY: function(t, e, i, s) {
                return void 0 === s && (s = !1), s ? Math.atan2(i - t.world.y, e - t.world.x) : Math.atan2(i - t.y, e - t.x)
            },
            angleToPointer: function(t, e, i) {
                return void 0 === e && (e = this.game.input.activePointer), void 0 === i && (i = !1), i ? Math.atan2(e.worldY - t.world.y, e.worldX - t.world.x) : Math.atan2(e.worldY - t.y, e.worldX - t.x)
            },
            worldAngleToPointer: function(t, e) {
                return this.angleToPointer(t, e, !0)
            }
        }, t.Physics.Arcade.Body = function(e) {
            this.sprite = e, this.game = e.game, this.type = t.Physics.ARCADE, this.enable = !0, this.isCircle = !1, this.radius = 0, this.offset = new t.Point, this.position = new t.Point(e.x, e.y), this.prev = new t.Point(this.position.x, this.position.y), this.allowRotation = !0, this.rotation = e.angle, this.preRotation = e.angle, this.width = e.width, this.height = e.height, this.sourceWidth = e.width, this.sourceHeight = e.height, e.texture && (this.sourceWidth = e.texture.frame.width, this.sourceHeight = e.texture.frame.height), this.halfWidth = Math.abs(e.width / 2), this.halfHeight = Math.abs(e.height / 2), this.center = new t.Point(e.x + this.halfWidth, e.y + this.halfHeight), this.velocity = new t.Point, this.newVelocity = new t.Point, this.deltaMax = new t.Point, this.acceleration = new t.Point, this.allowDrag = !0, this.drag = new t.Point, this.allowGravity = !0, this.gravity = new t.Point, this.bounce = new t.Point, this.worldBounce = null, this.onWorldBounds = null, this.onCollide = null, this.onOverlap = null, this.maxVelocity = new t.Point(1e4, 1e4), this.friction = new t.Point(1, 0), this.angularVelocity = 0, this.angularAcceleration = 0, this.angularDrag = 0, this.maxAngular = 1e3, this.mass = 1, this.angle = 0, this.speed = 0, this.facing = t.NONE, this.immovable = !1, this.moves = !0, this.customSeparateX = !1, this.customSeparateY = !1, this.overlapX = 0, this.overlapY = 0, this.overlapR = 0, this.embedded = !1, this.collideWorldBounds = !1, this.checkCollision = {
                none: !1,
                up: !0,
                down: !0,
                left: !0,
                right: !0
            }, this.touching = {
                none: !0,
                up: !1,
                down: !1,
                left: !1,
                right: !1
            }, this.wasTouching = {
                none: !0,
                up: !1,
                down: !1,
                left: !1,
                right: !1
            }, this.blocked = {
                none: !0,
                up: !1,
                down: !1,
                left: !1,
                right: !1
            }, this.tilePadding = new t.Point, this.dirty = !1, this.skipQuadTree = !1, this.syncBounds = !1, this.isMoving = !1, this.stopVelocityOnCollide = !0, this.moveTimer = 0, this.moveDistance = 0, this.moveDuration = 0, this.moveTarget = null, this.moveEnd = null, this.onMoveComplete = new t.Signal, this.movementCallback = null, this.movementCallbackContext = null, this._reset = !0, this._sx = e.scale.x, this._sy = e.scale.y, this._dx = 0, this._dy = 0
        }, t.Physics.Arcade.Body.prototype = {
            updateBounds: function() {
                if (this.syncBounds) {
                    var t = this.sprite.getBounds();
                    t.ceilAll(), t.width === this.width && t.height === this.height || (this.width = t.width, this.height = t.height, this._reset = !0)
                } else {
                    var e = Math.abs(this.sprite.scale.x),
                        i = Math.abs(this.sprite.scale.y);
                    e === this._sx && i === this._sy || (this.width = this.sourceWidth * e, this.height = this.sourceHeight * i, this._sx = e, this._sy = i, this._reset = !0)
                }
                this._reset && (this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.updateCenter())
            },
            updateCenter: function() {
                this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight)
            },
            preUpdate: function() {
                this.enable && !this.game.physics.arcade.isPaused && (this.dirty = !0, this.wasTouching.none = this.touching.none, this.wasTouching.up = this.touching.up, this.wasTouching.down = this.touching.down, this.wasTouching.left = this.touching.left, this.wasTouching.right = this.touching.right, this.touching.none = !0, this.touching.up = !1, this.touching.down = !1, this.touching.left = !1, this.touching.right = !1, this.blocked.none = !0, this.blocked.up = !1, this.blocked.down = !1, this.blocked.left = !1, this.blocked.right = !1, this.overlapR = 0, this.overlapX = 0, this.overlapY = 0, this.embedded = !1, this.updateBounds(), this.position.x = this.sprite.world.x - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x, this.position.x -= this.sprite.scale.x < 0 ? this.width : 0, this.position.y = this.sprite.world.y - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y, this.position.y -= this.sprite.scale.y < 0 ? this.height : 0, this.updateCenter(), this.rotation = this.sprite.angle, this.preRotation = this.rotation, (this._reset || this.sprite.fresh) && (this.prev.x = this.position.x, this.prev.y = this.position.y), this.moves && (this.game.physics.arcade.updateMotion(this), this.newVelocity.set(this.velocity.x * this.game.time.physicsElapsed, this.velocity.y * this.game.time.physicsElapsed), this.position.x += this.newVelocity.x, this.position.y += this.newVelocity.y, this.updateCenter(), this.position.x === this.prev.x && this.position.y === this.prev.y || (this.angle = this.velocity.atan()), this.speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y), this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds && this.onWorldBounds.dispatch(this.sprite, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right)), this._dx = this.deltaX(), this._dy = this.deltaY(), this._reset = !1)
            },
            updateMovement: function() {
                var t = 0,
                    e = 0 !== this.overlapX || 0 !== this.overlapY;
                if (this.moveDuration > 0 ? (this.moveTimer += this.game.time.elapsedMS, t = this.moveTimer / this.moveDuration) : (this.moveTarget.end.set(this.position.x, this.position.y), t = this.moveTarget.length / this.moveDistance), this.movementCallback) var i = this.movementCallback.call(this.movementCallbackContext, this, this.velocity, t);
                return !(e || t >= 1 || void 0 !== i && !0 !== i) || (this.stopMovement(t >= 1 || this.stopVelocityOnCollide && e), !1)
            },
            stopMovement: function(t) {
                this.isMoving && (this.isMoving = !1, t && this.velocity.set(0), this.onMoveComplete.dispatch(this.sprite, 0 !== this.overlapX || 0 !== this.overlapY))
            },
            postUpdate: function() {
                this.enable && this.dirty && (this.isMoving && this.updateMovement(), this.dirty = !1, this.deltaX() < 0 ? this.facing = t.LEFT : this.deltaX() > 0 && (this.facing = t.RIGHT), this.deltaY() < 0 ? this.facing = t.UP : this.deltaY() > 0 && (this.facing = t.DOWN), this.moves && (this._dx = this.deltaX(), this._dy = this.deltaY(), 0 !== this.deltaMax.x && 0 !== this._dx && (this._dx < 0 && this._dx < -this.deltaMax.x ? this._dx = -this.deltaMax.x : this._dx > 0 && this._dx > this.deltaMax.x && (this._dx = this.deltaMax.x)), 0 !== this.deltaMax.y && 0 !== this._dy && (this._dy < 0 && this._dy < -this.deltaMax.y ? this._dy = -this.deltaMax.y : this._dy > 0 && this._dy > this.deltaMax.y && (this._dy = this.deltaMax.y)), this.sprite.position.x += this._dx, this.sprite.position.y += this._dy, this._reset = !0), this.updateCenter(), this.allowRotation && (this.sprite.angle += this.deltaZ()), this.prev.x = this.position.x, this.prev.y = this.position.y)
            },
            checkWorldBounds: function() {
                var t = this.position,
                    e = this.game.physics.arcade.bounds,
                    i = this.game.physics.arcade.checkCollision,
                    s = this.worldBounce ? -this.worldBounce.x : -this.bounce.x,
                    n = this.worldBounce ? -this.worldBounce.y : -this.bounce.y;
                return t.x < e.x && i.left ? (t.x = e.x, this.velocity.x *= s, this.blocked.left = !0, this.blocked.none = !1) : this.right > e.right && i.right && (t.x = e.right - this.width, this.velocity.x *= s, this.blocked.right = !0, this.blocked.none = !1), t.y < e.y && i.up ? (t.y = e.y, this.velocity.y *= n, this.blocked.up = !0, this.blocked.none = !1) : this.bottom > e.bottom && i.down && (t.y = e.bottom - this.height, this.velocity.y *= n, this.blocked.down = !0, this.blocked.none = !1), !this.blocked.none
            },
            moveFrom: function(t, e, i) {
                return void 0 === e && (e = this.speed), 0 !== e && (void 0 === i ? (s = this.angle, i = this.game.math.radToDeg(s)) : s = this.game.math.degToRad(i), this.moveTimer = 0, this.moveDuration = t, 0 === i || 180 === i ? this.velocity.set(Math.cos(s) * e, 0) : 90 === i || 270 === i ? this.velocity.set(0, Math.sin(s) * e) : this.velocity.setToPolar(s, e), this.isMoving = !0, !0);
                var s
            },
            moveTo: function(e, i, s) {
                var n, r = i / (e / 1e3);
                return 0 !== r && (void 0 === s ? (n = this.angle, s = this.game.math.radToDeg(n)) : n = this.game.math.degToRad(s), i = Math.abs(i), this.moveDuration = 0, this.moveDistance = i, null === this.moveTarget && (this.moveTarget = new t.Line, this.moveEnd = new t.Point), this.moveTarget.fromAngle(this.x, this.y, n, i), this.moveEnd.set(this.moveTarget.end.x, this.moveTarget.end.y), this.moveTarget.setTo(this.x, this.y, this.x, this.y), 0 === s || 180 === s ? this.velocity.set(Math.cos(n) * r, 0) : 90 === s || 270 === s ? this.velocity.set(0, Math.sin(n) * r) : this.velocity.setToPolar(n, r), this.isMoving = !0, !0)
            },
            setSize: function(t, e, i, s) {
                void 0 === i && (i = this.offset.x), void 0 === s && (s = this.offset.y), this.sourceWidth = t, this.sourceHeight = e, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.setTo(i, s), this.updateCenter(), this.isCircle = !1, this.radius = 0
            },
            setCircle: function(t, e, i) {
                void 0 === e && (e = this.offset.x), void 0 === i && (i = this.offset.y), t > 0 ? (this.isCircle = !0, this.radius = t, this.sourceWidth = 2 * t, this.sourceHeight = 2 * t, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.setTo(e, i), this.updateCenter()) : this.isCircle = !1
            },
            reset: function(t, e) {
                this.stop(), this.position.x = t - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x, this.position.x -= this.sprite.scale.x < 0 ? this.width : 0, this.position.y = e - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y, this.position.y -= this.sprite.scale.y < 0 ? this.height : 0, this.prev.x = this.position.x, this.prev.y = this.position.y, this.rotation = this.sprite.angle, this.preRotation = this.rotation, this.updateBounds(), this.updateCenter()
            },
            stop: function() {
                this.velocity.set(0), this.acceleration.set(0), this.speed = 0, this.angularVelocity = 0, this.angularAcceleration = 0
            },
            getBounds: function(t) {
                return t.x = this.x, t.y = this.y, t.right = this.right, t.bottom = this.bottom, t
            },
            hitTest: function(e, i) {
                return this.isCircle ? t.Circle.contains(this, e, i) : t.Rectangle.contains(this, e, i)
            },
            onFloor: function() {
                return this.blocked.down
            },
            onCeiling: function() {
                return this.blocked.up
            },
            onWall: function() {
                return this.blocked.left || this.blocked.right
            },
            deltaAbsX: function() {
                return this.deltaX() > 0 ? this.deltaX() : -this.deltaX()
            },
            deltaAbsY: function() {
                return this.deltaY() > 0 ? this.deltaY() : -this.deltaY()
            },
            deltaX: function() {
                return this.position.x - this.prev.x
            },
            deltaY: function() {
                return this.position.y - this.prev.y
            },
            deltaZ: function() {
                return this.rotation - this.preRotation
            },
            destroy: function() {
                this.sprite.parent && this.sprite.parent instanceof t.Group && this.sprite.parent.removeFromHash(this.sprite), this.sprite.body = null, this.sprite = null
            }
        }, Object.defineProperty(t.Physics.Arcade.Body.prototype, "left", {
            get: function() {
                return this.position.x
            }
        }), Object.defineProperty(t.Physics.Arcade.Body.prototype, "right", {
            get: function() {
                return this.position.x + this.width
            }
        }), Object.defineProperty(t.Physics.Arcade.Body.prototype, "top", {
            get: function() {
                return this.position.y
            }
        }), Object.defineProperty(t.Physics.Arcade.Body.prototype, "bottom", {
            get: function() {
                return this.position.y + this.height
            }
        }), Object.defineProperty(t.Physics.Arcade.Body.prototype, "x", {
            get: function() {
                return this.position.x
            },
            set: function(t) {
                this.position.x = t
            }
        }), Object.defineProperty(t.Physics.Arcade.Body.prototype, "y", {
            get: function() {
                return this.position.y
            },
            set: function(t) {
                this.position.y = t
            }
        }), t.Physics.Arcade.Body.render = function(t, e, i, s, n) {
            void 0 === s && (s = !0), i = i || "rgba(0,255,0,0.4)", t.fillStyle = i, t.strokeStyle = i, t.lineWidth = n || 1, e.isCircle ? (t.beginPath(), t.arc(e.center.x - e.game.camera.x, e.center.y - e.game.camera.y, e.halfWidth, 0, 2 * Math.PI), s ? t.fill() : t.stroke()) : s ? t.fillRect(e.position.x - e.game.camera.x, e.position.y - e.game.camera.y, e.width, e.height) : t.strokeRect(e.position.x - e.game.camera.x, e.position.y - e.game.camera.y, e.width, e.height)
        }, t.Physics.Arcade.Body.renderBodyInfo = function(t, e) {
            t.line("x: " + e.x.toFixed(2), "y: " + e.y.toFixed(2), "width: " + e.width, "height: " + e.height), t.line("velocity x: " + e.velocity.x.toFixed(2), "y: " + e.velocity.y.toFixed(2), "deltaX: " + e._dx.toFixed(2), "deltaY: " + e._dy.toFixed(2)), t.line("acceleration x: " + e.acceleration.x.toFixed(2), "y: " + e.acceleration.y.toFixed(2), "speed: " + e.speed.toFixed(2), "angle: " + e.angle.toFixed(2)), t.line("gravity x: " + e.gravity.x, "y: " + e.gravity.y, "bounce x: " + e.bounce.x.toFixed(2), "y: " + e.bounce.y.toFixed(2)), t.line("touching left: " + e.touching.left, "right: " + e.touching.right, "up: " + e.touching.up, "down: " + e.touching.down), t.line("blocked left: " + e.blocked.left, "right: " + e.blocked.right, "up: " + e.blocked.up, "down: " + e.blocked.down)
        }, t.Physics.Arcade.Body.prototype.constructor = t.Physics.Arcade.Body, t.Physics.Arcade.TilemapCollision = function() {}, t.Physics.Arcade.TilemapCollision.prototype = {
            TILE_BIAS: 16,
            collideSpriteVsTilemapLayer: function(t, e, i, s, n, r) {
                if (t.body) {
                    var o = e.getTiles(t.body.position.x - t.body.tilePadding.x - e.getTileOffsetX(), t.body.position.y - t.body.tilePadding.y - e.getTileOffsetY(), t.body.width + t.body.tilePadding.x, t.body.height + t.body.tilePadding.y, !1, !1);
                    if (0 !== o.length)
                        for (var a = 0; a < o.length; a++) s ? s.call(n, t, o[a]) && this.separateTile(a, t.body, o[a], e, r) && (this._total++, i && i.call(n, t, o[a])) : this.separateTile(a, t.body, o[a], e, r) && (this._total++, i && i.call(n, t, o[a]))
                }
            },
            collideGroupVsTilemapLayer: function(t, e, i, s, n, r) {
                if (0 !== t.length)
                    for (var o = 0; o < t.children.length; o++) t.children[o].exists && this.collideSpriteVsTilemapLayer(t.children[o], e, i, s, n, r)
            },
            separateTile: function(t, e, i, s, n) {
                if (!e.enable) return !1;
                var r = s.getTileOffsetX(),
                    o = s.getTileOffsetY();
                if (!i.intersects(e.position.x - r, e.position.y - o, e.right - r, e.bottom - o)) return !1;
                if (n) return !0;
                if (i.collisionCallback && !i.collisionCallback.call(i.collisionCallbackContext, e.sprite, i)) return !1;
                if (void 0 !== i.layer.callbacks && i.layer.callbacks[i.index] && !i.layer.callbacks[i.index].callback.call(i.layer.callbacks[i.index].callbackContext, e.sprite, i)) return !1;
                if (!(i.faceLeft || i.faceRight || i.faceTop || i.faceBottom)) return !1;
                var a = 0,
                    h = 0,
                    l = 0,
                    c = 1;
                if (e.deltaAbsX() > e.deltaAbsY() ? l = -1 : e.deltaAbsX() < e.deltaAbsY() && (c = -1), 0 !== e.deltaX() && 0 !== e.deltaY() && (i.faceLeft || i.faceRight) && (i.faceTop || i.faceBottom) && (l = Math.min(Math.abs(e.position.x - r - i.right), Math.abs(e.right - r - i.left)), c = Math.min(Math.abs(e.position.y - o - i.bottom), Math.abs(e.bottom - o - i.top))), l < c) {
                    if ((i.faceLeft || i.faceRight) && 0 !== (a = this.tileCheckX(e, i, s)) && !i.intersects(e.position.x - r, e.position.y - o, e.right - r, e.bottom - o)) return !0;
                    (i.faceTop || i.faceBottom) && (h = this.tileCheckY(e, i, s))
                } else {
                    if ((i.faceTop || i.faceBottom) && 0 !== (h = this.tileCheckY(e, i, s)) && !i.intersects(e.position.x - r, e.position.y - o, e.right - r, e.bottom - o)) return !0;
                    (i.faceLeft || i.faceRight) && (a = this.tileCheckX(e, i, s))
                }
                return 0 !== a || 0 !== h
            },
            tileCheckX: function(t, e, i) {
                var s = 0,
                    n = i.getTileOffsetX();
                return t.deltaX() < 0 && !t.blocked.left && e.collideRight && t.checkCollision.left ? e.faceRight && t.x - n < e.right && (s = t.x - n - e.right) < -this.TILE_BIAS && (s = 0) : t.deltaX() > 0 && !t.blocked.right && e.collideLeft && t.checkCollision.right && e.faceLeft && t.right - n > e.left && (s = t.right - n - e.left) > this.TILE_BIAS && (s = 0), 0 !== s && (t.customSeparateX ? t.overlapX = s : this.processTileSeparationX(t, s)), s
            },
            tileCheckY: function(t, e, i) {
                var s = 0,
                    n = i.getTileOffsetY();
                return t.deltaY() < 0 && !t.blocked.up && e.collideDown && t.checkCollision.up ? e.faceBottom && t.y - n < e.bottom && (s = t.y - n - e.bottom) < -this.TILE_BIAS && (s = 0) : t.deltaY() > 0 && !t.blocked.down && e.collideUp && t.checkCollision.down && e.faceTop && t.bottom - n > e.top && (s = t.bottom - n - e.top) > this.TILE_BIAS && (s = 0), 0 !== s && (t.customSeparateY ? t.overlapY = s : this.processTileSeparationY(t, s)), s
            },
            processTileSeparationX: function(t, e) {
                e < 0 ? (t.blocked.left = !0, t.blocked.none = !1) : e > 0 && (t.blocked.right = !0, t.blocked.none = !1), t.position.x -= e, 0 === t.bounce.x ? t.velocity.x = 0 : t.velocity.x = -t.velocity.x * t.bounce.x
            },
            processTileSeparationY: function(t, e) {
                e < 0 ? (t.blocked.up = !0, t.blocked.none = !1) : e > 0 && (t.blocked.down = !0, t.blocked.none = !1), t.position.y -= e, 0 === t.bounce.y ? t.velocity.y = 0 : t.velocity.y = -t.velocity.y * t.bounce.y
            }
        }, t.Utils.mixinPrototype(t.Physics.Arcade.prototype, t.Physics.Arcade.TilemapCollision.prototype), p2.Body.prototype.parent = null, p2.Spring.prototype.parent = null, t.Physics.P2 = function(e, i) {
            this.game = e, void 0 === i ? i = {
                gravity: [0, 0],
                broadphase: new p2.SAPBroadphase
            } : (i.hasOwnProperty("gravity") || (i.gravity = [0, 0]), i.hasOwnProperty("broadphase") || (i.broadphase = new p2.SAPBroadphase)), this.config = i, this.world = new p2.World(this.config), this.frameRate = 1 / 60, this.useElapsedTime = !1, this.paused = !1, this.materials = [], this.gravity = new t.Physics.P2.InversePointProxy(this, this.world.gravity), this.walls = {
                left: null,
                right: null,
                top: null,
                bottom: null
            }, this.onBodyAdded = new t.Signal, this.onBodyRemoved = new t.Signal, this.onSpringAdded = new t.Signal, this.onSpringRemoved = new t.Signal, this.onConstraintAdded = new t.Signal, this.onConstraintRemoved = new t.Signal, this.onContactMaterialAdded = new t.Signal, this.onContactMaterialRemoved = new t.Signal, this.postBroadphaseCallback = null, this.callbackContext = null, this.onBeginContact = new t.Signal, this.onEndContact = new t.Signal, i.hasOwnProperty("mpx") && i.hasOwnProperty("pxm") && i.hasOwnProperty("mpxi") && i.hasOwnProperty("pxmi") && (this.mpx = i.mpx, this.mpxi = i.mpxi, this.pxm = i.pxm, this.pxmi = i.pxmi), this.world.on("beginContact", this.beginContactHandler, this), this.world.on("endContact", this.endContactHandler, this), this.collisionGroups = [], this.nothingCollisionGroup = new t.Physics.P2.CollisionGroup(1), this.boundsCollisionGroup = new t.Physics.P2.CollisionGroup(2), this.everythingCollisionGroup = new t.Physics.P2.CollisionGroup(2147483648), this.boundsCollidesWith = [], this._toRemove = [], this._collisionGroupID = 2, this._boundsLeft = !0, this._boundsRight = !0, this._boundsTop = !0, this._boundsBottom = !0, this._boundsOwnGroup = !1, this.setBoundsToWorld(!0, !0, !0, !0, !1)
        }, t.Physics.P2.prototype = {
            removeBodyNextStep: function(t) {
                this._toRemove.push(t)
            },
            preUpdate: function() {
                for (var t = this._toRemove.length; t--;) this.removeBody(this._toRemove[t]);
                this._toRemove.length = 0
            },
            enable: function(e, i, s) {
                void 0 === i && (i = !1), void 0 === s && (s = !0);
                var n = 1;
                if (Array.isArray(e))
                    for (n = e.length; n--;) e[n] instanceof t.Group ? this.enable(e[n].children, i, s) : (this.enableBody(e[n], i), s && e[n].hasOwnProperty("children") && e[n].children.length > 0 && this.enable(e[n], i, !0));
                else e instanceof t.Group ? this.enable(e.children, i, s) : (this.enableBody(e, i), s && e.hasOwnProperty("children") && e.children.length > 0 && this.enable(e.children, i, !0))
            },
            enableBody: function(e, i) {
                e.hasOwnProperty("body") && null === e.body && (e.body = new t.Physics.P2.Body(this.game, e, e.x, e.y, 1), e.body.debug = i, void 0 !== e.anchor && e.anchor.set(.5))
            },
            setImpactEvents: function(t) {
                t ? this.world.on("impact", this.impactHandler, this) : this.world.off("impact", this.impactHandler, this)
            },
            setPostBroadphaseCallback: function(t, e) {
                this.postBroadphaseCallback = t, this.callbackContext = e, null !== t ? this.world.on("postBroadphase", this.postBroadphaseHandler, this) : this.world.off("postBroadphase", this.postBroadphaseHandler, this)
            },
            postBroadphaseHandler: function(t) {
                if (this.postBroadphaseCallback && 0 !== t.pairs.length)
                    for (var e = t.pairs.length - 2; e >= 0; e -= 2) t.pairs[e].parent && t.pairs[e + 1].parent && !this.postBroadphaseCallback.call(this.callbackContext, t.pairs[e].parent, t.pairs[e + 1].parent) && t.pairs.splice(e, 2)
            },
            impactHandler: function(t) {
                if (t.bodyA.parent && t.bodyB.parent) {
                    var e = t.bodyA.parent,
                        i = t.bodyB.parent;
                    e._bodyCallbacks[t.bodyB.id] && e._bodyCallbacks[t.bodyB.id].call(e._bodyCallbackContext[t.bodyB.id], e, i, t.shapeA, t.shapeB), i._bodyCallbacks[t.bodyA.id] && i._bodyCallbacks[t.bodyA.id].call(i._bodyCallbackContext[t.bodyA.id], i, e, t.shapeB, t.shapeA), e._groupCallbacks[t.shapeB.collisionGroup] && e._groupCallbacks[t.shapeB.collisionGroup].call(e._groupCallbackContext[t.shapeB.collisionGroup], e, i, t.shapeA, t.shapeB), i._groupCallbacks[t.shapeA.collisionGroup] && i._groupCallbacks[t.shapeA.collisionGroup].call(i._groupCallbackContext[t.shapeA.collisionGroup], i, e, t.shapeB, t.shapeA)
                }
            },
            beginContactHandler: function(t) {
                t.bodyA && t.bodyB && (this.onBeginContact.dispatch(t.bodyA, t.bodyB, t.shapeA, t.shapeB, t.contactEquations), t.bodyA.parent && t.bodyA.parent.onBeginContact.dispatch(t.bodyB.parent, t.bodyB, t.shapeA, t.shapeB, t.contactEquations), t.bodyB.parent && t.bodyB.parent.onBeginContact.dispatch(t.bodyA.parent, t.bodyA, t.shapeB, t.shapeA, t.contactEquations))
            },
            endContactHandler: function(t) {
                t.bodyA && t.bodyB && (this.onEndContact.dispatch(t.bodyA, t.bodyB, t.shapeA, t.shapeB), t.bodyA.parent && t.bodyA.parent.onEndContact.dispatch(t.bodyB.parent, t.bodyB, t.shapeA, t.shapeB), t.bodyB.parent && t.bodyB.parent.onEndContact.dispatch(t.bodyA.parent, t.bodyA, t.shapeB, t.shapeA))
            },
            setBoundsToWorld: function(t, e, i, s, n) {
                this.setBounds(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, t, e, i, s, n)
            },
            setWorldMaterial: function(t, e, i, s, n) {
                void 0 === e && (e = !0), void 0 === i && (i = !0), void 0 === s && (s = !0), void 0 === n && (n = !0), e && this.walls.left && (this.walls.left.shapes[0].material = t), i && this.walls.right && (this.walls.right.shapes[0].material = t), s && this.walls.top && (this.walls.top.shapes[0].material = t), n && this.walls.bottom && (this.walls.bottom.shapes[0].material = t)
            },
            updateBoundsCollisionGroup: function(t) {
                void 0 === t && (t = !0);
                var e = t ? this.boundsCollisionGroup.mask : this.everythingCollisionGroup.mask;
                this.walls.left && (this.walls.left.shapes[0].collisionGroup = e), this.walls.right && (this.walls.right.shapes[0].collisionGroup = e), this.walls.top && (this.walls.top.shapes[0].collisionGroup = e), this.walls.bottom && (this.walls.bottom.shapes[0].collisionGroup = e), this._boundsOwnGroup = t
            },
            setBounds: function(t, e, i, s, n, r, o, a, h) {
                void 0 === n && (n = this._boundsLeft), void 0 === r && (r = this._boundsRight), void 0 === o && (o = this._boundsTop), void 0 === a && (a = this._boundsBottom), void 0 === h && (h = this._boundsOwnGroup), this.setupWall(n, "left", t, e, 1.5707963267948966, h), this.setupWall(r, "right", t + i, e, -1.5707963267948966, h), this.setupWall(o, "top", t, e, -3.141592653589793, h), this.setupWall(a, "bottom", t, e + s, 0, h), this._boundsLeft = n, this._boundsRight = r, this._boundsTop = o, this._boundsBottom = a, this._boundsOwnGroup = h
            },
            setupWall: function(t, e, i, s, n, r) {
                t ? (this.walls[e] ? this.walls[e].position = [this.pxmi(i), this.pxmi(s)] : (this.walls[e] = new p2.Body({
                    mass: 0,
                    position: [this.pxmi(i), this.pxmi(s)],
                    angle: n
                }), this.walls[e].addShape(new p2.Plane), this.world.addBody(this.walls[e])), r && (this.walls[e].shapes[0].collisionGroup = this.boundsCollisionGroup.mask)) : this.walls[e] && (this.world.removeBody(this.walls[e]), this.walls[e] = null)
            },
            pause: function() {
                this.paused = !0
            },
            resume: function() {
                this.paused = !1
            },
            update: function() {
                this.paused || (this.useElapsedTime ? this.world.step(this.game.time.physicsElapsed) : this.world.step(this.frameRate))
            },
            reset: function() {
                this.world.on("beginContact", this.beginContactHandler, this), this.world.on("endContact", this.endContactHandler, this), this.nothingCollisionGroup = new t.Physics.P2.CollisionGroup(1), this.boundsCollisionGroup = new t.Physics.P2.CollisionGroup(2), this.everythingCollisionGroup = new t.Physics.P2.CollisionGroup(2147483648), this._collisionGroupID = 2, this.setBoundsToWorld(!0, !0, !0, !0, !1)
            },
            clear: function() {
                this.world.time = 0, this.world.fixedStepTime = 0, this.world.solver && this.world.solver.equations.length && this.world.solver.removeAllEquations();
                for (var t = this.world.constraints, e = t.length - 1; e >= 0; e--) this.world.removeConstraint(t[e]);
                var i = this.world.bodies;
                for (e = i.length - 1; e >= 0; e--) this.world.removeBody(i[e]);
                var s = this.world.springs;
                for (e = s.length - 1; e >= 0; e--) this.world.removeSpring(s[e]);
                var n = this.world.contactMaterials;
                for (e = n.length - 1; e >= 0; e--) this.world.removeContactMaterial(n[e]);
                this.world.off("beginContact", this.beginContactHandler, this), this.world.off("endContact", this.endContactHandler, this), this.postBroadphaseCallback = null, this.callbackContext = null, this.impactCallback = null, this.collisionGroups = [], this._toRemove = [], this.boundsCollidesWith = [], this.walls = {
                    left: null,
                    right: null,
                    top: null,
                    bottom: null
                }
            },
            destroy: function() {
                this.clear(), this.game = null
            },
            addBody: function(t) {
                return !t.data.world && (this.world.addBody(t.data), this.onBodyAdded.dispatch(t), !0)
            },
            removeBody: function(t) {
                return t.data.world === this.world && (this.world.removeBody(t.data), this.onBodyRemoved.dispatch(t)), t
            },
            addSpring: function(e) {
                return e instanceof t.Physics.P2.Spring || e instanceof t.Physics.P2.RotationalSpring ? this.world.addSpring(e.data) : this.world.addSpring(e), this.onSpringAdded.dispatch(e), e
            },
            removeSpring: function(e) {
                return e instanceof t.Physics.P2.Spring || e instanceof t.Physics.P2.RotationalSpring ? this.world.removeSpring(e.data) : this.world.removeSpring(e), this.onSpringRemoved.dispatch(e), e
            },
            createDistanceConstraint: function(e, i, s, n, r, o) {
                if (e = this.getBody(e), i = this.getBody(i), e && i) return this.addConstraint(new t.Physics.P2.DistanceConstraint(this, e, i, s, n, r, o));
                console.warn("Cannot create Constraint, invalid body objects given")
            },
            createGearConstraint: function(e, i, s, n) {
                if (e = this.getBody(e), i = this.getBody(i), e && i) return this.addConstraint(new t.Physics.P2.GearConstraint(this, e, i, s, n));
                console.warn("Cannot create Constraint, invalid body objects given")
            },
            createRevoluteConstraint: function(e, i, s, n, r, o) {
                if (e = this.getBody(e), s = this.getBody(s), e && s) return this.addConstraint(new t.Physics.P2.RevoluteConstraint(this, e, i, s, n, r, o));
                console.warn("Cannot create Constraint, invalid body objects given")
            },
            createLockConstraint: function(e, i, s, n, r) {
                if (e = this.getBody(e), i = this.getBody(i), e && i) return this.addConstraint(new t.Physics.P2.LockConstraint(this, e, i, s, n, r));
                console.warn("Cannot create Constraint, invalid body objects given")
            },
            createPrismaticConstraint: function(e, i, s, n, r, o, a) {
                if (e = this.getBody(e), i = this.getBody(i), e && i) return this.addConstraint(new t.Physics.P2.PrismaticConstraint(this, e, i, s, n, r, o, a));
                console.warn("Cannot create Constraint, invalid body objects given")
            },
            addConstraint: function(t) {
                return this.world.addConstraint(t), this.onConstraintAdded.dispatch(t), t
            },
            removeConstraint: function(t) {
                return this.world.removeConstraint(t), this.onConstraintRemoved.dispatch(t), t
            },
            addContactMaterial: function(t) {
                return this.world.addContactMaterial(t), this.onContactMaterialAdded.dispatch(t), t
            },
            removeContactMaterial: function(t) {
                return this.world.removeContactMaterial(t), this.onContactMaterialRemoved.dispatch(t), t
            },
            getContactMaterial: function(t, e) {
                return this.world.getContactMaterial(t, e)
            },
            setMaterial: function(t, e) {
                for (var i = e.length; i--;) e[i].setMaterial(t)
            },
            createMaterial: function(e, i) {
                e = e || "";
                var s = new t.Physics.P2.Material(e);
                return this.materials.push(s), void 0 !== i && i.setMaterial(s), s
            },
            createContactMaterial: function(e, i, s) {
                void 0 === e && (e = this.createMaterial()), void 0 === i && (i = this.createMaterial());
                var n = new t.Physics.P2.ContactMaterial(e, i, s);
                return this.addContactMaterial(n)
            },
            getBodies: function() {
                for (var t = [], e = this.world.bodies.length; e--;) t.push(this.world.bodies[e].parent);
                return t
            },
            getBody: function(e) {
                return e instanceof p2.Body ? e : e instanceof t.Physics.P2.Body ? e.data : e.body && e.body.type === t.Physics.P2JS ? e.body.data : null
            },
            getSprings: function() {
                for (var t = [], e = this.world.springs.length; e--;) t.push(this.world.springs[e].parent);
                return t
            },
            getConstraints: function() {
                for (var t = [], e = this.world.constraints.length; e--;) t.push(this.world.constraints[e]);
                return t
            },
            hitTest: function(e, i, s, n) {
                void 0 === i && (i = this.world.bodies), void 0 === s && (s = 5), void 0 === n && (n = !1);
                for (var r = [this.pxmi(e.x), this.pxmi(e.y)], o = [], a = i.length; a--;) i[a] instanceof t.Physics.P2.Body && (!n || i[a].data.type !== p2.Body.STATIC) ? o.push(i[a].data) : i[a] instanceof p2.Body && i[a].parent && (!n || i[a].type !== p2.Body.STATIC) ? o.push(i[a]) : i[a] instanceof t.Sprite && i[a].hasOwnProperty("body") && (!n || i[a].body.data.type !== p2.Body.STATIC) && o.push(i[a].body.data);
                return this.world.hitTest(r, o, s)
            },
            toJSON: function() {
                return this.world.toJSON()
            },
            createCollisionGroup: function(e) {
                var i = Math.pow(2, this._collisionGroupID);
                this.walls.left && (this.walls.left.shapes[0].collisionMask = this.walls.left.shapes[0].collisionMask | i), this.walls.right && (this.walls.right.shapes[0].collisionMask = this.walls.right.shapes[0].collisionMask | i), this.walls.top && (this.walls.top.shapes[0].collisionMask = this.walls.top.shapes[0].collisionMask | i), this.walls.bottom && (this.walls.bottom.shapes[0].collisionMask = this.walls.bottom.shapes[0].collisionMask | i), this._collisionGroupID++;
                var s = new t.Physics.P2.CollisionGroup(i);
                return this.collisionGroups.push(s), e && this.setCollisionGroup(e, s), s
            },
            setCollisionGroup: function(e, i) {
                if (e instanceof t.Group)
                    for (var s = 0; s < e.total; s++) e.children[s].body && e.children[s].body.type === t.Physics.P2JS && e.children[s].body.setCollisionGroup(i);
                else e.body.setCollisionGroup(i)
            },
            createSpring: function(e, i, s, n, r, o, a, h, l) {
                if (e = this.getBody(e), i = this.getBody(i), e && i) return this.addSpring(new t.Physics.P2.Spring(this, e, i, s, n, r, o, a, h, l));
                console.warn("Cannot create Spring, invalid body objects given")
            },
            createRotationalSpring: function(e, i, s, n, r) {
                if (e = this.getBody(e), i = this.getBody(i), e && i) return this.addSpring(new t.Physics.P2.RotationalSpring(this, e, i, s, n, r));
                console.warn("Cannot create Rotational Spring, invalid body objects given")
            },
            createBody: function(e, i, s, n, r, o) {
                void 0 === n && (n = !1);
                var a = new t.Physics.P2.Body(this.game, null, e, i, s);
                return !(o && !a.addPolygon(r, o)) && (n && this.world.addBody(a.data), a)
            },
            createParticle: function(e, i, s, n, r, o) {
                void 0 === n && (n = !1);
                var a = new t.Physics.P2.Body(this.game, null, e, i, s);
                return !(o && !a.addPolygon(r, o)) && (n && this.world.addBody(a.data), a)
            },
            convertCollisionObjects: function(t, e, i) {
                void 0 === i && (i = !0);
                for (var s = [], n = 0, r = t.collision[e].length; n < r; n++) {
                    var o = t.collision[e][n],
                        a = o.polyline || o.polygon;
                    if (a) var h = this.createBody(o.x, o.y, 0, i, {}, a);
                    else o.rectangle && (h = this.createBody(o.x, o.y, 0, i)).addRectangle(o.width, o.height, o.width / 2, o.height / 2);
                    h && s.push(h)
                }
                return s
            },
            clearTilemapLayerBodies: function(t, e) {
                e = t.getLayer(e);
                for (var i = t.layers[e].bodies.length; i--;) t.layers[e].bodies[i].destroy();
                t.layers[e].bodies.length = 0
            },
            convertTilemap: function(t, e, i, s) {
                e = t.getLayer(e), void 0 === i && (i = !0), void 0 === s && (s = !0), this.clearTilemapLayerBodies(t, e);
                for (var n = 0, r = 0, o = 0, a = 0, h = t.layers[e].height; a < h; a++) {
                    n = 0;
                    for (var l = 0, c = t.layers[e].width; l < c; l++) {
                        var u = t.layers[e].data[a][l];
                        if (u && u.index > -1 && u.collides)
                            if (s) {
                                var d = t.getTileRight(e, l, a);
                                0 === n && (r = u.x * u.width, o = u.y * u.height, n = u.width), d && d.collides ? n += u.width : ((p = this.createBody(r, o, 0, !1)).addRectangle(n, u.height, n / 2, u.height / 2, 0), i && this.addBody(p), t.layers[e].bodies.push(p), n = 0)
                            } else {
                                var p = this.createBody(u.x * u.width, u.y * u.height, 0, !1);
                                p.addRectangle(u.width, u.height, u.width / 2, u.height / 2, 0), i && this.addBody(p), t.layers[e].bodies.push(p)
                            }
                    }
                }
                return t.layers[e].bodies
            },
            mpx: function(t) {
                return 20 * t
            },
            pxm: function(t) {
                return .05 * t
            },
            mpxi: function(t) {
                return -20 * t
            },
            pxmi: function(t) {
                return -.05 * t
            }
        }, Object.defineProperty(t.Physics.P2.prototype, "friction", {
            get: function() {
                return this.world.defaultContactMaterial.friction
            },
            set: function(t) {
                this.world.defaultContactMaterial.friction = t
            }
        }), Object.defineProperty(t.Physics.P2.prototype, "restitution", {
            get: function() {
                return this.world.defaultContactMaterial.restitution
            },
            set: function(t) {
                this.world.defaultContactMaterial.restitution = t
            }
        }), Object.defineProperty(t.Physics.P2.prototype, "contactMaterial", {
            get: function() {
                return this.world.defaultContactMaterial
            },
            set: function(t) {
                this.world.defaultContactMaterial = t
            }
        }), Object.defineProperty(t.Physics.P2.prototype, "applySpringForces", {
            get: function() {
                return this.world.applySpringForces
            },
            set: function(t) {
                this.world.applySpringForces = t
            }
        }), Object.defineProperty(t.Physics.P2.prototype, "applyDamping", {
            get: function() {
                return this.world.applyDamping
            },
            set: function(t) {
                this.world.applyDamping = t
            }
        }), Object.defineProperty(t.Physics.P2.prototype, "applyGravity", {
            get: function() {
                return this.world.applyGravity
            },
            set: function(t) {
                this.world.applyGravity = t
            }
        }), Object.defineProperty(t.Physics.P2.prototype, "solveConstraints", {
            get: function() {
                return this.world.solveConstraints
            },
            set: function(t) {
                this.world.solveConstraints = t
            }
        }), Object.defineProperty(t.Physics.P2.prototype, "time", {
            get: function() {
                return this.world.time
            }
        }), Object.defineProperty(t.Physics.P2.prototype, "emitImpactEvent", {
            get: function() {
                return this.world.emitImpactEvent
            },
            set: function(t) {
                this.world.emitImpactEvent = t
            }
        }), Object.defineProperty(t.Physics.P2.prototype, "sleepMode", {
            get: function() {
                return this.world.sleepMode
            },
            set: function(t) {
                this.world.sleepMode = t
            }
        }), Object.defineProperty(t.Physics.P2.prototype, "total", {
            get: function() {
                return this.world.bodies.length
            }
        }), t.Physics.P2.FixtureList = function(t) {
            Array.isArray(t) || (t = [t]), this.rawList = t, this.init(), this.parse(this.rawList)
        }, t.Physics.P2.FixtureList.prototype = {
            init: function() {
                this.namedFixtures = {}, this.groupedFixtures = [], this.allFixtures = []
            },
            setCategory: function(t, e) {
                this.getFixtures(e).forEach(function(e) {
                    e.collisionGroup = t
                })
            },
            setMask: function(t, e) {
                this.getFixtures(e).forEach(function(e) {
                    e.collisionMask = t
                })
            },
            setSensor: function(t, e) {
                this.getFixtures(e).forEach(function(e) {
                    e.sensor = t
                })
            },
            setMaterial: function(t, e) {
                this.getFixtures(e).forEach(function(e) {
                    e.material = t
                })
            },
            getFixtures: function(t) {
                var e = [];
                if (t) {
                    t instanceof Array || (t = [t]);
                    var i = this;
                    return t.forEach(function(t) {
                        i.namedFixtures[t] && e.push(i.namedFixtures[t])
                    }), this.flatten(e)
                }
                return this.allFixtures
            },
            getFixtureByKey: function(t) {
                return this.namedFixtures[t]
            },
            getGroup: function(t) {
                return this.groupedFixtures[t]
            },
            parse: function() {
                var t, e, i, s;
                for (t in s = [], i = this.rawList) e = i[t], isNaN(t - 0) ? this.namedFixtures[t] = this.flatten(e) : (this.groupedFixtures[t] = this.groupedFixtures[t] || [], this.groupedFixtures[t] = this.groupedFixtures[t].concat(e)), s.push(this.allFixtures = this.flatten(this.groupedFixtures))
            },
            flatten: function(t) {
                var e, i;
                return e = [], i = arguments.callee, t.forEach(function(t) {
                    return Array.prototype.push.apply(e, Array.isArray(t) ? i(t) : [t])
                }), e
            }
        }, t.Physics.P2.PointProxy = function(t, e) {
            this.world = t, this.destination = e
        }, t.Physics.P2.PointProxy.prototype.constructor = t.Physics.P2.PointProxy, Object.defineProperty(t.Physics.P2.PointProxy.prototype, "x", {
            get: function() {
                return this.world.mpx(this.destination[0])
            },
            set: function(t) {
                this.destination[0] = this.world.pxm(t)
            }
        }), Object.defineProperty(t.Physics.P2.PointProxy.prototype, "y", {
            get: function() {
                return this.world.mpx(this.destination[1])
            },
            set: function(t) {
                this.destination[1] = this.world.pxm(t)
            }
        }), Object.defineProperty(t.Physics.P2.PointProxy.prototype, "mx", {
            get: function() {
                return this.destination[0]
            },
            set: function(t) {
                this.destination[0] = t
            }
        }), Object.defineProperty(t.Physics.P2.PointProxy.prototype, "my", {
            get: function() {
                return this.destination[1]
            },
            set: function(t) {
                this.destination[1] = t
            }
        }), t.Physics.P2.InversePointProxy = function(t, e) {
            this.world = t, this.destination = e
        }, t.Physics.P2.InversePointProxy.prototype.constructor = t.Physics.P2.InversePointProxy, Object.defineProperty(t.Physics.P2.InversePointProxy.prototype, "x", {
            get: function() {
                return this.world.mpxi(this.destination[0])
            },
            set: function(t) {
                this.destination[0] = this.world.pxmi(t)
            }
        }), Object.defineProperty(t.Physics.P2.InversePointProxy.prototype, "y", {
            get: function() {
                return this.world.mpxi(this.destination[1])
            },
            set: function(t) {
                this.destination[1] = this.world.pxmi(t)
            }
        }), Object.defineProperty(t.Physics.P2.InversePointProxy.prototype, "mx", {
            get: function() {
                return this.destination[0]
            },
            set: function(t) {
                this.destination[0] = -t
            }
        }), Object.defineProperty(t.Physics.P2.InversePointProxy.prototype, "my", {
            get: function() {
                return this.destination[1]
            },
            set: function(t) {
                this.destination[1] = -t
            }
        }), t.Physics.P2.Body = function(e, i, s, n, r) {
            i = i || null, s = s || 0, n = n || 0, void 0 === r && (r = 1), this.game = e, this.world = e.physics.p2, this.sprite = i, this.type = t.Physics.P2JS, this.offset = new t.Point, this.data = new p2.Body({
                position: [this.world.pxmi(s), this.world.pxmi(n)],
                mass: r
            }), this.data.parent = this, this.velocity = new t.Physics.P2.InversePointProxy(this.world, this.data.velocity), this.force = new t.Physics.P2.InversePointProxy(this.world, this.data.force), this.gravity = new t.Point, this.onBeginContact = new t.Signal, this.onEndContact = new t.Signal, this.collidesWith = [], this.removeNextStep = !1, this.debugBody = null, this.dirty = !1, this._collideWorldBounds = !0, this._bodyCallbacks = {}, this._bodyCallbackContext = {}, this._groupCallbacks = {}, this._groupCallbackContext = {}, this._reset = !1, i && (this.setRectangleFromSprite(i), i.exists && this.game.physics.p2.addBody(this))
        }, t.Physics.P2.Body.prototype = {
            createBodyCallback: function(t, e, i) {
                var s = -1;
                t.id ? s = t.id : t.body && (s = t.body.id), s > -1 && (null === e ? (delete this._bodyCallbacks[s], delete this._bodyCallbackContext[s]) : (this._bodyCallbacks[s] = e, this._bodyCallbackContext[s] = i))
            },
            createGroupCallback: function(t, e, i) {
                null === e ? (delete this._groupCallbacks[t.mask], delete this._groupCallbackContext[t.mask]) : (this._groupCallbacks[t.mask] = e, this._groupCallbackContext[t.mask] = i)
            },
            getCollisionMask: function() {
                var t = 0;
                this._collideWorldBounds && (t = this.game.physics.p2.boundsCollisionGroup.mask);
                for (var e = 0; e < this.collidesWith.length; e++) t |= this.collidesWith[e].mask;
                return t
            },
            updateCollisionMask: function(t) {
                var e = this.getCollisionMask();
                if (void 0 === t)
                    for (var i = this.data.shapes.length - 1; i >= 0; i--) this.data.shapes[i].collisionMask = e;
                else t.collisionMask = e
            },
            setCollisionGroup: function(t, e) {
                var i = this.getCollisionMask();
                if (void 0 === e)
                    for (var s = this.data.shapes.length - 1; s >= 0; s--) this.data.shapes[s].collisionGroup = t.mask, this.data.shapes[s].collisionMask = i;
                else e.collisionGroup = t.mask, e.collisionMask = i
            },
            clearCollision: function(t, e, i) {
                if (void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === i)
                    for (var s = this.data.shapes.length - 1; s >= 0; s--) t && (this.data.shapes[s].collisionGroup = null), e && (this.data.shapes[s].collisionMask = null);
                else t && (i.collisionGroup = null), e && (i.collisionMask = null);
                t && (this.collidesWith.length = 0)
            },
            removeCollisionGroup: function(t, e, i) {
                var s;
                if (void 0 === e && (e = !0), Array.isArray(t))
                    for (r = 0; r < t.length; r++)(s = this.collidesWith.indexOf(t[r])) > -1 && (this.collidesWith.splice(s, 1), e && (delete this._groupCallbacks[t.mask], delete this._groupCallbackContext[t.mask]));
                else(s = this.collidesWith.indexOf(t)) > -1 && (this.collidesWith.splice(s, 1), e && (delete this._groupCallbacks[t.mask], delete this._groupCallbackContext[t.mask]));
                var n = this.getCollisionMask();
                if (void 0 === i)
                    for (var r = this.data.shapes.length - 1; r >= 0; r--) this.data.shapes[r].collisionMask = n;
                else i.collisionMask = n
            },
            collides: function(t, e, i, s) {
                if (Array.isArray(t))
                    for (r = 0; r < t.length; r++) - 1 === this.collidesWith.indexOf(t[r]) && (this.collidesWith.push(t[r]), e && this.createGroupCallback(t[r], e, i));
                else -1 === this.collidesWith.indexOf(t) && (this.collidesWith.push(t), e && this.createGroupCallback(t, e, i));
                var n = this.getCollisionMask();
                if (void 0 === s)
                    for (var r = this.data.shapes.length - 1; r >= 0; r--) this.data.shapes[r].collisionMask = n;
                else s.collisionMask = n
            },
            adjustCenterOfMass: function() {
                this.data.adjustCenterOfMass(), this.shapeChanged()
            },
            getVelocityAtPoint: function(t, e) {
                return this.data.getVelocityAtPoint(t, e)
            },
            applyDamping: function(t) {
                this.data.applyDamping(t)
            },
            applyImpulse: function(t, e, i) {
                this.data.applyImpulse(t, [this.world.pxmi(e), this.world.pxmi(i)])
            },
            applyImpulseLocal: function(t, e, i) {
                this.data.applyImpulseLocal(t, [this.world.pxmi(e), this.world.pxmi(i)])
            },
            applyForce: function(t, e, i) {
                this.data.applyForce(t, [this.world.pxmi(e), this.world.pxmi(i)])
            },
            setZeroForce: function() {
                this.data.setZeroForce()
            },
            setZeroRotation: function() {
                this.data.angularVelocity = 0
            },
            setZeroVelocity: function() {
                this.data.velocity[0] = 0, this.data.velocity[1] = 0
            },
            setZeroDamping: function() {
                this.data.damping = 0, this.data.angularDamping = 0
            },
            toLocalFrame: function(t, e) {
                return this.data.toLocalFrame(t, e)
            },
            toWorldFrame: function(t, e) {
                return this.data.toWorldFrame(t, e)
            },
            rotateLeft: function(t) {
                this.data.angularVelocity = this.world.pxm(-t)
            },
            rotateRight: function(t) {
                this.data.angularVelocity = this.world.pxm(t)
            },
            moveForward: function(t) {
                var e = this.world.pxmi(-t),
                    i = this.data.angle + Math.PI / 2;
                this.data.velocity[0] = e * Math.cos(i), this.data.velocity[1] = e * Math.sin(i)
            },
            moveBackward: function(t) {
                var e = this.world.pxmi(-t),
                    i = this.data.angle + Math.PI / 2;
                this.data.velocity[0] = -e * Math.cos(i), this.data.velocity[1] = -e * Math.sin(i)
            },
            thrust: function(t) {
                var e = this.world.pxmi(-t),
                    i = this.data.angle + Math.PI / 2;
                this.data.force[0] += e * Math.cos(i), this.data.force[1] += e * Math.sin(i)
            },
            thrustLeft: function(t) {
                var e = this.world.pxmi(-t),
                    i = this.data.angle;
                this.data.force[0] += e * Math.cos(i), this.data.force[1] += e * Math.sin(i)
            },
            thrustRight: function(t) {
                var e = this.world.pxmi(-t),
                    i = this.data.angle;
                this.data.force[0] -= e * Math.cos(i), this.data.force[1] -= e * Math.sin(i)
            },
            reverse: function(t) {
                var e = this.world.pxmi(-t),
                    i = this.data.angle + Math.PI / 2;
                this.data.force[0] -= e * Math.cos(i), this.data.force[1] -= e * Math.sin(i)
            },
            moveLeft: function(t) {
                this.data.velocity[0] = this.world.pxmi(-t)
            },
            moveRight: function(t) {
                this.data.velocity[0] = this.world.pxmi(t)
            },
            moveUp: function(t) {
                this.data.velocity[1] = this.world.pxmi(-t)
            },
            moveDown: function(t) {
                this.data.velocity[1] = this.world.pxmi(t)
            },
            preUpdate: function() {
                this.dirty = !0, this.removeNextStep && (this.removeFromWorld(), this.removeNextStep = !1)
            },
            postUpdate: function() {
                this.sprite.x = this.world.mpxi(this.data.position[0]) + this.offset.x, this.sprite.y = this.world.mpxi(this.data.position[1]) + this.offset.y, this.fixedRotation || (this.sprite.rotation = this.data.angle), this.debugBody && this.debugBody.updateSpriteTransform(), this.dirty = !1
            },
            reset: function(t, e, i, s) {
                void 0 === i && (i = !1), void 0 === s && (s = !1), this.setZeroForce(), this.setZeroVelocity(), this.setZeroRotation(), i && this.setZeroDamping(), s && (this.mass = 1), this.x = t, this.y = e
            },
            addToWorld: function() {
                if (this.game.physics.p2._toRemove)
                    for (var t = 0; t < this.game.physics.p2._toRemove.length; t++) this.game.physics.p2._toRemove[t] === this && this.game.physics.p2._toRemove.splice(t, 1);
                this.data.world !== this.game.physics.p2.world && this.game.physics.p2.addBody(this)
            },
            removeFromWorld: function() {
                this.data.world === this.game.physics.p2.world && this.game.physics.p2.removeBodyNextStep(this)
            },
            destroy: function() {
                this.removeFromWorld(), this.clearShapes(), this._bodyCallbacks = {}, this._bodyCallbackContext = {}, this._groupCallbacks = {}, this._groupCallbackContext = {}, this.debugBody && this.debugBody.destroy(!0, !0), this.debugBody = null, this.sprite && (this.sprite.body = null, this.sprite = null)
            },
            clearShapes: function() {
                for (var t = this.data.shapes.length; t--;) this.data.removeShape(this.data.shapes[t]);
                this.shapeChanged()
            },
            addShape: function(t, e, i, s) {
                return void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), this.data.addShape(t, [this.world.pxmi(e), this.world.pxmi(i)], s), this.shapeChanged(), t
            },
            addCircle: function(t, e, i, s) {
                var n = new p2.Circle({
                    radius: this.world.pxm(t)
                });
                return this.addShape(n, e, i, s)
            },
            addRectangle: function(t, e, i, s, n) {
                var r = new p2.Box({
                    width: this.world.pxm(t),
                    height: this.world.pxm(e)
                });
                return this.addShape(r, i, s, n)
            },
            addPlane: function(t, e, i) {
                var s = new p2.Plane;
                return this.addShape(s, t, e, i)
            },
            addParticle: function(t, e, i) {
                var s = new p2.Particle;
                return this.addShape(s, t, e, i)
            },
            addLine: function(t, e, i, s) {
                var n = new p2.Line({
                    length: this.world.pxm(t)
                });
                return this.addShape(n, e, i, s)
            },
            addCapsule: function(t, e, i, s, n) {
                var r = new p2.Capsule({
                    length: this.world.pxm(t),
                    radius: this.world.pxm(e)
                });
                return this.addShape(r, i, s, n)
            },
            addPolygon: function(t, e) {
                t = t || {}, Array.isArray(e) || (e = Array.prototype.slice.call(arguments, 1));
                var i = [];
                if (1 === e.length && Array.isArray(e[0])) i = e[0].slice(0);
                else if (Array.isArray(e[0])) i = e.slice();
                else if ("number" == typeof e[0])
                    for (var s = 0, n = e.length; s < n; s += 2) i.push([e[s], e[s + 1]]);
                var r = i.length - 1;
                i[r][0] === i[0][0] && i[r][1] === i[0][1] && i.pop();
                for (var o = 0; o < i.length; o++) i[o][0] = this.world.pxmi(i[o][0]), i[o][1] = this.world.pxmi(i[o][1]);
                var a = this.data.fromPolygon(i, t);
                return this.shapeChanged(), a
            },
            removeShape: function(t) {
                var e = this.data.removeShape(t);
                return this.shapeChanged(), e
            },
            setCircle: function(t, e, i, s) {
                return this.clearShapes(), this.addCircle(t, e, i, s)
            },
            setRectangle: function(t, e, i, s, n) {
                return void 0 === t && (t = 16), void 0 === e && (e = 16), this.clearShapes(), this.addRectangle(t, e, i, s, n)
            },
            setRectangleFromSprite: function(t) {
                return void 0 === t && (t = this.sprite), this.clearShapes(), this.addRectangle(t.width, t.height, 0, 0, t.rotation)
            },
            setMaterial: function(t, e) {
                if (void 0 === e)
                    for (var i = this.data.shapes.length - 1; i >= 0; i--) this.data.shapes[i].material = t;
                else e.material = t
            },
            shapeChanged: function() {
                this.debugBody && this.debugBody.draw()
            },
            addPhaserPolygon: function(t, e) {
                for (var i = this.game.cache.getPhysicsData(t, e), s = [], n = 0; n < i.length; n++) {
                    var r = i[n],
                        o = this.addFixture(r);
                    s[r.filter.group] = s[r.filter.group] || [], s[r.filter.group] = s[r.filter.group].concat(o), r.fixtureKey && (s[r.fixtureKey] = o)
                }
                return this.data.aabbNeedsUpdate = !0, this.shapeChanged(), s
            },
            addFixture: function(t) {
                var e = [];
                if (t.circle) {
                    (l = new p2.Circle({
                        radius: this.world.pxm(t.circle.radius)
                    })).collisionGroup = t.filter.categoryBits, l.collisionMask = t.filter.maskBits, l.sensor = t.isSensor;
                    var i = p2.vec2.create();
                    i[0] = this.world.pxmi(t.circle.position[0] - this.sprite.width / 2), i[1] = this.world.pxmi(t.circle.position[1] - this.sprite.height / 2), this.data.addShape(l, i), e.push(l)
                } else
                    for (var s = t.polygons, n = p2.vec2.create(), r = 0; r < s.length; r++) {
                        for (var o = s[r], a = [], h = 0; h < o.length; h += 2) a.push([this.world.pxmi(o[h]), this.world.pxmi(o[h + 1])]);
                        for (var l = new p2.Convex({
                                vertices: a
                            }), c = 0; c !== l.vertices.length; c++) {
                            var u = l.vertices[c];
                            p2.vec2.sub(u, u, l.centerOfMass)
                        }
                        p2.vec2.scale(n, l.centerOfMass, 1), n[0] -= this.world.pxmi(this.sprite.width / 2), n[1] -= this.world.pxmi(this.sprite.height / 2), l.updateTriangles(), l.updateCenterOfMass(), l.updateBoundingRadius(), l.collisionGroup = t.filter.categoryBits, l.collisionMask = t.filter.maskBits, l.sensor = t.isSensor, this.data.addShape(l, n), e.push(l)
                    }
                return e
            },
            loadPolygon: function(t, e, i) {
                if (null === t) s = e;
                else var s = this.game.cache.getPhysicsData(t, e);
                "number" != typeof i && (i = 1);
                for (var n = p2.vec2.create(), r = 0; r < s.length; r++) {
                    for (var o = [], a = 0; a < s[r].shape.length; a += 2) o.push([this.world.pxmi(s[r].shape[a] * i), this.world.pxmi(s[r].shape[a + 1] * i)]);
                    for (var h = new p2.Convex({
                            vertices: o
                        }), l = 0; l !== h.vertices.length; l++) {
                        var c = h.vertices[l];
                        p2.vec2.sub(c, c, h.centerOfMass)
                    }
                    p2.vec2.scale(n, h.centerOfMass, 1), n[0] -= this.world.pxmi(this.sprite.width / 2), n[1] -= this.world.pxmi(this.sprite.height / 2), h.updateTriangles(), h.updateCenterOfMass(), h.updateBoundingRadius(), this.data.addShape(h, n)
                }
                return this.data.aabbNeedsUpdate = !0, this.shapeChanged(), !0
            }
        }, t.Physics.P2.Body.prototype.constructor = t.Physics.P2.Body, t.Physics.P2.Body.DYNAMIC = 1, t.Physics.P2.Body.STATIC = 2, t.Physics.P2.Body.KINEMATIC = 4, Object.defineProperty(t.Physics.P2.Body.prototype, "static", {
            get: function() {
                return this.data.type === t.Physics.P2.Body.STATIC
            },
            set: function(e) {
                e && this.data.type !== t.Physics.P2.Body.STATIC ? (this.data.type = t.Physics.P2.Body.STATIC, this.mass = 0) : e || this.data.type !== t.Physics.P2.Body.STATIC || (this.data.type = t.Physics.P2.Body.DYNAMIC, this.mass = 1)
            }
        }), Object.defineProperty(t.Physics.P2.Body.prototype, "dynamic", {
            get: function() {
                return this.data.type === t.Physics.P2.Body.DYNAMIC
            },
            set: function(e) {
                e && this.data.type !== t.Physics.P2.Body.DYNAMIC ? (this.data.type = t.Physics.P2.Body.DYNAMIC, this.mass = 1) : e || this.data.type !== t.Physics.P2.Body.DYNAMIC || (this.data.type = t.Physics.P2.Body.STATIC, this.mass = 0)
            }
        }), Object.defineProperty(t.Physics.P2.Body.prototype, "kinematic", {
            get: function() {
                return this.data.type === t.Physics.P2.Body.KINEMATIC
            },
            set: function(e) {
                e && this.data.type !== t.Physics.P2.Body.KINEMATIC ? (this.data.type = t.Physics.P2.Body.KINEMATIC, this.mass = 4) : e || this.data.type !== t.Physics.P2.Body.KINEMATIC || (this.data.type = t.Physics.P2.Body.STATIC, this.mass = 0)
            }
        }), Object.defineProperty(t.Physics.P2.Body.prototype, "allowSleep", {
            get: function() {
                return this.data.allowSleep
            },
            set: function(t) {
                t !== this.data.allowSleep && (this.data.allowSleep = t)
            }
        }), Object.defineProperty(t.Physics.P2.Body.prototype, "angle", {
            get: function() {
                return t.Math.wrapAngle(t.Math.radToDeg(this.data.angle))
            },
            set: function(e) {
                this.data.angle = t.Math.degToRad(t.Math.wrapAngle(e))
            }
        }), Object.defineProperty(t.Physics.P2.Body.prototype, "angularDamping", {
            get: function() {
                return this.data.angularDamping
            },
            set: function(t) {
                this.data.angularDamping = t
            }
        }), Object.defineProperty(t.Physics.P2.Body.prototype, "angularForce", {
            get: function() {
                return this.data.angularForce
            },
            set: function(t) {
                this.data.angularForce = t
            }
        }), Object.defineProperty(t.Physics.P2.Body.prototype, "angularVelocity", {
            get: function() {
                return this.data.angularVelocity
            },
            set: function(t) {
                this.data.angularVelocity = t
            }
        }), Object.defineProperty(t.Physics.P2.Body.prototype, "damping", {
            get: function() {
                return this.data.damping
            },
            set: function(t) {
                this.data.damping = t
            }
        }), Object.defineProperty(t.Physics.P2.Body.prototype, "fixedRotation", {
            get: function() {
                return this.data.fixedRotation
            },
            set: function(t) {
                t !== this.data.fixedRotation && (this.data.fixedRotation = t)
            }
        }), Object.defineProperty(t.Physics.P2.Body.prototype, "inertia", {
            get: function() {
                return this.data.inertia
            },
            set: function(t) {
                this.data.inertia = t
            }
        }), Object.defineProperty(t.Physics.P2.Body.prototype, "mass", {
            get: function() {
                return this.data.mass
            },
            set: function(t) {
                t !== this.data.mass && (this.data.mass = t, this.data.updateMassProperties())
            }
        }), Object.defineProperty(t.Physics.P2.Body.prototype, "motionState", {
            get: function() {
                return this.data.type
            },
            set: function(t) {
                t !== this.data.type && (this.data.type = t)
            }
        }), Object.defineProperty(t.Physics.P2.Body.prototype, "rotation", {
            get: function() {
                return this.data.angle
            },
            set: function(t) {
                this.data.angle = t
            }
        }), Object.defineProperty(t.Physics.P2.Body.prototype, "sleepSpeedLimit", {
            get: function() {
                return this.data.sleepSpeedLimit
            },
            set: function(t) {
                this.data.sleepSpeedLimit = t
            }
        }), Object.defineProperty(t.Physics.P2.Body.prototype, "x", {
            get: function() {
                return this.world.mpxi(this.data.position[0])
            },
            set: function(t) {
                this.data.position[0] = this.world.pxmi(t)
            }
        }), Object.defineProperty(t.Physics.P2.Body.prototype, "y", {
            get: function() {
                return this.world.mpxi(this.data.position[1])
            },
            set: function(t) {
                this.data.position[1] = this.world.pxmi(t)
            }
        }), Object.defineProperty(t.Physics.P2.Body.prototype, "id", {
            get: function() {
                return this.data.id
            }
        }), Object.defineProperty(t.Physics.P2.Body.prototype, "debug", {
            get: function() {
                return null !== this.debugBody
            },
            set: function(e) {
                e && !this.debugBody ? this.debugBody = new t.Physics.P2.BodyDebug(this.game, this.data) : !e && this.debugBody && (this.debugBody.destroy(), this.debugBody = null)
            }
        }), Object.defineProperty(t.Physics.P2.Body.prototype, "collideWorldBounds", {
            get: function() {
                return this._collideWorldBounds
            },
            set: function(t) {
                t && !this._collideWorldBounds ? (this._collideWorldBounds = !0, this.updateCollisionMask()) : !t && this._collideWorldBounds && (this._collideWorldBounds = !1, this.updateCollisionMask())
            }
        }), t.Physics.P2.BodyDebug = function(e, i, s) {
            t.Group.call(this, e);
            var n = {
                pixelsPerLengthUnit: e.physics.p2.mpx(1),
                debugPolygons: !1,
                lineWidth: 1,
                alpha: .5
            };
            this.settings = Object.assign(n, s), this.ppu = this.settings.pixelsPerLengthUnit, this.ppu = -1 * this.ppu, this.body = i, this.canvas = new t.Graphics(e), this.canvas.alpha = this.settings.alpha, this.add(this.canvas), this.draw(), this.updateSpriteTransform()
        }, t.Physics.P2.BodyDebug.prototype = Object.create(t.Group.prototype), t.Physics.P2.BodyDebug.prototype.constructor = t.Physics.P2.BodyDebug, Object.assign(t.Physics.P2.BodyDebug.prototype, {
            updateSpriteTransform: function() {
                this.position.x = this.body.position[0] * this.ppu, this.position.y = this.body.position[1] * this.ppu, this.rotation = this.body.angle
            },
            draw: function() {
                var t, e, i, s, n, r, o, a, h, l, c, u, d, p;
                if (o = this.body, (h = this.canvas).clear(), i = parseInt(this.randomPastelHex(), 16), r = this.lineWidth, o instanceof p2.Body && o.shapes.length) {
                    var f = o.shapes.length;
                    for (s = 0; s !== f;) {
                        if (a = (e = o.shapes[s]).position || 0, t = e.angle || 0, e instanceof p2.Circle) this.drawCircle(h, a[0] * this.ppu, a[1] * this.ppu, t, e.radius * this.ppu, i, r);
                        else if (e instanceof p2.Capsule) this.drawCapsule(h, a[0] * this.ppu, a[1] * this.ppu, t, e.length * this.ppu, e.radius * this.ppu, 16711680, i, r);
                        else if (e instanceof p2.Plane) this.drawPlane(h, a[0] * this.ppu, -a[1] * this.ppu, i, 16711680, 5 * r, 10 * r, 10 * r, 100 * this.ppu, t);
                        else if (e instanceof p2.Line) this.drawLine(h, e.length * this.ppu, 16711680, r);
                        else if (e instanceof p2.Box) this.drawRectangle(h, a[0] * this.ppu, a[1] * this.ppu, t, e.width * this.ppu, e.height * this.ppu, 16711680, i, r);
                        else if (e instanceof p2.Convex) {
                            for (c = [], u = p2.vec2.create(), n = d = 0, p = e.vertices.length; p >= 0 ? d < p : d > p; n = p >= 0 ? ++d : --d) l = e.vertices[n], p2.vec2.rotate(u, l, t), c.push([(u[0] + a[0]) * this.ppu, -(u[1] + a[1]) * this.ppu]);
                            this.drawConvex(h, c, e.triangles, 16711680, i, r, this.settings.debugPolygons, [a[0] * this.ppu, -a[1] * this.ppu])
                        }
                        s++
                    }
                }
            },
            drawRectangle: function(t, e, i, s, n, r, o, a, h) {
                void 0 === h && (h = 1), void 0 === o && (o = 0), t.lineStyle(h, o, 1), t.beginFill(a), t.drawRect(e - n / 2, i - r / 2, n, r)
            },
            drawCircle: function(t, e, i, s, n, r, o) {
                void 0 === o && (o = 1), void 0 === r && (r = 16777215), t.lineStyle(o, 0, 1), t.beginFill(r, 1), t.drawCircle(e, i, 2 * -n), t.endFill(), t.moveTo(e, i), t.lineTo(e + n * Math.cos(-s), i + n * Math.sin(-s))
            },
            drawLine: function(t, e, i, s) {
                void 0 === s && (s = 1), void 0 === i && (i = 0), t.lineStyle(5 * s, i, 1), t.moveTo(-e / 2, 0), t.lineTo(e / 2, 0)
            },
            drawConvex: function(t, e, i, s, n, r, o, a) {
                var h, l, c, u, d, p, f, g, m, y, v;
                if (void 0 === r && (r = 1), void 0 === s && (s = 0), o) {
                    for (h = [16711680, 65280, 255], l = 0; l !== e.length + 1;) u = e[l % e.length], d = e[(l + 1) % e.length], f = u[0], y = u[1], g = d[0], v = d[1], t.lineStyle(r, h[l % h.length], 1), t.moveTo(f, -y), t.lineTo(g, -v), t.drawCircle(f, -y, 2 * r), l++;
                    return t.lineStyle(r, 0, 1), t.drawCircle(a[0], a[1], 2 * r)
                }
                for (t.lineStyle(r, s, 1), t.beginFill(n), l = 0; l !== e.length;) p = (c = e[l])[0], m = c[1], 0 === l ? t.moveTo(p, -m) : t.lineTo(p, -m), l++;
                if (t.endFill(), e.length > 2) return t.moveTo(e[e.length - 1][0], -e[e.length - 1][1]), t.lineTo(e[0][0], -e[0][1])
            },
            drawPath: function(t, e, i, s, n) {
                var r, o, a, h, l, c, u, d, p, f, g;
                for (void 0 === n && (n = 1), void 0 === i && (i = 0), t.lineStyle(n, i, 1), "number" == typeof s && t.beginFill(s), o = null, a = null, r = 0; r < e.length;) f = (p = e[r])[0], g = p[1], f === o && g === a || (0 === r ? t.moveTo(f, g) : (h = o, l = a, c = f, u = g, d = e[(r + 1) % e.length][0], 0 != (c - h) * (e[(r + 1) % e.length][1] - l) - (d - h) * (u - l) && t.lineTo(f, g)), o = f, a = g), r++;
                "number" == typeof s && t.endFill(), e.length > 2 && "number" == typeof s && (t.moveTo(e[e.length - 1][0], e[e.length - 1][1]), t.lineTo(e[0][0], e[0][1]))
            },
            drawPlane: function(t, e, i, s, n, r, o, a, h, l) {
                var c, u;
                void 0 === r && (r = 1), void 0 === s && (s = 16777215), t.lineStyle(r, n, 11), t.beginFill(s), t.moveTo(e, -i), c = e + Math.cos(l) * this.game.width, u = i + Math.sin(l) * this.game.height, t.lineTo(c, -u), t.moveTo(e, -i), c = e + Math.cos(l) * -this.game.width, u = i + Math.sin(l) * -this.game.height, t.lineTo(c, -u)
            },
            drawCapsule: function(t, e, i, s, n, r, o, a, h) {
                void 0 === h && (h = 1), void 0 === o && (o = 0), t.lineStyle(h, o, 1);
                var l = Math.cos(s),
                    c = Math.sin(s);
                t.beginFill(a, 1), t.drawCircle(-n / 2 * l + e, -n / 2 * c + i, 2 * -r), t.drawCircle(n / 2 * l + e, n / 2 * c + i, 2 * -r), t.endFill(), t.lineStyle(h, o, 0), t.beginFill(a, 1), t.moveTo(-n / 2 * l + r * c + e, -n / 2 * c + r * l + i), t.lineTo(n / 2 * l + r * c + e, n / 2 * c + r * l + i), t.lineTo(n / 2 * l - r * c + e, n / 2 * c - r * l + i), t.lineTo(-n / 2 * l - r * c + e, -n / 2 * c - r * l + i), t.endFill(), t.lineStyle(h, o, 1), t.moveTo(-n / 2 * l + r * c + e, -n / 2 * c + r * l + i), t.lineTo(n / 2 * l + r * c + e, n / 2 * c + r * l + i), t.moveTo(-n / 2 * l - r * c + e, -n / 2 * c - r * l + i), t.lineTo(n / 2 * l - r * c + e, n / 2 * c - r * l + i)
            },
            randomPastelHex: function() {
                var t, e, i, s;
                return i = [255, 255, 255], s = Math.floor(256 * Math.random()), e = Math.floor(256 * Math.random()), t = Math.floor(256 * Math.random()), s = Math.floor((s + 3 * i[0]) / 4), e = Math.floor((e + 3 * i[1]) / 4), t = Math.floor((t + 3 * i[2]) / 4), this.rgbToHex(s, e, t)
            },
            rgbToHex: function(t, e, i) {
                return this.componentToHex(t) + this.componentToHex(e) + this.componentToHex(i)
            },
            componentToHex: function(t) {
                var e;
                return 2 === (e = t.toString(16)).length ? e : e + "0"
            }
        }), t.Physics.P2.Spring = function(t, e, i, s, n, r, o, a, h, l) {
            this.game = t.game, this.world = t, void 0 === s && (s = 1), void 0 === n && (n = 100), void 0 === r && (r = 1);
            var c = {
                restLength: s = t.pxm(s),
                stiffness: n,
                damping: r
            };
            null != o && (c.worldAnchorA = [t.pxm(o[0]), t.pxm(o[1])]), null != a && (c.worldAnchorB = [t.pxm(a[0]), t.pxm(a[1])]), null != h && (c.localAnchorA = [t.pxm(h[0]), t.pxm(h[1])]), null != l && (c.localAnchorB = [t.pxm(l[0]), t.pxm(l[1])]), this.data = new p2.LinearSpring(e, i, c), this.data.parent = this
        }, t.Physics.P2.Spring.prototype.constructor = t.Physics.P2.Spring, t.Physics.P2.RotationalSpring = function(t, e, i, s, n, r) {
            this.game = t.game, this.world = t, void 0 === s && (s = null), void 0 === n && (n = 100), void 0 === r && (r = 1), s && (s = t.pxm(s));
            var o = {
                restAngle: s,
                stiffness: n,
                damping: r
            };
            this.data = new p2.RotationalSpring(e, i, o), this.data.parent = this
        }, t.Physics.P2.Spring.prototype.constructor = t.Physics.P2.Spring, t.Physics.P2.Material = function(t) {
            this.name = t, p2.Material.call(this)
        }, t.Physics.P2.Material.prototype = Object.create(p2.Material.prototype), t.Physics.P2.Material.prototype.constructor = t.Physics.P2.Material, t.Physics.P2.ContactMaterial = function(t, e, i) {
            p2.ContactMaterial.call(this, t, e, i)
        }, t.Physics.P2.ContactMaterial.prototype = Object.create(p2.ContactMaterial.prototype), t.Physics.P2.ContactMaterial.prototype.constructor = t.Physics.P2.ContactMaterial, t.Physics.P2.CollisionGroup = function(t) {
            this.mask = t
        }, t.Physics.P2.DistanceConstraint = function(t, e, i, s, n, r, o) {
            void 0 === s && (s = 100), void 0 === n && (n = [0, 0]), void 0 === r && (r = [0, 0]), void 0 === o && (o = Number.MAX_VALUE), this.game = t.game, this.world = t;
            var a = {
                distance: s = t.pxm(s),
                localAnchorA: n = [t.pxmi(n[0]), t.pxmi(n[1])],
                localAnchorB: r = [t.pxmi(r[0]), t.pxmi(r[1])],
                maxForce: o
            };
            p2.DistanceConstraint.call(this, e, i, a)
        }, t.Physics.P2.DistanceConstraint.prototype = Object.create(p2.DistanceConstraint.prototype), t.Physics.P2.DistanceConstraint.prototype.constructor = t.Physics.P2.DistanceConstraint, t.Physics.P2.GearConstraint = function(t, e, i, s, n) {
            void 0 === s && (s = 0), void 0 === n && (n = 1), this.game = t.game, this.world = t;
            var r = {
                angle: s,
                ratio: n
            };
            p2.GearConstraint.call(this, e, i, r)
        }, t.Physics.P2.GearConstraint.prototype = Object.create(p2.GearConstraint.prototype), t.Physics.P2.GearConstraint.prototype.constructor = t.Physics.P2.GearConstraint, t.Physics.P2.LockConstraint = function(t, e, i, s, n, r) {
            void 0 === s && (s = [0, 0]), void 0 === n && (n = 0), void 0 === r && (r = Number.MAX_VALUE), this.game = t.game, this.world = t;
            var o = {
                localOffsetB: s = [t.pxm(s[0]), t.pxm(s[1])],
                localAngleB: n,
                maxForce: r
            };
            p2.LockConstraint.call(this, e, i, o)
        }, t.Physics.P2.LockConstraint.prototype = Object.create(p2.LockConstraint.prototype), t.Physics.P2.LockConstraint.prototype.constructor = t.Physics.P2.LockConstraint, t.Physics.P2.PrismaticConstraint = function(t, e, i, s, n, r, o, a) {
            void 0 === s && (s = !0), void 0 === n && (n = [0, 0]), void 0 === r && (r = [0, 0]), void 0 === o && (o = [0, 0]), void 0 === a && (a = Number.MAX_VALUE), this.game = t.game, this.world = t;
            var h = {
                localAnchorA: n = [t.pxmi(n[0]), t.pxmi(n[1])],
                localAnchorB: r = [t.pxmi(r[0]), t.pxmi(r[1])],
                localAxisA: o,
                maxForce: a,
                disableRotationalLock: !s
            };
            p2.PrismaticConstraint.call(this, e, i, h)
        }, t.Physics.P2.PrismaticConstraint.prototype = Object.create(p2.PrismaticConstraint.prototype), t.Physics.P2.PrismaticConstraint.prototype.constructor = t.Physics.P2.PrismaticConstraint, t.Physics.P2.RevoluteConstraint = function(t, e, i, s, n, r, o) {
            void 0 === r && (r = Number.MAX_VALUE), void 0 === o && (o = null), this.game = t.game, this.world = t, i = [t.pxmi(i[0]), t.pxmi(i[1])], n = [t.pxmi(n[0]), t.pxmi(n[1])], o && (o = [t.pxmi(o[0]), t.pxmi(o[1])]);
            var a = {
                worldPivot: o,
                localPivotA: i,
                localPivotB: n,
                maxForce: r
            };
            p2.RevoluteConstraint.call(this, e, s, a)
        }, t.Physics.P2.RevoluteConstraint.prototype = Object.create(p2.RevoluteConstraint.prototype), t.Physics.P2.RevoluteConstraint.prototype.constructor = t.Physics.P2.RevoluteConstraint, t.ImageCollection = function(t, e, i, s, n, r, o) {
            (void 0 === i || i <= 0) && (i = 32), (void 0 === s || s <= 0) && (s = 32), void 0 === n && (n = 0), void 0 === r && (r = 0), this.name = t, this.firstgid = 0 | e, this.imageWidth = 0 | i, this.imageHeight = 0 | s, this.imageMargin = 0 | n, this.imageSpacing = 0 | r, this.properties = o || {}, this.images = [], this.total = 0
        }, t.ImageCollection.prototype = {
            containsImageIndex: function(t) {
                return t >= this.firstgid && t < this.firstgid + this.total
            },
            addImage: function(t, e) {
                this.images.push({
                    gid: t,
                    image: e
                }), this.total++
            }
        }, t.ImageCollection.prototype.constructor = t.ImageCollection, t.Tile = function(t, e, i, s, n, r) {
            this.layer = t, this.index = e, this.x = i, this.y = s, this.rotation = 0, this.flipped = !1, this.worldX = i * n, this.worldY = s * r, this.width = n, this.height = r, this.centerX = Math.abs(n / 2), this.centerY = Math.abs(r / 2), this.alpha = 1, this.properties = {}, this.scanned = !1, this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1, this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.collisionCallback = null, this.collisionCallbackContext = this, this.debug = !1
        }, t.Tile.prototype = {
            containsPoint: function(t, e) {
                return !(t < this.worldX || e < this.worldY || t > this.right || e > this.bottom)
            },
            intersects: function(t, e, i, s) {
                return !(i <= this.worldX || s <= this.worldY || t >= this.worldX + this.width || e >= this.worldY + this.height)
            },
            setCollisionCallback: function(t, e) {
                this.collisionCallback = t, this.collisionCallbackContext = e
            },
            destroy: function() {
                this.collisionCallback = null, this.collisionCallbackContext = null, this.properties = null
            },
            setCollision: function(t, e, i, s) {
                this.collideLeft = t, this.collideRight = e, this.collideUp = i, this.collideDown = s, this.faceLeft = t, this.faceRight = e, this.faceTop = i, this.faceBottom = s
            },
            resetCollision: function() {
                this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1
            },
            isInteresting: function(t, e) {
                return t && e ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.faceTop || this.faceBottom || this.faceLeft || this.faceRight || this.collisionCallback : t ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown : !!e && (this.faceTop || this.faceBottom || this.faceLeft || this.faceRight)
            },
            copy: function(t) {
                this.index = t.index, this.alpha = t.alpha, this.properties = t.properties, this.collideUp = t.collideUp, this.collideDown = t.collideDown, this.collideLeft = t.collideLeft, this.collideRight = t.collideRight, this.collisionCallback = t.collisionCallback, this.collisionCallbackContext = t.collisionCallbackContext
            }
        }, t.Tile.prototype.constructor = t.Tile, Object.defineProperty(t.Tile.prototype, "collides", {
            get: function() {
                return this.collideLeft || this.collideRight || this.collideUp || this.collideDown
            }
        }), Object.defineProperty(t.Tile.prototype, "canCollide", {
            get: function() {
                return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback
            }
        }), Object.defineProperty(t.Tile.prototype, "left", {
            get: function() {
                return this.worldX
            }
        }), Object.defineProperty(t.Tile.prototype, "right", {
            get: function() {
                return this.worldX + this.width
            }
        }), Object.defineProperty(t.Tile.prototype, "top", {
            get: function() {
                return this.worldY
            }
        }), Object.defineProperty(t.Tile.prototype, "bottom", {
            get: function() {
                return this.worldY + this.height
            }
        }), t.Tilemap = function(e, i, s, n, r, o) {
            this.game = e, this.key = i;
            var a = t.TilemapParser.parse(this.game, i, s, n, r, o);
            null !== a && (this.width = a.width, this.height = a.height, this.tileWidth = a.tileWidth, this.tileHeight = a.tileHeight, this.orientation = a.orientation, this.format = a.format, this.version = a.version, this.properties = a.properties, this.widthInPixels = a.widthInPixels, this.heightInPixels = a.heightInPixels, this.layers = a.layers, this.tilesets = a.tilesets, this.imagecollections = a.imagecollections, this.tiles = a.tiles, this.objects = a.objects, this.collideIndexes = [], this.collision = a.collision, this.images = a.images, this.enableDebug = !1, this.currentLayer = 0, this.debugMap = [], this._results = [], this._tempA = 0, this._tempB = 0)
        }, t.Tilemap.CSV = 0, t.Tilemap.TILED_JSON = 1, t.Tilemap.NORTH = 0, t.Tilemap.EAST = 1, t.Tilemap.SOUTH = 2, t.Tilemap.WEST = 3, t.Tilemap.prototype = {
            create: function(t, e, i, s, n, r) {
                return void 0 === r && (r = this.game.world), this.width = e, this.height = i, this.setTileSize(s, n), this.layers.length = 0, this.createBlankLayer(t, e, i, s, n, r)
            },
            setTileSize: function(t, e) {
                this.tileWidth = t, this.tileHeight = e, this.widthInPixels = this.width * t, this.heightInPixels = this.height * e
            },
            addTilesetImage: function(e, i, s, n, r, o, a) {
                if (void 0 === e) return null;
                void 0 === s && (s = this.tileWidth), void 0 === n && (n = this.tileHeight), void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === a && (a = 0), 0 === s && (s = 32), 0 === n && (n = 32);
                var h = null;
                if (null != i || (i = e), i instanceof t.BitmapData) h = i.canvas;
                else {
                    if (!this.game.cache.checkImageKey(i)) return console.warn('Phaser.Tilemap.addTilesetImage: Invalid image key given: "' + i + '"'), null;
                    h = this.game.cache.getImage(i)
                }
                var l = this.getTilesetIndex(e);
                if (null === l && this.format === t.Tilemap.TILED_JSON) return console.warn('Phaser.Tilemap.addTilesetImage: No data found in the JSON matching the tileset name: "' + e + '"'), gradle.event("Tilesets: ", this.tilesets), null;
                if (this.tilesets[l]) return this.tilesets[l].setImage(h), this.tilesets[l];
                var c = new t.Tileset(e, a, s, n, r, o, {});
                c.setImage(h), this.tilesets.push(c);
                for (var u = this.tilesets.length - 1, d = r, p = r, f = 0, g = 0, m = 0, y = a; y < a + c.total && (this.tiles[y] = [d, p, u], d += s + o, ++f !== c.total) && (++g !== c.columns || (d = r, p += n + o, g = 0, ++m !== c.rows)); y++);
                return c
            },
            createFromObjects: function(e, i, s, n, r, o, a, h, l, c) {
                if (void 0 === r && (r = !0), void 0 === o && (o = !1), void 0 === a && (a = this.game.world), void 0 === h && (h = t.Sprite), void 0 === l && (l = !0), void 0 === c && (c = !0), !this.objects[e]) return console.warn("Tilemap.createFromObjects: Invalid objectgroup name given: " + e), void gradle.event("Objects: ", this.objects);
                for (var u = 0; u < this.objects[e].length; u++) {
                    var d = !1,
                        p = this.objects[e][u];
                    if (void 0 !== p.gid && "number" == typeof i && p.gid === i ? d = !0 : void 0 !== p.id && "number" == typeof i && p.id === i ? d = !0 : void 0 !== p.name && "string" == typeof i && p.name === i && (d = !0), d) {
                        var f = new h(this.game, parseFloat(p.x), parseFloat(p.y), s, n);
                        for (var g in f.name = p.name, f.autoCull = o, f.exists = r, f.visible = p.visible, c && (p.width && (f.width = p.width), p.height && (f.height = p.height)), p.rotation && (f.angle = p.rotation), l && (f.y -= f.height), a.add(f), p.properties) a.set(f, g, p.properties[g], !1, !1, 0, !0)
                    }
                }
            },
            createFromTiles: function(e, i, s, n, r, o) {
                "number" == typeof e && (e = [e]), null == i ? i = [] : "number" == typeof i && (i = [i]), n = this.getLayer(n), void 0 === r && (r = this.game.world), void 0 === o && (o = {}), void 0 === o.customClass && (o.customClass = t.Sprite), void 0 === o.adjustY && (o.adjustY = !0);
                var a = this.layers[n].width,
                    h = this.layers[n].height;
                if (this.copy(0, 0, a, h, n), this._results.length < 2) return 0;
                for (var l, c = 0, u = 1, d = this._results.length; u < d; u++)
                    if (-1 !== e.indexOf(this._results[u].index)) {
                        for (var p in l = new o.customClass(this.game, this._results[u].worldX, this._results[u].worldY, s), o) l[p] = o[p];
                        r.add(l), c++
                    }
                if (1 === i.length)
                    for (u = 0; u < e.length; u++) this.replace(e[u], i[0], 0, 0, a, h, n);
                else if (i.length > 1)
                    for (u = 0; u < e.length; u++) this.replace(e[u], i[u], 0, 0, a, h, n);
                return c
            },
            createLayer: function(e, i, s, n) {
                void 0 === i && (i = this.game.width), void 0 === s && (s = this.game.height), void 0 === n && (n = this.game.world);
                var r = e;
                if ("string" == typeof e && (r = this.getLayerIndex(e)), null === r || r > this.layers.length) return console.warn('Tilemap.createLayer: Invalid layer ID given: "' + e + '"'), void gradle.event("Layers: ", this.layers);
                void 0 === i || i <= 0 ? i = Math.min(this.game.width, this.layers[r].widthInPixels) : i > this.game.width && (i = this.game.width), void 0 === s || s <= 0 ? s = Math.min(this.game.height, this.layers[r].heightInPixels) : s > this.game.height && (s = this.game.height), this.enableDebug && (console.group("Tilemap.createLayer"), gradle.event("Name:", this.layers[r].name), gradle.event("Size:", i, "x", s), gradle.event("Tileset:", this.tilesets[0].name, "index:", r));
                var o = n.add(new t.TilemapLayer(this.game, this, r, i, s));
                return this.enableDebug && console.groupEnd(), o
            },
            createBlankLayer: function(e, i, s, n, r, o) {
                if (void 0 === o && (o = this.game.world), null === this.getLayerIndex(e)) {
                    for (var a, h = {
                            name: e,
                            x: 0,
                            y: 0,
                            width: i,
                            height: s,
                            widthInPixels: i * n,
                            heightInPixels: s * r,
                            alpha: 1,
                            visible: !0,
                            properties: {},
                            indexes: [],
                            callbacks: [],
                            bodies: [],
                            data: null
                        }, l = [], c = 0; c < s; c++) {
                        a = [];
                        for (var u = 0; u < i; u++) a.push(new t.Tile(h, -1, u, c, n, r));
                        l.push(a)
                    }
                    h.data = l, this.layers.push(h), this.currentLayer = this.layers.length - 1;
                    var d = h.widthInPixels,
                        p = h.heightInPixels;
                    return d > this.game.width && (d = this.game.width), p > this.game.height && (p = this.game.height), (l = new t.TilemapLayer(this.game, this, this.layers.length - 1, d, p)).name = e, o.add(l)
                }
                console.warn("Tilemap.createBlankLayer: Layer with matching name already exists: " + e)
            },
            getIndex: function(t, e) {
                for (var i = 0; i < t.length; i++)
                    if (t[i].name === e) return i;
                return null
            },
            getLayerIndex: function(t) {
                return this.getIndex(this.layers, t)
            },
            getTilesetIndex: function(t) {
                return this.getIndex(this.tilesets, t)
            },
            getImageIndex: function(t) {
                return this.getIndex(this.images, t)
            },
            setTileIndexCallback: function(t, e, i, s) {
                if (s = this.getLayer(s), "number" == typeof t) null === e ? delete this.layers[s].callbacks[t] : this.layers[s].callbacks[t] = {
                    callback: e,
                    callbackContext: i
                };
                else
                    for (var n = 0, r = t.length; n < r; n++) null === e ? delete this.layers[s].callbacks[t[n]] : this.layers[s].callbacks[t[n]] = {
                        callback: e,
                        callbackContext: i
                    }
            },
            setTileLocationCallback: function(t, e, i, s, n, r, o) {
                if (o = this.getLayer(o), this.copy(t, e, i, s, o), !(this._results.length < 2))
                    for (var a = 1; a < this._results.length; a++) this._results[a].setCollisionCallback(n, r)
            },
            setCollision: function(t, e, i, s) {
                if (void 0 === e && (e = !0), void 0 === s && (s = !0), i = this.getLayer(i), "number" == typeof t) return this.setCollisionByIndex(t, e, i, !0);
                if (Array.isArray(t)) {
                    for (var n = 0; n < t.length; n++) this.setCollisionByIndex(t[n], e, i, !1);
                    s && this.calculateFaces(i)
                }
            },
            setCollisionBetween: function(t, e, i, s, n) {
                if (void 0 === i && (i = !0), void 0 === n && (n = !0), s = this.getLayer(s), !(t > e)) {
                    for (var r = t; r <= e; r++) this.setCollisionByIndex(r, i, s, !1);
                    n && this.calculateFaces(s)
                }
            },
            setCollisionByExclusion: function(t, e, i, s) {
                void 0 === e && (e = !0), void 0 === s && (s = !0), i = this.getLayer(i);
                for (var n = 0, r = this.tiles.length; n < r; n++) - 1 === t.indexOf(n) && this.setCollisionByIndex(n, e, i, !1);
                s && this.calculateFaces(i)
            },
            setCollisionByIndex: function(t, e, i, s) {
                if (void 0 === e && (e = !0), void 0 === i && (i = this.currentLayer), void 0 === s && (s = !0), e) this.collideIndexes.push(t);
                else {
                    var n = this.collideIndexes.indexOf(t);
                    n > -1 && this.collideIndexes.splice(n, 1)
                }
                for (var r = 0; r < this.layers[i].height; r++)
                    for (var o = 0; o < this.layers[i].width; o++) {
                        var a = this.layers[i].data[r][o];
                        a && a.index === t && (e ? a.setCollision(!0, !0, !0, !0) : a.resetCollision(), a.faceTop = e, a.faceBottom = e, a.faceLeft = e, a.faceRight = e)
                    }
                return s && this.calculateFaces(i), i
            },
            getLayer: function(e) {
                if (void 0 === e) e = this.currentLayer;
                else if ("string" == typeof e) {
                    var i = e;
                    null === (e = this.getLayerIndex(e)) && console.warn("No such layer name: " + i)
                } else e instanceof t.TilemapLayer && (e = e.index);
                return e
            },
            setPreventRecalculate: function(t) {
                if (!0 === t && !0 !== this.preventingRecalculate && (this.preventingRecalculate = !0, this.needToRecalculate = {}), !1 === t && !0 === this.preventingRecalculate) {
                    for (var e in this.preventingRecalculate = !1, this.needToRecalculate) this.calculateFaces(e);
                    this.needToRecalculate = !1
                }
            },
            calculateFaces: function(t) {
                if (this.preventingRecalculate) this.needToRecalculate[t] = !0;
                else
                    for (var e = null, i = null, s = null, n = null, r = 0, o = this.layers[t].height; r < o; r++)
                        for (var a = 0, h = this.layers[t].width; a < h; a++) {
                            var l = this.layers[t].data[r][a];
                            l && (e = this.getTileAbove(t, a, r), i = this.getTileBelow(t, a, r), s = this.getTileLeft(t, a, r), n = this.getTileRight(t, a, r), l.collides && (l.faceTop = !0, l.faceBottom = !0, l.faceLeft = !0, l.faceRight = !0), e && e.collides && (l.faceTop = !1), i && i.collides && (l.faceBottom = !1), s && s.collides && (l.faceLeft = !1), n && n.collides && (l.faceRight = !1))
                        }
            },
            getTileAbove: function(t, e, i) {
                return i > 0 ? this.layers[t].data[i - 1][e] : null
            },
            getTileBelow: function(t, e, i) {
                return i < this.layers[t].height - 1 ? this.layers[t].data[i + 1][e] : null
            },
            getTileLeft: function(t, e, i) {
                return e > 0 ? this.layers[t].data[i][e - 1] : null
            },
            getTileRight: function(t, e, i) {
                return e < this.layers[t].width - 1 ? this.layers[t].data[i][e + 1] : null
            },
            setLayer: function(t) {
                t = this.getLayer(t), this.layers[t] && (this.currentLayer = t)
            },
            hasTile: function(t, e, i) {
                return i = this.getLayer(i), void 0 !== this.layers[i].data[e] && void 0 !== this.layers[i].data[e][t] && this.layers[i].data[e][t].index > -1
            },
            removeTile: function(e, i, s) {
                if (s = this.getLayer(s), e >= 0 && e < this.layers[s].width && i >= 0 && i < this.layers[s].height && this.hasTile(e, i, s)) {
                    var n = this.layers[s].data[i][e];
                    return this.layers[s].data[i][e] = new t.Tile(this.layers[s], -1, e, i, this.tileWidth, this.tileHeight), this.layers[s].dirty = !0, this.calculateFaces(s), n
                }
            },
            removeTileWorldXY: function(t, e, i, s, n) {
                return n = this.getLayer(n), t = this.game.math.snapToFloor(t, i) / i, e = this.game.math.snapToFloor(e, s) / s, this.removeTile(t, e, n)
            },
            putTile: function(e, i, s, n) {
                return null === e ? this.removeTile(i, s, n) : (n = this.getLayer(n), i >= 0 && i < this.layers[n].width && s >= 0 && s < this.layers[n].height ? (e instanceof t.Tile ? (r = e.index, this.hasTile(i, s, n) ? this.layers[n].data[s][i].copy(e) : this.layers[n].data[s][i] = new t.Tile(n, r, i, s, e.width, e.height)) : (r = e, this.hasTile(i, s, n) ? this.layers[n].data[s][i].index = r : this.layers[n].data[s][i] = new t.Tile(this.layers[n], r, i, s, this.tileWidth, this.tileHeight)), this.collideIndexes.indexOf(r) > -1 ? this.layers[n].data[s][i].setCollision(!0, !0, !0, !0) : this.layers[n].data[s][i].resetCollision(), this.layers[n].dirty = !0, this.calculateFaces(n), this.layers[n].data[s][i]) : null);
                var r
            },
            putTileWorldXY: function(t, e, i, s, n, r) {
                return r = this.getLayer(r), e = this.game.math.snapToFloor(e, s) / s, i = this.game.math.snapToFloor(i, n) / n, this.putTile(t, e, i, r)
            },
            searchTileIndex: function(t, e, i, s) {
                void 0 === e && (e = 0), void 0 === i && (i = !1), s = this.getLayer(s);
                var n = 0;
                if (i) {
                    for (r = this.layers[s].height - 1; r >= 0; r--)
                        for (o = this.layers[s].width - 1; o >= 0; o--)
                            if (this.layers[s].data[r][o].index === t) {
                                if (n === e) return this.layers[s].data[r][o];
                                n++
                            }
                } else
                    for (var r = 0; r < this.layers[s].height; r++)
                        for (var o = 0; o < this.layers[s].width; o++)
                            if (this.layers[s].data[r][o].index === t) {
                                if (n === e) return this.layers[s].data[r][o];
                                n++
                            } return null
            },
            getTile: function(t, e, i, s) {
                return void 0 === s && (s = !1), i = this.getLayer(i), t >= 0 && t < this.layers[i].width && e >= 0 && e < this.layers[i].height ? -1 === this.layers[i].data[e][t].index ? s ? this.layers[i].data[e][t] : null : this.layers[i].data[e][t] : null
            },
            getTileWorldXY: function(t, e, i, s, n, r) {
                return void 0 === i && (i = this.tileWidth), void 0 === s && (s = this.tileHeight), n = this.getLayer(n), t = this.game.math.snapToFloor(t, i) / i, e = this.game.math.snapToFloor(e, s) / s, this.getTile(t, e, n, r)
            },
            copy: function(t, e, i, s, n) {
                if (n = this.getLayer(n), this.layers[n]) {
                    void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.layers[n].width), void 0 === s && (s = this.layers[n].height), t < 0 && (t = 0), e < 0 && (e = 0), i > this.layers[n].width && (i = this.layers[n].width), s > this.layers[n].height && (s = this.layers[n].height), this._results.length = 0, this._results.push({
                        x: t,
                        y: e,
                        width: i,
                        height: s,
                        layer: n
                    });
                    for (var r = e; r < e + s; r++)
                        for (var o = t; o < t + i; o++) this._results.push(this.layers[n].data[r][o]);
                    return this._results
                }
                this._results.length = 0
            },
            paste: function(t, e, i, s) {
                if (void 0 === t && (t = 0), void 0 === e && (e = 0), s = this.getLayer(s), i && !(i.length < 2)) {
                    for (var n = t - i[1].x, r = e - i[1].y, o = 1; o < i.length; o++) this.layers[s].data[r + i[o].y][n + i[o].x].copy(i[o]);
                    this.layers[s].dirty = !0, this.calculateFaces(s)
                }
            },
            swap: function(t, e, i, s, n, r, o) {
                o = this.getLayer(o), this.copy(i, s, n, r, o), this._results.length < 2 || (this._tempA = t, this._tempB = e, this._results.forEach(this.swapHandler, this), this.paste(i, s, this._results, o))
            },
            swapHandler: function(t) {
                t.index === this._tempA ? t.index = this._tempB : t.index === this._tempB && (t.index = this._tempA)
            },
            forEach: function(t, e, i, s, n, r, o) {
                o = this.getLayer(o), this.copy(i, s, n, r, o), this._results.length < 2 || (this._results.forEach(t, e), this.paste(i, s, this._results, o))
            },
            replace: function(t, e, i, s, n, r, o) {
                if (o = this.getLayer(o), this.copy(i, s, n, r, o), !(this._results.length < 2)) {
                    for (var a = 1; a < this._results.length; a++) this._results[a].index === t && (this._results[a].index = e);
                    this.paste(i, s, this._results, o)
                }
            },
            random: function(t, e, i, s, n) {
                if (n = this.getLayer(n), this.copy(t, e, i, s, n), !(this._results.length < 2)) {
                    for (var r = [], o = 1; o < this._results.length; o++)
                        if (this._results[o].index) {
                            var a = this._results[o].index; - 1 === r.indexOf(a) && r.push(a)
                        }
                    for (var h = 1; h < this._results.length; h++) this._results[h].index = this.game.rnd.pick(r);
                    this.paste(t, e, this._results, n)
                }
            },
            shuffle: function(e, i, s, n, r) {
                if (r = this.getLayer(r), this.copy(e, i, s, n, r), !(this._results.length < 2)) {
                    for (var o = [], a = 1; a < this._results.length; a++) this._results[a].index && o.push(this._results[a].index);
                    t.ArrayUtils.shuffle(o);
                    for (var h = 1; h < this._results.length; h++) this._results[h].index = o[h - 1];
                    this.paste(e, i, this._results, r)
                }
            },
            fill: function(t, e, i, s, n, r) {
                if (r = this.getLayer(r), this.copy(e, i, s, n, r), !(this._results.length < 2)) {
                    for (var o = 1; o < this._results.length; o++) this._results[o].index = t;
                    this.paste(e, i, this._results, r)
                }
            },
            removeAllLayers: function() {
                this.layers.length = 0, this.currentLayer = 0
            },
            dump: function() {
                for (var t = "", e = [""], i = 0; i < this.layers[this.currentLayer].height; i++) {
                    for (var s = 0; s < this.layers[this.currentLayer].width; s++) t += "%c  ", this.layers[this.currentLayer].data[i][s] > 1 ? this.debugMap[this.layers[this.currentLayer].data[i][s]] ? e.push("background: " + this.debugMap[this.layers[this.currentLayer].data[i][s]]) : e.push("background: #ffffff") : e.push("background: rgb(0, 0, 0)");
                    t += "\n"
                }
                e[0] = t, gradle.event.apply(console, e)
            },
            destroy: function() {
                this.removeAllLayers(), this.data = [], this.game = null
            }
        }, t.Tilemap.prototype.constructor = t.Tilemap, Object.defineProperty(t.Tilemap.prototype, "layer", {
            get: function() {
                return this.layers[this.currentLayer]
            },
            set: function(t) {
                t !== this.currentLayer && this.setLayer(t)
            }
        }), t.TilemapLayer = function(e, i, s, n, r) {
            n |= 0, r |= 0, t.Sprite.call(this, e, 0, 0), this.map = i, this.index = s, this.layer = i.layers[s], this.canvas = t.CanvasPool.create(this, n, r), this.context = this.canvas.getContext("2d"), this.setTexture(new PIXI.Texture(new PIXI.BaseTexture(this.canvas, null, this.game.resolution))), this.type = t.TILEMAPLAYER, this.physicsType = t.TILEMAPLAYER, this.renderSettings = {
                enableScrollDelta: !0,
                overdrawRatio: .2,
                copyCanvas: null
            }, this.debug = !1, this.exists = !0, this.debugSettings = {
                missingImageFill: "rgb(255,255,255)",
                debuggedTileOverfill: "rgba(0,255,0,0.4)",
                forceFullRedraw: !0,
                debugAlpha: .5,
                facingEdgeStroke: "rgba(0,255,0,1)",
                collidingTileOverfill: "rgba(0,255,0,0.2)"
            }, this.scrollFactorX = 1, this.scrollFactorY = 1, this.dirty = !0, this.rayStepRate = 4, this._wrap = !1, this._mc = {
                scrollX: 0,
                scrollY: 0,
                renderWidth: 0,
                renderHeight: 0,
                tileWidth: i.tileWidth,
                tileHeight: i.tileHeight,
                cw: i.tileWidth,
                ch: i.tileHeight,
                tilesets: []
            }, this._scrollX = 0, this._scrollY = 0, this.tileOffset = new t.Point(this.layer.offsetX || 0, this.layer.offsetY || 0), this._results = [], e.device.canvasBitBltShift || (this.renderSettings.copyCanvas = t.TilemapLayer.ensureSharedCopyCanvas()), this.fixedToCamera = !0
        }, t.TilemapLayer.prototype = Object.create(t.Sprite.prototype), t.TilemapLayer.prototype.constructor = t.TilemapLayer, t.TilemapLayer.prototype.preUpdateCore = t.Component.Core.preUpdate, t.TilemapLayer.sharedCopyCanvas = null, t.TilemapLayer.ensureSharedCopyCanvas = function() {
            return this.sharedCopyCanvas || (this.sharedCopyCanvas = t.CanvasPool.create(this, 2, 2)), this.sharedCopyCanvas
        }, t.TilemapLayer.prototype.preUpdate = function() {
            return this.preUpdateCore()
        }, t.TilemapLayer.prototype.postUpdate = function() {
            this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y), this._scrollX = (this.game.camera.view.x - this.tileOffset.x) * this.scrollFactorX / this.scale.x, this._scrollY = (this.game.camera.view.y - this.tileOffset.y) * this.scrollFactorY / this.scale.y
        }, t.TilemapLayer.prototype._renderCanvas = function(t) {
            this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y), this._scrollX = (this.game.camera.view.x - this.tileOffset.x) * this.scrollFactorX / this.scale.x, this._scrollY = (this.game.camera.view.y - this.tileOffset.y) * this.scrollFactorY / this.scale.y, this.render(), PIXI.Sprite.prototype._renderCanvas.call(this, t)
        }, t.TilemapLayer.prototype._renderWebGL = function(t) {
            this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y), this._scrollX = (this.game.camera.view.x - this.tileOffset.x) * this.scrollFactorX / this.scale.x, this._scrollY = (this.game.camera.view.y - this.tileOffset.y) * this.scrollFactorY / this.scale.y, this.render(), PIXI.Sprite.prototype._renderWebGL.call(this, t)
        }, t.TilemapLayer.prototype.destroy = function() {
            t.CanvasPool.remove(this), t.Component.Destroy.prototype.destroy.call(this)
        }, t.TilemapLayer.prototype.resize = function(t, e) {
            this.canvas.width = t, this.canvas.height = e, this.texture.frame.resize(t, e), this.texture.width = t, this.texture.height = e, this.texture.crop.width = t, this.texture.crop.height = e, this.texture.baseTexture.width = t, this.texture.baseTexture.height = e, this.texture.baseTexture.dirty(), this.texture.requiresUpdate = !0, this.texture._updateUvs(), this.dirty = !0
        }, t.TilemapLayer.prototype.resizeWorld = function() {
            this.game.world.setBounds(0, 0, this.layer.widthInPixels * this.scale.x, this.layer.heightInPixels * this.scale.y)
        }, t.TilemapLayer.prototype.getTileOffsetX = function() {
            return this.tileOffset.x || (this.fixedToCamera ? 0 : this.position.x)
        }, t.TilemapLayer.prototype.getTileOffsetY = function() {
            return this.tileOffset.y || (this.fixedToCamera ? 0 : this.position.y)
        }, t.TilemapLayer.prototype._fixX = function(t) {
            return 1 === this.scrollFactorX || 0 === this.scrollFactorX && 0 === this.position.x ? t : 0 === this.scrollFactorX && 0 !== this.position.x ? t - this.position.x : this._scrollX + (t - this._scrollX / this.scrollFactorX)
        }, t.TilemapLayer.prototype._unfixX = function(t) {
            return 1 === this.scrollFactorX ? t : this._scrollX / this.scrollFactorX + (t - this._scrollX)
        }, t.TilemapLayer.prototype._fixY = function(t) {
            return 1 === this.scrollFactorY || 0 === this.scrollFactorY && 0 === this.position.y ? t : 0 === this.scrollFactorY && 0 !== this.position.y ? t - this.position.y : this._scrollY + (t - this._scrollY / this.scrollFactorY)
        }, t.TilemapLayer.prototype._unfixY = function(t) {
            return 1 === this.scrollFactorY ? t : this._scrollY / this.scrollFactorY + (t - this._scrollY)
        }, t.TilemapLayer.prototype.getTileX = function(t) {
            return Math.floor(this._fixX(t) / this._mc.tileWidth)
        }, t.TilemapLayer.prototype.getTileY = function(t) {
            return Math.floor(this._fixY(t) / this._mc.tileHeight)
        }, t.TilemapLayer.prototype.getTileXY = function(t, e, i) {
            return i.x = this.getTileX(t), i.y = this.getTileY(e), i
        }, t.TilemapLayer.prototype.getRayCastTiles = function(t, e, i, s) {
            e || (e = this.rayStepRate), void 0 === i && (i = !1), void 0 === s && (s = !1);
            var n = this.getTiles(t.x, t.y, t.width, t.height, i, s);
            if (0 === n.length) return [];
            for (var r = t.coordinatesOnLine(e), o = [], a = 0; a < n.length; a++)
                for (var h = 0; h < r.length; h++) {
                    var l = n[a],
                        c = r[h];
                    if (l.containsPoint(c[0], c[1])) {
                        o.push(l);
                        break
                    }
                }
            return o
        }, t.TilemapLayer.prototype.getTiles = function(t, e, i, s, n, r) {
            void 0 === n && (n = !1), void 0 === r && (r = !1);
            var o = !(n || r);
            t = this._fixX(t), e = this._fixY(e);
            for (var a = Math.floor(t / (this._mc.cw * this.scale.x)), h = Math.floor(e / (this._mc.ch * this.scale.y)), l = Math.ceil((t + i) / (this._mc.cw * this.scale.x)) - a, c = Math.ceil((e + s) / (this._mc.ch * this.scale.y)) - h; this._results.length;) this._results.pop();
            for (var u = h; u < h + c; u++)
                for (var d = a; d < a + l; d++) {
                    var p = this.layer.data[u];
                    p && p[d] && (o || p[d].isInteresting(n, r)) && this._results.push(p[d])
                }
            return this._results.slice()
        }, t.TilemapLayer.prototype.resolveTileset = function(t) {
            var e = this._mc.tilesets;
            if (t < 2e3)
                for (; e.length < t;) e.push(void 0);
            var i = this.map.tiles[t] && this.map.tiles[t][2];
            if (null !== i) {
                var s = this.map.tilesets[i];
                if (s && s.containsTileIndex(t)) return e[t] = s
            }
            return e[t] = null
        }, t.TilemapLayer.prototype.resetTilesetCache = function() {
            for (var t = this._mc.tilesets; t.length;) t.pop()
        }, t.TilemapLayer.prototype.setScale = function(t, e) {
            t = t || 1, e = e || t;
            for (var i = 0; i < this.layer.data.length; i++)
                for (var s = this.layer.data[i], n = 0; n < s.length; n++) {
                    var r = s[n];
                    r.width = this.map.tileWidth * t, r.height = this.map.tileHeight * e, r.worldX = r.x * r.width, r.worldY = r.y * r.height
                }
            this.scale.setTo(t, e)
        }, t.TilemapLayer.prototype.shiftCanvas = function(t, e, i) {
            var s = t.canvas,
                n = s.width - Math.abs(e),
                r = s.height - Math.abs(i),
                o = 0,
                a = 0,
                h = e,
                l = i;
            e < 0 && (o = -e, h = 0), i < 0 && (a = -i, l = 0);
            var c = this.renderSettings.copyCanvas;
            if (c) {
                (c.width < n || c.height < r) && (c.width = n, c.height = r);
                var u = c.getContext("2d");
                u.clearRect(0, 0, n, r), u.drawImage(s, o, a, n, r, 0, 0, n, r), t.clearRect(h, l, n, r), t.drawImage(c, 0, 0, n, r, h, l, n, r)
            } else t.save(), t.globalCompositeOperation = "copy", t.drawImage(s, o, a, n, r, h, l, n, r), t.restore()
        }, t.TilemapLayer.prototype.renderRegion = function(t, e, i, s, n, r) {
            var o = this.context,
                a = this.layer.width,
                h = this.layer.height,
                l = this._mc.tileWidth,
                c = this._mc.tileHeight,
                u = this._mc.tilesets,
                d = NaN;
            this._wrap || (i <= n && (i = Math.max(0, i), n = Math.min(a - 1, n)), s <= r && (s = Math.max(0, s), r = Math.min(h - 1, r)));
            var p, f, g, m, y, v, x = i * l - t,
                b = (i + (1 << 20) * a) % a;
            for (m = (s + (1 << 20) * h) % h, v = r - s, f = s * c - e; v >= 0; m++, v--, f += c) {
                m >= h && (m -= h);
                var _ = this.layer.data[m];
                for (g = b, y = n - i, p = x; y >= 0; g++, y--, p += l) {
                    g >= a && (g -= a);
                    var w = _[g];
                    if (w && !(w.index < 0)) {
                        var T = w.index,
                            P = u[T];
                        void 0 === P && (P = this.resolveTileset(T)), w.alpha === d || this.debug || (o.globalAlpha = w.alpha, d = w.alpha), P ? w.rotation || w.flipped ? (o.save(), o.translate(p + w.centerX, f + w.centerY), o.rotate(w.rotation), w.flipped && o.scale(-1, 1), P.draw(o, -w.centerX, -w.centerY, T), o.restore()) : P.draw(o, p, f, T) : this.debugSettings.missingImageFill && (o.fillStyle = this.debugSettings.missingImageFill, o.fillRect(p, f, l, c)), w.debug && this.debugSettings.debuggedTileOverfill && (o.fillStyle = this.debugSettings.debuggedTileOverfill, o.fillRect(p, f, l, c))
                    }
                }
            }
        }, t.TilemapLayer.prototype.renderDeltaScroll = function(t, e) {
            var i = this._mc.scrollX,
                s = this._mc.scrollY,
                n = this.canvas.width,
                r = this.canvas.height,
                o = this._mc.tileWidth,
                a = this._mc.tileHeight,
                h = 0,
                l = -o,
                c = 0,
                u = -a;
            if (t < 0 ? (h = n + t, l = n - 1) : t > 0 && (l = t), e < 0 ? (c = r + e, u = r - 1) : e > 0 && (u = e), this.shiftCanvas(this.context, t, e), h = Math.floor((h + i) / o), l = Math.floor((l + i) / o), c = Math.floor((c + s) / a), u = Math.floor((u + s) / a), h <= l) {
                this.context.clearRect(h * o - i, 0, (l - h + 1) * o, r);
                var d = Math.floor((0 + s) / a),
                    p = Math.floor((r - 1 + s) / a);
                this.renderRegion(i, s, h, d, l, p)
            }
            if (c <= u) {
                this.context.clearRect(0, c * a - s, n, (u - c + 1) * a);
                var f = Math.floor((0 + i) / o),
                    g = Math.floor((n - 1 + i) / o);
                this.renderRegion(i, s, f, c, g, u)
            }
        }, t.TilemapLayer.prototype.renderFull = function() {
            var t = this._mc.scrollX,
                e = this._mc.scrollY,
                i = this.canvas.width,
                s = this.canvas.height,
                n = this._mc.tileWidth,
                r = this._mc.tileHeight,
                o = Math.floor(t / n),
                a = Math.floor((i - 1 + t) / n),
                h = Math.floor(e / r),
                l = Math.floor((s - 1 + e) / r);
            this.context.clearRect(0, 0, i, s), this.renderRegion(t, e, o, h, a, l)
        }, t.TilemapLayer.prototype.render = function() {
            var t = !1;
            if (this.visible) {
                (this.dirty || this.layer.dirty) && (this.layer.dirty = !1, t = !0);
                var e = this.canvas.width,
                    i = this.canvas.height,
                    s = 0 | this._scrollX,
                    n = 0 | this._scrollY,
                    r = this._mc,
                    o = r.scrollX - s,
                    a = r.scrollY - n;
                if (t || 0 !== o || 0 !== a || r.renderWidth !== e || r.renderHeight !== i) return this.context.save(), r.scrollX = s, r.scrollY = n, r.renderWidth === e && r.renderHeight === i || (r.renderWidth = e, r.renderHeight = i), this.debug && (this.context.globalAlpha = this.debugSettings.debugAlpha, this.debugSettings.forceFullRedraw && (t = !0)), !t && this.renderSettings.enableScrollDelta && Math.abs(o) + Math.abs(a) < Math.min(e, i) ? this.renderDeltaScroll(o, a) : this.renderFull(), this.debug && (this.context.globalAlpha = 1, this.renderDebug()), this.texture.baseTexture.dirty(), this.dirty = !1, this.context.restore(), !0
            }
        }, t.TilemapLayer.prototype.renderDebug = function() {
            var t, e, i, s, n, r, o = this._mc.scrollX,
                a = this._mc.scrollY,
                h = this.context,
                l = this.canvas.width,
                c = this.canvas.height,
                u = this.layer.width,
                d = this.layer.height,
                p = this._mc.tileWidth,
                f = this._mc.tileHeight,
                g = Math.floor(o / p),
                m = Math.floor((l - 1 + o) / p),
                y = Math.floor(a / f),
                v = Math.floor((c - 1 + a) / f),
                x = g * p - o,
                b = y * f - a,
                _ = (g + (1 << 20) * u) % u,
                w = (y + (1 << 20) * d) % d;
            for (h.strokeStyle = this.debugSettings.facingEdgeStroke, s = w, r = v - y, e = b; r >= 0; s++, r--, e += f) {
                s >= d && (s -= d);
                var T = this.layer.data[s];
                for (i = _, n = m - g, t = x; n >= 0; i++, n--, t += p) {
                    i >= u && (i -= u);
                    var P = T[i];
                    !P || P.index < 0 || !P.collides || (this.debugSettings.collidingTileOverfill && (h.fillStyle = this.debugSettings.collidingTileOverfill, h.fillRect(t, e, this._mc.cw, this._mc.ch)), this.debugSettings.facingEdgeStroke && (h.beginPath(), P.faceTop && (h.moveTo(t, e), h.lineTo(t + this._mc.cw, e)), P.faceBottom && (h.moveTo(t, e + this._mc.ch), h.lineTo(t + this._mc.cw, e + this._mc.ch)), P.faceLeft && (h.moveTo(t, e), h.lineTo(t, e + this._mc.ch)), P.faceRight && (h.moveTo(t + this._mc.cw, e), h.lineTo(t + this._mc.cw, e + this._mc.ch)), h.closePath(), h.stroke()))
                }
            }
        }, Object.defineProperty(t.TilemapLayer.prototype, "wrap", {
            get: function() {
                return this._wrap
            },
            set: function(t) {
                this._wrap = t, this.dirty = !0
            }
        }), Object.defineProperty(t.TilemapLayer.prototype, "scrollX", {
            get: function() {
                return this._scrollX
            },
            set: function(t) {
                this._scrollX = t
            }
        }), Object.defineProperty(t.TilemapLayer.prototype, "scrollY", {
            get: function() {
                return this._scrollY
            },
            set: function(t) {
                this._scrollY = t
            }
        }), Object.defineProperty(t.TilemapLayer.prototype, "collisionWidth", {
            get: function() {
                return this._mc.cw
            },
            set: function(t) {
                this._mc.cw = 0 | t, this.dirty = !0
            }
        }), Object.defineProperty(t.TilemapLayer.prototype, "collisionHeight", {
            get: function() {
                return this._mc.ch
            },
            set: function(t) {
                this._mc.ch = 0 | t, this.dirty = !0
            }
        }), t.TilemapParser = {
            INSERT_NULL: !1,
            parse: function(e, i, s, n, r, o) {
                if (void 0 === s && (s = 32), void 0 === n && (n = 32), void 0 === r && (r = 10), void 0 === o && (o = 10), void 0 === i) return this.getEmptyData();
                if (null === i) return this.getEmptyData(s, n, r, o);
                var a = e.cache.getTilemapData(i);
                if (a) {
                    if (a.format === t.Tilemap.CSV) return this.parseCSV(i, a.data, s, n);
                    if (!a.format || a.format === t.Tilemap.TILED_JSON) return this.parseTiledJSON(a.data)
                } else console.warn('No map data found for key "%s"', i)
            },
            parseCSV: function(e, i, s, n) {
                for (var r = this.getEmptyData(), o = [], a = (i = i.trim()).split("\n"), h = a.length, l = 0, c = 0; c < a.length; c++) {
                    o[c] = [];
                    for (var u = a[c].split(","), d = 0; d < u.length; d++) o[c][d] = new t.Tile(r.layers[0], parseInt(u[d], 10), d, c, s, n);
                    0 === l && (l = u.length)
                }
                return r.format = t.Tilemap.CSV, r.name = e, r.width = l, r.height = h, r.tileWidth = s, r.tileHeight = n, r.widthInPixels = l * s, r.heightInPixels = h * n, r.layers[0].width = l, r.layers[0].height = h, r.layers[0].widthInPixels = r.widthInPixels, r.layers[0].heightInPixels = r.heightInPixels, r.layers[0].data = o, r
            },
            getEmptyData: function(t, e, i, s) {
                return {
                    width: null != i ? i : 0,
                    height: null != s ? s : 0,
                    tileWidth: null != t ? t : 0,
                    tileHeight: null != e ? e : 0,
                    orientation: "orthogonal",
                    version: "1",
                    properties: {},
                    widthInPixels: 0,
                    heightInPixels: 0,
                    layers: [{
                        name: "layer",
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0,
                        widthInPixels: 0,
                        heightInPixels: 0,
                        alpha: 1,
                        visible: !0,
                        properties: {},
                        indexes: [],
                        callbacks: [],
                        bodies: [],
                        data: []
                    }],
                    images: [],
                    objects: {},
                    collision: {},
                    tilesets: [],
                    tiles: []
                }
            },
            _slice: function(t, e) {
                var i = {};
                for (var s in e) {
                    var n = e[s];
                    void 0 !== t[n] && (i[n] = t[n])
                }
                return i
            },
            parseObjectGroup: function(t, e, i, s, n) {
                s = s || t.name, n = n || {
                    x: 0,
                    y: 0
                };
                var r = this._slice;
                s || console.warn("No name found for objectGroup", t), void 0 !== n.x && void 0 !== n.y || console.warn("Malformed xy properties in relativePosition", n), e[s] = e[s] || [], i[s] = i[s] || [];
                for (var o = 0, a = t.objects.length; o < a; o++) {
                    var h = t.objects[o];
                    if (h.gid) l = {
                        gid: h.gid,
                        name: h.name,
                        type: h.type || "",
                        x: h.x + n.x,
                        y: h.y + n.y,
                        width: h.width,
                        height: h.height,
                        visible: h.visible,
                        properties: h.properties
                    }, h.rotation && (l.rotation = h.rotation), e[s].push(l);
                    else if (h.polyline) {
                        var l = {
                            name: h.name,
                            type: h.type,
                            x: h.x + n.x,
                            y: h.y + n.y,
                            width: h.width,
                            height: h.height,
                            visible: h.visible,
                            properties: h.properties
                        };
                        for (h.rotation && (l.rotation = h.rotation), l.polyline = [], c = 0; c < h.polyline.length; c++) l.polyline.push([h.polyline[c].x, h.polyline[c].y]);
                        i[s].push(l), e[s].push(l)
                    } else if (h.polygon) {
                        (l = r(h, ["name", "type", "x", "y", "visible", "rotation", "properties"])).x += n.x, l.y += n.y, l.polygon = [];
                        for (var c = 0; c < h.polygon.length; c++) l.polygon.push([h.polygon[c].x, h.polygon[c].y]);
                        i[s].push(l), e[s].push(l)
                    } else h.ellipse ? ((l = r(h, ["name", "type", "ellipse", "x", "y", "width", "height", "visible", "rotation", "properties"])).x += n.x, l.y += n.y, i[s].push(l), e[s].push(l)) : ((l = r(h, ["name", "type", "x", "y", "width", "height", "visible", "rotation", "properties"])).x += n.x, l.y += n.y, l.rectangle = !0, i[s].push(l), e[s].push(l))
                }
                return {
                    objectsCollection: e,
                    collisionCollection: i
                }
            },
            parseTiledJSON: function(e) {
                if ("orthogonal" !== e.orientation) return console.warn('Phaser CE supports only orthogonal maps. This map\'s orientation is "%s".', e.orientation), null;
                e.version > 1.1 && console.warn('Some features in this Tiled JSON map (version %s) may not work in Phaser CE. Enable the json1 plugin and reexport the map in "Tiled 1.1" format. https://github.com/photonstorm/phaser-ce/issues/623', e.version);
                for (var i = {
                        width: e.width,
                        height: e.height,
                        tileWidth: e.tilewidth,
                        tileHeight: e.tileheight,
                        orientation: e.orientation,
                        format: t.Tilemap.TILED_JSON,
                        version: e.version,
                        properties: e.properties,
                        widthInPixels: e.width * e.tilewidth,
                        heightInPixels: e.height * e.tileheight
                    }, s = [], n = 0; n < e.layers.length; n++)
                    if ("tilelayer" === e.layers[n].type) {
                        var r = e.layers[n];
                        if (!r.compression && r.encoding && "base64" === r.encoding) {
                            for (var o = window.atob(r.data), a = o.length, h = new Array(a), l = 0; l < a; l += 4) h[l / 4] = (o.charCodeAt(l) | o.charCodeAt(l + 1) << 8 | o.charCodeAt(l + 2) << 16 | o.charCodeAt(l + 3) << 24) >>> 0;
                            r.data = h, delete r.encoding
                        } else if (r.compression) {
                            console.warn('Layer compression is unsupported, skipping layer "%s".', r.name);
                            continue
                        }
                        k = {
                            name: r.name,
                            x: r.x,
                            y: r.y,
                            width: r.width,
                            height: r.height,
                            widthInPixels: r.width * e.tilewidth,
                            heightInPixels: r.height * e.tileheight,
                            alpha: r.opacity,
                            offsetX: r.offsetx,
                            offsetY: r.offsety,
                            visible: r.visible,
                            properties: {},
                            indexes: [],
                            callbacks: [],
                            bodies: []
                        }, r.properties && (k.properties = r.properties);
                        var c, u, d, p = 0,
                            f = [],
                            g = [],
                            m = 0;
                        for (a = r.data.length; m < a; m++) {
                            if (c = 0, u = !1, d = 0, (A = r.data[m]) > 536870912) switch (A > 2147483648 && (A -= 2147483648, d += 4), A > 1073741824 && (A -= 1073741824, d += 2), A > 536870912 && (A -= 536870912, d += 1), d) {
                                case 5:
                                    c = Math.PI / 2;
                                    break;
                                case 6:
                                    c = Math.PI;
                                    break;
                                case 3:
                                    c = 3 * Math.PI / 2;
                                    break;
                                case 4:
                                    c = 0, u = !0;
                                    break;
                                case 7:
                                    c = Math.PI / 2, u = !0;
                                    break;
                                case 2:
                                    c = Math.PI, u = !0;
                                    break;
                                case 1:
                                    c = 3 * Math.PI / 2, u = !0
                            }
                            A > 0 ? ((F = new t.Tile(k, A, p, g.length, e.tilewidth, e.tileheight)).rotation = c, F.flipped = u, 0 !== d && (F.flippedVal = d), f.push(F)) : t.TilemapParser.INSERT_NULL ? f.push(null) : f.push(new t.Tile(k, -1, p, g.length, e.tilewidth, e.tileheight)), ++p === r.width && (g.push(f), p = 0, f = [])
                        }
                        k.data = g, s.push(k)
                    }
                i.layers = s;
                var y = [];
                for (n = 0; n < e.layers.length; n++)
                    if ("imagelayer" === e.layers[n].type) {
                        var v = e.layers[n],
                            x = {
                                name: v.name,
                                image: v.image,
                                x: v.x,
                                y: v.y,
                                alpha: v.opacity,
                                visible: v.visible,
                                properties: {}
                            };
                        v.properties && (x.properties = v.properties), y.push(x)
                    }
                i.images = y;
                var b = [],
                    _ = {},
                    w = [],
                    T = null;
                for (n = 0; n < e.tilesets.length; n++) {
                    if ((U = e.tilesets[n]).source) console.warn("Phaser CE can't load external tilesets (%s). Embed the tileset and then export the map again. https://github.com/photonstorm/phaser-ce/issues/273", U.source);
                    else if (U.image) {
                        var P = new t.Tileset(U.name, U.firstgid, U.tilewidth, U.tileheight, U.margin, U.spacing, U.properties);
                        U.tileproperties && (P.tileProperties = U.tileproperties), P.updateTileData(U.imagewidth, U.imageheight), b.push(P)
                    } else {
                        if (!U.tiles) throw new Error("Tileset " + U.name + " has no `image` or `tiles` property.");
                        var C = new t.ImageCollection(U.name, U.firstgid, U.tilewidth, U.tileheight, U.margin, U.spacing, U.properties);
                        for (var S in U.tiles) {
                            x = U.tiles[S].image;
                            var A = U.firstgid + parseInt(S, 10);
                            C.addImage(A, x)
                        }
                        w.push(C)
                    }
                    for (var S in U.tiles)(R = U.tiles[S].objectgroup) && (_[parseInt(S, 10) + U.firstgid] = R);
                    T && (T.lastgid = U.firstgid - 1), T = U
                }
                if (0 === b.length && 0 === w.length) throw new Error("This tilemap has no tilesets.");
                i.tilesets = b, i.imagecollections = w;
                var E = {},
                    M = {};
                for (n = 0; n < e.layers.length; n++)
                    if ("objectgroup" === e.layers[n].type) {
                        var R = e.layers[n];
                        this.parseObjectGroup(R, E, M)
                    }
                for (i.objects = E, i.collision = M, i.tiles = [], n = 0; n < i.tilesets.length; n++) {
                    p = (U = i.tilesets[n]).tileMargin;
                    var L = U.tileMargin,
                        B = 0,
                        I = 0,
                        O = 0;
                    for (m = U.firstgid; m < U.firstgid + U.total && (i.tiles[m] = [p, L, n], p += U.tileWidth + U.tileSpacing, ++B !== U.total) && (++I !== U.columns || (p = U.tileMargin, L += U.tileHeight + U.tileSpacing, I = 0, ++O !== U.rows)); m++);
                }
                var k, F, D, U;
                for (n = 0; n < i.layers.length; n++)
                    for (M[(k = i.layers[n]).name] = [], U = null, l = 0; l < k.data.length; l++) {
                        f = k.data[l];
                        for (var G = 0; G < f.length; G++) null === (F = f[G]) || F.index < 0 || (D = i.tiles[F.index][2], (U = i.tilesets[D]).tileProperties && U.tileProperties[F.index - U.firstgid] && (F.properties = t.Utils.mixin(U.tileProperties[F.index - U.firstgid], F.properties)), (R = _[F.index]) && this.parseObjectGroup(R, i.objects, i.collision, F.layer.name, {
                            x: F.worldX + R.x,
                            y: F.worldY + R.y
                        }))
                    }
                return i
            }
        }, t.Tileset = function(t, e, i, s, n, r, o) {
            (void 0 === i || i <= 0) && (i = 32), (void 0 === s || s <= 0) && (s = 32), void 0 === n && (n = 0), void 0 === r && (r = 0), this.name = t, this.firstgid = 0 | e, this.tileWidth = 0 | i, this.tileHeight = 0 | s, this.tileMargin = 0 | n, this.tileSpacing = 0 | r, this.properties = o || {}, this.image = null, this.rows = 0, this.columns = 0, this.total = 0, this.drawCoords = []
        }, t.Tileset.prototype = {
            draw: function(t, e, i, s) {
                var n = s - this.firstgid << 1;
                n >= 0 && n + 1 < this.drawCoords.length && t.drawImage(this.image, this.drawCoords[n], this.drawCoords[n + 1], this.tileWidth, this.tileHeight, e, i, this.tileWidth, this.tileHeight)
            },
            containsTileIndex: function(t) {
                return t >= this.firstgid && t < this.firstgid + this.total
            },
            setImage: function(t) {
                this.image = t, this.updateTileData(t.width, t.height)
            },
            setSpacing: function(t, e) {
                this.tileMargin = 0 | t, this.tileSpacing = 0 | e, this.image && this.updateTileData(this.image.width, this.image.height)
            },
            updateTileData: function(t, e) {
                var i = (e - 2 * this.tileMargin + this.tileSpacing) / (this.tileHeight + this.tileSpacing),
                    s = (t - 2 * this.tileMargin + this.tileSpacing) / (this.tileWidth + this.tileSpacing);
                i % 1 == 0 && s % 1 == 0 || console.warn("Phaser.Tileset - '%s' image tile area (%s x %s) is not a whole multiple of tile size (%s x %s + %s + %s)", this.name, t, e, this.tileWidth, this.tileHeight, this.tileMargin, this.tileSpacing), i = Math.floor(i), s = Math.floor(s), (this.rows && this.rows !== i || this.columns && this.columns !== s) && console.warn("Phaser.Tileset - Tile layout from image '%s' (%s rows by %s columns) differs from tileset '%s' (%s rows by %s columns)", this.image.name, s, i, this.name, this.columns, this.rows), this.rows = i, this.columns = s, this.total = i * s, this.drawCoords.length = 0;
                for (var n = this.tileMargin, r = this.tileMargin, o = 0; o < this.rows; o++) {
                    for (var a = 0; a < this.columns; a++) this.drawCoords.push(n), this.drawCoords.push(r), n += this.tileWidth + this.tileSpacing;
                    n = this.tileMargin, r += this.tileHeight + this.tileSpacing
                }
            }
        }, t.Tileset.prototype.constructor = t.Tileset, t.Particle = function(e, i, s, n, r) {
            t.Sprite.call(this, e, i, s, n, r), this.autoScale = !1, this.scaleData = null, this._s = 0, this.autoAlpha = !1, this.alphaData = null, this._a = 0
        }, t.Particle.prototype = Object.create(t.Sprite.prototype), t.Particle.prototype.constructor = t.Particle, t.Particle.prototype.update = function() {
            this.autoScale && (--this._s ? this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y) : this.autoScale = !1), this.autoAlpha && (--this._a ? this.alpha = this.alphaData[this._a].v : this.autoAlpha = !1)
        }, t.Particle.prototype.onEmit = function() {}, t.Particle.prototype.setAlphaData = function(t) {
            this.alphaData = t, this._a = t.length - 1, this.alpha = this.alphaData[this._a].v, this.autoAlpha = !0
        }, t.Particle.prototype.setScaleData = function(t) {
            this.scaleData = t, this._s = t.length - 1, this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y), this.autoScale = !0
        }, t.Particle.prototype.reset = function(e, i, s) {
            return t.Component.Reset.prototype.reset.call(this, e, i, s), this.alpha = 1, this.scale.set(1), this.autoScale = !1, this.autoAlpha = !1, this
        }, t.Particles = function(t) {
            this.game = t, this.emitters = {}, this.ID = 0
        }, t.Particles.prototype = {
            add: function(t) {
                return this.emitters[t.id] = t, t
            },
            remove: function(t) {
                delete this.emitters[t.id]
            }
        }, t.Particles.prototype.constructor = t.Particles, t.Particles.Arcade = {}, t.Particles.Arcade.Emitter = function(e, i, s, n) {
            this.maxParticles = n || 50, t.Group.call(this, e), this._id = this.game.particles.ID++, this.name = "emitter" + this.id, this.type = t.EMITTER, this.physicsType = t.GROUP, this.area = new t.Rectangle(i, s, 1, 1), this.minAngle = null, this.maxAngle = null, this.minSpeed = 0, this.maxSpeed = 100, this.minParticleSpeed = new t.Point(-100, -100), this.maxParticleSpeed = new t.Point(100, 100), this.minParticleScale = 1, this.maxParticleScale = 1, this.scaleData = null, this.minRotation = -360, this.maxRotation = 360, this.minParticleAlpha = 1, this.maxParticleAlpha = 1, this.alphaData = null, this.particleClass = t.Particle, this.particleDrag = new t.Point, this.angularDrag = 0, this.frequency = 100, this.lifespan = 2e3, this.bounce = new t.Point, this.on = !1, this.particleAnchor = new t.Point(.5, .5), this.blendMode = t.blendModes.NORMAL, this.emitX = i, this.emitY = s, this.autoScale = !1, this.autoAlpha = !1, this.particleBringToTop = !1, this.particleSendToBack = !1, this.counts = {
                emitted: 0,
                failed: 0,
                totalEmitted: 0,
                totalFailed: 0
            }, this._gravity = new t.Point(0, 100), this._minParticleScale = new t.Point(1, 1), this._maxParticleScale = new t.Point(1, 1), this._total = 0, this._timer = 0, this._counter = 0, this._flowQuantity = 0, this._flowTotal = 0, this._explode = !0, this._frames = null
        }, t.Particles.Arcade.Emitter.prototype = Object.create(t.Group.prototype), t.Particles.Arcade.Emitter.prototype.constructor = t.Particles.Arcade.Emitter, t.Particles.Arcade.Emitter.prototype.update = function() {
            if (this.counts.emitted = 0, this.counts.failed = 0, this.on && this.game.time.time >= this._timer)
                if (this._timer = this.game.time.time + this.frequency * this.game.time.slowMotion, 0 !== this._flowTotal)
                    if (this._flowQuantity > 0) {
                        for (t = 0; t < this._flowQuantity; t++)
                            if (this.emitParticle() && (this._counter++, -1 !== this._flowTotal && this._counter >= this._flowTotal)) {
                                this.on = !1;
                                break
                            }
                    } else this.emitParticle() && (this._counter++, -1 !== this._flowTotal && this._counter >= this._flowTotal && (this.on = !1));
            else this.emitParticle() && (this._counter++, this._total > 0 && this._counter >= this._total && (this.on = !1));
            for (var t = this.children.length; t--;) this.children[t].exists && this.children[t].update()
        }, t.Particles.Arcade.Emitter.prototype.makeParticles = function(t, e, i, s, n, r) {
            void 0 === e && (e = 0), void 0 === i && (i = this.maxParticles), void 0 === s && (s = !1), void 0 === n && (n = !1), void 0 === r && (r = null);
            var o, a = 0,
                h = t,
                l = e;
            for (this._frames = e, i > this.maxParticles && (this.maxParticles = i); a < i;) Array.isArray(t) && (h = this.game.rnd.pick(t)), Array.isArray(e) && (l = this.game.rnd.pick(e)), o = new this.particleClass(this.game, 0, 0, h, l, r), this.game.physics.arcade.enable(o, !1), o.body.checkCollision.none = !s, o.body.collideWorldBounds = n, o.body.skipQuadTree = !0, o.exists = !1, o.visible = !1, o.anchor.copyFrom(this.particleAnchor), this.add(o), a++;
            return this
        }, t.Particles.Arcade.Emitter.prototype.kill = function() {
            return this.on = !1, this.alive = !1, this.exists = !1, this
        }, t.Particles.Arcade.Emitter.prototype.revive = function() {
            return this.alive = !0, this.exists = !0, this
        }, t.Particles.Arcade.Emitter.prototype.explode = function(t, e) {
            return void 0 === e && (e = this.maxParticles), this._flowTotal = 0, this.start(!0, t, 0, e, !1), this
        }, t.Particles.Arcade.Emitter.prototype.flow = function(t, e, i, s, n) {
            return null != e || (e = 250), void 0 !== i && 0 !== i || (i = 1), void 0 === s && (s = -1), void 0 === n && (n = !0), i > this.maxParticles && (i = this.maxParticles), this._counter = 0, this._flowQuantity = i, this._flowTotal = s, n ? (this.start(!0, t, e, i), this._counter += i, this.on = !0, this._timer = this.game.time.time + e * this.game.time.slowMotion) : this.start(!1, t, e, i), this
        }, t.Particles.Arcade.Emitter.prototype.start = function(t, e, i, s, n) {
            if (void 0 === t && (t = !0), void 0 === e && (e = 0), null != i || (i = 250), void 0 === s && (s = 0), void 0 === n && (n = !1), s > this.maxParticles && (s = this.maxParticles), this.revive(), this.visible = !0, this.lifespan = e, this.frequency = i, t || n)
                for (var r = 0; r < s; r++) this.emitParticle();
            else this.on = !0, this._total = s, this._counter = 0, this._timer = this.game.time.time + i * this.game.time.slowMotion;
            return this
        }, t.Particles.Arcade.Emitter.prototype.emitParticle = function(t, e, i, s) {
            void 0 === t && (t = null), void 0 === e && (e = null);
            var n = this.getNextParticle();
            if (null === n) return this.counts.failed++, this.counts.totalFailed++, !1;
            this.counts.emitted++, this.counts.totalEmitted++;
            var r = this.game.rnd;
            void 0 !== i && void 0 !== s ? n.loadTexture(i, s) : void 0 !== i && (n.loadTexture(i), n.frame = Array.isArray(this._frames) ? r.pick(this._frames) : this._frames);
            var o = this.emitX,
                a = this.emitY;
            return null !== t ? o = t : this.width > 1 && (o = r.between(this.left, this.right)), null !== e ? a = e : this.height > 1 && (a = r.between(this.top, this.bottom)), this.resetParticle(n, o, a), !0
        }, t.Particles.Arcade.Emitter.prototype.getNextParticle = function() {
            for (var t = this.length; t--;) {
                var e = this.next();
                if (!e.exists) return e
            }
            return null
        }, t.Particles.Arcade.Emitter.prototype.resetParticle = function(t, e, i) {
            var s = this.game.rnd;
            t.reset(e, i), t.angle = 0, t.lifespan = this.lifespan, this.particleBringToTop ? this.bringToTop(t) : this.particleSendToBack && this.sendToBack(t), this.autoScale ? t.setScaleData(this.scaleData) : 1 !== this.minParticleScale || 1 !== this.maxParticleScale ? t.scale.set(s.realInRange(this.minParticleScale, this.maxParticleScale)) : this._minParticleScale.x !== this._maxParticleScale.x || this._minParticleScale.y !== this._maxParticleScale.y ? t.scale.set(s.realInRange(this._minParticleScale.x, this._maxParticleScale.x), s.realInRange(this._minParticleScale.y, this._maxParticleScale.y)) : t.scale.set(this._minParticleScale.x, this._minParticleScale.y), this.autoAlpha ? t.setAlphaData(this.alphaData) : t.alpha = s.realInRange(this.minParticleAlpha, this.maxParticleAlpha), t.blendMode = this.blendMode;
            var n = t.body;
            n.updateBounds(), n.bounce.copyFrom(this.bounce), n.drag.copyFrom(this.particleDrag), null != this.minAngle && null != this.maxAngle ? this.game.physics.arcade.velocityFromAngle(this.minAngle === this.maxAngle ? this.minAngle : s.between(this.minAngle, this.maxAngle), this.minSpeed === this.maxSpeed ? this.minSpeed : s.between(this.minSpeed, this.maxSpeed), n.velocity) : (n.velocity.x = s.between(this.minParticleSpeed.x, this.maxParticleSpeed.x), n.velocity.y = s.between(this.minParticleSpeed.y, this.maxParticleSpeed.y)), n.angularVelocity = s.between(this.minRotation, this.maxRotation), n.gravity.copyFrom(this.gravity), n.angularDrag = this.angularDrag, t.onEmit()
        }, t.Particles.Arcade.Emitter.prototype.destroy = function() {
            this.game.particles.remove(this), t.Group.prototype.destroy.call(this, !0, !1)
        }, t.Particles.Arcade.Emitter.prototype.setSize = function(t, e) {
            return this.area.width = t, this.area.height = e, this
        }, t.Particles.Arcade.Emitter.prototype.setXSpeed = function(t, e) {
            return t = t || 0, e = e || 0, this.minParticleSpeed.x = t, this.maxParticleSpeed.x = e, this
        }, t.Particles.Arcade.Emitter.prototype.setYSpeed = function(t, e) {
            return t = t || 0, e = e || 0, this.minParticleSpeed.y = t, this.maxParticleSpeed.y = e, this
        }, t.Particles.Arcade.Emitter.prototype.setRotation = function(t, e) {
            return t = t || 0, e = e || 0, this.minRotation = t, this.maxRotation = e, this
        }, t.Particles.Arcade.Emitter.prototype.setAlpha = function(e, i, s, n, r) {
            if (void 0 === e && (e = 1), void 0 === i && (i = 1), void 0 === s && (s = 0), void 0 === n && (n = t.Easing.Linear.None), void 0 === r && (r = !1), this.minParticleAlpha = e, this.maxParticleAlpha = i, this.autoAlpha = !1, s > 0 && e !== i) {
                var o = {
                        v: e
                    },
                    a = this.game.make.tween(o).to({
                        v: i
                    }, s, n);
                a.yoyo(r), this.alphaData = a.generateData(60), this.alphaData.reverse(), this.autoAlpha = !0
            }
            return this
        }, t.Particles.Arcade.Emitter.prototype.setScale = function(e, i, s, n, r, o, a) {
            if (void 0 === e && (e = 1), void 0 === i && (i = 1), void 0 === s && (s = 1), void 0 === n && (n = 1), void 0 === r && (r = 0), void 0 === o && (o = t.Easing.Linear.None), void 0 === a && (a = !1), this.minParticleScale = 1, this.maxParticleScale = 1, this._minParticleScale.set(e, s), this._maxParticleScale.set(i, n), this.autoScale = !1, r > 0 && (e !== i || s !== n)) {
                var h = {
                        x: e,
                        y: s
                    },
                    l = this.game.make.tween(h).to({
                        x: i,
                        y: n
                    }, r, o);
                l.yoyo(a), this.scaleData = l.generateData(60), this.scaleData.reverse(), this.autoScale = !0
            }
            return this
        }, t.Particles.Arcade.Emitter.prototype.setAngle = function(t, e, i, s) {
            return this.minAngle = t, this.maxAngle = e, null != i && (this.minSpeed = i), null != s && (this.maxSpeed = s), this
        }, t.Particles.Arcade.Emitter.prototype.at = function(t) {
            return t.center ? (this.emitX = t.center.x, this.emitY = t.center.y) : (this.emitX = t.world.x + t.anchor.x * t.width, this.emitY = t.world.y + t.anchor.y * t.height), this
        }, Object.defineProperty(t.Particles.Arcade.Emitter.prototype, "gravity", {
            get: function() {
                return this._gravity
            },
            set: function(t) {
                "number" == typeof t ? this._gravity.y = t : this._gravity = t
            }
        }), Object.defineProperty(t.Particles.Arcade.Emitter.prototype, "id", {
            get: function() {
                return this._id
            }
        }), Object.defineProperty(t.Particles.Arcade.Emitter.prototype, "width", {
            get: function() {
                return this.area.width
            },
            set: function(t) {
                this.area.width = t
            }
        }), Object.defineProperty(t.Particles.Arcade.Emitter.prototype, "height", {
            get: function() {
                return this.area.height
            },
            set: function(t) {
                this.area.height = t
            }
        }), Object.defineProperty(t.Particles.Arcade.Emitter.prototype, "x", {
            get: function() {
                return this.emitX
            },
            set: function(t) {
                this.emitX = t
            }
        }), Object.defineProperty(t.Particles.Arcade.Emitter.prototype, "y", {
            get: function() {
                return this.emitY
            },
            set: function(t) {
                this.emitY = t
            }
        }), Object.defineProperty(t.Particles.Arcade.Emitter.prototype, "left", {
            get: function() {
                return Math.floor(this.x - this.area.width / 2)
            }
        }), Object.defineProperty(t.Particles.Arcade.Emitter.prototype, "right", {
            get: function() {
                return Math.floor(this.x + this.area.width / 2)
            }
        }), Object.defineProperty(t.Particles.Arcade.Emitter.prototype, "top", {
            get: function() {
                return Math.floor(this.y - this.area.height / 2)
            }
        }), Object.defineProperty(t.Particles.Arcade.Emitter.prototype, "bottom", {
            get: function() {
                return Math.floor(this.y + this.area.height / 2)
            }
        }), Object.defineProperty(t.Particles.Arcade.Emitter.prototype, "output", {
            get: function() {
                return 1e3 * this._flowQuantity / this.frequency
            }
        }), Object.defineProperty(t.Particles.Arcade.Emitter.prototype, "lifespanOutput", {
            get: function() {
                return (0 === this.lifespan ? 1 / 0 : this.lifespan) * this._flowQuantity / this.frequency
            }
        }), Object.defineProperty(t.Particles.Arcade.Emitter.prototype, "remainder", {
            get: function() {
                return this.maxParticles - this.lifespanOutput
            }
        }), t.Weapon = function(e, i) {
            t.Plugin.call(this, e, i), this.bullets = null, this.autoExpandBulletsGroup = !1, this.autofire = !1, this.shots = 0, this.fireLimit = 0, this.fireRate = 100, this.fireRateVariance = 0, this.fireFrom = new t.Rectangle(0, 0, 1, 1), this.fireAngle = t.ANGLE_UP, this.bulletInheritSpriteSpeed = !1, this.bulletAnimation = "", this.bulletFrameRandom = !1, this.bulletFrameCycle = !1, this.bulletWorldWrap = !1, this.bulletWorldWrapPadding = 0, this.bulletAngleOffset = 0, this.bulletAngleVariance = 0, this.bulletSpeed = 200, this.bulletSpeedVariance = 0, this.bulletLifespan = 0, this.bulletKillDistance = 0, this.bulletGravity = new t.Point(0, 0), this.bulletRotateToVelocity = !1, this.bulletKey = "", this.bulletFrame = "", this._bulletClass = t.Bullet, this._bulletCollideWorldBounds = !1, this._bulletKillType = t.Weapon.KILL_WORLD_BOUNDS, this._data = {
                customBody: !1,
                width: 0,
                height: 0,
                offsetX: 0,
                offsetY: 0
            }, this.bounds = new t.Rectangle, this.bulletBounds = e.world.bounds, this.bulletFrames = [], this.bulletFrameIndex = 0, this.anims = {}, this.onFire = new t.Signal, this.onKill = new t.Signal, this.onFireLimit = new t.Signal, this.trackedSprite = null, this.trackedPointer = null, this.multiFire = !1, this._hasFired = !1, this.trackRotation = !1, this.trackOffset = new t.Point, this._nextFire = 0, this._tempNextFire = 0, this._rotatedPoint = new t.Point
        }, t.Weapon.prototype = Object.create(t.Plugin.prototype), t.Weapon.prototype.constructor = t.Weapon, t.Weapon.KILL_NEVER = 0, t.Weapon.KILL_LIFESPAN = 1, t.Weapon.KILL_DISTANCE = 2, t.Weapon.KILL_WEAPON_BOUNDS = 3, t.Weapon.KILL_CAMERA_BOUNDS = 4, t.Weapon.KILL_WORLD_BOUNDS = 5, t.Weapon.KILL_STATIC_BOUNDS = 6, t.Weapon.prototype.createBullets = function(e, i, s, n) {
            return void 0 === e && (e = 1), void 0 === n && (n = this.game.world), this.bullets && !this.bullets.game && (this.bullets = null), this.bullets || (this.bullets = this.game.add.physicsGroup(t.Physics.ARCADE, n), this.bullets.classType = this._bulletClass), 0 !== e && (-1 === e && (this.autoExpandBulletsGroup = !0, e = 1), this.bullets.createMultiple(e, i, s), this.bullets.setAll("data.bulletManager", this), this.bulletKey = i, this.bulletFrame = s), this
        }, t.Weapon.prototype.forEach = function(t, e) {
            return this.bullets.forEachExists(t, e, arguments), this
        }, t.Weapon.prototype.pauseAll = function() {
            return this.bullets.setAll("body.enable", !1), this
        }, t.Weapon.prototype.resumeAll = function() {
            return this.bullets.setAll("body.enable", !0), this
        }, t.Weapon.prototype.killAll = function() {
            return this.bullets.callAllExists("kill", !0), this.bullets.setAll("body.enable", !0), this
        }, t.Weapon.prototype.resetShots = function(t) {
            return this.shots = 0, void 0 !== t && (this.fireLimit = t), this
        }, t.Weapon.prototype.destroy = function() {
            this.parent.remove(this, !1), this.bullets.destroy(), this.game = null, this.parent = null, this.active = !1, this.visible = !1
        }, t.Weapon.prototype.update = function() {
            this._bulletKillType === t.Weapon.KILL_WEAPON_BOUNDS && (this.trackedSprite ? (this.trackedSprite.updateTransform(), this.bounds.centerOn(this.trackedSprite.worldPosition.x, this.trackedSprite.worldPosition.y)) : this.trackedPointer && this.bounds.centerOn(this.trackedPointer.worldX, this.trackedPointer.worldY)), this.autofire && this.fire()
        }, t.Weapon.prototype.postRender = function() {
            this.multiFire && this._hasFired && (this._hasFired = !1, this._nextFire = this._tempNextFire)
        }, t.Weapon.prototype.trackSprite = function(t, e, i, s) {
            return void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = !1), this.trackedPointer = null, this.trackedSprite = t, this.trackRotation = s, this.trackOffset.set(e, i), this
        }, t.Weapon.prototype.trackPointer = function(t, e, i) {
            return void 0 === t && (t = this.game.input.activePointer), void 0 === e && (e = 0), void 0 === i && (i = 0), this.trackedPointer = t, this.trackedSprite = null, this.trackRotation = !1, this.trackOffset.set(e, i), this
        }, t.Weapon.prototype.fireMany = function(t, e) {
            this.multiFire = !0;
            var i = [],
                s = this;
            return e || this.trackedSprite || this.trackedPointer ? t.forEach(function(t) {
                i.push(s.fire(e, null, null, t.x, t.y))
            }) : t.forEach(function(t) {
                i.push(s.fire(t))
            }), i
        }, t.Weapon.prototype.fireOffset = function(t, e) {
            return void 0 === t && (t = 0), void 0 === e && (e = 0), this.fire(null, null, null, t, e)
        }, t.Weapon.prototype.fire = function(e, i, s, n, r) {
            if (void 0 === i && (i = null), void 0 === s && (s = null), this.game.time.now < this._nextFire || this.fireLimit > 0 && this.shots === this.fireLimit) return null;
            var o = this.bulletSpeed;
            0 !== this.bulletSpeedVariance && (o += t.Math.between(-this.bulletSpeedVariance, this.bulletSpeedVariance)), e ? this.fireFrom.width > 1 ? this.fireFrom.centerOn(e.x, e.y) : (this.fireFrom.x = e.x, this.fireFrom.y = e.y) : this.trackedSprite ? (this.trackRotation ? (this._rotatedPoint.set(this.trackedSprite.world.x + this.trackOffset.x, this.trackedSprite.world.y + this.trackOffset.y), this._rotatedPoint.rotate(this.trackedSprite.world.x, this.trackedSprite.world.y, this.trackedSprite.worldRotation), this.fireFrom.width > 1 ? this.fireFrom.centerOn(this._rotatedPoint.x, this._rotatedPoint.y) : (this.fireFrom.x = this._rotatedPoint.x, this.fireFrom.y = this._rotatedPoint.y)) : this.fireFrom.width > 1 ? this.fireFrom.centerOn(this.trackedSprite.world.x + this.trackOffset.x, this.trackedSprite.world.y + this.trackOffset.y) : (this.fireFrom.x = this.trackedSprite.world.x + this.trackOffset.x, this.fireFrom.y = this.trackedSprite.world.y + this.trackOffset.y), this.bulletInheritSpriteSpeed && (o += this.trackedSprite.body.speed)) : this.trackedPointer && (this.fireFrom.width > 1 ? this.fireFrom.centerOn(this.trackedPointer.world.x + this.trackOffset.x, this.trackedPointer.world.y + this.trackOffset.y) : (this.fireFrom.x = this.trackedPointer.world.x + this.trackOffset.x, this.fireFrom.y = this.trackedPointer.world.y + this.trackOffset.y)), void 0 !== n && (this.fireFrom.x += n), void 0 !== r && (this.fireFrom.y += r);
            var a = this.fireFrom.width > 1 ? this.fireFrom.randomX : this.fireFrom.x,
                h = this.fireFrom.height > 1 ? this.fireFrom.randomY : this.fireFrom.y,
                l = this.trackRotation ? this.trackedSprite.angle : this.fireAngle;
            null !== i && null !== s && (l = this.game.math.radToDeg(Math.atan2(s - h, i - a))), 0 !== this.bulletAngleVariance && (l += t.Math.between(-this.bulletAngleVariance, this.bulletAngleVariance));
            var c = 0,
                u = 0;
            0 === l || 180 === l ? c = Math.cos(this.game.math.degToRad(l)) * o : 90 === l || 270 === l ? u = Math.sin(this.game.math.degToRad(l)) * o : (c = Math.cos(this.game.math.degToRad(l)) * o, u = Math.sin(this.game.math.degToRad(l)) * o);
            var d = null;
            if (this.autoExpandBulletsGroup ? (d = this.bullets.getFirstExists(!1, !0, a, h, this.bulletKey, this.bulletFrame)).data.bulletManager = this : d = this.bullets.getFirstExists(!1), d) {
                if (d.reset(a, h), d.data.fromX = a, d.data.fromY = h, d.data.killType = this.bulletKillType, d.data.killDistance = this.bulletKillDistance, d.data.rotateToVelocity = this.bulletRotateToVelocity, this.bulletKillType === t.Weapon.KILL_LIFESPAN && (d.lifespan = this.bulletLifespan), d.angle = l + this.bulletAngleOffset, "" !== this.bulletAnimation) {
                    if (null === d.animations.getAnimation(this.bulletAnimation)) {
                        var p = this.anims[this.bulletAnimation];
                        d.animations.add(p.name, p.frames, p.frameRate, p.loop, p.useNumericIndex)
                    }
                    d.animations.play(this.bulletAnimation)
                } else this.bulletFrameCycle ? (d.frame = this.bulletFrames[this.bulletFrameIndex], ++this.bulletFrameIndex >= this.bulletFrames.length && (this.bulletFrameIndex = 0)) : this.bulletFrameRandom && (d.frame = this.bulletFrames[Math.floor(Math.random() * this.bulletFrames.length)]);
                d.data.bodyDirty && (this._data.customBody && d.body.setSize(this._data.width, this._data.height, this._data.offsetX, this._data.offsetY), d.body.collideWorldBounds = this.bulletCollideWorldBounds, d.data.bodyDirty = !1), d.body.velocity.set(c, u), d.body.gravity.set(this.bulletGravity.x, this.bulletGravity.y);
                var f = 0;
                if (0 !== this.bulletSpeedVariance) {
                    var g = this.fireRate;
                    (g += t.Math.between(-this.fireRateVariance, this.fireRateVariance)) < 0 && (g = 0), f = this.game.time.now + g
                } else f = this.game.time.now + this.fireRate;
                this.multiFire ? this._hasFired || (this._hasFired = !0, this._tempNextFire = f, this.shots++) : (this._nextFire = f, this.shots++), this.onFire.dispatch(d, this, o), this.fireLimit > 0 && this.shots === this.fireLimit && this.onFireLimit.dispatch(this, this.fireLimit)
            }
            return d
        }, t.Weapon.prototype.fireAtPointer = function(t) {
            return void 0 === t && (t = this.game.input.activePointer), this.fire(null, t.worldX, t.worldY)
        }, t.Weapon.prototype.fireAtSprite = function(t) {
            return this.fire(null, t.world.x, t.world.y)
        }, t.Weapon.prototype.fireAtXY = function(t, e) {
            return this.fire(null, t, e)
        }, t.Weapon.prototype.setBulletBodyOffset = function(t, e, i, s) {
            return void 0 === i && (i = 0), void 0 === s && (s = 0), this._data.customBody = !0, this._data.width = t, this._data.height = e, this._data.offsetX = i, this._data.offsetY = s, this.bullets.callAll("body.setSize", "body", t, e, i, s), this.bullets.setAll("data.bodyDirty", !1), this
        }, t.Weapon.prototype.setBulletFrames = function(e, i, s, n) {
            return void 0 === s && (s = !0), void 0 === n && (n = !1), this.bulletFrames = t.ArrayUtils.numberArray(e, i), this.bulletFrameIndex = 0, this.bulletFrameCycle = s, this.bulletFrameRandom = n, this
        }, t.Weapon.prototype.addBulletAnimation = function(t, e, i, s, n) {
            return this.anims[t] = {
                name: t,
                frames: e,
                frameRate: i,
                loop: s,
                useNumericIndex: n
            }, this.bullets.callAll("animations.add", "animations", t, e, i, s, n), this.bulletAnimation = t, this
        }, t.Weapon.prototype.debug = function(t, e, i) {
            void 0 === t && (t = 16), void 0 === e && (e = 32), void 0 === i && (i = !1), this.game.debug.text("Weapon Plugin", t, e), this.game.debug.text("Bullets Alive: " + this.bullets.total + " - Total: " + this.bullets.length, t, e + 24), i && this.bullets.forEachExists(this.game.debug.body, this.game.debug, "rgba(255, 0, 255, 0.8)")
        }, Object.defineProperty(t.Weapon.prototype, "bulletClass", {
            get: function() {
                return this._bulletClass
            },
            set: function(t) {
                this._bulletClass = t, this.bullets && (this.bullets.classType = this._bulletClass)
            }
        }), Object.defineProperty(t.Weapon.prototype, "bulletKillType", {
            get: function() {
                return this._bulletKillType
            },
            set: function(e) {
                switch (e) {
                    case t.Weapon.KILL_STATIC_BOUNDS:
                    case t.Weapon.KILL_WEAPON_BOUNDS:
                        this.bulletBounds = this.bounds;
                        break;
                    case t.Weapon.KILL_CAMERA_BOUNDS:
                        this.bulletBounds = this.game.camera.view;
                        break;
                    case t.Weapon.KILL_WORLD_BOUNDS:
                        this.bulletBounds = this.game.world.bounds
                }
                this._bulletKillType = e
            }
        }), Object.defineProperty(t.Weapon.prototype, "bulletCollideWorldBounds", {
            get: function() {
                return this._bulletCollideWorldBounds
            },
            set: function(t) {
                this._bulletCollideWorldBounds = t, this.bullets.setAll("body.collideWorldBounds", t), this.bullets.setAll("data.bodyDirty", !1)
            }
        }), Object.defineProperty(t.Weapon.prototype, "x", {
            get: function() {
                return this.fireFrom.x
            },
            set: function(t) {
                this.fireFrom.x = t
            }
        }), Object.defineProperty(t.Weapon.prototype, "y", {
            get: function() {
                return this.fireFrom.y
            },
            set: function(t) {
                this.fireFrom.y = t
            }
        }), t.Bullet = function(e, i, s, n, r) {
            t.Sprite.call(this, e, i, s, n, r), this.anchor.set(.5), this.data = {
                bulletManager: null,
                fromX: 0,
                fromY: 0,
                bodyDirty: !0,
                rotateToVelocity: !1,
                killType: 0,
                killDistance: 0
            }
        }, t.Bullet.prototype = Object.create(t.Sprite.prototype), t.Bullet.prototype.constructor = t.Bullet, t.Bullet.prototype.kill = function() {
            return this.alive = !1, this.exists = !1, this.visible = !1, this.data.bulletManager.onKill.dispatch(this), this
        }, t.Bullet.prototype.update = function() {
            this.exists && (this.data.killType > t.Weapon.KILL_LIFESPAN && (this.data.killType === t.Weapon.KILL_DISTANCE ? this.game.physics.arcade.distanceToXY(this, this.data.fromX, this.data.fromY, !0) > this.data.killDistance && this.kill() : this.data.bulletManager.bulletBounds.intersects(this) || this.kill()), this.data.rotateToVelocity && (this.rotation = this.body.velocity.atan()), this.data.bulletManager.bulletWorldWrap && this.game.world.wrap(this, this.data.bulletManager.bulletWorldWrapPadding))
        }, t.Video = function(e, i, s) {
            if (void 0 === i && (i = null), void 0 === s && (s = null), this.game = e, this.key = i, this.width = 0, this.height = 0, this.type = t.VIDEO, this.disableTextureUpload = !1, this.touchLocked = !1, this.onPlay = new t.Signal, this.onChangeSource = new t.Signal, this.onComplete = new t.Signal, this.onAccess = new t.Signal, this.onError = new t.Signal, this.onTimeout = new t.Signal, this.onTouchUnlock = new t.Signal, this.playWhenUnlocked = !0, this.timeout = 15e3, this._timeOutID = null, this.video = null, this.videoStream = null, this.isStreaming = !1, this.retryLimit = 20, this.retry = 0, this.retryInterval = 500, this._retryID = null, this._codeMuted = !1, this._muted = !1, this._codePaused = !1, this._paused = !1, this._pending = !1, this._pendingChangeSource = !1, this._autoplay = !1, this._endCallback = null, this._playCallback = null, i && this.game.cache.checkVideoKey(i)) {
                var n = this.game.cache.getVideo(i);
                n.isBlob ? this.createVideoFromBlob(n.data) : this.video = n.data, this.width = this.video.videoWidth, this.height = this.video.videoHeight
            } else s && this.createVideoFromURL(s, !1);
            this.video && !s ? (this.baseTexture = new PIXI.BaseTexture(this.video, null, this.game.resolution), this.baseTexture.forceLoaded(this.width, this.height)) : (this.baseTexture = new PIXI.BaseTexture(t.Cache.DEFAULT.baseTexture.source, null, this.game.resolution), this.baseTexture.forceLoaded(this.width, this.height)), this.texture = new PIXI.Texture(this.baseTexture), this.textureFrame = new t.Frame(0, 0, 0, this.width, this.height, "video"), this.texture.setFrame(this.textureFrame), this.texture.valid = !1, null !== i && this.video && (this.texture.valid = this.video.canplay), this.snapshot = null, t.BitmapData && (this.snapshot = new t.BitmapData(this.game, "", this.width, this.height)), this.game.device.needsTouchUnlock() ? this.setTouchLock() : n && (n.locked = !1)
        }, t.Video.prototype = {
            connectToMediaStream: function(t, e) {
                return t && e && (this.video = t, this.videoStream = e, this.isStreaming = !0, this.baseTexture.source = this.video, this.updateTexture(null, this.video.videoWidth, this.video.videoHeight), this.onAccess.dispatch(this)), this
            },
            startMediaStream: function(t, e, i) {
                if (void 0 === t && (t = !1), void 0 === e && (e = null), void 0 === i && (i = null), !this.game.device.getUserMedia) return this.onError.dispatch(this, "No getUserMedia"), !1;
                null !== this.videoStream && (this.videoStream.active ? this.videoStream.active = !1 : this.videoStream.stop()), this.removeVideoElement(), this.video = document.createElement("video"), this.video.setAttribute("autoplay", "autoplay"), this.video.setAttribute("playsinline", "playsinline"), null !== e && (this.video.width = e), null !== i && (this.video.height = i), this._timeOutID = window.setTimeout(this.getUserMediaTimeout.bind(this), this.timeout);
                try {
                    navigator.getUserMedia({
                        audio: t,
                        video: !0
                    }, this.getUserMediaSuccess.bind(this), this.getUserMediaError.bind(this))
                } catch (t) {
                    this.getUserMediaError(t)
                }
                return this
            },
            getUserMediaTimeout: function() {
                clearTimeout(this._timeOutID), this.onTimeout.dispatch(this)
            },
            getUserMediaError: function(t) {
                clearTimeout(this._timeOutID), this.onError.dispatch(this, t)
            },
            getUserMediaSuccess: function(t) {
                clearTimeout(this._timeOutID), this.videoStream = t, void 0 !== this.video.mozSrcObject ? this.video.mozSrcObject = t : void 0 !== this.video.srcObject ? this.video.srcObject = t : this.video.src = window.URL && window.URL.createObjectURL(t) || t;
                var e = this;
                this.video.onloadeddata = function() {
                    var t = 10;
                    ! function i() {
                        if (t > 0)
                            if (e.video.videoWidth > 0) {
                                var s = e.video.videoWidth,
                                    n = e.video.videoHeight;
                                isNaN(e.video.videoHeight) && (n = s / (4 / 3)), e.video.play(), e.isStreaming = !0, e.baseTexture.source = e.video, e.updateTexture(null, s, n), e.onAccess.dispatch(e)
                            } else window.setTimeout(i, 500);
                        else console.warn("Unable to connect to video stream. Webcam error?");
                        t--
                    }()
                }
            },
            createVideoFromBlob: function(t) {
                var e = this;
                return this.video = document.createElement("video"), this.video.controls = !1, this.video.setAttribute("autoplay", "autoplay"), this.video.setAttribute("playsinline", "playsinline"), this.video.addEventListener("loadeddata", function(t) {
                    e.updateTexture(t)
                }, !0), this.video.src = window.URL.createObjectURL(t), this.video.canplay = !0, this
            },
            createVideoFromURL: function(t, e) {
                return void 0 === e && (e = !1), this.texture && (this.texture.valid = !1), this.video = document.createElement("video"), this.video.controls = !1, e && this.video.setAttribute("autoplay", "autoplay"), this.video.setAttribute("playsinline", "playsinline"), this.video.src = t, this.video.canplay = !0, this.video.load(), this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval), this.key = t, this
            },
            updateTexture: function(t, e, i) {
                var s = !1;
                null != e || (e = this.video.videoWidth, s = !0), null != i || (i = this.video.videoHeight), this.width = e, this.height = i, this.baseTexture.source !== this.video && (this.baseTexture.source = this.video), this.baseTexture.forceLoaded(e, i), this.texture.frame.resize(e, i), this.texture.width = e, this.texture.height = i, this.texture.valid = !0, this.snapshot && this.snapshot.resize(e, i), s && null !== this.key && (this.onChangeSource.dispatch(this, e, i), this._autoplay && (this.video.play(), this.onPlay.dispatch(this, this.loop, this.playbackRate)))
            },
            complete: function() {
                this.onComplete.dispatch(this)
            },
            play: function(t, e) {
                return this._pendingChangeSource ? this : (void 0 === t && (t = !1), void 0 === e && (e = 1), this.game.sound.onMute && (this.game.sound.onMute.add(this.setMute, this), this.game.sound.onUnMute.add(this.unsetMute, this), this.game.sound.mute && this.setMute()), this.game.onPause.add(this.setPause, this), this.game.onResume.add(this.setResume, this), this._endCallback = this.complete.bind(this), this.video.addEventListener("ended", this._endCallback, !0), this.video.addEventListener("webkitendfullscreen", this._endCallback, !0), this.video.loop = t ? "loop" : "", this.video.playbackRate = e, this.touchLocked ? this._pending = !0 : (this._pending = !1, null !== this.key && (4 !== this.video.readyState ? (this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval)) : (this._playCallback = this.playHandler.bind(this), this.video.addEventListener("playing", this._playCallback, !0))), this.video.play(), this.onPlay.dispatch(this, t, e)), this)
            },
            playHandler: function() {
                this.video.removeEventListener("playing", this._playCallback, !0), this.updateTexture()
            },
            stop: function() {
                return this.game.sound.onMute && (this.game.sound.onMute.remove(this.setMute, this), this.game.sound.onUnMute.remove(this.unsetMute, this)), this.game.onPause.remove(this.setPause, this), this.game.onResume.remove(this.setResume, this), this.isStreaming ? (this.video.mozSrcObject ? (this.video.mozSrcObject.stop(), this.video.src = null) : this.video.srcObject ? (this.video.srcObject.stop(), this.video.src = null) : (this.video.src = "", this.videoStream.active ? this.videoStream.active = !1 : this.videoStream.getTracks ? this.videoStream.getTracks().forEach(function(t) {
                    t.stop()
                }) : this.videoStream.stop()), this.videoStream = null, this.isStreaming = !1) : (this.video.removeEventListener("ended", this._endCallback, !0), this.video.removeEventListener("webkitendfullscreen", this._endCallback, !0), this.video.removeEventListener("playing", this._playCallback, !0), this.touchLocked ? this._pending = !1 : this.video.pause()), this
            },
            add: function(t) {
                if (Array.isArray(t))
                    for (var e = 0; e < t.length; e++) t[e].loadTexture && t[e].loadTexture(this);
                else t.loadTexture(this);
                return this
            },
            addToWorld: function(t, e, i, s, n, r) {
                n = n || 1, r = r || 1;
                var o = this.game.add.image(t, e, this);
                return o.anchor.set(i, s), o.scale.set(n, r), o
            },
            render: function() {
                !this.disableTextureUpload && this.playing && this.baseTexture.dirty()
            },
            setMute: function() {
                this._muted || (this._muted = !0, this.video.muted = !0)
            },
            unsetMute: function() {
                this._muted && !this._codeMuted && (this._muted = !1, this.video.muted = !1)
            },
            setPause: function() {
                this._paused || this.touchLocked || (this._paused = !0, this.video.pause())
            },
            setResume: function() {
                !this._paused || this._codePaused || this.touchLocked || (this._paused = !1, this.video.ended || this.video.play())
            },
            changeSource: function(t, e) {
                return void 0 === e && (e = !0), this.texture.valid = !1, this.video.pause(), this._pendingChangeSource = !0, this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval), this.video.src = t, this.video.load(), this._autoplay = e, e || (this.paused = !0), this
            },
            checkVideoProgress: function() {
                4 === this.video.readyState ? (this._pendingChangeSource = !1, this.updateTexture()) : --this.retry > 0 ? this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval) : console.warn("Phaser.Video: Unable to start downloading video in time", this.isStreaming)
            },
            setTouchLock: function() {
                this.game.input.addTouchLockCallback(this.unlock, this, !0), this.touchLocked = !0
            },
            unlock: function() {
                if (this.touchLocked = !1, this.playWhenUnlocked && (this.video.play(), this.onPlay.dispatch(this, this.loop, this.playbackRate)), this.key) {
                    var t = this.game.cache.getVideo(this.key);
                    t && !t.isBlob && (t.locked = !1)
                }
                return this.onTouchUnlock.dispatch(this), !0
            },
            grab: function(t, e, i) {
                if (void 0 === t && (t = !1), void 0 === e && (e = 1), void 0 === i && (i = null), null !== this.snapshot) return t && this.snapshot.cls(), this.snapshot.copy(this.video, 0, 0, this.width, this.height, 0, 0, this.width, this.height, 0, 0, 0, 1, 1, e, i), this.snapshot;
                console.warn("Video.grab cannot run because Phaser.BitmapData is unavailable")
            },
            removeVideoElement: function() {
                if (this.video) {
                    for (this.video.parentNode && this.video.parentNode.removeChild(this.video); this.video.hasChildNodes();) this.video.removeChild(this.video.firstChild);
                    this.video.removeAttribute("autoplay"), this.video.removeAttribute("src"), this.video = null
                }
            },
            destroy: function() {
                this.stop(), this.removeVideoElement(), this.touchLocked && this.game.input.removeTouchLockCallback(this.unlock, this), this._retryID && window.clearTimeout(this._retryID)
            }
        }, Object.defineProperty(t.Video.prototype, "currentTime", {
            get: function() {
                return this.video ? this.video.currentTime : 0
            },
            set: function(t) {
                this.video.currentTime = t
            }
        }), Object.defineProperty(t.Video.prototype, "duration", {
            get: function() {
                return this.video ? this.video.duration : 0
            }
        }), Object.defineProperty(t.Video.prototype, "progress", {
            get: function() {
                return this.video ? this.video.currentTime / this.video.duration : 0
            }
        }), Object.defineProperty(t.Video.prototype, "mute", {
            get: function() {
                return this._muted
            },
            set: function(t) {
                if (t = t || null) {
                    if (this._muted) return;
                    this._codeMuted = !0, this.setMute()
                } else {
                    if (!this._muted) return;
                    this._codeMuted = !1, this.unsetMute()
                }
            }
        }), Object.defineProperty(t.Video.prototype, "paused", {
            get: function() {
                return this._paused
            },
            set: function(t) {
                if (t = t || null, !this.touchLocked)
                    if (t) {
                        if (this._paused) return;
                        this._codePaused = !0, this.setPause()
                    } else {
                        if (!this._paused) return;
                        this._codePaused = !1, this.setResume()
                    }
            }
        }), Object.defineProperty(t.Video.prototype, "volume", {
            get: function() {
                return this.video ? this.video.volume : 1
            },
            set: function(t) {
                t < 0 ? t = 0 : t > 1 && (t = 1), this.video && (this.video.volume = t)
            }
        }), Object.defineProperty(t.Video.prototype, "playbackRate", {
            get: function() {
                return this.video ? this.video.playbackRate : 1
            },
            set: function(t) {
                this.video && (this.video.playbackRate = t)
            }
        }), Object.defineProperty(t.Video.prototype, "loop", {
            get: function() {
                return !!this.video && this.video.loop
            },
            set: function(t) {
                t && this.video ? this.video.loop = "loop" : this.video && (this.video.loop = "")
            }
        }), Object.defineProperty(t.Video.prototype, "playing", {
            get: function() {
                return !(!this.video || this.video.paused && this.video.ended)
            }
        }), t.Video.prototype.constructor = t.Video, void 0 === PIXI.blendModes && (PIXI.blendModes = t.blendModes), void 0 === PIXI.scaleModes && (PIXI.scaleModes = t.scaleModes), void 0 === PIXI.Texture.emptyTexture && (PIXI.Texture.emptyTexture = new PIXI.Texture(new PIXI.BaseTexture)), void 0 === PIXI.DisplayObject._tempMatrix && (PIXI.DisplayObject._tempMatrix = new t.Matrix), PIXI.TextureSilentFail = !0, PIXI.canUseNewCanvasBlendModes = function() {
            return t.Device.canUseMultiply
        }, "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = t), exports.Phaser = t) : "undefined" != typeof define && define.amd ? define("Phaser", this.Phaser = t) : this.Phaser = t, t
    }.call(this);
const enable_rewarded_videos = !0,
    difficulty_level = 2,
    bomb_powerup_basic_price = 15,
    bomb_powerup_price_step = 5,
    lightning_powerup_basic_price = 25,
    lightning_powerup_price_step = 5,
    get_stars_button_cooldown = 300,
    get_stars_button_basic_reward = 5,
    get_stars_button_reward_step = 5,
    results_watch_video_reward = 10;
"use strict";

function _typeof(e) {
    return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}

function _get(e, t, i) {
    return (_get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(e, t, i) {
        var n = _superPropBase(e, t);
        if (n) {
            var a = Object.getOwnPropertyDescriptor(n, t);
            return a.get ? a.get.call(i) : a.value
        }
    })(e, t, i || e)
}

function _superPropBase(e, t) {
    for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = _getPrototypeOf(e)););
    return e
}

function _possibleConstructorReturn(e, t) {
    return !t || "object" !== _typeof(t) && "function" != typeof t ? _assertThisInitialized(e) : t
}

function _getPrototypeOf(e) {
    return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
        return e.__proto__ || Object.getPrototypeOf(e)
    })(e)
}

function _assertThisInitialized(e) {
    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e
}

function _inherits(e, t) {
    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, {
        constructor: {
            value: e,
            writable: !0,
            configurable: !0
        }
    }), t && _setPrototypeOf(e, t)
}

function _setPrototypeOf(e, t) {
    return (_setPrototypeOf = Object.setPrototypeOf || function(e, t) {
        return e.__proto__ = t, e
    })(e, t)
}

function _classCallCheck(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
}

function _defineProperties(e, t) {
    for (var i = 0; i < t.length; i++) {
        var n = t[i];
        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
    }
}

function _createClass(e, t, i) {
    return t && _defineProperties(e.prototype, t), i && _defineProperties(e, i), e
}
var game;
! function(e) {
    ! function(e) {
        e[e.PORTRAIT = 0] = "PORTRAIT", e[e.SQUARED = 1] = "SQUARED", e[e.LANDSCAPE = 2] = "LANDSCAPE"
    }(e.LayoutType || (e.LayoutType = {}))
}(BlockPuzzle || (BlockPuzzle = {})),
function(e) {
    var t = function() {
        function t() {
            _classCallCheck(this, t)
        }
        return _createClass(t, null, [{
            key: "update",
            value: function(t, i) {
                this.WIDTH = t, this.HEIGHT = i;
                var n = this.getScreenRatio();
                n <= this.PORTRAIT_RATIO ? (this.LAYOUT = e.LayoutType.PORTRAIT, this.SCALE_X = this.SCALE_Y = t / this.ORIGINAL_WIDTH, this.UPSCALE_FACTOR = 1) : n >= this.LANDSCAPE_RATIO ? (this.LAYOUT = e.LayoutType.LANDSCAPE, this.UPSCALE_FACTOR = e.App.instance.device.desktop ? 1 : Math.pow(n / this.ORIGINAL_RATIO, .35), this.SCALE_X = this.SCALE_Y = i / this.ORIGINAL_HEIGHT * this.UPSCALE_FACTOR) : (this.LAYOUT = e.LayoutType.SQUARED, this.UPSCALE_FACTOR = e.App.instance.device.desktop ? 1 : Math.pow(n / this.ORIGINAL_RATIO, .55), this.SCALE_X = this.SCALE_Y = i / this.ORIGINAL_HEIGHT * this.UPSCALE_FACTOR), e.App.instance.scale.scaleMode != Phaser.ScaleManager.RESIZE && e.App.instance.state.getCurrentState().resize(e.App.instance.width, e.App.instance.height), e.BackgroundManager.instance.resize(), e.WindowManager.instance.resize(), e.TransitionScreen.instance.resize()
            }
        }, {
            key: "getLayout",
            value: function() {
                return this.LAYOUT
            }
        }, {
            key: "isLandscape",
            value: function() {
                return this.getLayout() === e.LayoutType.LANDSCAPE
            }
        }, {
            key: "isPortrait",
            value: function() {
                return this.getLayout() === e.LayoutType.PORTRAIT
            }
        }, {
            key: "isSquared",
            value: function() {
                return this.getLayout() === e.LayoutType.SQUARED
            }
        }, {
            key: "getScaleMode",
            value: function() {
                return e.Settings.USE_HIGH_RESOLUTION_SCALING ? Phaser.ScaleManager.USER_SCALE : Phaser.ScaleManager.RESIZE
            }
        }, {
            key: "getPixelRatio",
            value: function() {
                return e.App.instance.device.desktop || !e.Settings.USE_HIGH_RESOLUTION_SCALING ? 1 : Math.min(e.App.instance.device.pixelRatio, e.Settings.PIXEL_RATIO_MAX_THRESHOLD)
            }
        }, {
            key: "getScreenRatio",
            value: function() {
                return this.WIDTH / this.HEIGHT
            }
        }]), t
    }();
    t.PORTRAIT_RATIO = .75, t.LANDSCAPE_RATIO = 1366 / 960, t.ORIGINAL_WIDTH = 640, t.ORIGINAL_HEIGHT = 960, t.WIDTH = 640, t.HEIGHT = 960, t.LAYOUT = e.LayoutType.PORTRAIT, t.SCALE_X = 1, t.SCALE_Y = 1, t.UPSCALE_FACTOR = 1, t.ORIGINAL_RATIO = t.ORIGINAL_WIDTH / t.ORIGINAL_HEIGHT, e.CustomScaleManager = t
}(BlockPuzzle || (BlockPuzzle = {})),
function(e) {
    var t = function() {
        function e() {
            _classCallCheck(this, e)
        }
        return _createClass(e, null, [{
            key: "detectRenderMode",
            value: function() {
                var e = window.navigator.userAgent.indexOf("MSIE ") > 0 || window.navigator.userAgent.indexOf("Trident/") > 0,
                    t = navigator.userAgent.toLowerCase().indexOf("firefox") > -1,
                    i = window.navigator.userAgent.indexOf("iPhone ") > -1;
                return e || t || i ? Phaser.CANVAS : Phaser.AUTO
            }
        }]), e
    }();
    e.RenderUtils = t
}(BlockPuzzle || (BlockPuzzle = {})),
function(e) {
    var t = function e() {
        _classCallCheck(this, e)
    };
    t.USE_HIGH_RESOLUTION_SCALING = !0, t.PIXEL_RATIO_MAX_THRESHOLD = 3, t.DEFAULT_FONT_FAMILY = "Kanit", t.WINDOW_BACKGROUND_ALPHA = .975, t.REVIVE_WINDOW_TIMER = 60, t.RESULTS_WINDOW_TIMER = 85, t.RESULTS_WINDOW_TIMER_WITHOUT_REVIVE = 110, t.PRELOADER_ATLAS = "preloader", t.GAME_ATLAS = "assets", t.ANIMATION_ATLAS = "animations", t.BOARD_ROWS = 8, t.BOARD_COLS = 8, t.CELL_HEIGHT = t.CELL_WIDTH = 75, t.FIGURE_VIEW_DRAGGING_DELTA = -160, t.FIGURE_VIEW_SPACING = 5, t.DEFAULT_FIGURE_SCALE = .4, t.DRAGGING_FIGURE_SCALE = .88, t.FINAL_FIGURE_SCALE = 1, t.FIGURE_APPEARING_DURATION = 350, t.FIGURE_APPEARING_DELAY = 120, t.FIGURE_RETURNING_SPEED = 2e3, t.FIGURE_PICK_UP_TWEEN_DURATION = 70, t.FIGURE_DISPOSING_TWEEN_DURATION = 250, t.NOT_APPLICABLE_FIGURE_APLHA = .475, t.BLOCK_DESTROY_ANIMATION_DELAY = 65, t.BLOCK_DISAPPEARING_DURATION = 180, t.PICK_RANDOM_EXPLOSION_STARTING_POINT = !0, t.SET_THE_SAME_EXPLOSION_COLOR_FOR_ALL_THE_EXPLODING_CELLS = !0, t.STAR_SHINING_TWEEN_DURATION = 1400, t.STARRED_BLOCK_APPEARING_TWEEN_DURATION = 750, t.BLOCK_DEACTIVATION_TWEEN_DURATION = 400, t.BLOCK_ACTIVATION_TWEEN_DURATION = 250, t.DIFFICULTY_FACTOR = difficulty_level, t.POWERUP_USAGE_COUNTDOWN_WHEN_NO_MOVES_LEFT = 6e3, t.BOMB_PRICE = bomb_powerup_basic_price, t.BOMB_PRICE_STEP = bomb_powerup_price_step, t.LIGHTNING_PRICE = lightning_powerup_basic_price, t.LIGHTNING_PRICE_STEP = lightning_powerup_price_step, t.POWERUP_HIGHLIGHTING_ALPHA = .3, t.POWERUP_DRAGGING_DELTA = -100, t.LIGHTING_DELAY_BETWEEN_STRIKES = 8, t.LIGHTING_MIN_TARGETS = 3, t.LIGHTING_MAX_TARGETS = 5, t.REVIVE_TIMER_DURATION = 10500, t.BASIC_LINE_DESTROYING_REWARD = 10, t.MULTIPLIER_MILESTONES = [100, 500, 3e3, 14400, 72e3, 34e4, 15e5, 6e6, 2e7, 1e8], t.GENERATE_MAX_FIGURES_PER_ITERATION = 25, t.GENERATE_MAX_POSITIONS_FOR_EACH_FIGURE = 1, t.RESULTING_FIGURE_RANDOM_COMPRESSION_FACTOR = 1.85, t.MISTAKE_PROBABILITY_BASIC_STEP = .025, t.MISTAKE_PROBABILITY_STEP_SPEED = .005, t.MISTAKE_MAX_PROBABILITY = .1, t.MISTAKE_IMMUNITY_MIN_MOVES = 5, t.MISTAKE_IMMUNITY_MAX_MOVES = 10, t.SKIP_STARS_GENERATION_FOR_FIRST_X_MOVES = 5, t.BASIC_STAR_GENERATION_PROBABILITY = .02, t.BASIC_STAR_GENERATION_PROBABILITY_STEP = .0065, t.ADDITIONAL_SECOND_STAR_GENERATION_PROBABILITY = .01, t.ADDITIONAL_STAR_GENERATION_PROBABILITY_FOR_DESTROYING_MULTIPLE_LINES = .02, t.MAX_STAR_GENERATING_PROBABILITY = .3, t.STAR_GENERATION_DELAY = 1e3, t.MAX_STARS_ON_BOARD_SIMULTANEOUSLY = 3, t.RESULTS_DOUBLE_STARS_REWARD = results_watch_video_reward, t.GET_STARS_BUTTON_LAST_REWARD_TIMESTAMP = 0, t.GET_STARS_BUTTON_COOLDOWN = get_stars_button_cooldown, t.GET_STARS_BUTTON_ENABLED = get_stars_button_cooldown > 0, t.GET_STARS_BUTTON_REWARD_STARS_AMOUNT = get_stars_button_basic_reward, t.GET_STARS_BUTTON_REWARD_STARS_AMOUNT_STEP = get_stars_button_reward_step, t.ACHIEVEMENT_INFORMER_VISIBILITY_DURATION = 5e3, t.TUTORIAL_COMPLETED = !1, t.GAME_VERSION = "3", t.ENABLE_API = !0, t.RELEASE_BUILD = !0, t.MUSIC_ENABLED_BY_DEFAULT = !0, t.LOCAL_STORAGE_KEY = "Element_Blocks" + t.GAME_VERSION, e.Settings = t
}(BlockPuzzle || (BlockPuzzle = {})),
function(e) {
    var t = function(t) {
        function i() {
            var t;
            return _classCallCheck(this, i), t = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, i.gameConfig)), i.instance = _assertThisInitialized(t), t.state.add("Boot", e.Boot, !1), t.state.add("Preloader", e.Preloader, !1), t.state.add("Level", e.Level, !1), t.state.start("Boot"), t
        }
        return _inherits(i, Phaser.Game), _createClass(i, [{
            key: "navigateToSponsor",
            value: function() {
                e.Settings.ENABLE_API && gradle.moreGamesLink()
            }
        }, {
            key: "pauseGame",
            value: function() {
                e.SoundController.instance.pauseAudio(), this.paused = !0, gradle.event("pausing game...")
            }
        }, {
            key: "unpauseGame",
            value: function() {
                var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                !isPageVisible || adIsShowing && !t ? gradle.event("resuming game is not allowed now because ads are displaying or page isn't visible...") : (this.paused = !1, e.SoundController.instance.resumeAudio(), gradle.event("resuming game..."))
            }
        }]), i
    }();
    t.gameConfig = {
        width: e.CustomScaleManager.ORIGINAL_WIDTH,
        height: e.CustomScaleManager.ORIGINAL_HEIGHT,
        renderer: e.RenderUtils.detectRenderMode(),
        transparent: !0,
        enableDebug: !1
    }, e.App = t
}(BlockPuzzle || (BlockPuzzle = {}));
var hidden, visibilityChange, BlockPuzzle, isPageVisible = !0,
    adIsShowing = !1;

function handleVisibilityChange() {
    document[hidden] ? (isPageVisible = !1, game && !adIsShowing && game.pauseGame()) : (isPageVisible = !0, game && !adIsShowing && game.unpauseGame())
}
window.onPauseRequested = function() {
        adIsShowing = !0, game && game.pauseGame()
    }, window.onResumeRequested = function() {
        adIsShowing = !1, game && game.unpauseGame()
    }, void 0 !== document.hidden ? (hidden = "hidden", visibilityChange = "visibilitychange") : void 0 !== document.msHidden ? (hidden = "msHidden", visibilityChange = "msvisibilitychange") : void 0 !== document.webkitHidden && (hidden = "webkitHidden", visibilityChange = "webkitvisibilitychange"), void 0 === document.addEventListener || void 0 === document[hidden] ? gradle.event("Browser doesn't support the Page Visibility API.") : document.addEventListener(visibilityChange, handleVisibilityChange, !1),
    function(e) {
        var t = function() {
            function t() {
                _classCallCheck(this, t), this.onAchievementCompleted = new Phaser.Signal, this.achievementModels = [{
                    key: e.AchievementType.TOTAL_SCORES,
                    name: "Total scores reached",
                    currentValue: 0,
                    requiredValues: [35e3, 105e3, 225e3],
                    rewards: [20, 31, 52],
                    achieved: [!1, !1, !1],
                    rewardClaimed: [!1, !1, !1]
                }, {
                    key: e.AchievementType.TOTAL_STARS,
                    name: "Total stars picked up",
                    currentValue: 0,
                    requiredValues: [50, 180, 365],
                    rewards: [23, 34, 55],
                    achieved: [!1, !1, !1],
                    rewardClaimed: [!1, !1, !1]
                }, {
                    key: e.AchievementType.TOTAL_LEVEL_UPS,
                    name: "Level-ups collected",
                    currentValue: 0,
                    requiredValues: [25, 75, 150],
                    rewards: [26, 37, 58],
                    achieved: [!1, !1, !1],
                    rewardClaimed: [!1, !1, !1]
                }, {
                    key: e.AchievementType.TOTAL_GREATS,
                    name: "Great inscriptions appeared",
                    currentValue: 0,
                    requiredValues: [5, 30, 60],
                    rewards: [8, 19, 40],
                    achieved: [!1, !1, !1],
                    rewardClaimed: [!1, !1, !1]
                }, {
                    key: e.AchievementType.BOMB_EXPLOSIONS,
                    name: "Bomb explosions",
                    currentValue: 0,
                    requiredValues: [5, 20, 75],
                    rewards: [17, 28, 49],
                    achieved: [!1, !1, !1],
                    rewardClaimed: [!1, !1, !1]
                }, {
                    key: e.AchievementType.LINES_DESTROYED,
                    name: "Destroyed lines",
                    currentValue: 0,
                    requiredValues: [240, 720, 1600],
                    rewards: [14, 25, 46],
                    achieved: [!1, !1, !1],
                    rewardClaimed: [!1, !1, !1]
                }, {
                    key: e.AchievementType.BLOCKS_PLACED,
                    name: "Blocks placed at the board",
                    currentValue: 0,
                    requiredValues: [1600, 6400, 15e3],
                    rewards: [11, 22, 43],
                    achieved: [!1, !1, !1],
                    rewardClaimed: [!1, !1, !1]
                }, {
                    key: e.AchievementType.FIRE_BLOCKS_DESTROYED,
                    name: "Red blocks destroyed",
                    currentValue: 0,
                    requiredValues: [350, 1050, 2250],
                    rewards: [17, 28, 49],
                    achieved: [!1, !1, !1],
                    rewardClaimed: [!1, !1, !1]
                }, {
                    key: e.AchievementType.BEST_SCORE_REACHED,
                    name: "Best score reached",
                    currentValue: 0,
                    requiredValues: [6e3, 1e4, 16e3],
                    rewards: [5, 16, 37],
                    achieved: [!1, !1, !1],
                    rewardClaimed: [!1, !1, !1]
                }]
            }
            return _createClass(t, [{
                key: "loadAchievementsState",
                value: function(e) {
                    var t = this;
                    e.forEach(function(e) {
                        var i = t.getAchievementModel(e.key);
                        i && (i.currentValue = e.currentValue, i.achieved = e.achieved.slice(), i.rewardClaimed = e.rewardClaimed.slice())
                    })
                }
            }, {
                key: "getAchievementsStates",
                value: function() {
                    return this.achievementModels.map(function(e) {
                        return {
                            key: e.key,
                            currentValue: e.currentValue,
                            achieved: e.achieved.slice(),
                            rewardClaimed: e.rewardClaimed.slice()
                        }
                    })
                }
            }, {
                key: "saveMedalsState",
                value: function() {
                    e.LocalStorageController.instance.save()
                }
            }, {
                key: "getAchievementModel",
                value: function(e) {
                    return this.achievementModels.find(function(t) {
                        return t.key == e
                    })
                }
            }, {
                key: "addValue",
                value: function(i, n) {
                    var a = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                        s = this.getAchievementModel(i);
                    if (s) {
                        var o = t.getAchievementLevel(s);
                        s.currentValue += n, t.getAchievementLevel(s) > o && (this.onAchievementCompleted.dispatch(s), e.SoundController.instance.playAchievementClaimedSound()), a && this.saveMedalsState()
                    }
                }
            }, {
                key: "setValue",
                value: function(i, n) {
                    var a = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                        s = this.getAchievementModel(i);
                    if (s && n > s.currentValue) {
                        var o = t.getAchievementLevel(s);
                        s.currentValue = n, t.getAchievementLevel(s) > o && (this.onAchievementCompleted.dispatch(s), e.SoundController.instance.playAchievementClaimedSound()), a && this.saveMedalsState()
                    }
                }
            }, {
                key: "hasAvailableRewards",
                value: function() {
                    var e = !1;
                    return this.achievementModels.forEach(function(t) {
                        t.currentValue >= t.requiredValues[0] && !t.rewardClaimed[0] ? e = !0 : t.currentValue >= t.requiredValues[1] && !t.rewardClaimed[1] ? e = !0 : t.currentValue >= t.requiredValues[2] && !t.rewardClaimed[2] && (e = !0)
                    }), e
                }
            }], [{
                key: "getAchievementLevel",
                value: function(e) {
                    return e.currentValue >= e.requiredValues[2] ? 3 : e.currentValue >= e.requiredValues[1] ? 2 : e.currentValue >= e.requiredValues[0] ? 1 : 0
                }
            }, {
                key: "instance",
                get: function() {
                    return t._instance ? t._instance : t._instance = new t
                }
            }]), t
        }();
        t._instance = null, e.AchievementsManager = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function() {
            function t() {
                _classCallCheck(this, t)
            }
            return _createClass(t, [{
                key: "isRewardedVideoFeatureEnabled",
                value: function() {
                    return !!enable_rewarded_videos
                }
            }, {
                key: "hasRewardedVideo",
                value: function() {
                    return !!(e.Settings.ENABLE_API && this.isRewardedVideoFeatureEnabled() && gradle.hasRewardedAd) && gradle.hasRewardedAd()
                }
            }, {
                key: "showRewardedVideo",
                value: function(t) {
					if(gradle.hasRewardedAd){
						gradle.event('SHOW_VIDEO');
					}
                    t();
                }
            }, {
                key: "showAds",
                value: function(t) {
                    var i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                    gradle.event('showAd'); 
					t();
                }
            }], [{
                key: "instance",
                get: function() {
                    return t._instance ? t._instance : t._instance = new t
                }
            }]), t
        }();
        t._instance = null, e.APIUtils = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function() {
            function t() {
                _classCallCheck(this, t)
            }
            return _createClass(t, [{
                key: "initUser",
                value: function() {
                    var e = {
					  "splitTests": {
						"tutorial": false
					  },
					  "uid": "gradle_487"
					};
					//gradle.event(e);
						i = e.uid;
					e.splitTests;
					t.initialized = !0, t.USER_ID = i;
					//gradle.event("UID #", i);
                }
            }, {
                key: "startLevel",
                value: function() {
                    if (t.initialized) {
                        //gradle.event('startLevel');
                    }
                }
            }, {
                key: "finishLevel",
                value: function(i, n, a, s) {
                    if (t.initialized) {
                        var o = {
                                success: !1,
                                score: i,
                                stars: n,
                                revives: a,
                                powerups: s
                            };
                        gradle.event('finishLevel', o);
                    }
                }
            }, {
                key: "updateLevelData",
                value: function(i) {
                    if (t.initialized) {
                        gradle.event('updateLevelData', i);
                    }
                }
            }], [{
                key: "instance",
                get: function() {
                    return t._instance ? t._instance : t._instance = new t
                }
            }]), t
        }();
        t._instance = null, t.USER_ID = void 0, t.initialized = !1, e.Analytics = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i() {
                var t;
                return _classCallCheck(this, i), (t = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e.App.instance, null))).containerWidth = e.CustomScaleManager.ORIGINAL_WIDTH, t.containerHeight = e.CustomScaleManager.ORIGINAL_HEIGHT, t.leafs = [], t.isInitialized = !1, t.leafAnchors = [new Phaser.Point(1, .85), new Phaser.Point(.9, 1), new Phaser.Point(.93, 1), new Phaser.Point(.05, 1), new Phaser.Point(0, 1), new Phaser.Point(.0875, .98)], e.App.instance.stage.addChildAt(_assertThisInitialized(t), 0), t.container = t.add(e.App.instance.make.group()), t.topLeftContainer = t.container.add(e.App.instance.make.group()), t.topRightContainer = t.container.add(e.App.instance.make.group()), t.bottomLeftContainer = t.container.add(e.App.instance.make.group()), t.bottomRightContainer = t.container.add(e.App.instance.make.group()), t.resize(), t
            }
            return _inherits(i, Phaser.Group), _createClass(i, [{
                key: "buildChildren",
                value: function() {
                    this.createLeaf(this.topLeftContainer, 1, -49.7, 3.1, -125.3009796142578, 1, -1), this.createLeaf(this.topLeftContainer, 4, -245.05, 42.25, 65.98316955566406), this.createLeaf(this.topLeftContainer, 5, -131.4, 19.85, 58.43214416503906), this.createLeaf(this.topRightContainer, 5, 138.2, -17.4, 107.98501586914062, 1, -1), this.createLeaf(this.topRightContainer, 2, 132, -39.6, -122.82777404785156), this.createLeaf(this.topRightContainer, 1, 76.55, -16.95, -49), this.createLeaf(this.topRightContainer, 4, 190.55, -50.05, -119.5193603515625), this.createLeaf(this.bottomLeftContainer, 5, -30.25, 100.15, -11.46099853515625), this.createLeaf(this.bottomLeftContainer, 4, -15.6, 159.1, -8.1023071289063), this.createLeaf(this.bottomLeftContainer, 6, -32.05, 113.05, 16.472152709960938), this.createLeaf(this.bottomLeftContainer, 1, -34.15, 66.85, 170.1315155029297, 1, -1), this.createLeaf(this.bottomRightContainer, 4, 100, 132.85, -32.88969421386719), this.createLeaf(this.bottomRightContainer, 3, 118.8, 137.6, -17.000503540039062), this.createLeaf(this.bottomRightContainer, 2, 123.6, 84.4, -46.802825927734375), this.createLeaf(this.bottomRightContainer, 1, 60.6, 61.8, 38.27931213378906)
                }
            }, {
                key: "createLeaf",
                value: function(t, i, n, a, s) {
                    var o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1,
                        r = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 1,
                        l = t.add(e.App.instance.make.sprite(n, a, e.Settings.PRELOADER_ATLAS, "leaf" + i + "0000"));
                    l.anchor.set(this.leafAnchors[i - 1].x, this.leafAnchors[i - 1].y), l.scale.set(o, r);
                    var h = e.App.instance.rnd.realInRange(1, 3) * e.App.instance.rnd.sign(),
                        u = e.App.instance.rnd.integerInRange(2800, 5e3);
                    l.angle = s + h, l.shakeTween = e.App.instance.tweens.create(l).to({
                        angle: s - h
                    }, u, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0), e.App.instance.tweens.add(l.shakeTween), this.leafs.push(l)
                }
            }, {
                key: "handleStateChanged",
                value: function() {
                    this.isInitialized && this.leafs.forEach(function(e) {
                        e.shakeTween.pendingDelete = !1
                    })
                }
            }, {
                key: "init",
                value: function() {
                    this.buildChildren(), this.isInitialized = !0, this.resize()
                }
            }, {
                key: "resize",
                value: function() {
                    this.isInitialized && (this.container.scale.set(e.CustomScaleManager.SCALE_X, e.CustomScaleManager.SCALE_Y), this.container.position.set(e.CustomScaleManager.WIDTH / 2 - this.containerWidth * e.CustomScaleManager.SCALE_X / 2, e.CustomScaleManager.HEIGHT / 2 - this.containerHeight * e.CustomScaleManager.SCALE_Y / 2), this.windowBounds = this.windowBounds || new e.WindowBounds, this.windowBounds.set(-(e.CustomScaleManager.WIDTH / e.CustomScaleManager.SCALE_X - this.containerWidth) / 2, (e.CustomScaleManager.WIDTH / e.CustomScaleManager.SCALE_X - this.containerWidth) / 2 + this.containerWidth, -(e.CustomScaleManager.HEIGHT / e.CustomScaleManager.SCALE_Y - this.containerHeight) / 2, (e.CustomScaleManager.HEIGHT / e.CustomScaleManager.SCALE_Y - this.containerHeight) / 2 + this.containerHeight), this.topLeftContainer.position.copyFrom(this.windowBounds.getPosition(-.06, -.01)), this.topLeftContainer.alpha = .8, this.topRightContainer.position.copyFrom(this.windowBounds.getPosition(1.03, -.025)), this.topRightContainer.alpha = .8, this.bottomLeftContainer.position.copyFrom(this.windowBounds.getPosition(-.05, 1)), this.bottomLeftContainer.alpha = .9, this.bottomRightContainer.position.copyFrom(this.windowBounds.getPosition(1.04, 1)), this.bottomRightContainer.alpha = .9)
                }
            }], [{
                key: "instance",
                get: function() {
                    return i._instance ? i._instance : i._instance = new i
                }
            }]), i
        }();
        t._instance = null, e.BackgroundManager = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        ! function(e) {
            e[e.TOTAL_SCORES = 1] = "TOTAL_SCORES", e[e.TOTAL_STARS = 2] = "TOTAL_STARS", e[e.TOTAL_LEVEL_UPS = 3] = "TOTAL_LEVEL_UPS", e[e.TOTAL_GREATS = 4] = "TOTAL_GREATS", e[e.BOMB_EXPLOSIONS = 5] = "BOMB_EXPLOSIONS", e[e.LINES_DESTROYED = 6] = "LINES_DESTROYED", e[e.BLOCKS_PLACED = 7] = "BLOCKS_PLACED", e[e.FIRE_BLOCKS_DESTROYED = 8] = "FIRE_BLOCKS_DESTROYED", e[e.BEST_SCORE_REACHED = 9] = "BEST_SCORE_REACHED"
        }(e.AchievementType || (e.AchievementType = {}))
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        ! function(e) {
            e[e.RED = 0] = "RED", e[e.GREEN = 1] = "GREEN", e[e.YELLOW = 2] = "YELLOW", e[e.BLUE = 3] = "BLUE", e[e.ORANGE = 4] = "ORANGE", e[e.WHITE = 5] = "WHITE", e[e.PURPLE = 6] = "PURPLE"
        }(e.BlockColor || (e.BlockColor = {}))
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        ! function(e) {
            e[e.CELL_EMPTY = 0] = "CELL_EMPTY", e[e.CELL_BUSY = 1] = "CELL_BUSY", e[e.CELL_NEW = 2] = "CELL_NEW"
        }(e.CellModelState || (e.CellModelState = {}))
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        ! function(e) {
            e[e.INACTIVE = 0] = "INACTIVE", e[e.DRAGGING = 1] = "DRAGGING", e[e.PLACED = 2] = "PLACED"
        }(e.FigureState || (e.FigureState = {}))
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        ! function(e) {
            e.GOOD = "Good", e.GREAT = "Great", e.EXCELLENT = "Excellent", e.AWESOME = "Awesome"
        }(e.InscriptionLevel || (e.InscriptionLevel = {}))
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        ! function(e) {
            e.BOMB = "Bomb", e.LIGHTNING = "Lightning"
        }(e.PowerupType || (e.PowerupType = {}))
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        ! function(e) {
            e[e.SILVER = 0] = "SILVER", e[e.GOLD = 1] = "GOLD"
        }(e.WindowHeadingBackplateType || (e.WindowHeadingBackplateType = {}))
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t, n, a) {
                var s;
                return _classCallCheck(this, i), (s = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e.App.instance, t, n, a))).width = e.CustomScaleManager.ORIGINAL_WIDTH, s.height = 30, s.minParticleScale = 1, s.maxParticleScale = 1.4, s.makeParticles(e.Settings.ANIMATION_ATLAS, ["particleStar10000", "particleStar20000", "particleStar30000"], a), s.gravity.set(0, 1200), s.setYSpeed(-100, 700), s.autoAlpha = !0, s.setAlpha(1, 0, 1800, Phaser.Easing.Quadratic.In), s.flow(3500, 5, 6, a, !1), s
            }
            return _inherits(i, Phaser.Particles.Arcade.Emitter), i
        }();
        e.BestScoreReachedEffectEmitter = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t) {
                var n;
                return _classCallCheck(this, i), (n = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e.App.instance, t.x, t.y, 100))).particlefrequency = 12, n.makeParticles(e.Settings.ANIMATION_ATLAS, ["particleStar10000", "particleStar20000", "particleStar30000"]), n.width = 40, n.height = 40, n.minParticleScale = 1, n.maxParticleScale = 2.5, n.gravity.setTo(0, 0), n.setYSpeed(-130, 130), n.setXSpeed(-130, 130), n.minRotation = 0, n.maxRotation = 0, n.autoAlpha = !0, n.setAlpha(1, 0, 420, Phaser.Easing.Quintic.In), n.autoScale = !0, n.setScale(2, .6, 2, .6, 500, Phaser.Easing.Sinusoidal.InOut), n.start(!1, 600, n.particlefrequency, 100 / n.particlefrequency), n.game.time.events.add(1600, function() {
                    return n.destroy()
                }), n
            }
            return _inherits(i, Phaser.Particles.Arcade.Emitter), i
        }();
        e.ExplodingEffectEmitter = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t, n, a, s) {
                var o;
                return _classCallCheck(this, i), (o = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, t.game, a.x, a.y, 250))).particleSpeed = 1200, o.particlefrequency = 17, o.level = t, o.points = n, o.distance = Phaser.Math.distance(s.x, s.y, a.x, a.y), o.duration = o.distance / o.particleSpeed * 1e3, o.makeParticles(e.Settings.ANIMATION_ATLAS, ["particleMultiplier10000", "particleMultiplier20000", "particleMultiplier30000"]), o.width = 25, o.height = 25, o.minParticleScale = .8, o.maxParticleScale = 1.3, o.gravity.setTo(0, 200), o.setYSpeed(-25, 25), o.setXSpeed(-25, 25), o.minRotation = 0, o.maxRotation = 0, o.autoAlpha = !0, o.setAlpha(1, 0, 370, Phaser.Easing.Quintic.In), o.flow(600, o.particlefrequency, 2, o.duration / o.particlefrequency * 3), o.game.add.tween(_assertThisInitialized(o)).to({
                    x: s.x,
                    y: s.y
                }, o.duration, Phaser.Easing.Linear.None, !0).onComplete.add(o.addPoints, _assertThisInitialized(o)), o.game.time.events.add(o.duration + 1600, function() {
                    return o.destroy()
                }), o
            }
            return _inherits(i, Phaser.Particles.Arcade.Emitter), _createClass(i, [{
                key: "addPoints",
                value: function() {
                    this.on = !1, this.width = 45, this.height = 45, this.setYSpeed(-120, 120), this.setXSpeed(-120, 120), this.setAlpha(1, 0, 300, Phaser.Easing.Quintic.In), this.setScale(1, .3, 1, .3, 280, Phaser.Easing.Sinusoidal.InOut), this.start(!1, 300, 10, 12)
                }
            }]), i
        }();
        e.FlyingParticlesEmitter = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t, n, a) {
                var s;
                return _classCallCheck(this, i), (s = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e.App.instance, null))).inscriptionLevel = t, s.game.camera.shake(.0058, 200), s.position.set(n, Math.max(a, -120) + 40), s.sprite = s.add(s.game.make.sprite(0, 0, e.Settings.GAME_ATLAS, "inscription" + s.inscriptionLevel + "0000")), s.sprite.anchor.set(.5, 1), s.sprite.alpha = 0, s.sprite.scale.set(0), s.game.add.tween(s.sprite).to({
                    alpha: 1
                }, 420, Phaser.Easing.Sinusoidal.Out, !1).to({
                    alpha: 1
                }, 250, Phaser.Easing.Sinusoidal.Out, !1).to({
                    alpha: 0
                }, 650, Phaser.Easing.Sinusoidal.In, !1).start().onComplete.add(function() {
                    return s.destroy()
                }), s.game.add.tween(s.sprite).to({
                    y: -120
                }, 350, Phaser.Easing.Sinusoidal.Out, !1).to({
                    y: -140
                }, 800, Phaser.Easing.Linear.None, !1).start(), s.game.add.tween(s.sprite.scale).to({
                    x: 1,
                    y: 1
                }, 420, s.amplifiedBackOut, !1).to({
                    x: 1.25,
                    y: 1.25
                }, 850, Phaser.Easing.Sinusoidal.In, !1, 50).start(), e.SoundController.instance.playInscriptionSound(t), s.inscriptionLevel == e.InscriptionLevel.GREAT && e.AchievementsManager.instance.addValue(e.AchievementType.TOTAL_GREATS, 1), s
            }
            return _inherits(i, Phaser.Group), _createClass(i, [{
                key: "amplifiedBackOut",
                value: function(e) {
                    var t = .70158;
                    return --e * e * ((t + 1) * e + t) + 1
                }
            }]), i
        }();
        e.InscriptionEffect = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t) {
                var n;
                _classCallCheck(this, i), (n = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e.App.instance, 0, 0, 250))).particleSpeed = 750, n.particleFrequency = 8;
                var a = e.App.instance.state.getCurrentState().uiManager.starsCounter,
                    s = a.toLocal(t.star.position, t),
                    o = new PIXI.Point(0, 0),
                    r = Phaser.Math.clamp(20 * Math.pow(Phaser.Math.distance(o.x, o.y, s.x, s.y), .5), 330, 700) / n.particleSpeed * 1e3;
                return a.addAt(_assertThisInitialized(n), 0), n.x = s.x, n.y = s.y, n.makeParticles(e.Settings.ANIMATION_ATLAS, ["particleStar10000", "particleStar20000", "particleStar30000"]), n.width = 30, n.height = 30, n.minParticleScale = .7, n.maxParticleScale = 1.5, n.gravity.setTo(0, -100), n.setYSpeed(-100, 100), n.setXSpeed(-100, 100), n.minRotation = 0, n.maxRotation = 0, n.autoAlpha = !0, n.setAlpha(1, 0, 420, Phaser.Easing.Quintic.In), n.autoScale = !0, n.setScale(1, .3, 1, .3, 500, Phaser.Easing.Sinusoidal.InOut), n.game.add.tween(_assertThisInitialized(n)).to({
                    x: o.x
                }, r, Phaser.Easing.Back.In, !0), n.game.add.tween(_assertThisInitialized(n)).to({
                    y: o.y
                }, r, Phaser.Easing.Sinusoidal.In, !0).onComplete.add(n.finalizeTween, _assertThisInitialized(n)), n.start(!1, 600, n.particleFrequency, r / n.particleFrequency), n.game.time.events.add(r + 1600, function() {
                    return n.destroy()
                }), n.starSprite = a.addAt(t.star, 1), n.starSprite.position.set(s.x, s.y), n.game.add.tween(n.starSprite).to({
                    x: o.x
                }, r, Phaser.Easing.Back.In, !0), n.game.add.tween(n.starSprite).to({
                    y: o.y,
                    angle: s.x < o.x ? "-373" : "+347"
                }, r, Phaser.Easing.Sinusoidal.In, !0), n
            }
            return _inherits(i, Phaser.Particles.Arcade.Emitter), _createClass(i, [{
                key: "finalizeTween",
                value: function() {
                    this.starSprite.destroy(), this.on = !1, this.width = 45, this.height = 45, this.setYSpeed(-140, 140), this.setXSpeed(-140, 140), this.setAlpha(1, 0, 480, Phaser.Easing.Quintic.In), this.setScale(1.2, .3, 1.2, .3, 540, Phaser.Easing.Sinusoidal.InOut), this.start(!1, 580, 10, 12), e.StarsManager.instance.pickupStars(1)
                }
            }]), i
        }();
        e.StarPickingUpEffect = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t) {
                var n;
                return _classCallCheck(this, i), (n = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e.App.instance, null))).buildChildren(t), n
            }
            return _inherits(i, Phaser.Group), _createClass(i, [{
                key: "buildChildren",
                value: function(t) {
                    this.block = this.add(this.game.make.sprite(0, 0, e.Settings.GAME_ATLAS, "blockStarred000" + t)), this.block.anchor.set(.5), this.star = this.add(this.game.make.sprite(0, 0, e.Settings.GAME_ATLAS, "star0000")), this.star.anchor.set(.5), this.shining = this.add(this.game.make.sprite(0, 0, e.Settings.GAME_ATLAS, "starShining0000")), this.shining.anchor.set(.5), this.shining.alpha = 0, this.shadow = this.add(this.game.make.sprite(-2, -2, e.Settings.GAME_ATLAS, "starShadow0000")), this.shadow.anchor.set(.5)
                }
            }, {
                key: "startShining",
                value: function() {
                    this.game.tweens.removeFrom(this.shining), this.shining.alpha = 0, this.game.add.tween(this.shining).to({
                        alpha: 1
                    }, e.Settings.STAR_SHINING_TWEEN_DURATION, Phaser.Easing.Linear.None, !0, 0, -1, !0), this.game.tweens.removeFrom(this.star.scale), this.star.scale.set(.9), this.game.add.tween(this.star.scale).to({
                        x: 1,
                        y: 1
                    }, e.Settings.STAR_SHINING_TWEEN_DURATION, Phaser.Easing.Linear.None, !0, 0, -1, !0)
                }
            }, {
                key: "setColor",
                value: function(e) {
                    this.block.frameName = "blockStarred000" + e
                }
            }, {
                key: "startAppearingTween",
                value: function(t, i) {
                    var n = this,
                        a = t.toLocal(this.position, this.parent);
                    this.position.set(a.x, a.y), t.add(this), this.game.time.events.add(70, function() {
                        return e.SoundController.instance.playStarAppearSound()
                    }), this.game.tweens.removeFrom(this.block), this.block.alpha = 0, this.game.add.tween(this.block).to({
                        alpha: 1
                    }, .35 * e.Settings.STARRED_BLOCK_APPEARING_TWEEN_DURATION, Phaser.Easing.Linear.None, !0), this.shining.alpha = 0, this.shadow.alpha = 0, this.game.add.tween(this.shadow).to({
                        alpha: 1
                    }, .2 * e.Settings.STARRED_BLOCK_APPEARING_TWEEN_DURATION, Phaser.Easing.Sinusoidal.In, !0, .8 * e.Settings.STARRED_BLOCK_APPEARING_TWEEN_DURATION), this.game.tweens.removeFrom(this.star), this.star.alpha = .5, this.game.add.tween(this.star).to({
                        alpha: 1
                    }, .7 * e.Settings.STARRED_BLOCK_APPEARING_TWEEN_DURATION, Phaser.Easing.Quadratic.Out, !0), this.star.angle = -45, this.game.add.tween(this.star).to({
                        angle: 0
                    }, .62 * e.Settings.STARRED_BLOCK_APPEARING_TWEEN_DURATION, Phaser.Easing.Sinusoidal.Out, !1).start(), this.game.tweens.removeFrom(this.star.scale), this.star.scale.set(5), this.game.add.tween(this.star.scale).to({
                        x: .8,
                        y: .8
                    }, .62 * e.Settings.STARRED_BLOCK_APPEARING_TWEEN_DURATION, Phaser.Easing.Sinusoidal.Out, !1).to({
                        x: .9,
                        y: .9
                    }, .1 * e.Settings.STARRED_BLOCK_APPEARING_TWEEN_DURATION, Phaser.Easing.Sinusoidal.In, !1).start().onComplete.add(function() {
                        n.position.set(0, 0), i.add(n), n.startShining()
                    })
                }
            }, {
                key: "destroy",
                value: function() {
                    _get(_getPrototypeOf(i.prototype), "destroy", this).call(this)
                }
            }, {
                key: "pickupStar",
                value: function(t) {
                    var i = this;
                    this.game.time.events.add(t, function() {
                        new e.StarPickingUpEffect(i)
                    })
                }
            }]), i
        }();
        e.BlockStarredView = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t, n) {
                var a;
                return _classCallCheck(this, i), (a = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e.App.instance, null))).position.set(t, n), a.explosionA = a.add(a.game.make.sprite(0, 0, "explosionA")), a.explosionA.anchor.set(.5), a.explosionA.scale.set(1.2), a.explosionA.angle = 360 * Math.random(), a.explosionA.animations.add("boom"), a.explosionA.animations.play("boom", 120, !1, !0), a.explosionB = a.add(a.game.make.sprite(0, 0, "explosionB")), a.explosionB.anchor.set(.5), a.explosionB.scale.set(1.3), a.explosionB.angle = 360 * Math.random(), a.explosionB.animations.add("boom"), a.explosionB.animations.play("boom", 60, !1, !0), a.game.camera.shake(.0035, 350), e.SoundController.instance.playExplosionSound(), a
            }
            return _inherits(i, Phaser.Group), i
        }();
        e.ExplosionEffect = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t, n) {
                var a;
                return _classCallCheck(this, i), (a = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e.App.instance, n.x, n.y, e.Settings.GAME_ATLAS, "lighting0000"))).anchor.set(.5, 0), a.initialCellPosition = t.position.clone(), a.targetCellPosition = n.position.clone(), a.targetCell = n, a.update(), a.blinkAnimation = a.animations.add("blinkAnimation", Phaser.Animation.generateFrameNames("lighting", 0, i.LIGHTING_FRAMES - 1, "", 4)), a.endAnimation = a.animations.add("endAnimation", Phaser.Animation.generateFrameNames("lightingEnd", 0, i.DISAPPEARING_FRAMES - 1, "", 4)), a
            }
            return _inherits(i, Phaser.Sprite), _createClass(i, [{
                key: "delayedStart",
                value: function(e) {
                    var t = this;
                    return this.visible = !1, this.game.time.events.add(e, function() {
                        t.targetCell ? t.startAnimations() : t.destroy()
                    }), this
                }
            }, {
                key: "startAnimations",
                value: function() {
                    var t = this;
                    e.SoundController.instance.playLightningSound(), this.visible = !0, this.blinkAnimation.play(i.FPS, !1, !1), this.blinkAnimation.onComplete.add(function() {
                        t.endAnimation.play(i.FPS, !1, !1), t.endAnimation.onComplete.add(function() {
                            t.destroy()
                        }), t.scale.set(1, 1)
                    }), this.targetCell && (e.ScoreManager.instance.addScores(5), this.targetCell.destroyBlock(35))
                }
            }, {
                key: "update",
                value: function() {
                    _get(_getPrototypeOf(i.prototype), "update", this).call(this);
                    var e = Phaser.Math.distance(this.targetCellPosition.x, this.targetCellPosition.y, this.initialCellPosition.x, this.initialCellPosition.y);
                    this.targetCell ? (this.targetCellPosition.copyFrom(this.targetCell.position), this.scale.set(1, Math.max(.5, e / 130)), 0 == e && this.anchor.set(.5)) : e < 120 && this.scale.set(1, e / 130), this.position.copyFrom(this.targetCellPosition), this.rotation = Phaser.Math.angleBetween(this.targetCellPosition.x, this.targetCellPosition.y, this.initialCellPosition.x, this.initialCellPosition.y) - Math.PI / 2
                }
            }, {
                key: "destroy",
                value: function() {
                    _get(_getPrototypeOf(i.prototype), "destroy", this).call(this), this.blinkAnimation = null, this.endAnimation = null
                }
            }]), i
        }();
        t.LIGHTING_FRAMES = 15, t.DISAPPEARING_FRAMES = 13, t.TOTAL_FRAMES = t.LIGHTING_FRAMES + t.DISAPPEARING_FRAMES, t.FPS = 180, e.LightningEffect = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t, n, a, s, o) {
                var r;
                _classCallCheck(this, i), (r = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, t.game))).targetScale = 1, r.level = t, r.scores = n;
                var l = e.App.instance.state.getCurrentState().uiManager.multiplierBar,
                    h = l.toLocal(new Phaser.Point(a, s), r.level.boardManager.getBoard().cellsContainer),
                    u = new PIXI.Point(0, 0);
                return r.position.set(h.x, h.y), l.addAt(_assertThisInitialized(r), 0), r.buildContent(), r.animateContentA(o, u), r
            }
            return _inherits(i, Phaser.Group), _createClass(i, [{
                key: "buildContent",
                value: function() {
                    this.scoresText = this.add(new e.BitmapTextField("+" + this.scores, e.Settings.GAME_ATLAS, "Gold", 1, .5, .5, 1))
                }
            }, {
                key: "animateContentA",
                value: function(t, i) {
                    var n = this;
                    this.scale.set(0), this.game.add.tween(this.scale).to({
                        x: this.targetScale,
                        y: this.targetScale
                    }, 300, Phaser.Easing.Back.Out, !0, t), this.appearingTween = this.game.add.tween(this.scoresText).to({
                        y: this.scoresText.y - 80
                    }, 350, Phaser.Easing.Back.Out, !0, t), this.disappearingTween = this.game.add.tween(this).to({
                        alpha: 0,
                        y: this.y - 70
                    }, 750, Phaser.Easing.Cubic.In, !1), this.disappearingTween.onStart.add(function() {}), this.disappearingTween.onComplete.add(function() {
                        return n.destroy()
                    }), this.game.time.events.add(t, function() {
                        return n.parent.addChildAt(new e.FlyingParticlesEmitter(n.level, n.scores, new PIXI.Point(n.x, n.y - 80), new Phaser.Point(i.x, i.y)), 0)
                    }), this.appearingTween.chain(this.disappearingTween)
                }
            }, {
                key: "destroy",
                value: function() {
                    _get(_getPrototypeOf(i.prototype), "destroy", this).call(this), this.level = null, this.scoresText = null, this.appearingTween = null, this.disappearingTween = null
                }
            }]), i
        }();
        e.ScoresEffect = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t, n, a, s) {
                var o;
                return _classCallCheck(this, i), (o = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e.App.instance, n, a, e.Settings.ANIMATION_ATLAS))).anchor.set(.5, .24), o.anim = o.animations.add("destroying", Phaser.Animation.generateFrameNames("blockDestroyingAnim" + t, 0, 35, "", 4)), o.visible = !1, o.game.time.events.add(s, function() {
                    o.visible = !0, o.anim.play(62, !1, !0)
                }), o
            }
            return _inherits(i, Phaser.Sprite), i
        }();
        e.BlockDestroyingEffect = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t, n) {
                var a;
                return _classCallCheck(this, i), (a = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e.App.instance, null))).starred = !1, a.active = !0, a.posX = t.posX, a.posY = t.posY, a.glow = a.add(a.game.make.sprite(0, 0, e.Settings.GAME_ATLAS, "blockGlow000" + n)), a.glow.anchor.set(.5), a.glow.alpha = 0, a.glow.visible = !1, a.block = a.add(a.game.make.sprite(0, 0, e.Settings.GAME_ATLAS, "block000" + n)), a.block.anchor.set(.5), a.blockGrayscale = a.add(a.game.make.sprite(0, 0, e.Settings.GAME_ATLAS, "blockGrey000" + n)), a.blockGrayscale.anchor.set(.5), a.blockGrayscale.visible = !1, a.blockGrayscale.alpha = 0, a.setColor(n), a
            }
            return _inherits(i, Phaser.Group), _createClass(i, [{
                key: "addStar",
                value: function(t) {
                    this.starred || (this.starred = !0, this.block.visible = !1, this.blockStarred = this.blockStarred || this.add(new e.BlockStarredView(this.color)), this.blockStarred.startAppearingTween(t.boardManager.getBoard().effectsContainer, this))
                }
            }, {
                key: "hasStar",
                value: function() {
                    return this.starred
                }
            }, {
                key: "setColor",
                value: function(e) {
                    this.color = e, this.block.frameName = "block000" + this.color, this.glow.frameName = "blockGlow000" + this.color, this.blockStarred && this.blockStarred.setColor(this.color), this.blockGrayscale.frameName = this.hasStar() ? "blockStarredGrey000" + this.color : "blockGrey000" + this.color
                }
            }, {
                key: "setTemporalColor",
                value: function(e) {
                    this.temporalColor = e, this.block.frameName = "block000" + this.temporalColor, this.glow.frameName = "blockGlow000" + this.temporalColor, this.blockStarred && this.blockStarred.setColor(this.temporalColor), this.blockGrayscale.frameName = this.hasStar() ? "blockStarredGrey000" + this.color : "blockGrey000" + this.color
                }
            }, {
                key: "applyTemporalColor",
                value: function() {
                    this.temporalColor && this.setColor(this.temporalColor)
                }
            }, {
                key: "activate",
                value: function(t) {
                    this.active = !0, this.block.visible = !0, this.hasStar() && (this.blockStarred.visible = !0, this.blockStarred.alpha = 1, this.blockGrayscale.parent.setChildIndex(this.blockGrayscale, this.blockGrayscale.parent.children.length - 1)), this.game.add.tween(this.blockGrayscale).to({
                        alpha: 0
                    }, e.Settings.BLOCK_ACTIVATION_TWEEN_DURATION, Phaser.Easing.Sinusoidal.Out, !0, t)
                }
            }, {
                key: "deactivate",
                value: function(t) {
                    var i = this;
                    this.active = !1, this.blockGrayscale.parent.setChildIndex(this.blockGrayscale, this.blockGrayscale.parent.children.length - 1), this.blockGrayscale.visible = !0, this.blockGrayscale.alpha = 0, this.game.add.tween(this.blockGrayscale).to({
                        alpha: 1
                    }, e.Settings.BLOCK_DEACTIVATION_TWEEN_DURATION, Phaser.Easing.Sinusoidal.Out, !0, t).onComplete.add(function() {
                        i.block.visible = !1, i.hasStar() && (i.blockStarred.visible = !1, i.blockStarred.alpha = 0)
                    })
                }
            }, {
                key: "dispose",
                value: function(t) {
                    var i = 8 - this.posY + 1,
                        n = i * e.Settings.CELL_HEIGHT,
                        a = Math.floor(this.game.rnd.integerInRange(20, 60)),
                        s = n,
                        o = 250 + 45 * i;
                    this.game.add.tween(this).to({
                        x: a.toString()
                    }, o, Phaser.Easing.Sinusoidal.In, !0, t), this.game.add.tween(this).to({
                        alpha: 0
                    }, o, Phaser.Easing.Exponential.In, !0, t), this.game.add.tween(this).to({
                        y: "+" + s
                    }, o, Phaser.Easing.Back.In, !0, t)
                }
            }, {
                key: "enableGlow",
                value: function(e) {
                    this.game.tweens.removeFrom(this.glow), this.glow.visible = !0, this.glow.alpha = 0, this.game.add.tween(this.glow).to({
                        alpha: .6
                    }, e, Phaser.Easing.Sinusoidal.InOut, !0)
                }
            }, {
                key: "disableGlow",
                value: function(e) {
                    var t = this;
                    this.game.tweens.removeFrom(this.glow), this.game.add.tween(this.glow).to({
                        alpha: 0
                    }, e, Phaser.Easing.Sinusoidal.Out, !0).onComplete.add(function() {
                        return t.glow.visible = !1
                    })
                }
            }, {
                key: "animateDestroying",
                value: function(t, i) {
                    var n = this;
                    t.add(new e.BlockDestroyingEffect(this.color, this.x, this.y, i)), this.game.add.tween(this.scale).to({
                        x: .5,
                        y: .5
                    }, e.Settings.BLOCK_DISAPPEARING_DURATION, Phaser.Easing.Sinusoidal.Out, !0, i), this.game.add.tween(this).to({
                        alpha: 0
                    }, e.Settings.BLOCK_DISAPPEARING_DURATION, Phaser.Easing.Sinusoidal.Out, !0, i).onComplete.add(function() {
                        n.color == e.BlockColor.RED && e.AchievementsManager.instance.addValue(e.AchievementType.FIRE_BLOCKS_DESTROYED, 1), n.destroy()
                    }), this.hasStar() && this.blockStarred && this.blockStarred.pickupStar(i)
                }
            }]), i
        }();
        e.Block = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(e, t, n) {
                var a;
                return _classCallCheck(this, i), (a = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e.game))).active = !0, a.boardManager = e, a.level = e.level, a.numRows = t, a.numCols = n, a.buildCells(), a.alignCells(), a.animateAppearing(), a
            }
            return _inherits(i, Phaser.Group), _createClass(i, [{
                key: "buildCells",
                value: function() {
                    this.cells = [], this.cellsContainer = this.add(this.game.make.group()), this.fieldCoverSprite = this.add(this.game.make.image(0, 0, "field-cover")), this.fieldCoverSprite.anchor.set(.5), this.blocksContainer = this.add(this.game.make.group()), this.explosionsContainer = this.add(this.game.make.group()), this.effectsContainer = this.add(this.game.make.group());
                    for (var t = 0; t < this.numRows * this.numCols; t++) {
                        var i = Math.floor(t / this.numCols),
                            n = t % this.numCols;
                        this.cells.push(this.cellsContainer.add(new e.Cell(this, n, i)))
                    }
                }
            }, {
                key: "alignCells",
                value: function() {
                    var t = this;
                    this.cells.forEach(function(i) {
                        return i.position.set(i.posX - t.numCols / 2 + .5, i.posY - t.numRows / 2 + .5).multiply(e.Settings.CELL_WIDTH, e.Settings.CELL_HEIGHT)
                    })
                }
            }, {
                key: "animateAppearing",
                value: function() {
                    for (var e = this, t = null, i = 0; i < this.numCols; i++)
                        for (var n = 0; n < this.numRows; n++)(t = this.getCellAt(i, n)).scale.set(0), this.game.add.tween(t.scale).to({
                            x: 1,
                            y: 1
                        }, 120, Phaser.Easing.Quadratic.Out, !0, 20 * (i + n) + 100);
                    this.game.time.events.add(20 * (this.numCols + this.numRows) + 100, function() {
                        return e.level.eventManager.onBoardCreated.dispatch()
                    })
                }
            }, {
                key: "findClosestCell",
                value: function(t) {
                    var i = null;
                    return this.getCells().forEach(function(n) {
                        Math.abs(n.x - t.x) <= e.Settings.CELL_WIDTH / 2 && Math.abs(n.y - t.y) <= e.Settings.CELL_HEIGHT / 2 && (i = n)
                    }), i
                }
            }, {
                key: "isActive",
                value: function() {
                    return this.active
                }
            }, {
                key: "getScale",
                value: function() {
                    return this.scale.x
                }
            }, {
                key: "getCells",
                value: function() {
                    return this.cells
                }
            }, {
                key: "getNotEmptyCells",
                value: function() {
                    var e = this;
                    return this.getCells().filter(function(t) {
                        return !e.isEmpty(t)
                    })
                }
            }, {
                key: "getEmptyCells",
                value: function() {
                    var e = this;
                    return this.getCells().filter(function(t) {
                        return e.isEmpty(t)
                    })
                }
            }, {
                key: "getCellAt",
                value: function(e, t) {
                    return e < 0 || e >= this.numCols || t < 0 || t >= this.numRows ? null : this.cells[t * this.numRows + e] || null
                }
            }, {
                key: "isEmpty",
                value: function(e) {
                    return e && e.isEmpty()
                }
            }, {
                key: "activate",
                value: function() {
                    this.isActive() || (this.active = !0, e.SoundController.instance.playReviveSound(), Phaser.ArrayUtils.shuffle(this.getNotEmptyCells()).forEach(function(e, t) {
                        return e.getBlock().activate(7 * t)
                    }))
                }
            }, {
                key: "deactivate",
                value: function(t) {
                    this.isActive() && (this.active = !1, e.SoundController.instance.playLoseSound(), Phaser.ArrayUtils.shuffle(this.getNotEmptyCells()).forEach(function(e, i) {
                        return e.getBlock().deactivate(t + 10 * i)
                    }))
                }
            }, {
                key: "disposeBlocks",
                value: function(t, i) {
                    i && (this.active = !1, e.SoundController.instance.playLoseSound()), Phaser.ArrayUtils.shuffle(this.getNotEmptyCells()).forEach(function(e, n) {
                        return e.disposeBlock(t + 8 * n, i)
                    })
                }
            }, {
                key: "dispatchFigureIsBeingDragged",
                value: function(t) {
                    var i = this;
                    if (this.getCells().forEach(function(e) {
                            return e.resetView(!1)
                        }), this.targetCells = this.getTargetCellsFor(t), this.targetCells && t) {
                        this.targetCells.forEach(function(e) {
                            return e.showHighlighting(t.color, !1)
                        });
                        var n = this.getModel();
                        this.targetCells.forEach(function(t) {
                            return n.setCellStateAt(e.CellModelState.CELL_NEW, t.posX, t.posY)
                        }), n.findCellsToClear().forEach(function(e) {
                            return i.getCellAt(e.x, e.y).showHighlighting(t.color, !1)
                        })
                    }
                }
            }, {
                key: "dispatchPowerupIsBeingDragged",
                value: function(e) {
                    this.getCells().forEach(function(e) {
                        return e.resetAlphaHighlighting()
                    }), e && e.length > 0 && (this.getCells().forEach(function(e) {
                        return e.applyAlphaHighlighting(!0)
                    }), e.forEach(function(e) {
                        return e.applyAlphaHighlighting(!1)
                    }))
                }
            }, {
                key: "placeFigure",
                value: function(e) {
                    return !(!e || (this.targetCells = this.getTargetCellsFor(e), !this.targetCells)) && (this.targetCells.forEach(function(t, i) {
                        return t.placeBlock(e.getView().getBlocks()[i])
                    }), this.clearFilledRowsAndColumns(this.targetCells, e), this.targetCells = null, !0)
                }
            }, {
                key: "getTargetCellsFor",
                value: function(t) {
                    var i = this;
                    if (t) {
                        var n = t.getView().getFirstBlock(),
                            a = this.cellsContainer.toLocal(t.getView().position, t),
                            s = new Phaser.Point(a.x + n.x, a.y + n.y),
                            o = this.findClosestCell(s);
                        if (o) {
                            var r = t.getView().getBlocks().map(function(e) {
                                return i.getCellAt(o.posX + e.posX - n.posX, o.posY + e.posY - n.posY)
                            });
                            if (r.every(function(e) {
                                    return i.isEmpty(e)
                                })) return e.Settings.TUTORIAL_COMPLETED ? r : r.every(function(e) {
                                return !!t.getModel().getCells().find(function(i) {
                                    return e.posX == i.posX + t.getModel().posX && e.posY == i.posY + t.getModel().posY
                                })
                            }) ? r : null
                        }
                    }
                    return null
                }
            }, {
                key: "getCellUnderPoint",
                value: function(t) {
                    return this.level.boardManager.getBoard().getCells().find(function(i) {
                        return Math.abs(i.x - t.x) < e.Settings.CELL_WIDTH / 2 && Math.abs(i.y - t.y) < e.Settings.CELL_HEIGHT / 2
                    }) || null
                }
            }, {
                key: "getNumStarsOnTheBoard",
                value: function() {
                    return this.getNotEmptyCells().reduce(function(e, t) {
                        return e + (t.getBlock().hasStar() ? 1 : 0)
                    }, 0)
                }
            }, {
                key: "clearFilledRowsAndColumns",
                value: function(t, i) {
                    for (var n = [], a = 0, s = 0; s < this.numRows; s++) this.isRowFilled(s) && (a++, n = e.ArrayUtils.uniteArrays(n, this.getRow(s)));
                    for (var o = 0; o < this.numCols; o++) this.isColumnFilled(o) && (a++, n = e.ArrayUtils.uniteArrays(n, this.getColumn(o)));
                    if (n.length > 0) {
                        this.level.dataManager.dispatchLinesDestroyed(a, n.map(function(e) {
                            return {
                                x: e.posX,
                                y: e.posY
                            }
                        })), e.Settings.SET_THE_SAME_EXPLOSION_COLOR_FOR_ALL_THE_EXPLODING_CELLS && n.forEach(function(e) {
                            return e.getBlock().setColor(i.color)
                        });
                        var r = a * (a + 1) / 2 * e.Settings.BASIC_LINE_DESTROYING_REWARD + i.getModel().numCells(),
                            l = this.findExplosionStartingPosition(n, t, e.Settings.PICK_RANDOM_EXPLOSION_STARTING_POINT),
                            h = this.level.boardManager.getBoard().getCellAt(l.x, l.y).position;
                        this.level.serviceManager.inscriptionsService.displayScoresEffect(r, h.x, h.y), n.forEach(function(t) {
                            return t.destroyBlock(e.Settings.BLOCK_DESTROY_ANIMATION_DELAY * Math.max(Math.abs(t.posX - l.x), Math.abs(t.posY - l.y)))
                        }), e.SoundController.instance.playNextLineDestroyingSound(a), e.AchievementsManager.instance.addValue(e.AchievementType.LINES_DESTROYED, a)
                    } else {
                        var u = this.level.boardManager.getBoard().cellsContainer.toLocal(i.getView().parent.toGlobal(i.getView().position), this.game.world);
                        this.level.serviceManager.inscriptionsService.displayScoresEffect(i.getModel().numCells(), u.x, u.y - 60)
                    }
                    return a
                }
            }, {
                key: "isRowFilled",
                value: function(e) {
                    return this.getRow(e).every(function(e) {
                        return 0 == e.isEmpty()
                    })
                }
            }, {
                key: "isColumnFilled",
                value: function(e) {
                    return this.getColumn(e).every(function(e) {
                        return 0 == e.isEmpty()
                    })
                }
            }, {
                key: "getRow",
                value: function(e) {
                    return this.getCells().filter(function(t) {
                        return t.posX == e
                    })
                }
            }, {
                key: "getColumn",
                value: function(e) {
                    return this.getCells().filter(function(t) {
                        return t.posY == e
                    })
                }
            }, {
                key: "findExplosionStartingPosition",
                value: function(e, t, i) {
                    var n = e.filter(function(e) {
                        return -1 != t.indexOf(e)
                    });
                    if (0 == n.length && (n = e.slice()), i) {
                        var a = Phaser.ArrayUtils.getRandomItem(n);
                        return {
                            x: a.posX,
                            y: a.posY
                        }
                    }
                    return {
                        x: (n.reduce(function(e, t) {
                            return Math.min(e, t.posX)
                        }, Number.MAX_SAFE_INTEGER) + n.reduce(function(e, t) {
                            return Math.max(e, t.posX)
                        }, 0)) / 2,
                        y: (n.reduce(function(e, t) {
                            return Math.min(e, t.posY)
                        }, Number.MAX_SAFE_INTEGER) + n.reduce(function(e, t) {
                            return Math.max(e, t.posY)
                        }, 0)) / 2
                    }
                }
            }, {
                key: "getModel",
                value: function() {
                    return new e.BoardModel(this.numCols, this.numRows).parseFromBoard(this)
                }
            }]), i
        }();
        e.Board = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(e, t, n) {
                var a;
                return _classCallCheck(this, i), (a = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e.game))).forceHighlighting = !1, a.board = e, a.boardManager = e.boardManager, a.level = a.boardManager.level, a.posX = t, a.posY = n, a.buildContent(), a
            }
            return _inherits(i, Phaser.Group), _createClass(i, [{
                key: "buildContent",
                value: function() {
                    this.cellSprite = this.add(this.game.make.sprite(0, 0, e.Settings.GAME_ATLAS, "cell000" + Math.floor(3 * Math.random()))), this.cellSprite.anchor.set(.5), this.highlightSprite = this.add(this.game.make.sprite(0, 0, e.Settings.GAME_ATLAS, "block0000")), this.highlightSprite.anchor.set(.5), this.highlightSprite.alpha = .5, this.highlightSprite.visible = !1, this.block = null
                }
            }, {
                key: "equalsTo",
                value: function(e) {
                    return this.posX === e.posX && this.posY === e.posY
                }
            }, {
                key: "isEmpty",
                value: function() {
                    return null == this.block
                }
            }, {
                key: "hasBlock",
                value: function() {
                    return !this.isEmpty()
                }
            }, {
                key: "getBlock",
                value: function() {
                    return this.block
                }
            }, {
                key: "disposeBlock",
                value: function(t, i) {
                    this.hasBlock() && (i ? (this.getBlock().deactivate(t), this.getBlock().dispose(t + e.Settings.BLOCK_DEACTIVATION_TWEEN_DURATION)) : this.getBlock().dispose(t), this.block = null)
                }
            }, {
                key: "placeBlock",
                value: function(e) {
                    var t = this.board.blocksContainer.toLocal(e.position, e.parent);
                    this.block = this.board.blocksContainer.add(e), this.block.posX = this.posX, this.block.posY = this.posY, this.block.position.set(t.x, t.y), this.game.tweens.removeFrom(this.block, !1), this.game.tweens.removeFrom(this.block.scale), this.game.add.tween(this.block).to({
                        x: this.x,
                        y: this.y
                    }, 130, Phaser.Easing.Circular.Out, !0, 0), this.game.add.tween(this.block.scale).to({
                        x: 1,
                        y: 1
                    }, 120, Phaser.Easing.Cubic.In, !0, 0)
                }
            }, {
                key: "destroyBlock",
                value: function(e) {
                    this.block && (this.block.animateDestroying(this.board.explosionsContainer, e), this.block = null)
                }
            }, {
                key: "applyAlphaHighlighting",
                value: function(t) {
                    this.hasBlock() ? this.getBlock().alpha = t ? e.Settings.POWERUP_HIGHLIGHTING_ALPHA : 1 : this.alpha = t ? e.Settings.POWERUP_HIGHLIGHTING_ALPHA : 1
                }
            }, {
                key: "resetAlphaHighlighting",
                value: function() {
                    this.hasBlock() && (this.getBlock().alpha = 1), this.alpha = 1
                }
            }, {
                key: "showHighlighting",
                value: function(e, t) {
                    t && (this.forceHighlighting = !0), this.isEmpty() ? (this.highlightSprite.frameName = "block000" + e, this.highlightSprite.visible = !0) : this.block.setTemporalColor(e)
                }
            }, {
                key: "resetView",
                value: function(e) {
                    e && (this.forceHighlighting = !1), this.forceHighlighting || (this.highlightSprite.visible = !1), this.isEmpty() || this.block.setColor(this.block.color)
                }
            }]), i
        }();
        e.Cell = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t, n, a, s) {
                var o;
                return _classCallCheck(this, i), (o = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, t.game))).figureWidth = 0, o.figureHeight = 0, o.applicable = !0, o.figureManager = t, o.level = o.figureManager.level, o.board = o.level.boardManager.getBoard(), o.figureModel = n, o.figureState = e.FigureState.INACTIVE, o.color = a, o.barIndex = s, o.figureWidth = n.getWidth(), o.figureHeight = n.getHeight(), o.figureView = o.add(new e.FigureView(_assertThisInitialized(o), n)), o.inputHandler = o.add(o.game.make.sprite(0, 0, e.Settings.GAME_ATLAS, "blackSquare0000")), o.inputHandler.anchor.set(.5), o.inputHandler.inputEnabled = !0, o.inputHandler.width = 5 * e.Settings.CELL_WIDTH * e.Settings.DEFAULT_FIGURE_SCALE, o.inputHandler.height = 5 * e.Settings.CELL_HEIGHT * e.Settings.DEFAULT_FIGURE_SCALE, o.inputHandler.alpha = 0, o.inputHandler.events.onInputDown.add(o.handleInputDown, _assertThisInitialized(o)), o.inputHandler.events.onInputUp.add(o.handleInputUp, _assertThisInitialized(o)), o
            }
            return _inherits(i, Phaser.Group), _createClass(i, [{
                key: "setPosition",
                value: function(e, t) {
                    this.posX = e, this.posY = t
                }
            }, {
                key: "getView",
                value: function() {
                    return this.figureView
                }
            }, {
                key: "getModel",
                value: function() {
                    return this.figureModel
                }
            }, {
                key: "playAppearingTween",
                value: function(e) {
                    this.figureView.playAppearingTween(e)
                }
            }, {
                key: "pickUp",
                value: function() {
                    this.figureState = e.FigureState.DRAGGING, this.parent && this.parent.setChildIndex(this, this.parent.children.length - 1), this.game.add.tween(this.figureView).to(this.level.serviceManager.layoutService.getFigureDraggingDelta(this.barIndex), e.Settings.FIGURE_PICK_UP_TWEEN_DURATION, Phaser.Easing.Circular.Out, !0), this.figureView.tweenScale(e.Settings.DRAGGING_FIGURE_SCALE, !0, 1.25 * e.Settings.FIGURE_PICK_UP_TWEEN_DURATION, 1 / this.scale.x * this.board.getScale()), this.figureView.getBlocks().forEach(function(t) {
                        return t.enableGlow(1.5 * e.Settings.FIGURE_PICK_UP_TWEEN_DURATION)
                    }), e.SoundController.instance.playFigurePickupSound()
                }
            }, {
                key: "putDown",
                value: function() {
                    this.figureState = e.FigureState.PLACED, this.figureView.getBlocks().forEach(function(t) {
                        return t.disableGlow(e.Settings.FIGURE_PICK_UP_TWEEN_DURATION / 2)
                    }), e.SoundController.instance.playFigurePlaceSound()
                }
            }, {
                key: "release",
                value: function() {
                    this.figureState = e.FigureState.INACTIVE, this.game.add.tween(this.figureView).to({
                        x: 0,
                        y: 0
                    }, e.Settings.FIGURE_PICK_UP_TWEEN_DURATION, Phaser.Easing.Sinusoidal.Out, !0), this.figureView.tweenScale(e.Settings.DEFAULT_FIGURE_SCALE, !1, e.Settings.FIGURE_PICK_UP_TWEEN_DURATION), this.figureView.getBlocks().forEach(function(t) {
                        return t.disableGlow(e.Settings.FIGURE_PICK_UP_TWEEN_DURATION)
                    }), e.SoundController.instance.playFigureFailSound()
                }
            }, {
                key: "dispose",
                value: function() {
                    var t = this;
                    this.game.add.tween(this.figureView).to(this.level.serviceManager.layoutService.getFigureDisposingTweenParams(), e.Settings.FIGURE_DISPOSING_TWEEN_DURATION, Phaser.Easing.Sinusoidal.Out, !0).onComplete.add(function() {
                        return t.destroy()
                    })
                }
            }, {
                key: "setApplicable",
                value: function(t) {
                    t != this.applicable && (this.applicable = t, this.game.tweens.removeFrom(this, !1), this.game.add.tween(this).to({
                        alpha: t ? 1 : e.Settings.NOT_APPLICABLE_FIGURE_APLHA
                    }, 350, Phaser.Easing.Linear.None, !0, 450))
                }
            }, {
                key: "handleInputDown",
                value: function() {
                    this.figureView.isReady && this.figureManager.handleFigureInputDown(this)
                }
            }, {
                key: "handleInputUp",
                value: function() {
                    this.figureView.isReady && this.figureManager.handleFigureInputUp(this)
                }
            }, {
                key: "destroy",
                value: function() {
                    this.inputHandler.events.onInputDown.remove(this.handleInputDown, this), this.inputHandler.events.onInputUp.remove(this.handleInputUp, this), _get(_getPrototypeOf(i.prototype), "destroy", this).call(this), this.figureView = null, this.inputHandler = null
                }
            }]), i
        }();
        e.Figure = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(e) {
                var t;
                return _classCallCheck(this, i), (t = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e.game))).level = e, t
            }
            return _inherits(i, Phaser.Group), _createClass(i, [{
                key: "resize",
                value: function() {
                    switch (e.CustomScaleManager.getLayout()) {
                        case e.LayoutType.PORTRAIT:
                            this.resizePortrait();
                            break;
                        case e.LayoutType.SQUARED:
                            this.resizeSquared();
                            break;
                        case e.LayoutType.LANDSCAPE:
                            this.resizeLandscape()
                    }
                }
            }]), i
        }();
        e.AbstractManager = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t) {
                var n;
                return _classCallCheck(this, i), (n = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, t))).board = n.add(new e.Board(_assertThisInitialized(n), e.Settings.BOARD_ROWS, e.Settings.BOARD_COLS)), n
            }
            return _inherits(i, e.AbstractManager), _createClass(i, [{
                key: "getBoard",
                value: function() {
                    return this.board
                }
            }, {
                key: "resizeLandscape",
                value: function() {
                    this.fillAvailableSpace()
                }
            }, {
                key: "resizeSquared",
                value: function() {
                    this.fillAvailableSpace()
                }
            }, {
                key: "resizePortrait",
                value: function() {
                    this.fillAvailableSpace()
                }
            }, {
                key: "getOriginalBounds",
                value: function(t) {
                    var i = (this.getBoard().numCols + (t ? .5 : 0)) * e.Settings.CELL_WIDTH,
                        n = (this.getBoard().numRows + (t ? .5 : 0)) * e.Settings.CELL_HEIGHT;
                    return new Phaser.Rectangle(-i / 2, -n / 2, i, n)
                }
            }, {
                key: "getBoardBounds",
                value: function(e) {
                    var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                        i = this.getOriginalBounds(t),
                        n = e.toLocal(new Phaser.Point(i.x, i.y), this.level.boardManager.getBoard().cellsContainer),
                        a = e.toLocal(new Phaser.Point(i.x + i.width, i.y + i.height), this.level.boardManager.getBoard().cellsContainer);
                    return new Phaser.Rectangle(n.x, n.y, a.x - n.x, a.y - n.y)
                }
            }, {
                key: "fillAvailableSpace",
                value: function() {
                    var e = this.getOriginalBounds(!0),
                        t = this.level.serviceManager.layoutService.getAvailableBoardBounds();
                    this.board.position.set(t.x, t.y), this.board.scale.set(Math.min(t.width / e.width, t.height / e.height))
                }
            }]), i
        }();
        e.BoardManager = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(e) {
                var t;
                return _classCallCheck(this, i), (t = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e))).numMoves = 0, t.initData(), t
            }
            return _inherits(i, e.AbstractManager), _createClass(i, [{
                key: "initData",
                value: function() {
                    this.numMoves = 0
                }
            }, {
                key: "moveFinished",
                value: function() {
                    this.numMoves++, this.level.eventManager.onMoveFinished.dispatch(this.numMoves)
                }
            }, {
                key: "dispatchLinesDestroyed",
                value: function(e, t) {
                    this.level.eventManager.onLinesDestroyed.dispatch(e, t)
                }
            }, {
                key: "getMaxMistakeProbability",
                value: function() {
                    return Phaser.Math.clamp(e.Settings.MISTAKE_MAX_PROBABILITY + e.Settings.MISTAKE_MAX_PROBABILITY * (e.Settings.DIFFICULTY_FACTOR - 1) * .2 + .001 * this.numMoves, 0, .4)
                }
            }, {
                key: "getMaxMistakeProbabilityStep",
                value: function() {
                    return this.getMaxMistakeProbability() / 5
                }
            }, {
                key: "getMistakeProbabilityStepSpeed",
                value: function() {
                    return e.Settings.MISTAKE_PROBABILITY_STEP_SPEED + e.Settings.MISTAKE_PROBABILITY_STEP_SPEED * (e.Settings.DIFFICULTY_FACTOR - 1) * .15
                }
            }, {
                key: "resizeLandscape",
                value: function() {}
            }, {
                key: "resizeSquared",
                value: function() {}
            }, {
                key: "resizePortrait",
                value: function() {}
            }]), i
        }();
        e.DataManager = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(e) {
                var t;
                return _classCallCheck(this, i), (t = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e))).buildSignals(), t
            }
            return _inherits(i, e.AbstractManager), _createClass(i, [{
                key: "buildSignals",
                value: function() {
                    this.onBoardCreated = new Phaser.Signal, this.onRoundFinished = new Phaser.Signal, this.onMoveFinished = new Phaser.Signal, this.onReviveApplied = new Phaser.Signal, this.onReviveFailed = new Phaser.Signal, this.onLinesDestroyed = new Phaser.Signal, this.onPowerupUsageTimerExceeded = new Phaser.Signal, this.onPowerupApplied = new Phaser.Signal
                }
            }, {
                key: "resizeLandscape",
                value: function() {}
            }, {
                key: "resizeSquared",
                value: function() {}
            }, {
                key: "resizePortrait",
                value: function() {}
            }, {
                key: "destroy",
                value: function() {
                    this.onBoardCreated.dispose(), this.onRoundFinished.dispose(), this.onMoveFinished.dispose(), this.onReviveApplied.dispose(), this.onReviveFailed.dispose(), this.onLinesDestroyed.dispose(), this.onPowerupUsageTimerExceeded.dispose(), this.onPowerupApplied.dispose(), _get(_getPrototypeOf(i.prototype), "destroy", this).call(this)
                }
            }]), i
        }();
        e.EventManager = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t) {
                var n;
                return _classCallCheck(this, i), (n = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, t))).figures = [], n.activeFigure = null, n.activeFigurePointerDelta = null, n.currentMistakeStep = 0, n.currentMistakeProbability = 0, n.mistakeImmunityCounter = 0, n.initialFigureScale = 1, n.initialFigurePositions = [new Phaser.Point(0, 0), new Phaser.Point(0, 0), new Phaser.Point(0, 0)], n.figureService = n.level.serviceManager.figureService, n.currentMistakeStep = e.Settings.MISTAKE_PROBABILITY_BASIC_STEP, n.mistakeImmunityCounter = n.game.rnd.integerInRange(e.Settings.MISTAKE_IMMUNITY_MIN_MOVES, e.Settings.MISTAKE_IMMUNITY_MAX_MOVES), n.buildContent(), n.resize(), n
            }
            return _inherits(i, e.AbstractManager), _createClass(i, [{
                key: "buildContent",
                value: function() {
                    this.figuresContainer = this.add(this.game.make.group()), this.createFigures(!1)
                }
            }, {
                key: "getPointerLocalPosition",
                value: function() {
                    var e = this.figuresContainer.toLocal(this.game.input.activePointer.position, this.game.world),
                        t = e.x,
                        i = e.y;
                    return new Phaser.Point(t, i)
                }
            }, {
                key: "getFigureInitialPosition",
                value: function(e) {
                    return this.initialFigurePositions[e.barIndex]
                }
            }, {
                key: "getFiguresLeft",
                value: function() {
                    return this.figures.filter(function(e) {
                        return null != e
                    }).length
                }
            }, {
                key: "createFigures",
                value: function(t) {
                    var i = this,
                        n = this.figureService.getNextFiguresSet(this.level.boardManager.getBoard().getModel());
                    t && e.Settings.TUTORIAL_COMPLETED && this.level.dataManager.numMoves > this.mistakeImmunityCounter && (this.currentMistakeStep = Phaser.Math.clamp(this.currentMistakeStep + this.level.dataManager.getMistakeProbabilityStepSpeed(), 0, this.level.dataManager.getMaxMistakeProbabilityStep()), this.currentMistakeProbability += this.currentMistakeStep, Math.random() < this.currentMistakeProbability && (gradle.event("Random figure generated with probability of " + Phaser.Math.roundTo(100 * this.currentMistakeProbability, -1) + "%"), n[Math.floor(Math.random() * n.length)] = this.figureService.getRandomFigureModel(), this.currentMistakeProbability = 0, this.currentMistakeStep *= .05 * (e.Settings.DIFFICULTY_FACTOR - 1))), n.forEach(function(t, n) {
                        return i.addFigure(new e.Figure(i, t, i.figureService.getRandomColor(), n), (n + 1) * e.Settings.FIGURE_APPEARING_DELAY + 100)
                    }), this.alignFigures()
                }
            }, {
                key: "update",
                value: function() {
                    _get(_getPrototypeOf(i.prototype), "update", this).call(this), this.activeFigure ? (this.activeFigure.position.copyFrom(this.getPointerLocalPosition().subtract(this.activeFigurePointerDelta.x, this.activeFigurePointerDelta.y)), this.level.boardManager.getBoard().dispatchFigureIsBeingDragged(this.activeFigure)) : this.level.boardManager.getBoard().dispatchFigureIsBeingDragged(null)
                }
            }, {
                key: "resizeLandscape",
                value: function() {
                    var t = this.level.serviceManager.layoutService.getAvailableFiguresPanelBounds(),
                        i = Math.min(t.width / 6, t.height / 18),
                        n = i / e.Settings.CELL_WIDTH;
                    this.initialFigurePositions.forEach(function(e, t) {
                        return e.set(0, (t - 1) * i * 6)
                    }), this.initialFigureScale = n, this.figuresContainer.position.set(t.x, t.y), this.alignFigures()
                }
            }, {
                key: "resizeSquared",
                value: function() {
                    var t = this.level.serviceManager.layoutService.getAvailableFiguresPanelBounds(),
                        i = Math.min(t.width / 6, t.height / 18),
                        n = i / e.Settings.CELL_WIDTH;
                    this.initialFigurePositions.forEach(function(e, t) {
                        return e.set(0, (t - 1) * i * 6)
                    }), this.initialFigureScale = n, this.figuresContainer.position.set(t.x, t.y), this.alignFigures()
                }
            }, {
                key: "resizePortrait",
                value: function() {
                    var t = this.level.serviceManager.layoutService.getAvailableFiguresPanelBounds(),
                        i = Math.min(t.width / 18, t.height / 6),
                        n = i / e.Settings.CELL_WIDTH;
                    this.initialFigurePositions.forEach(function(e, t) {
                        return e.set((t - 1) * i * 6, 0)
                    }), this.initialFigureScale = n, this.figuresContainer.position.set(t.x, t.y - .05 * t.height), this.alignFigures()
                }
            }, {
                key: "getOriginalBounds",
                value: function() {
                    var e = this.figuresContainer.getBounds(this.figuresContainer.parent);
                    return this.add(this.game.make.graphics(e.x, e.y).beginFill(16777215, .5).drawRect(0, 0, e.width, e.height).endFill()), new Phaser.Rectangle(e.x, e.y, e.width, e.height)
                }
            }, {
                key: "alignFigures",
                value: function() {
                    var t = this;
                    this.figures.forEach(function(i) {
                        i && (t.game.tweens.removeFrom(i, !1), i.scale.set(t.initialFigureScale / e.Settings.DEFAULT_FIGURE_SCALE), i.position.copyFrom(t.getFigureInitialPosition(i)))
                    })
                }
            }, {
                key: "getFigures",
                value: function() {
                    return this.figures
                }
            }, {
                key: "addFigure",
                value: function(e, t) {
                    this.figures[e.barIndex] = this.figuresContainer.add(e), e.position.copyFrom(this.getFigureInitialPosition(e)), e.playAppearingTween(t)
                }
            }, {
                key: "removeFigure",
                value: function(e) {
                    -1 != this.figures.indexOf(e) && (this.figures[this.figures.indexOf(e)] = null, e.destroy()), 0 == this.getFiguresLeft() && (this.level.eventManager.onRoundFinished.dispatch(), this.createFigures(!0))
                }
            }, {
                key: "regenerateFigures",
                value: function() {
                    for (var e = 0; e < this.figures.length; e++) this.figures[e] && this.figures[e].dispose(), this.figures[e] = null;
                    this.createFigures(!1)
                }
            }, {
                key: "isNextMovePossible",
                value: function() {
                    var e = this,
                        t = (this.figures.filter(function(e) {
                            return !!e
                        }).sort(function(e, t) {
                            return e.getModel().numCells() - t.getModel().numCells()
                        }), 0);
                    return this.figures.forEach(function(i) {
                        if (i) {
                            var n = e.figureService.hasAvailableSpaceForFigure(i, e.level.boardManager.getBoard().getModel());
                            i.setApplicable(n), n && (t += 1)
                        }
                    }), t > 0
                }
            }, {
                key: "updateFiguresApplicability",
                value: function() {
                    var e = this;
                    this.figures.forEach(function(t) {
                        return t && t.setApplicable(e.figureService.hasAvailableSpaceForFigure(t, e.level.boardManager.getBoard().getModel()))
                    })
                }
            }, {
                key: "handleFigureInputDown",
                value: function(t) {
                    if (this.level.gameStateManager.isGameActive() && !this.activeFigure && t.figureState == e.FigureState.INACTIVE) {
                        if (!e.Settings.TUTORIAL_COMPLETED && this.level.tutorialManager.getActiveFigure() != t) return;
                        this.activeFigure = t, this.activeFigure.pickUp(), this.activeFigurePointerDelta = this.getPointerLocalPosition().subtract(this.activeFigure.x, this.activeFigure.y)
                    }
                }
            }, {
                key: "handleFigureInputUp",
                value: function(t) {
                    if (this.level.gameStateManager.isGameActive() && this.activeFigure && this.activeFigure == t)
                        if (this.level.boardManager.getBoard().placeFigure(t)) e.AchievementsManager.instance.addValue(e.AchievementType.BLOCKS_PLACED, t.getModel().numCells()), this.activeFigure.putDown(), this.removeFigure(this.activeFigure), this.level.dataManager.moveFinished();
                        else {
                            var i = e.Settings.FIGURE_PICK_UP_TWEEN_DURATION;
                            this.game.add.tween(this.activeFigure).to({
                                x: this.getFigureInitialPosition(t).x,
                                y: this.getFigureInitialPosition(t).y
                            }, i, Phaser.Easing.Linear.None, !0), this.activeFigure.release()
                        }
                    this.activeFigure = null, this.activeFigurePointerDelta = null
                }
            }]), i
        }();
        e.FigureManager = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(e) {
                var t;
                return _classCallCheck(this, i), (t = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e))).started = !1, t.finished = !1, t.paused = !1, t.reviveAvailable = !0, t.reviveUsed = !1, t.reviveTimer = 0, t.resultsTimer = 0, t.reviveAvailable = !0, t.level.eventManager.onBoardCreated.add(t.dispatchBoardCreated, _assertThisInitialized(t)), t.level.eventManager.onMoveFinished.add(t.dispatchMoveFinished, _assertThisInitialized(t)), t.level.eventManager.onPowerupUsageTimerExceeded.add(t.dispatchPowerupUsageTimerExceeded, _assertThisInitialized(t)), t.level.eventManager.onPowerupApplied.add(t.dispatchPowerupApplied, _assertThisInitialized(t)), t.level.eventManager.onReviveApplied.add(t.reviveApplied, _assertThisInitialized(t)), t.level.eventManager.onReviveFailed.add(t.reviveFailed, _assertThisInitialized(t)), t
            }
            return _inherits(i, e.AbstractManager), _createClass(i, [{
                key: "update",
                value: function() {
                    _get(_getPrototypeOf(i.prototype), "update", this).call(this), this.reviveTimer > 0 && (this.reviveTimer--, this.reviveTimer <= 0 && (this.reviveTimer = 0, e.WindowManager.instance.showRevive())), this.resultsTimer > 0 && (this.resultsTimer--, this.resultsTimer <= 0 && (this.resultsTimer = 0, e.Analytics.instance.finishLevel(e.ScoreManager.instance.getCurrentScores(), e.StarsManager.instance.getLastRoundStars(), this.reviveUsed ? 1 : 0, this.level.uiManager.powerupContainer.usedPowerups), e.WindowManager.instance.showResults()))
                }
            }, {
                key: "isGameActive",
                value: function() {
                    return this.started && !this.paused && !this.finished
                }
            }, {
                key: "isStarted",
                value: function() {
                    return this.started
                }
            }, {
                key: "isPaused",
                value: function() {
                    return this.paused
                }
            }, {
                key: "isFinished",
                value: function() {
                    return this.finished
                }
            }, {
                key: "dispatchBoardCreated",
                value: function() {
                    this.started = !0
                }
            }, {
                key: "dispatchMoveFinished",
                value: function() {
                    this.finished || this.level.figureManager.isNextMovePossible() || (e.PowerupManager.instance.hasBoughtPowerups() ? this.level.uiManager.powerupContainer.startCountdown() : this.finishGame())
                }
            }, {
                key: "dispatchPowerupUsageTimerExceeded",
                value: function() {
                    this.finished || this.level.figureManager.isNextMovePossible() || this.finishGame()
                }
            }, {
                key: "dispatchPowerupApplied",
                value: function() {
                    this.finished || this.level.figureManager.isNextMovePossible() || (e.PowerupManager.instance.hasBoughtPowerups() ? this.level.uiManager.powerupContainer.startCountdown() : this.finishGame())
                }
            }, {
                key: "finishGame",
                value: function() {
                    this.finished = !0, this.reviveAvailable = this.reviveAvailable && e.APIUtils.instance.hasRewardedVideo(), this.reviveAvailable ? (this.reviveAvailable = !1, this.reviveTimer = e.Settings.REVIVE_WINDOW_TIMER, this.resultsTimer = 0, this.level.boardManager.getBoard().deactivate(200)) : (this.level.uiManager.levelFinished(), this.reviveTimer = 0, this.resultsTimer = e.Settings.RESULTS_WINDOW_TIMER_WITHOUT_REVIVE, this.level.boardManager.getBoard().disposeBlocks(250, !0))
                }
            }, {
                key: "reviveApplied",
                value: function() {
                    e.Analytics.instance.updateLevelData({
                        revives: 1
                    }), this.reviveUsed = !0, this.finished = !1, this.reviveTimer = 0, this.resultsTimer = 0, this.level.figureManager.regenerateFigures(), this.level.boardManager.getBoard().activate()
                }
            }, {
                key: "reviveFailed",
                value: function() {
                    this.finished = !0, this.reviveTimer = 0, this.resultsTimer = e.Settings.RESULTS_WINDOW_TIMER, this.level.boardManager.getBoard().disposeBlocks(250, !1), this.level.uiManager.levelFinished()
                }
            }, {
                key: "resizeLandscape",
                value: function() {}
            }, {
                key: "resizeSquared",
                value: function() {}
            }, {
                key: "resizePortrait",
                value: function() {}
            }, {
                key: "destroy",
                value: function() {
                    _get(_getPrototypeOf(i.prototype), "destroy", this).call(this)
                }
            }]), i
        }();
        e.GameStateManager = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(e) {
                var t;
                return _classCallCheck(this, i), (t = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e))).initServices(), t
            }
            return _inherits(i, e.AbstractManager), _createClass(i, [{
                key: "initServices",
                value: function() {
                    this.layoutService = new e.LayoutService(this), this.figureService = new e.FigureService(this), this.starsService = new e.StarsService(this), this.inscriptionsService = new e.InscriptionsService(this)
                }
            }, {
                key: "resizeLandscape",
                value: function() {}
            }, {
                key: "resizeSquared",
                value: function() {}
            }, {
                key: "resizePortrait",
                value: function() {}
            }]), i
        }();
        e.ServiceManager = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t) {
                var n;
                return _classCallCheck(this, i), (n = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, t))).isManualTutorialActive = e.Settings.TUTORIAL_COMPLETED, n.isInitialized = !1, n.activeFigure = null, n.buildContent(), n.level.eventManager.onBoardCreated.add(n.handleBoardCreated, _assertThisInitialized(n)), n.level.eventManager.onMoveFinished.add(n.handleFigurePlaced, _assertThisInitialized(n)), n.level.eventManager.onRoundFinished.add(n.handleRoundFinished, _assertThisInitialized(n)), n.visible = !1, n
            }
            return _inherits(i, e.AbstractManager), _createClass(i, [{
                key: "start",
                value: function() {
                    this.isInitialized = !0
                }
            }, {
                key: "resizeLandscape",
                value: function() {
                    this.startHandAnimation()
                }
            }, {
                key: "resizeSquared",
                value: function() {
                    this.startHandAnimation()
                }
            }, {
                key: "resizePortrait",
                value: function() {
                    this.startHandAnimation()
                }
            }, {
                key: "update",
                value: function() {
                    _get(_getPrototypeOf(i.prototype), "update", this).call(this)
                }
            }, {
                key: "getActiveFigure",
                value: function() {
                    return this.activeFigure
                }
            }, {
                key: "restartTutorial",
                value: function() {
                    this.isManualTutorialActive = !0, e.Settings.TUTORIAL_COMPLETED = !1, this.startHandAnimation()
                }
            }, {
                key: "buildContent",
                value: function() {
                    this.tutorialHand = this.add(this.game.make.sprite(0, 0, e.Settings.GAME_ATLAS, "tutorialHand0000")), this.tutorialHand.anchor.set(.4, 0), this.visible = !1
                }
            }, {
                key: "startHandAnimation",
                value: function() {
                    var t = this;
                    if (this.isInitialized && !e.Settings.TUTORIAL_COMPLETED) {
                        var i = this.level.boardManager.getBoard();
                        this.level.boardManager.getBoard().getCells().forEach(function(e) {
                            return e.resetView(!0)
                        }), this.visible = !0;
                        var n = this.level.figureManager.getFigures().slice().filter(function(e) {
                            return !!e
                        }).sort(function(e, t) {
                            return e.getModel().numCells() - t.getModel().numCells()
                        })[0];
                        if (n) {
                            this.activeFigure = n;
                            var a = this.toLocal(n.getView().position, n.getView().parent),
                                s = this.level.boardManager.getBoard().getCellAt(n.getModel().posX, n.getModel().posY);
                            if (!s) {
                                var o = this.level.serviceManager.figureService.getRandomPositionForFigure(n, i.getModel());
                                if (!o) return void this.finishTutorial();
                                n.getModel().posX = o.x, n.getModel().posY = o.y, s = this.level.boardManager.getBoard().getCellAt(o.x, o.y)
                            }
                            var r = this.toLocal(s.position, s.parent);
                            this.game.tweens.removeFrom(this.tutorialHand), this.tutorialHand.position.set(a.x, a.y), this.tutorialHand.alpha = 0;
                            var l = this.game.add.tween(this.tutorialHand).to({
                                    alpha: 1,
                                    x: a.x,
                                    y: a.y
                                }, 500, Phaser.Easing.Sinusoidal.Out, !1),
                                h = this.game.add.tween(this.tutorialHand).to({
                                    x: r.x + (n.getModel().getCenterX() - .5) * e.Settings.CELL_WIDTH * i.getScale(),
                                    y: r.y + (n.getModel().getCenterY() - .5) * e.Settings.CELL_HEIGHT * i.getScale()
                                }, 1200, Phaser.Easing.Sinusoidal.InOut, !1, 0, 0, !1),
                                u = this.game.add.tween(this.tutorialHand).to({
                                    alpha: 0
                                }, 750, Phaser.Easing.Exponential.In, !1),
                                c = this.game.add.tween(this.tutorialHand).to({
                                    x: a.x,
                                    y: a.y
                                }, 10, Phaser.Easing.Linear.None, !1);
                            l.onComplete.add(function() {
                                return t.tutorialHand.frameName = "tutorialHand0001"
                            }), u.onStart.add(function() {
                                return t.tutorialHand.frameName = "tutorialHand0000"
                            }), l.chain(h), h.chain(u), u.chain(c), c.chain(l), l.start(), n.getModel().getCells().forEach(function(e) {
                                return i.getCellAt(s.posX + e.x, s.posY + e.y).showHighlighting(n.color, !0)
                            })
                        } else this.activeFigure = null
                    }
                }
            }, {
                key: "handleFigurePlaced",
                value: function() {
                    if (!this.isInitialized || !e.Settings.TUTORIAL_COMPLETED) {
                        if (this.level.boardManager.getBoard().getCells().forEach(function(e) {
                                return e.resetView(!0)
                            }), this.isManualTutorialActive) return this.finishTutorial();
                        this.startHandAnimation()
                    }
                }
            }, {
                key: "handleRoundFinished",
                value: function() {
                    this.finishTutorial()
                }
            }, {
                key: "finishTutorial",
                value: function() {
                    e.Settings.TUTORIAL_COMPLETED || (this.visible = !1, this.activeFigure = null, e.Settings.TUTORIAL_COMPLETED = !0, e.LocalStorageController.instance.save(), e.Settings.ENABLE_API && gradle.event("EVENT_TUTORIALCOMPLETED"), this.level.boardManager.getBoard().getCells().forEach(function(e) {
                        return e.resetView(!0)
                    }))
                }
            }, {
                key: "handleBoardCreated",
                value: function() {
                    this.isInitialized = !0, this.startHandAnimation()
                }
            }]), i
        }();
        e.TutorialManager = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(e) {
                var t;
                return _classCallCheck(this, i), (t = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e))).buildContent(), t
            }
            return _inherits(i, e.AbstractManager), _createClass(i, [{
                key: "buildContent",
                value: function() {
                    this.buttonAchievements = this.add(new e.ButtonAchievements(this.level)), this.buttonSettings = this.add(e.ButtonUtils.createSimpleButton(e.Settings.GAME_ATLAS, "buttonSettings", 0, 0, 1, this.settingsClicked, this)), this.topContainer = this.add(this.game.make.group()), this.scoreCounter = this.topContainer.add(new e.ScoreCounter(this)), this.starsCounter = this.topContainer.add(new e.StarsCounter(this)), this.multiplierBar = this.topContainer.add(new e.MultiplierBar(this)), this.powerupContainer = this.add(new e.PowerupContainer(this))
                }
            }, {
                key: "resizeLandscape",
                value: function() {
                    var e = this.level.serviceManager.layoutService.getAvailableUIContainerBounds();
                    this.buttonAchievements.position.set(this.level.windowBounds.left + e.width / 2, this.level.windowBounds.top + 70), this.buttonSettings.position.set(this.level.windowBounds.right - e.width / 2, this.level.windowBounds.top + 65), this.scoreCounter.position.set(-65, -50), this.multiplierBar.position.set(-65, -50), this.starsCounter.position.set(-65, 50), this.buttonAchievements.setScale(1.18), this.buttonSettings.setScale(1.18), this.topContainer.position.set(e.x, e.y), this.topContainer.scale.set(Math.min(1.25, e.width / this.topContainer.getLocalBounds().width)), this.buttonAchievements.resizeLandscape(), this.powerupContainer.resize()
                }
            }, {
                key: "resizeSquared",
                value: function() {
                    this.buttonAchievements.position.set(this.level.windowBounds.left + 95, this.level.windowBounds.top + 60), this.buttonSettings.position.set(this.level.windowBounds.right - 88, this.level.windowBounds.top + 60), this.topContainer.position.copyFrom(this.level.windowBounds.getPosition(.5, 0, 0, 55)), this.topContainer.scale.set(.95), this.scoreCounter.position.set(.22 * -this.level.windowBounds.width, 0), this.multiplierBar.position.set(.22 * -this.level.windowBounds.width, 0), this.starsCounter.position.set(.06 * this.level.windowBounds.width, 0), this.buttonAchievements.setScale(1.1), this.buttonSettings.setScale(1.1), this.buttonAchievements.resizeSquared(), this.powerupContainer.resize()
                }
            }, {
                key: "resizePortrait",
                value: function() {
                    var e = this.level.serviceManager.layoutService.getAvailableUIContainerBounds();
                    this.buttonAchievements.position.set(this.level.windowBounds.left + 65, this.level.windowBounds.down - 65), this.buttonSettings.position.set(this.level.windowBounds.right - 65, this.level.windowBounds.down - 65), this.topContainer.position.copyFrom(this.level.windowBounds.getPosition(.5, 0, 0, 0)), this.topContainer.y = e.y, this.topContainer.scale.set(1), this.scoreCounter.position.set(.3 * -this.level.windowBounds.width, 0), this.multiplierBar.position.set(.3 * -this.level.windowBounds.width, 0), this.starsCounter.position.set(.13 * this.level.windowBounds.width, 0), this.buttonAchievements.setScale(1.1), this.buttonSettings.setScale(1.1), this.buttonAchievements.resizePortrait(), this.powerupContainer.resize()
                }
            }, {
                key: "levelFinished",
                value: function() {
                    this.powerupContainer.hidePowerups()
                }
            }, {
                key: "settingsClicked",
                value: function() {
                    e.Settings.ENABLE_API && gradle.event('SCREEN_SETTINGS'), e.WindowManager.instance.showSettings()
                }
            }]), i
        }();
        e.UIManager = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function() {
            function t(e, i) {
                _classCallCheck(this, t), this.cleanedCells = 0, this.numCols = e, this.numRows = i
            }
            return _createClass(t, [{
                key: "parseFromBoard",
                value: function(t) {
                    this.cells = [];
                    for (var i = 0; i < this.numCols; i++) {
                        this.cells[i] = [];
                        for (var n = 0; n < this.numRows; n++) this.cells[i][n] = e.CellModelState.CELL_EMPTY
                    }
                    var a = !0,
                        s = !1,
                        o = void 0;
                    try {
                        for (var r, l = t.getCells()[Symbol.iterator](); !(a = (r = l.next()).done); a = !0) {
                            var h = r.value;
                            this.cells[h.posX][h.posY] = h.isEmpty() ? e.CellModelState.CELL_EMPTY : e.CellModelState.CELL_BUSY
                        }
                    } catch (e) {
                        s = !0, o = e
                    } finally {
                        try {
                            a || null == l.return || l.return()
                        } finally {
                            if (s) throw o
                        }
                    }
                    return this
                }
            }, {
                key: "getCopy",
                value: function() {
                    return new t(this.numCols, this.numRows).copyFrom(this)
                }
            }, {
                key: "copyFrom",
                value: function(e) {
                    return this.cleanedCells = e.cleanedCells, this.cells = e.cells.map(function(e) {
                        return e.slice()
                    }), this
                }
            }, {
                key: "getCellStateAt",
                value: function(e, t) {
                    return e >= 0 && e < this.numCols && t >= 0 && t < this.numRows ? this.cells[e][t] : null
                }
            }, {
                key: "setCellStateAt",
                value: function(e, t, i) {
                    t >= 0 && t < this.numCols && i >= 0 && i < this.numRows && (this.cells[t][i] = e)
                }
            }, {
                key: "placeFigure",
                value: function(t, i) {
                    var n = this;
                    this.couldBePlaced(t, i) && (t.forEach(function(t) {
                        return n.setCellStateAt(e.CellModelState.CELL_BUSY, i.x + t.x, i.y + t.y)
                    }), this.clearFilledRowsAndColumns())
                }
            }, {
                key: "couldBePlaced",
                value: function(t, i) {
                    var n = this;
                    return t.map(function(e) {
                        return n.getCellStateAt(i.x + e.x, i.y + e.y)
                    }).every(function(t) {
                        return t == e.CellModelState.CELL_EMPTY
                    })
                }
            }, {
                key: "print",
                value: function() {
                    var e = this;
                    gradle.event(this.cells.map(function(t, i) {
                        return t.map(function(t, n) {
                            return e.cells[n][i]
                        })
                    }))
                }
            }, {
                key: "equals",
                value: function(e) {
                    if (this.numRows != e.numRows || this.numCols != e.numCols) return !1;
                    for (var t = 0; t < this.numCols; t++)
                        for (var i = 0; i < this.numRows; i++)
                            if (this.cells[t][i] != e.getCellStateAt(t, i)) return !1;
                    return !0
                }
            }, {
                key: "findCellsToClear",
                value: function() {
                    for (var t = [], i = 0; i < this.numRows; i++) this.isRowFilled(i) && (t = e.ArrayUtils.uniteArrays(t, this.getRowModel(i)));
                    for (var n = 0; n < this.numCols; n++) this.isColumnFilled(n) && (t = e.ArrayUtils.uniteArrays(t, this.getColumnModel(n)));
                    return t
                }
            }, {
                key: "clearFilledRowsAndColumns",
                value: function() {
                    var t = this;
                    this.findCellsToClear().forEach(function(i) {
                        t.getCellStateAt(i.x, i.y) != e.CellModelState.CELL_EMPTY && (t.cleanedCells += 1, t.setCellStateAt(e.CellModelState.CELL_EMPTY, i.x, i.y))
                    })
                }
            }, {
                key: "isRowFilled",
                value: function(t) {
                    return this.getRow(t).every(function(t) {
                        return t != e.CellModelState.CELL_EMPTY
                    })
                }
            }, {
                key: "isColumnFilled",
                value: function(t) {
                    return this.getColumn(t).every(function(t) {
                        return t != e.CellModelState.CELL_EMPTY
                    })
                }
            }, {
                key: "getRow",
                value: function(e) {
                    return this.cells.map(function(t) {
                        return t[e]
                    })
                }
            }, {
                key: "getColumn",
                value: function(e) {
                    return this.cells[e].slice()
                }
            }, {
                key: "getRowModel",
                value: function(e) {
                    return this.cells.map(function(t, i) {
                        return {
                            x: i,
                            y: e
                        }
                    })
                }
            }, {
                key: "getColumnModel",
                value: function(e) {
                    return this.cells[e].map(function(t, i) {
                        return {
                            x: e,
                            y: i
                        }
                    })
                }
            }]), t
        }();
        e.BoardModel = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(e) {
            function t(e, i) {
                return _classCallCheck(this, t), _possibleConstructorReturn(this, _getPrototypeOf(t).call(this, e, i))
            }
            return _inherits(t, Phaser.Point), _createClass(t, [{
                key: "getCopy",
                value: function() {
                    return new t(this.posX, this.posY)
                }
            }, {
                key: "posX",
                get: function() {
                    return this.x
                },
                set: function(e) {
                    this.x = e
                }
            }, {
                key: "posY",
                get: function() {
                    return this.y
                },
                set: function(e) {
                    this.y = e
                }
            }]), t
        }();
        e.CellModel = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function() {
            function t(e) {
                _classCallCheck(this, t), this.figureWidth = 0, this.figureHeight = 0, this.centerX = 0, this.centerY = 0, this.cells = e.slice(), this.normalizeCells()
            }
            return _createClass(t, [{
                key: "normalizeCells",
                value: function() {
                    if (this.cells && 0 !== this.cells.length) {
                        var e = this.cells.reduce(function(e, t) {
                                return e.posX <= t.posX ? e : t
                            }).posX,
                            t = this.cells.reduce(function(e, t) {
                                return e.posY <= t.posY ? e : t
                            }).posY;
                        this.cells.forEach(function(i) {
                            return i.subtract(e, t)
                        }), this.figureWidth = this.cells.reduce(function(e, t) {
                            return e.posX >= t.posX ? e : t
                        }).posX - this.cells.reduce(function(e, t) {
                            return e.posX <= t.posX ? e : t
                        }).posX + 1, this.figureHeight = this.cells.reduce(function(e, t) {
                            return e.posY >= t.posY ? e : t
                        }).posY - this.cells.reduce(function(e, t) {
                            return e.posY <= t.posY ? e : t
                        }).posY + 1, this.centerX = this.figureWidth / 2, this.centerY = this.figureHeight / 2
                    }
                }
            }, {
                key: "setPosition",
                value: function(e, t) {
                    return this.posX = e, this.posY = t, this
                }
            }, {
                key: "getCells",
                value: function() {
                    return this.cells
                }
            }, {
                key: "numCells",
                value: function() {
                    return this.getCells().length
                }
            }, {
                key: "getWidth",
                value: function() {
                    return this.figureWidth
                }
            }, {
                key: "getHeight",
                value: function() {
                    return this.figureHeight
                }
            }, {
                key: "getCenterX",
                value: function() {
                    return this.centerX
                }
            }, {
                key: "getCenterY",
                value: function() {
                    return this.centerY
                }
            }, {
                key: "clone",
                value: function() {
                    return new t(this.getCells().map(function(t) {
                        return new e.CellModel(t.posX, t.posY)
                    }))
                }
            }]), t
        }();
        e.FigureModel = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        e.AbstractService = function e(t) {
            _classCallCheck(this, e), this.serviceManager = t, this.level = t.level
        }
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i() {
                var t;
                return _classCallCheck(this, i), (t = _possibleConstructorReturn(this, _getPrototypeOf(i).apply(this, arguments))).prevColor = null, t.figurePresets = [t.normalizeCells([new e.CellModel(1, 1)]), t.normalizeCells([new e.CellModel(0, 0), new e.CellModel(1, 0)]), t.normalizeCells([new e.CellModel(0, 0), new e.CellModel(0, 1)]), t.normalizeCells([new e.CellModel(0, 0), new e.CellModel(1, 0), new e.CellModel(2, 0)]), t.normalizeCells([new e.CellModel(0, 0), new e.CellModel(0, 1), new e.CellModel(0, 2)]), t.normalizeCells([new e.CellModel(0, 0), new e.CellModel(1, 0), new e.CellModel(0, 1)]), t.normalizeCells([new e.CellModel(0, 0), new e.CellModel(0, 1), new e.CellModel(1, 1), new e.CellModel(2, 1)]), t.normalizeCells([new e.CellModel(0, 0), new e.CellModel(0, 1), new e.CellModel(0, 2), new e.CellModel(0, 3)]), t.normalizeCells([new e.CellModel(0, 0), new e.CellModel(0, 1), new e.CellModel(1, 0), new e.CellModel(1, 1)]), t.normalizeCells([new e.CellModel(1, 0), new e.CellModel(0, 1), new e.CellModel(1, 1), new e.CellModel(2, 1)]), t.normalizeCells([new e.CellModel(1, 0), new e.CellModel(2, 0), new e.CellModel(0, 1), new e.CellModel(1, 1)]), t.normalizeCells([new e.CellModel(0, 0), new e.CellModel(1, 0), new e.CellModel(2, 0), new e.CellModel(3, 0), new e.CellModel(4, 0)]), t.normalizeCells([new e.CellModel(0, 0), new e.CellModel(1, 0), new e.CellModel(2, 0), new e.CellModel(2, 1), new e.CellModel(2, 2)]), t.normalizeCells([new e.CellModel(0, 0), new e.CellModel(0, 1), new e.CellModel(0, 2), new e.CellModel(1, 0), new e.CellModel(1, 1), new e.CellModel(1, 2), new e.CellModel(2, 0), new e.CellModel(2, 1), new e.CellModel(2, 2)])], t.tutorialPlacements = [{
                    preset: t.normalizeCells([new e.CellModel(0, 0), new e.CellModel(0, 1), new e.CellModel(1, 1), new e.CellModel(2, 1)]),
                    position: {
                        x: 2,
                        y: 3
                    }
                }, {
                    preset: t.normalizeCells([new e.CellModel(0, 0), new e.CellModel(0, 1), new e.CellModel(1, 0), new e.CellModel(1, 1)]),
                    position: {
                        x: 0,
                        y: 3
                    }
                }, {
                    preset: t.normalizeCells([new e.CellModel(0, 0), new e.CellModel(0, 1), new e.CellModel(0, 2), new e.CellModel(1, 0), new e.CellModel(1, 1), new e.CellModel(1, 2), new e.CellModel(2, 0), new e.CellModel(2, 1), new e.CellModel(2, 2)]),
                    position: {
                        x: 5,
                        y: 2
                    }
                }], t.iterations = 0, t
            }
            return _inherits(i, e.AbstractService), _createClass(i, [{
                key: "normalizeCells",
                value: function(e) {
                    var t = e.reduce(function(e, t) {
                            return e.posX <= t.posX ? e : t
                        }).posX,
                        i = e.reduce(function(e, t) {
                            return e.posY <= t.posY ? e : t
                        }).posY;
                    return e.forEach(function(e) {
                        return e.subtract(t, i)
                    }), e
                }
            }, {
                key: "getRandomFigureModel",
                value: function() {
                    return new e.FigureModel(this.getCopy(Phaser.ArrayUtils.getRandomItem(this.figurePresets)))
                }
            }, {
                key: "getRandomColor",
                value: function() {
                    var t = this;
                    return this.prevColor = Phaser.ArrayUtils.getRandomItem(Object.keys(e.BlockColor).map(function(t) {
                        return e.BlockColor[t]
                    }).filter(function(e) {
                        return "number" == typeof e && e != t.prevColor
                    })), this.prevColor
                }
            }, {
                key: "getRandomPositionForFigure",
                value: function(e, t) {
                    return Phaser.ArrayUtils.getRandomItem(this.findFigurePositions(e.getModel().getCells(), t, 1)) || null
                }
            }, {
                key: "hasAvailableSpaceForFigure",
                value: function(e, t) {
                    return this.findFigurePositions(e.getModel().getCells(), t, 1).length > 0
                }
            }, {
                key: "getNextFiguresSet",
                value: function(t) {
                    var i = this;
                    if (!e.Settings.TUTORIAL_COMPLETED) return this.tutorialPlacements.map(function(t) {
                        return new e.FigureModel(i.getCopy(t.preset)).setPosition(t.position.x, t.position.y)
                    });
                    this.iterations = 0;
                    var n = [];
                    return this.findFigurePositionsRecursive(t, [], n), n.sort(function(e, t) {
                        return t.reduce(function(e, t) {
                            return e + t.preset.length
                        }, 0) - e.reduce(function(e, t) {
                            return e + t.preset.length
                        }, 0)
                    }), n.length > 0 ? Phaser.ArrayUtils.shuffle(e.ArrayUtils.getRandomItem(n, e.Settings.RESULTING_FIGURE_RANDOM_COMPRESSION_FACTOR).map(function(t) {
                        return new e.FigureModel(t.preset)
                    })) : Phaser.ArrayUtils.shuffle([this.getRandomFigureModel(), this.getRandomFigureModel(), this.getRandomFigureModel()])
                }
            }, {
                key: "findFigurePositionsRecursive",
                value: function(e, t, i) {
                    var n = this.findAppropriateFigurePresetsForBoard(e, !0);
                    if (n.length > 0) {
                        i.length > 0 && (n = [Phaser.ArrayUtils.getRandomItem(n)]);
                        var a = !0,
                            s = !1,
                            o = void 0;
                        try {
                            for (var r, l = n[Symbol.iterator](); !(a = (r = l.next()).done); a = !0) {
                                var h = r.value,
                                    u = !0,
                                    c = !1,
                                    d = void 0;
                                try {
                                    for (var g, p = h.figurePositions[Symbol.iterator](); !(u = (g = p.next()).done); u = !0) {
                                        var v = g.value;
                                        if (this.iterations++, 2 == t.length) i.push(t.slice().concat({
                                            preset: h.figurePreset,
                                            position: v,
                                            cleanedCells: e.cleanedCells
                                        }));
                                        else {
                                            var m = e.getCopy();
                                            m.placeFigure(h.figurePreset, v), this.findFigurePositionsRecursive(m, t.slice().concat({
                                                preset: h.figurePreset,
                                                position: v,
                                                cleanedCells: m.cleanedCells
                                            }), i)
                                        }
                                    }
                                } catch (e) {
                                    c = !0, d = e
                                } finally {
                                    try {
                                        u || null == p.return || p.return()
                                    } finally {
                                        if (c) throw d
                                    }
                                }
                            }
                        } catch (e) {
                            s = !0, o = e
                        } finally {
                            try {
                                a || null == l.return || l.return()
                            } finally {
                                if (s) throw o
                            }
                        }
                    }
                }
            }, {
                key: "findAppropriateFigurePresetsForBoard",
                value: function(t, i) {
                    var n = [],
                        a = !0,
                        s = !1,
                        o = void 0;
                    try {
                        for (var r, l = Phaser.ArrayUtils.shuffle(this.figurePresets.slice())[Symbol.iterator](); !(a = (r = l.next()).done); a = !0) {
                            var h = r.value;
                            n.push({
                                figurePreset: h,
                                figurePositions: this.findFigurePositions(h, t, e.Settings.GENERATE_MAX_POSITIONS_FOR_EACH_FIGURE)
                            })
                        }
                    } catch (e) {
                        s = !0, o = e
                    } finally {
                        try {
                            a || null == l.return || l.return()
                        } finally {
                            if (s) throw o
                        }
                    }
                    return i ? Phaser.ArrayUtils.shuffle(n) : n
                }
            }, {
                key: "findFiguresAtPosition",
                value: function(e, t) {
                    var i = [],
                        n = !0,
                        a = !1,
                        s = void 0;
                    try {
                        for (var o, r = this.figurePresets[Symbol.iterator](); !(n = (o = r.next()).done); n = !0) {
                            var l = o.value;
                            t.couldBePlaced(l, e) && i.push(l)
                        }
                    } catch (e) {
                        a = !0, s = e
                    } finally {
                        try {
                            n || null == r.return || r.return()
                        } finally {
                            if (a) throw s
                        }
                    }
                    return i
                }
            }, {
                key: "findFigurePositions",
                value: function(e, t, i) {
                    var n = [],
                        a = !0,
                        s = !1,
                        o = void 0;
                    try {
                        for (var r, l = Phaser.ArrayUtils.shuffle([0, 1, 2, 3, 4, 5, 6, 7])[Symbol.iterator](); !(a = (r = l.next()).done); a = !0) {
                            var h = r.value,
                                u = !0,
                                c = !1,
                                d = void 0;
                            try {
                                for (var g, p = Phaser.ArrayUtils.shuffle([0, 1, 2, 3, 4, 5, 6, 7])[Symbol.iterator](); !(u = (g = p.next()).done); u = !0) {
                                    var v = g.value;
                                    if (t.couldBePlaced(e, {
                                            x: h,
                                            y: v
                                        }) && (n.push({
                                            x: h,
                                            y: v
                                        }), n.length >= i)) return n
                                }
                            } catch (e) {
                                c = !0, d = e
                            } finally {
                                try {
                                    u || null == p.return || p.return()
                                } finally {
                                    if (c) throw d
                                }
                            }
                        }
                    } catch (e) {
                        s = !0, o = e
                    } finally {
                        try {
                            a || null == l.return || l.return()
                        } finally {
                            if (s) throw o
                        }
                    }
                    return n
                }
            }, {
                key: "getCopy",
                value: function(e) {
                    return e.map(function(e) {
                        return e.getCopy()
                    })
                }
            }]), i
        }();
        e.FigureService = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(e) {
                var t;
                return _classCallCheck(this, i), (t = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e))).level.eventManager.onLinesDestroyed.add(t.dispatchLinesDestroyed, _assertThisInitialized(t)), t
            }
            return _inherits(i, e.AbstractService), _createClass(i, [{
                key: "dispatchLinesDestroyed",
                value: function(e, t) {
                    if (e >= 2) {
                        var i = t.reduce(function(e, t) {
                                return e + t.x
                            }, 0) / t.length,
                            n = t.reduce(function(e, t) {
                                return e + t.y
                            }, 0) / t.length,
                            a = this.level.boardManager.getBoard().getCellAt(Math.floor(i), Math.floor(n)).position;
                        this.displayInscription(e, a.x, a.y)
                    }
                }
            }, {
                key: "displayInscription",
                value: function(t, i, n) {
                    var a = e.InscriptionLevel.AWESOME;
                    switch (t) {
                        case 2:
                            a = e.InscriptionLevel.GOOD;
                            break;
                        case 3:
                            a = e.InscriptionLevel.GREAT;
                            break;
                        case 4:
                            a = e.InscriptionLevel.EXCELLENT;
                            break;
                        case 5:
                            a = e.InscriptionLevel.AWESOME
                    }
                    this.level.boardManager.getBoard().effectsContainer.add(new e.InscriptionEffect(a, i, n))
                }
            }, {
                key: "displayScoresEffect",
                value: function(t, i, n) {
                    new e.ScoresEffect(this.level, t * e.ScoreManager.instance.getMultiplier(), i, Math.max(n, -150), 50), e.ScoreManager.instance.addScores(t)
                }
            }]), i
        }();
        e.InscriptionsService = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i() {
                return _classCallCheck(this, i), _possibleConstructorReturn(this, _getPrototypeOf(i).apply(this, arguments))
            }
            return _inherits(i, e.AbstractService), _createClass(i, [{
                key: "getFigureDraggingDelta",
                value: function(t) {
                    return e.App.instance.device.desktop ? {
                        x: 0,
                        y: 0
                    } : e.CustomScaleManager.isPortrait() ? {
                        x: 0,
                        y: e.Settings.FIGURE_VIEW_DRAGGING_DELTA
                    } : {
                        x: e.Settings.FIGURE_VIEW_DRAGGING_DELTA,
                        y: -30 * t
                    }
                }
            }, {
                key: "getPowerupDraggingDelta",
                value: function() {
                    return e.App.instance.device.desktop ? {
                        x: 0,
                        y: 0
                    } : (e.CustomScaleManager.isPortrait(), {
                        x: 0,
                        y: e.Settings.POWERUP_DRAGGING_DELTA
                    })
                }
            }, {
                key: "getAvailableBoardBounds",
                value: function() {
                    if (e.CustomScaleManager.isPortrait()) {
                        var t = this.level.windowBounds.getBounds(0, 1, .12, .75),
                            i = t.minX,
                            n = t.maxX,
                            a = t.minY,
                            s = t.maxY;
                        return new Phaser.Rectangle((i + n) / 2, (a + s) / 2, n - i, s - a)
                    }
                    if (e.CustomScaleManager.isSquared()) {
                        var o = this.level.windowBounds.getBounds(0, .75, .15, 1),
                            r = o.minX,
                            l = o.maxX,
                            h = o.minY,
                            u = o.maxY;
                        return new Phaser.Rectangle((r + l) / 2, (h + u) / 2, l - r, u - h)
                    }
                    if (e.CustomScaleManager.isLandscape()) {
                        var c = this.level.windowBounds.getBounds(.2, .8, 0, 1),
                            d = c.minX,
                            g = c.maxX,
                            p = c.minY,
                            v = c.maxY;
                        return new Phaser.Rectangle((d + g) / 2, (p + v) / 2, g - d, v - p)
                    }
                }
            }, {
                key: "getAvailableFiguresPanelBounds",
                value: function() {
                    if (e.CustomScaleManager.isPortrait()) {
                        var t = this.level.windowBounds.getBounds(0, 1, .75, .94),
                            i = t.minX,
                            n = t.maxX,
                            a = t.minY,
                            s = (t.maxY, this.level.boardManager.getBoardBounds(this.level.container), 5 * this.level.boardManager.getBoardBounds(this.level.container).width / 15);
                        return a = this.level.boardManager.getBoardBounds(this.level.container, !1).bottom, new Phaser.Rectangle((i + n) / 2, a + s / 2, n - i, s)
                    }
                    if (e.CustomScaleManager.isSquared()) {
                        var o = this.level.windowBounds.getBounds(.75, 1, .15, .87),
                            r = o.minX,
                            l = o.maxX,
                            h = o.minY,
                            u = o.maxY;
                        return r = this.level.boardManager.getBoardBounds(this.level.container).right, new Phaser.Rectangle((r + l) / 2, (h + u) / 2, l - r, u - h)
                    }
                    if (e.CustomScaleManager.isLandscape()) {
                        var c = this.level.windowBounds.getBounds(.8, 1, .16, 1),
                            d = c.minX,
                            g = c.maxX,
                            p = c.minY,
                            v = c.maxY;
                        return d = this.level.boardManager.getBoardBounds(this.level.container).right, new Phaser.Rectangle((d + g) / 2, (p + v) / 2, g - d, v - p)
                    }
                }
            }, {
                key: "getAvailableUIContainerBounds",
                value: function() {
                    if (e.CustomScaleManager.isPortrait()) {
                        var t = this.level.windowBounds.getBounds(0, 1, 0, .15),
                            i = t.minX,
                            n = t.maxX,
                            a = t.minY,
                            s = t.maxY;
                        return s = this.level.boardManager.getBoardBounds(this.level.container).top, new Phaser.Rectangle((i + n) / 2, (a + s) / 2, n - i, s - a)
                    }
                    if (e.CustomScaleManager.isSquared()) {
                        var o = this.level.windowBounds.getBounds(0, 1, 0, .15),
                            r = o.minX,
                            l = o.maxX,
                            h = o.minY,
                            u = o.maxY;
                        return u = this.level.boardManager.getBoardBounds(this.level.container).top, new Phaser.Rectangle((r + l) / 2, (h + u) / 2, l - r, u - h)
                    }
                    if (e.CustomScaleManager.isLandscape()) {
                        var c = this.level.windowBounds.getBounds(0, .2, .25, .72),
                            d = c.minX,
                            g = c.maxX,
                            p = c.minY,
                            v = c.maxY;
                        return g = this.level.boardManager.getBoardBounds(this.level.container).left, new Phaser.Rectangle((d + g) / 2, (p + v) / 2, g - d, v - p)
                    }
                }
            }, {
                key: "getFigureDisposingTweenParams",
                value: function() {
                    return e.CustomScaleManager.isPortrait() ? {
                        y: "+75",
                        alpha: 0
                    } : {
                        x: "+75",
                        alpha: 0
                    }
                }
            }, {
                key: "getAvailablePowerupsContainerBounds",
                value: function() {
                    if (e.CustomScaleManager.isPortrait()) {
                        var t = this.level.windowBounds.getBounds(0, 1, .9, 1),
                            i = t.minX,
                            n = t.maxX,
                            a = t.minY,
                            s = t.maxY;
                        return a = this.getAvailableFiguresPanelBounds().y + this.getAvailableFiguresPanelBounds().height / 2, new Phaser.Rectangle((i + n) / 2, (a + s) / 2, n - i, s - a)
                    }
                    if (e.CustomScaleManager.isSquared()) {
                        var o = this.level.windowBounds.getBounds(.8, 1, .88, .97),
                            r = o.minX,
                            l = o.maxX,
                            h = o.minY,
                            u = o.maxY;
                        return r = this.level.boardManager.getBoardBounds(this.level.container, !1).right, new Phaser.Rectangle((r + l) / 2, (h + u) / 2, l - r, u - h)
                    }
                    if (e.CustomScaleManager.isLandscape()) {
                        var c = this.level.windowBounds.getBounds(0, .2, .86, .94),
                            d = c.minX,
                            g = c.maxX,
                            p = c.minY,
                            v = c.maxY;
                        return g = this.level.boardManager.getBoardBounds(this.level.container, !1).left, new Phaser.Rectangle((d + g) / 2, (p + v) / 2, g - d, v - p)
                    }
                }
            }]), i
        }();
        e.LayoutService = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t) {
                var n;
                return _classCallCheck(this, i), (n = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, t))).currentStarGenerationProbability = 0, n.currentStarGenerationProbability = e.Settings.BASIC_STAR_GENERATION_PROBABILITY, n.level.eventManager.onLinesDestroyed.add(n.dispatchLinesDestroyed, _assertThisInitialized(n)), n.level.eventManager.onMoveFinished.add(n.dispatchMoveFinished, _assertThisInitialized(n)), n
            }
            return _inherits(i, e.AbstractService), _createClass(i, [{
                key: "dispatchMoveFinished",
                value: function(t) {
                    t < e.Settings.SKIP_STARS_GENERATION_FOR_FIRST_X_MOVES || (Math.random() < this.currentStarGenerationProbability ? this.level.boardManager.getBoard().getNumStarsOnTheBoard() < e.Settings.MAX_STARS_ON_BOARD_SIMULTANEOUSLY && (this.currentStarGenerationProbability = e.Settings.BASIC_STAR_GENERATION_PROBABILITY, this.generateRandomStar(e.Settings.STAR_GENERATION_DELAY), Math.random() < e.Settings.ADDITIONAL_SECOND_STAR_GENERATION_PROBABILITY && this.generateRandomStar(1.5 * e.Settings.STAR_GENERATION_DELAY)) : this.currentStarGenerationProbability = Phaser.Math.clamp(this.currentStarGenerationProbability + e.Settings.BASIC_STAR_GENERATION_PROBABILITY_STEP, 0, e.Settings.MAX_STAR_GENERATING_PROBABILITY))
                }
            }, {
                key: "dispatchLinesDestroyed",
                value: function(e) {}
            }, {
                key: "generateRandomStar",
                value: function(t) {
                    var i = this;
                    e.App.instance.time.events.add(t, function() {
                        if (i.level.gameStateManager.isGameActive()) {
                            var e = i.level.boardManager.getBoard().getCells().filter(function(e) {
                                return e && !e.isEmpty() && !e.getBlock().hasStar()
                            });
                            e.length > 0 && Phaser.ArrayUtils.getRandomItem(e).getBlock().addStar(i.level)
                        }
                    })
                }
            }]), i
        }();
        e.StarsService = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t, n) {
                var a;
                return _classCallCheck(this, i), (a = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, t.game))).isReady = !1, a.figure = t, a.level = t.level, a.viewDeltaX = -a.figure.figureWidth / 2 + .5, a.viewDeltaY = -a.figure.figureHeight / 2 + .5, a.createBlocks(n), a.tweenScale(e.Settings.DEFAULT_FIGURE_SCALE, !1, 0), a
            }
            return _inherits(i, Phaser.Group), _createClass(i, [{
                key: "createBlocks",
                value: function(t) {
                    var i = this;
                    this.blocks = t.getCells().map(function(t) {
                        return i.add(new e.Block(t, i.figure.color))
                    })
                }
            }, {
                key: "alignBlocks",
                value: function() {
                    var t = this;
                    this.blocks.forEach(function(i) {
                        return i.position.set((i.posX + t.viewDeltaX) * e.Settings.CELL_WIDTH, (i.posY + t.viewDeltaY) * e.Settings.CELL_HEIGHT)
                    })
                }
            }, {
                key: "getBlocks",
                value: function() {
                    return this.blocks
                }
            }, {
                key: "getFirstBlock",
                value: function() {
                    return this.blocks[0]
                }
            }, {
                key: "playAppearingTween",
                value: function(t) {
                    var i = this;
                    this.scale.set(0), this.game.add.tween(this.scale).to({
                        x: 1,
                        y: 1
                    }, e.Settings.FIGURE_APPEARING_DURATION, Phaser.Easing.Back.Out, !0, t).onComplete.add(function() {
                        return i.isReady = !0
                    })
                }
            }, {
                key: "tweenScale",
                value: function(t, i, n) {
                    var a = this,
                        s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1,
                        o = t * s,
                        r = 1 * s;
                    this.blocks.forEach(function(t) {
                        a.game.tweens.removeFrom(t, !1), a.game.tweens.removeFrom(t.scale, !1), n > 0 ? (a.game.add.tween(t.scale).to({
                            x: o,
                            y: o
                        }, n, Phaser.Easing.Sinusoidal.In, !0), a.game.add.tween(t).to({
                            x: (t.posX + a.viewDeltaX) * e.Settings.CELL_WIDTH * (i ? r : o),
                            y: (t.posY + a.viewDeltaY) * e.Settings.CELL_HEIGHT * (i ? r : o)
                        }, n, Phaser.Easing.Sinusoidal.In, !0)) : (t.scale.set(o), t.position.set((t.posX + a.viewDeltaX) * e.Settings.CELL_WIDTH * (i ? r : o), (t.posY + a.viewDeltaY) * e.Settings.CELL_HEIGHT * (i ? r : o)))
                    })
                }
            }]), i
        }();
        e.FigureView = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function() {
            function t() {
                _classCallCheck(this, t), this.onPowerupBought = new Phaser.Signal, this.powerupStates = new Map, this.powerupStates.set(e.PowerupType.BOMB, !1), this.powerupStates.set(e.PowerupType.LIGHTNING, !1), this.powerupPrices = new Map, this.powerupPrices.set(e.PowerupType.BOMB, e.Settings.BOMB_PRICE), this.powerupPrices.set(e.PowerupType.LIGHTNING, e.Settings.LIGHTNING_PRICE), this.powerupPriceSteps = new Map, this.powerupPriceSteps.set(e.PowerupType.BOMB, e.Settings.BOMB_PRICE_STEP), this.powerupPriceSteps.set(e.PowerupType.LIGHTNING, e.Settings.LIGHTNING_PRICE_STEP)
            }
            return _createClass(t, [{
                key: "setInitialState",
                value: function(e, t) {
                    this.powerupStates.set(e, t)
                }
            }, {
                key: "isBought",
                value: function(e) {
                    return this.powerupStates.get(e) || !1
                }
            }, {
                key: "resetPrices",
                value: function() {
                    this.powerupPrices.set(e.PowerupType.BOMB, e.Settings.BOMB_PRICE), this.powerupPrices.set(e.PowerupType.LIGHTNING, e.Settings.LIGHTNING_PRICE)
                }
            }, {
                key: "buy",
                value: function(t) {
                    this.powerupStates.set(t, !0), e.StarsManager.instance.setStarsAmount(e.StarsManager.instance.getStarsAmount() - this.getPrice(t)), this.onPowerupBought.dispatch(t), e.LocalStorageController.instance.save(), this.powerupPrices.set(t, this.powerupPrices.get(t) + this.powerupPriceSteps.get(t))
                }
            }, {
                key: "usePowerup",
                value: function(t) {
                    this.powerupStates.set(t, !1), e.LocalStorageController.instance.save()
                }
            }, {
                key: "getPrice",
                value: function(e) {
                    return this.powerupPrices.get(e) || Number.MAX_SAFE_INTEGER
                }
            }, {
                key: "hasUnboughtPowerups",
                value: function() {
                    var e = !1;
                    return this.powerupStates.forEach(function(t, i) {
                        t || (e = !0)
                    }), e
                }
            }, {
                key: "hasBoughtPowerups",
                value: function() {
                    var e = !1;
                    return this.powerupStates.forEach(function(t, i) {
                        t && (e = !0)
                    }), e
                }
            }], [{
                key: "instance",
                get: function() {
                    return t._instance ? t._instance : t._instance = new t
                }
            }]), t
        }();
        t._instance = null, e.PowerupManager = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function() {
            function t() {
                _classCallCheck(this, t), this.currentMultiplier = 1, this.maxScores = 0, this.prevMaxScores = 0, this.currentScore = 0, this.lastRoundScores = 0, this.roundNumber = 0, this.onScoreChanges = new Phaser.Signal, this.onMultiplierChanges = new Phaser.Signal
            }
            return _createClass(t, [{
                key: "reset",
                value: function() {
                    this.currentScore = 0, this.currentMultiplier = 1
                }
            }, {
                key: "getCurrentScores",
                value: function() {
                    return ~~this.currentScore
                }
            }, {
                key: "addScores",
                value: function(t) {
                    this.lastRoundScores = t * this.getMultiplier(), this.currentScore += this.lastRoundScores, 0 != t && (this.currentMultiplier = this.calculateMultiplier(), this.onScoreChanges.dispatch(this.getCurrentScores()), this.onMultiplierChanges.dispatch(this.getMultiplier(), this.getMultiplierProgress()), e.AchievementsManager.instance.addValue(e.AchievementType.TOTAL_SCORES, this.lastRoundScores), e.AchievementsManager.instance.setValue(e.AchievementType.BEST_SCORE_REACHED, this.getCurrentScores()), e.Analytics.instance.updateLevelData({
                        score: this.getCurrentScores()
                    }))
                }
            }, {
                key: "startRound",
                value: function() {
                    this.roundNumber++
                }
            }, {
                key: "getRoundNumber",
                value: function() {
                    return this.roundNumber
                }
            }, {
                key: "isFirstRound",
                value: function() {
                    return this.roundNumber <= 1
                }
            }, {
                key: "calculateMultiplier",
                value: function() {
                    for (var t = this.getCurrentScores(), i = 0; i < e.Settings.MULTIPLIER_MILESTONES.length; i++)
                        if (e.Settings.MULTIPLIER_MILESTONES[i] > t) return i + 1;
                    return e.Settings.MULTIPLIER_MILESTONES.length
                }
            }, {
                key: "getMultiplier",
                value: function() {
                    return this.currentMultiplier
                }
            }, {
                key: "getMultiplierProgress",
                value: function() {
                    return this.currentMultiplier >= 2 ? (this.getCurrentScores() - e.Settings.MULTIPLIER_MILESTONES[this.currentMultiplier - 2]) / (e.Settings.MULTIPLIER_MILESTONES[this.currentMultiplier - 1] - e.Settings.MULTIPLIER_MILESTONES[this.currentMultiplier - 2]) : this.getCurrentScores() / e.Settings.MULTIPLIER_MILESTONES[this.currentMultiplier - 1]
                }
            }, {
                key: "getMaxScores",
                value: function() {
                    return this.maxScores
                }
            }, {
                key: "getPrevMaxScores",
                value: function() {
                    return this.prevMaxScores
                }
            }, {
                key: "setMaxScores",
                value: function(e) {
                    this.maxScores = Math.max(this.maxScores, e), this.prevMaxScores = this.maxScores
                }
            }, {
                key: "updateMaxScores",
                value: function(t) {
                    return t > this.maxScores && (this.prevMaxScores = this.maxScores, this.maxScores = t, e.LocalStorageController.instance.save(), !0)
                }
            }, {
                key: "removeListeners",
                value: function() {
                    this.onScoreChanges.removeAll(), this.onMultiplierChanges.removeAll()
                }
            }], [{
                key: "instance",
                get: function() {
                    return t._instance ? t._instance : t._instance = new t
                }
            }]), t
        }();
        t._instance = null, e.ScoreManager = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function() {
            function t() {
                _classCallCheck(this, t), this.numStars = 0, this.lastRoundStars = 0, this.onStarAdded = new Phaser.Signal, this.onStarsAmountChanged = new Phaser.Signal
            }
            return _createClass(t, [{
                key: "reset",
                value: function() {
                    this.lastRoundStars = 0
                }
            }, {
                key: "getLastRoundStars",
                value: function() {
                    return this.lastRoundStars
                }
            }, {
                key: "getStarsAmount",
                value: function() {
                    return this.numStars
                }
            }, {
                key: "setStarsAmount",
                value: function(t) {
                    var i = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                    this.numStars = t, this.onStarsAmountChanged.dispatch(this.getStarsAmount()), i && e.LocalStorageController.instance.save()
                }
            }, {
                key: "addBonusStars",
                value: function(t) {
                    this.setStarsAmount(this.getStarsAmount() + t), this.lastRoundStars += t, e.AchievementsManager.instance.addValue(e.AchievementType.TOTAL_STARS, t), e.Analytics.instance.updateLevelData({
                        stars: this.getStarsAmount()
                    })
                }
            }, {
                key: "pickupStars",
                value: function(t) {
                    var i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    this.setStarsAmount(this.getStarsAmount() + t), i || (this.lastRoundStars += t), e.AchievementsManager.instance.addValue(e.AchievementType.TOTAL_STARS, t), e.Analytics.instance.updateLevelData({
                        stars: this.getStarsAmount()
                    }), this.onStarAdded.dispatch(this.getStarsAmount()), e.LocalStorageController.instance.save()
                }
            }, {
                key: "removeListeners",
                value: function() {}
            }], [{
                key: "instance",
                get: function() {
                    return t._instance ? t._instance : t._instance = new t
                }
            }]), t
        }();
        t._instance = null, e.StarsManager = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function() {
            function t() {
                _classCallCheck(this, t), this.currentMusicVolume = e.Settings.MUSIC_ENABLED_BY_DEFAULT ? .4 : 0, this.currentSFXVolume = .5, this.currentBlockDestroyingSoundIndex = 0, this.hadBeenMutedBeforePauseTriggered = !1, this.debouncedSoundsTimestamps = new Map, this.melodyNames = ["melody"], this.soundNames = ["click", "error", "counting", "panel", "panelUp", "figureTap", "figureRelease", "figureFail", "starAppear", "starReceived", "good", "great", "excellent", "awesome", "buying", "match1", "match2", "match3", "match4", "match5", "match6", "match7", "block", "revive", "lose", "stamp", "heartbeat", "levelUp", "reward", "achievement", "fire", "bomb", "lighting"]
            }
            return _createClass(t, [{
                key: "isDecodingSupported",
                value: function() {
                    return e.App.instance.sound.usingWebAudio
                }
            }, {
                key: "getSFXNames",
                value: function() {
                    return this.soundNames
                }
            }, {
                key: "getSoundNames",
                value: function() {
                    return this.melodyNames.slice().concat(this.soundNames)
                }
            }, {
                key: "init",
                value: function() {}
            }, {
                key: "startMusic",
                value: function() {
                    this.mainTheme = e.App.instance.sound.play("melody", this.currentMusicVolume, !0)
                }
            }, {
                key: "pauseAudio",
                value: function() {
                    this.hadBeenMutedBeforePauseTriggered = e.App.instance.sound.mute, e.App.instance.sound.mute = !0
                }
            }, {
                key: "resumeAudio",
                value: function() {
                    e.App.instance.sound.mute = this.hadBeenMutedBeforePauseTriggered
                }
            }, {
                key: "addSuspendedContextRestoreHandler",
                value: function() {
                    "ontouchstart" in window && e.App.instance.sound.usingWebAudio && (gradle.event("Adding context resume handler..."), document.querySelector("canvas").addEventListener("touchstart", function() {
                        "suspended" === e.App.instance.sound.context.state && (gradle.event("Resuming suspended context..."), e.App.instance.sound.context.resume().then(function() {
                            gradle.event("Playback resumed successfully")
                        }))
                    }))
                }
            }, {
                key: "getMusicVolume",
                value: function() {
                    return this.currentMusicVolume
                }
            }, {
                key: "setMusicVolume",
                value: function(e) {
                    this.currentMusicVolume = Phaser.Math.clamp(e, 0, 1), this.mainTheme && this.mainTheme.isPlaying && (this.mainTheme.volume = this.currentMusicVolume)
                }
            }, {
                key: "getSFXVolume",
                value: function() {
                    return this.currentSFXVolume
                }
            }, {
                key: "setSFXVolume",
                value: function(e) {
                    this.currentSFXVolume = Phaser.Math.clamp(e, 0, 1)
                }
            }, {
                key: "playClickSound",
                value: function() {
                    this.playSound("click")
                }
            }, {
                key: "playPanelMovementSound",
                value: function() {
                    this.playSound("panel")
                }
            }, {
                key: "playPanelUpMovementSound",
                value: function() {
                    this.playSound("panelUp")
                }
            }, {
                key: "playFigurePickupSound",
                value: function() {
                    this.playSound("figureTap")
                }
            }, {
                key: "playFigurePlaceSound",
                value: function() {
                    this.playSound("figureRelease")
                }
            }, {
                key: "playFigureFailSound",
                value: function() {
                    this.playSound("figureFail")
                }
            }, {
                key: "playStarAppearSound",
                value: function() {
                    this.playSound("starAppear")
                }
            }, {
                key: "playStarReceivedSound",
                value: function() {
                    this.playSound("starReceived")
                }
            }, {
                key: "playBuyingSound",
                value: function() {
                    this.playSound("buying")
                }
            }, {
                key: "playBlockSound",
                value: function() {
                    this.playSound("block", .8)
                }
            }, {
                key: "playReviveSound",
                value: function() {
                    this.playSound("revive", .6)
                }
            }, {
                key: "playStampSound",
                value: function() {
                    this.playSound("stamp")
                }
            }, {
                key: "playErrorSound",
                value: function() {
                    this.playSound("error")
                }
            }, {
                key: "playLoseSound",
                value: function() {
                    var t = this;
                    e.App.instance.time.events.add(70, function() {
                        return t.playSound("lose", .7)
                    })
                }
            }, {
                key: "playHeartBeatSound",
                value: function() {
                    this.playSound("heartbeat", 1)
                }
            }, {
                key: "playlevelUpSound",
                value: function() {
                    this.playSound("levelUp", .5)
                }
            }, {
                key: "playAchievementClaimedSound",
                value: function() {
                    this.playSound("achievement", .8)
                }
            }, {
                key: "playRewardClaimedSound",
                value: function() {
                    this.playSound("reward", .8)
                }
            }, {
                key: "playExplosionSound",
                value: function() {
                    this.playSound("bomb", .8), this.playSound("fire", .8)
                }
            }, {
                key: "playLightningSound",
                value: function() {
                    this.playSound("lighting", .8)
                }
            }, {
                key: "playNextLineDestroyingSound",
                value: function(t) {
                    var i = this;
                    this.playSound("match" + (this.currentBlockDestroyingSoundIndex++ % 7 + 1)), this.playSound("block"), t > 1 && e.App.instance.time.events.add(100, function() {
                        return i.playSound("block")
                    })
                }
            }, {
                key: "playInscriptionSound",
                value: function(t) {
                    switch (t) {
                        case e.InscriptionLevel.GOOD:
                            this.playSound("good", .6);
                            break;
                        case e.InscriptionLevel.GREAT:
                            this.playSound("great", .6);
                            break;
                        case e.InscriptionLevel.AWESOME:
                            this.playSound("awesome", .6);
                            break;
                        case e.InscriptionLevel.EXCELLENT:
                            this.playSound("excellent", .6)
                    }
                }
            }, {
                key: "playSound",
                value: function(t) {
                    var i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .5,
                        n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                    e.App.instance.sound.usingWebAudio && "suspended" === e.App.instance.sound.context.state || e.App.instance.sound.play(t, i * this.currentSFXVolume, n)
                }
            }, {
                key: "startCountingSound",
                value: function() {
                    this.countingSound && this.stopCountingSound(), this.countingSound = e.App.instance.add.sound("counting", .55, !0), this.countingSound.play()
                }
            }, {
                key: "stopCountingSound",
                value: function() {
                    this.countingSound && (this.countingSound.isPlaying && this.countingSound.stop(), this.countingSound.destroy()), this.countingSound = null
                }
            }, {
                key: "debounceSound",
                value: function(e, t, i) {
                    var n = (new Date).getTime();
                    n - (this.debouncedSoundsTimestamps.get(e) || 0) >= i && (this.playSound(e, t, !1), this.debouncedSoundsTimestamps.set(e, n))
                }
            }, {
                key: "chokeMusicVolume",
                value: function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 500;
                    this.mainTheme && this.mainTheme.fadeTo(e, this.currentMusicVolume > 0 ? Math.min(.1, this.currentMusicVolume / 3) : 0)
                }
            }, {
                key: "restoreMusicVolume",
                value: function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 500;
                    this.mainTheme && this.mainTheme.fadeTo(e, this.currentMusicVolume)
                }
            }], [{
                key: "instance",
                get: function() {
                    return t._instance ? t._instance : t._instance = new t
                }
            }]), t
        }();
        t._instance = null, e.SoundController = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function n() {
                return _classCallCheck(this, n), _possibleConstructorReturn(this, _getPrototypeOf(n).apply(this, arguments))
            }
            return _inherits(n, Phaser.State), _createClass(n, [{
                key: "init",
                value: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : e.CustomScaleManager.ORIGINAL_WIDTH,
                        a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e.CustomScaleManager.ORIGINAL_HEIGHT;
                    _get(_getPrototypeOf(n.prototype), "init", this).call(this), this.isInitialized = !1, this.containerWidth = t, this.containerHeight = a, this.container = this.add.existing(this.game.make.group(null)), this.originalBounds = new i, this.originalBounds.set(0, e.CustomScaleManager.ORIGINAL_WIDTH, 0, e.CustomScaleManager.ORIGINAL_HEIGHT), this.resize()
                }
            }, {
                key: "create",
                value: function() {
                    this.isInitialized = !0
                }
            }, {
                key: "addChild",
                value: function(e) {
                    return this.container.add(e)
                }
            }, {
                key: "getInputPosition",
                value: function() {
                    return new Phaser.Point((this.game.input.activePointer.x - this.container.x) / e.CustomScaleManager.SCALE_X, (this.game.input.activePointer.y - this.container.y) / e.CustomScaleManager.SCALE_Y)
                }
            }, {
                key: "translateInputPosition",
                value: function(t) {
                    return new Phaser.Point((t.x - this.container.x) / e.CustomScaleManager.SCALE_X, (t.y - this.container.y) / e.CustomScaleManager.SCALE_Y)
                }
            }, {
                key: "resize",
                value: function() {
                    arguments.length > 0 && void 0 !== arguments[0] && arguments[0], arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    this.container.scale.set(e.CustomScaleManager.SCALE_X, e.CustomScaleManager.SCALE_Y), this.container.position.set(e.CustomScaleManager.WIDTH / 2 - this.containerWidth * e.CustomScaleManager.SCALE_X / 2, e.CustomScaleManager.HEIGHT / 2 - this.containerHeight * e.CustomScaleManager.SCALE_Y / 2), this.windowBounds = this.windowBounds || new i, this.windowBounds.set(-(e.CustomScaleManager.WIDTH / e.CustomScaleManager.SCALE_X - this.containerWidth) / 2, (e.CustomScaleManager.WIDTH / e.CustomScaleManager.SCALE_X - this.containerWidth) / 2 + this.containerWidth, -(e.CustomScaleManager.HEIGHT / e.CustomScaleManager.SCALE_Y - this.containerHeight) / 2, (e.CustomScaleManager.HEIGHT / e.CustomScaleManager.SCALE_Y - this.containerHeight) / 2 + this.containerHeight)
                }
            }, {
                key: "shutdown",
                value: function() {
                    this.container.destroy(), this.container = null
                }
            }]), n
        }();
        e.AutoResizeableState = t;
        var i = function() {
            function e() {
                _classCallCheck(this, e), this.set(0, 0, 0, 0)
            }
            return _createClass(e, [{
                key: "set",
                value: function(e, t, i, n) {
                    this.left = e, this.right = t, this.top = i, this.down = n, this.x = e, this.y = i, this.width = t - e, this.height = n - i, this.centerX = (t + e) / 2, this.centerY = (n + i) / 2
                }
            }, {
                key: "getPosition",
                value: function(e, t) {
                    var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                        n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
                    return new Phaser.Point(this.left + e * this.width + i, this.top + t * this.height + n)
                }
            }, {
                key: "getBounds",
                value: function(e, t, i, n) {
                    return {
                        minX: this.left + e * this.width,
                        maxX: this.left + t * this.width,
                        minY: this.top + i * this.height,
                        maxY: this.top + n * this.height
                    }
                }
            }]), e
        }();
        e.WindowBounds = i
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i() {
                return _classCallCheck(this, i), _possibleConstructorReturn(this, _getPrototypeOf(i).apply(this, arguments))
            }
            return _inherits(i, Phaser.State), _createClass(i, [{
                key: "init",
                value: function() {
                    this.game.scale.scaleMode = e.CustomScaleManager.getScaleMode(), this.game.scale.fullScreenScaleMode = e.CustomScaleManager.getScaleMode(), this.game.scale.pageAlignHorizontally = !0, this.game.scale.pageAlignVertically = !0, this.game.device.android && (this.game.input.mouse.enabled = !this.game.device.mspointer), this.game.scale.setResizeCallback(this.resizeCallback, this), this.game.scale.onSizeChange.add(this.sizeChanged, this), this.stage.disableVisibilityChange = !0, e.Analytics.instance.initUser(), e.SoundController.instance.addSuspendedContextRestoreHandler()
                }
            }, {
                key: "preload",
                value: function() {
                    this.game.load.atlasJSONArray(e.Settings.PRELOADER_ATLAS, "img/" + e.Settings.PRELOADER_ATLAS + ".png", "img/" + e.Settings.PRELOADER_ATLAS + ".json"), this.game.load.json("l10n", "lang/texts.json")
                }
            }, {
                key: "create",
                value: function() {
                    this.input.maxPointers = 1, this.game.device.desktop && (this.game.canvas.oncontextmenu = function(e) {
                        e.preventDefault()
                    }), e.LocalizationManager.init(this.game.cache.getJSON("l10n")), this.game.state.start("Preloader", !0, !1)
                }
            }, {
                key: "resizeCallback",
                value: function(t, i) {
                    e.CustomScaleManager.getScaleMode() == Phaser.ScaleManager.USER_SCALE && (this.game.width == window.innerWidth * e.CustomScaleManager.getPixelRatio() && this.game.height == window.innerHeight * e.CustomScaleManager.getPixelRatio() || (t.setGameSize(window.innerWidth * e.CustomScaleManager.getPixelRatio(), window.innerHeight * e.CustomScaleManager.getPixelRatio()), t.setUserScale(1 / e.CustomScaleManager.getPixelRatio(), 1 / e.CustomScaleManager.getPixelRatio())))
                }
            }, {
                key: "sizeChanged",
                value: function(t, i, n) {
                    var a = this.game.device.android && window.visualViewport && window.visualViewport.width && window.visualViewport.height ? new Phaser.Rectangle(0, 0, Math.min(i, window.visualViewport.width), Math.min(n, window.visualViewport.height)) : new Phaser.Rectangle(0, 0, window.innerWidth, window.innerHeight);
                    e.CustomScaleManager.update(a.width * e.CustomScaleManager.getPixelRatio(), a.height * e.CustomScaleManager.getPixelRatio())
                }
            }]), i
        }();
        e.Boot = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i() {
                return _classCallCheck(this, i), _possibleConstructorReturn(this, _getPrototypeOf(i).apply(this, arguments))
            }
            return _inherits(i, e.AutoResizeableState), _createClass(i, [{
                key: "create",
                value: function() {
                    e.ScoreManager.instance.reset(), e.ScoreManager.instance.startRound(), e.StarsManager.instance.reset(), e.PowerupManager.instance.resetPrices(), e.Analytics.instance.startLevel(), e.Settings.ENABLE_API && (gradle.event('SCREEN_LEVEL'), e.Settings.TUTORIAL_COMPLETED || gradle.event('SCREEN_TUTORIAL')), e.Analytics.instance.startLevel(), this.createChildren(), this.resize(this.game.width, this.game.height)
                }
            }, {
                key: "createChildren",
                value: function() {
                    _get(_getPrototypeOf(i.prototype), "create", this).call(this), this.eventManager = this.addChild(new e.EventManager(this)), this.dataManager = this.addChild(new e.DataManager(this)), this.serviceManager = this.addChild(new e.ServiceManager(this)), this.gameStateManager = this.addChild(new e.GameStateManager(this)), this.boardManager = this.addChild(new e.BoardManager(this)), this.figureManager = this.addChild(new e.FigureManager(this)), this.uiManager = this.addChild(new e.UIManager(this)), this.tutorialManager = this.addChild(new e.TutorialManager(this)), this.resize(this.game.width, this.game.height)
                }
            }, {
                key: "resize",
                value: function(e, t) {
                    _get(_getPrototypeOf(i.prototype), "resize", this).call(this, e, t), this.isInitialized && (this.eventManager.resize(), this.dataManager.resize(), this.gameStateManager.resize(), this.serviceManager.resize(), this.boardManager.resize(), this.figureManager.resize(), this.uiManager.resize(), this.tutorialManager.resize())
                }
            }, {
                key: "shutdown",
                value: function() {
                    e.ScoreManager.instance.removeListeners(), e.StarsManager.instance.removeListeners(), this.eventManager.destroy(), this.eventManager = null, this.dataManager.destroy(), this.dataManager = null, this.gameStateManager.destroy(), this.gameStateManager = null, this.serviceManager.destroy(), this.serviceManager = null, this.figureManager.destroy(), this.figureManager = null, this.boardManager.destroy(), this.boardManager = null, this.uiManager.destroy(), this.uiManager = null, this.tutorialManager.destroy(), this.tutorialManager = null, _get(_getPrototypeOf(i.prototype), "shutdown", this).call(this)
                }
            }]), i
        }();
        e.Level = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i() {
                return _classCallCheck(this, i), _possibleConstructorReturn(this, _getPrototypeOf(i).apply(this, arguments))
            }
            return _inherits(i, e.AutoResizeableState), _createClass(i, [{
                key: "preload",
                value: function() {
                    _get(_getPrototypeOf(i.prototype), "preload", this).call(this, this.game), this.buildChildren(), this.preloadContent(), this.resize(this.game.width, this.game.height)
                }
            }, {
                key: "buildChildren",
                value: function() {
                    e.BackgroundManager.instance.init(), this.game.state.onStateChange.add(this.handleStateChanged, this), this.preloadContainer = this.addChild(this.game.make.group()), this.backScreen = this.game.world.addAt(this.game.make.sprite(0, 0, e.Settings.PRELOADER_ATLAS, "blackSquare0000"), 0), this.backScreen.position.set(-50, -50), this.backScreen.width = 2400, this.backScreen.height = 2400, this.backScreen.alpha = .7, this.logo = this.addChild(this.game.make.sprite(0, 0, e.Settings.PRELOADER_ATLAS, "logo0000")), this.logo.anchor.setTo(.5), this.preloadPad = this.preloadContainer.add(this.game.make.sprite(0, 0, e.Settings.PRELOADER_ATLAS, "preloaderBack0000")), this.preloadPad.anchor.setTo(.5), this.preloadBar = this.preloadContainer.add(this.game.make.sprite(-157, -2, e.Settings.PRELOADER_ATLAS)), this.preloadBar.animations.add("cycle", Phaser.Animation.generateFrameNames("preloadBar", 0, 9, "", 4)).play(45, !0), this.preloadBar.anchor.setTo(0, .5), this.load.setPreloadSprite(this.preloadBar), this.versionText = this.addChild(e.TextUtils.getText("v" + e.Settings.GAME_VERSION, 0, 0, 12, "#ffffff")), this.preloadText = this.preloadContainer.add(new e.BitmapTextField("0%", e.Settings.PRELOADER_ATLAS, "Gold", 1, .5, .5, 1)), this.preloadText.position.set(0, 65), this.game.load.onFileComplete.add(this.onFileComplete, this), this.game.load.onLoadComplete.add(this.onLoadingComplete, this), this.isInitialized = !0
                }
            }, {
                key: "preloadContent",
                value: function() {
                    var t = !0,
                        i = !1,
                        n = void 0;
                    try {
                        for (var a, s = e.SoundController.instance.getSoundNames()[Symbol.iterator](); !(t = (a = s.next()).done); t = !0) {
                            var o = a.value;
                            this.game.load.audio(o, ["sound/mp3/" + o + ".mp3", "sound/m4a/" + o + ".m4a", "sound/ogg/" + o + ".ogg"])
                        }
                    } catch (e) {
                        i = !0, n = e
                    } finally {
                        try {
                            t || null == s.return || s.return()
                        } finally {
                            if (i) throw n
                        }
                    }
                    e.Settings.ENABLE_API && this.game.load.image("more_games", e.Settings.RELEASE_BUILD ? "img/more-games.png" : "img/more-games.png"), this.game.load.atlasJSONArray(e.Settings.GAME_ATLAS, "img/" + e.Settings.GAME_ATLAS + ".png", "img/" + e.Settings.GAME_ATLAS + ".json"), this.game.load.atlasJSONArray(e.Settings.ANIMATION_ATLAS, "img/" + e.Settings.ANIMATION_ATLAS + ".png", "img/" + e.Settings.ANIMATION_ATLAS + ".json"), this.game.load.image("field-cover", "img/field-cover.png"), this.game.load.spritesheet("explosionA", "img/18.png", 256, 256, 40), this.game.load.spritesheet("explosionB", "img/22.png", 256, 256, 40)
                }
            }, {
                key: "create",
                value: function() {
                    _get(_getPrototypeOf(i.prototype), "create", this).call(this)
                }
            }, {
                key: "resize",
                value: function(t, n) {
                    _get(_getPrototypeOf(i.prototype), "resize", this).call(this, t, n), this.isInitialized && (this.backScreen.width = this.windowBounds.width * e.CustomScaleManager.SCALE_X + 100, this.backScreen.height = this.windowBounds.height * e.CustomScaleManager.SCALE_X + 100, this.preloadContainer.position.copyFrom(this.windowBounds.getPosition(.5, .58)), this.versionText.position.set(this.windowBounds.left + 25, this.windowBounds.down - 16), this.logo.position.copyFrom(this.windowBounds.getPosition(.5, .24)))
                }
            }, {
                key: "handleStateChanged",
                value: function() {
                    e.BackgroundManager.instance.handleStateChanged()
                }
            }, {
                key: "onFileComplete",
                value: function(e, t, i, n, a) {
                    this.preloadText.changeText(e + "%")
                }
            }, {
                key: "onLoadingComplete",
                value: function() {
                    e.WindowManager.instance.init(), e.TransitionScreen.instance.init(), e.LocalStorageController.instance.loadSave(), e.SoundController.instance.init(), e.SoundController.instance.isDecodingSupported() ? this.game.sound.setDecodedCallback(e.SoundController.instance.getSFXNames(), this.onSoundsDecoded, this) : this.onSoundsDecoded()
                }
            }, {
                key: "onSoundsDecoded",
                value: function() {
                    e.SoundController.instance.startMusic(), this.preloadText.changeText("100%"), e.TransitionScreen.instance.changeState("Level")
                }
            }]), i
        }();
        e.Preloader = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t, n, a) {
                var s, o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1,
                    r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : .5,
                    l = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : .5,
                    h = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0,
                    u = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0,
                    c = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 16777215;
                return _classCallCheck(this, i), (s = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e.App.instance))).valueHolder = {
                    value: 0,
                    targetValue: 0
                }, s.pivotX = .5, s.pivotY = .5, s.atlasKey = "", s.styleKey = "", s.letterSpacing = 0, s.letterFrame = 0, s.tintValue = 0, s.internalScale = 1, s.atlasKey = n, s.styleKey = a, s.letterSpacing = h, s.letterFrame = u, s.textScale = o, s.pivotX = r, s.pivotY = l, s.tintValue = c, s.changeText(t), s
            }
            return _inherits(i, Phaser.Group), _createClass(i, [{
                key: "changeText",
                value: function(t) {
                    var i = this;
                    if (arguments.length > 1 && void 0 !== arguments[1] && arguments[1] || this.textValue != t) {
                        this.textValue = t, this.removeAll(!0), this.scale.set(1);
                        for (var n = 0; n < t.length; n++) {
                            var a = e.BitmapTextFactory.getLetter(this.styleKey, this.atlasKey, t.charAt(n), this.letterFrame);
                            a ? (a.x = this.width + (n > 0 ? this.letterSpacing : 0), a.anchor.set(0, .5), this.add(a)) : console.warn("BitmapTextFactory.getSprite - letter '".concat(t.charAt(n), "' not found in spritesheet"))
                        }
                        var s = this.width,
                            o = this.height;
                        this.children.forEach(function(e) {
                            return e.position.set(e.x - i.pivotX * s, e.y - (i.pivotY - .5) * o)
                        }), this.children.forEach(function(e) {
                            return e.tint = i.tintValue
                        }), this.scale.set(this.textScale * this.internalScale)
                    }
                }
            }, {
                key: "setColor",
                value: function(e) {
                    var t = this;
                    this.tintValue = e, this.children.forEach(function(e) {
                        return e.tint = t.tintValue
                    })
                }
            }, {
                key: "tweenText",
                value: function(e, t, i, n) {
                    var a = this;
                    this.game.tweens.removeFrom(this.valueHolder), this.valueHolder.value = e, this.valueHolder.targetValue = t, this.game.add.tween(this.valueHolder).to({
                        value: t
                    }, i, Phaser.Easing.Linear.None, !0, n).onUpdateCallback(function() {
                        return a.changeText("" + Math.floor(a.valueHolder.value))
                    }).onComplete.add(function() {
                        return a.changeText("" + Math.floor(a.valueHolder.targetValue))
                    })
                }
            }, {
                key: "tweenTextAdvanced",
                value: function(t, i, n, a, s) {
                    var o = this,
                        r = arguments.length > 5 && void 0 !== arguments[5] && arguments[5],
                        l = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : ["Level"];
                    if (this.changeText("" + Math.floor(i)), i != n) {
                        var h = {
                                value: i
                            },
                            u = this.game.add.tween(h).to({
                                value: n
                            }, a, Phaser.Easing.Linear.None, !0, s);
                        u.onStart.add(function() {
                            r && -1 != l.indexOf(o.game.state.getCurrentState().key) && e.SoundController.instance.startCountingSound()
                        }), u.onUpdateCallback(function() {
                            return o.changeText(t + Math.floor(h.value))
                        }), u.onComplete.add(function() {
                            o.changeText(t + Math.floor(h.value)), r && e.SoundController.instance.stopCountingSound()
                        })
                    }
                }
            }]), i
        }();
        e.BitmapTextField = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i() {
                var t;
                return _classCallCheck(this, i), (t = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e.App.instance, null))).isInitialized = !1, t
            }
            return _inherits(i, Phaser.Group), _createClass(i, [{
                key: "buildChildren",
                value: function() {
                    this.background = this.add(this.game.make.sprite(0, 0, e.Settings.GAME_ATLAS, "transitionSquare0000")), this.background.anchor.set(.5), this.background.alpha = .01, this.background.inputEnabled = !0, this.background.events.onInputDown.add(function() {
                        return gradle.event("Transition Screen: input locked")
                    })
                }
            }, {
                key: "init",
                value: function() {
                    this.isInitialized = !0, this.buildChildren()
                }
            }, {
                key: "resize",
                value: function() {
                    this.isInitialized && (this.position.set(this.game.world.centerX, this.game.world.centerY), this.background.width = this.game.width + 100, this.background.height = this.game.height + 100)
                }
            }, {
                key: "changeState",
                value: function(e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                    this.targetStateName = e, this.callback = t, this.show()
                }
            }, {
                key: "show",
                value: function() {
                    this.game.stage.addChild(this), this.visible = !0, this.resize(), this.game.add.tween(this.background).to({
                        alpha: 1
                    }, 140, Phaser.Easing.Quadratic.Out, !0).onComplete.add(this.close, this)
                }
            }, {
                key: "close",
                value: function() {
                    this.targetStateName && (this.game.state.start(this.targetStateName, !0, !1), e.WindowManager.instance.hideAll()), this.callback && (this.callback(), this.callback = null), this.proceedClosing()
                }
            }, {
                key: "proceedClosing",
                value: function() {
                    var e = this;
                    this.parent && this.parent.getChildIndex(this) > -1 ? this.parent.setChildIndex(this, this.parent.children.length - 1) : this.game.stage.addChild(this), setTimeout(function() {
                        e.game.add.tween(e.background).to({
                            alpha: 0
                        }, 120, Phaser.Easing.Linear.None, !0).onComplete.add(e.onTransitionFinished, e)
                    }, 20), setTimeout(function() {
                        e.onTransitionFinished()
                    }, 400)
                }
            }, {
                key: "onTransitionFinished",
                value: function() {
                    this.hide()
                }
            }, {
                key: "hide",
                value: function() {
                    this.parent && this.parent.getChildIndex(this) > -1 && this.parent.removeChild(this), this.visible = !1
                }
            }], [{
                key: "instance",
                get: function() {
                    return i._instance ? i._instance : i._instance = new i
                }
            }]), i
        }();
        t._instance = null, e.TransitionScreen = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(e) {
                var t;
                return _classCallCheck(this, i), (t = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e.game))).active = !1, t.visibilityTimer = 0, t.targetY = -100, t.achievementsButton = e, t.level = e.level, t.buildChildren(), t
            }
            return _inherits(i, Phaser.Group), _createClass(i, [{
                key: "buildChildren",
                value: function() {
                    this.container = this.add(this.game.make.group()), this.container.position.set(0, -100), this.informerPad = this.container.add(this.game.make.sprite(0, 0, e.Settings.GAME_ATLAS, "achievementInformerPad0000")), this.informerPad.anchor.set(.5), this.informerPad.alpha = .75, this.informerPad.inputEnabled = !0, this.informerPad.events.onInputDown.add(this.openAchievements, this), this.achievementSprite = this.container.add(this.game.make.sprite(0, -5, e.Settings.GAME_ATLAS, "achievement10000")), this.achievementSprite.anchor.set(.5), this.badgesSprite = this.container.add(this.game.make.sprite(40, 30, e.Settings.GAME_ATLAS, "achievementBadges0000")), this.badgesSprite.anchor.set(.5), this.visible = !1
                }
            }, {
                key: "show",
                value: function(t) {
                    this.game.tweens.removeFrom(this.container.scale, !1), this.game.tweens.removeFrom(this.container, !1), this.game.tweens.removeFrom(this.achievementSprite), this.game.tweens.removeFrom(this.achievementSprite.scale), this.game.tweens.removeFrom(this.badgesSprite), this.game.tweens.removeFrom(this.badgesSprite.scale), this.visible = !0, this.active = !0, this.visibilityTimer = e.Settings.ACHIEVEMENT_INFORMER_VISIBILITY_DURATION, this.container.y = 0, this.container.alpha = 0, this.game.add.tween(this.container).to({
                        alpha: 1
                    }, 250, Phaser.Easing.Linear.None, !0), this.game.add.tween(this.container).to({
                        y: this.targetY
                    }, 280, Phaser.Easing.Back.Out, !0), this.container.scale.set(.6), this.game.add.tween(this.container.scale).to({
                        x: 1,
                        y: 1
                    }, 280, Phaser.Easing.Sinusoidal.Out, !0), this.achievementSprite.scale.set(0), this.game.add.tween(this.achievementSprite.scale).to({
                        x: .7,
                        y: .7
                    }, 270, Phaser.Easing.Back.Out, !0, 30), this.achievementSprite.y = -3, this.game.add.tween(this.achievementSprite).to({
                        y: -7
                    }, 350, Phaser.Easing.Sinusoidal.InOut, !0, 180, -1, !0), this.badgesSprite.alpha = 0, this.game.add.tween(this.badgesSprite).to({
                        alpha: 1
                    }, 160, Phaser.Easing.Sinusoidal.In, !0, 100), this.badgesSprite.scale.set(0), this.game.add.tween(this.badgesSprite.scale).to({
                        x: 1,
                        y: 1
                    }, 200, Phaser.Easing.Back.Out, !0, 100), this.achievementSprite.frameName = "achievement" + t.key + "0000", this.badgesSprite.frameName = "achievementBadges000" + Phaser.Math.clamp(e.AchievementsManager.getAchievementLevel(t) - 1, 0, 2)
                }
            }, {
                key: "hide",
                value: function() {
                    var e = this;
                    this.active = !1, this.game.tweens.removeFrom(this.container.scale, !1), this.game.tweens.removeFrom(this.container, !1), this.game.add.tween(this.container).to({
                        alpha: 0
                    }, 150, Phaser.Easing.Linear.None, !0), this.game.add.tween(this.container).to({
                        y: 0
                    }, 220, Phaser.Easing.Sinusoidal.Out, !0), this.game.add.tween(this.container.scale).to({
                        x: .5,
                        y: .5
                    }, 150, Phaser.Easing.Back.Out, !0).onComplete.add(function() {
                        return e.visible = !1
                    })
                }
            }, {
                key: "openAchievements",
                value: function() {
                    this.achievementsButton.handleClick()
                }
            }, {
                key: "resizeLandscape",
                value: function() {
                    this.targetY = 110, this.game.add.tween(this.container).to({
                        y: this.targetY
                    }, 50, Phaser.Easing.Sinusoidal.Out, !0)
                }
            }, {
                key: "resizeSquared",
                value: function() {
                    this.targetY = 110, this.game.add.tween(this.container).to({
                        y: this.targetY
                    }, 50, Phaser.Easing.Sinusoidal.Out, !0)
                }
            }, {
                key: "resizePortrait",
                value: function() {
                    this.targetY = -110, this.game.add.tween(this.container).to({
                        y: this.targetY
                    }, 50, Phaser.Easing.Sinusoidal.Out, !0)
                }
            }, {
                key: "update",
                value: function() {
                    this.visible && this.active && this.visibilityTimer > 0 && (this.visibilityTimer -= this.game.time.elapsedMS, this.visibilityTimer <= 0 && this.hide())
                }
            }]), i
        }();
        e.AchievementInformer = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(e, t, n, a) {
                var s;
                return _classCallCheck(this, i), (s = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e.game))).currentReward = 0, s.windowAchievements = e, s.achievementKey = t, s.position.set(n, a), s.buildContent(), s
            }
            return _inherits(i, Phaser.Group), _createClass(i, [{
                key: "updateView",
                value: function() {
                    var t = e.AchievementsManager.instance.getAchievementModel(this.achievementKey),
                        i = e.AchievementsManager.getAchievementLevel(t),
                        n = i > 0 ? i < 3 ? t.currentValue - t.requiredValues[i - 1] : t.requiredValues[2] : t.currentValue,
                        a = i > 0 ? i < 3 ? t.currentValue : t.requiredValues[2] : t.currentValue,
                        s = i > 0 ? i < 3 ? t.requiredValues[i] - t.requiredValues[i - 1] : t.requiredValues[2] : t.requiredValues[0],
                        o = i > 0 ? i < 3 ? t.requiredValues[i] : t.requiredValues[2] : t.requiredValues[0],
                        r = i < 3 ? n / s : 1;
                    this.buttonClaimReward.visible = !1, this.progressBarContainer.visible = !0, this.badges.visible = t.rewardClaimed[0] || t.rewardClaimed[1] || t.rewardClaimed[2], this.badges.frameName = t.rewardClaimed[2] ? "achievementBadges0002" : t.rewardClaimed[1] ? "achievementBadges0001" : "achievementBadges0000", this.icon.frameName = "achievement" + this.achievementKey + "000" + (i > 0 ? "0" : "1"), this.progressBarMask.x = this.progressBar.x - (1 - r) * this.progressBar.width, i < 3 ? (this.progressBarContainer.visible = !0, this.maxText.visible = !1, this.progressText.setText("".concat(a, "/").concat(o))) : (this.progressBarContainer.visible = !1, this.maxText.visible = !0), t.currentValue >= t.requiredValues[0] && !t.rewardClaimed[0] ? (this.buttonClaimReward.visible = !0, this.progressBarContainer.visible = !1, this.currentReward = t.rewards[0], this.buttonClaimReward.updateView("+" + this.currentReward)) : t.currentValue >= t.requiredValues[1] && !t.rewardClaimed[1] ? (this.buttonClaimReward.visible = !0, this.progressBarContainer.visible = !1, this.currentReward = t.rewards[1], this.buttonClaimReward.updateView("+" + this.currentReward)) : t.currentValue >= t.requiredValues[2] && !t.rewardClaimed[2] && (this.buttonClaimReward.visible = !0, this.progressBarContainer.visible = !1, this.currentReward = t.rewards[2], this.buttonClaimReward.updateView("+" + this.currentReward))
                }
            }, {
                key: "buildContent",
                value: function() {
                    this.icon = this.add(this.game.make.sprite(0, 0, e.Settings.GAME_ATLAS, "achievement" + this.achievementKey + "0000")), this.icon.anchor.set(.5), this.progressBarContainer = this.add(this.game.make.group()), this.progressBarContainer.position.set(0, 85), this.progressPad = this.progressBarContainer.add(this.game.make.sprite(0, 0, e.Settings.GAME_ATLAS, "achievementProgressPad0000")), this.progressPad.anchor.set(.5), this.progressBar = this.progressBarContainer.add(this.game.make.sprite(-this.progressPad.width / 2 + 5, -2, e.Settings.GAME_ATLAS, "achievementProgressBar0000")), this.progressBar.anchor.set(0, .5), this.progressBarMask = this.progressBarContainer.add(this.game.make.graphics(this.progressBar.x, this.progressBar.y - this.progressBar.height / 2)), this.progressBarMask.beginFill(16777215, .5).drawRect(0, 0, this.progressBar.width, this.progressBar.height).endFill(), this.progressBar.mask = this.progressBarMask, this.progressText = this.progressBarContainer.add(e.TextUtils.getText("0/1000", 0, 1, 19, "#DAFFF4")), this.maxText = this.add(this.game.make.sprite(0, 80, e.Settings.GAME_ATLAS, "achievementMax0000")), this.maxText.anchor.set(.5), this.badges = this.add(this.game.make.sprite(68, 46, e.Settings.GAME_ATLAS, "achievementBadges0000")), this.badges.anchor.set(.5), this.buttonClaimReward = this.add(new e.ButtonClaimReward(this, "+89", 1, this.claimRewardClicked, this)), this.buttonClaimReward.position.set(3, 85)
                }
            }, {
                key: "claimRewardClicked",
                value: function() {
                    e.StarsManager.instance.pickupStars(this.currentReward, !0), this.currentReward = 0;
                    var t = e.AchievementsManager.instance.getAchievementModel(this.achievementKey);
                    e.AchievementsManager.getAchievementLevel(t);
                    t && (t.currentValue >= t.requiredValues[0] && !t.rewardClaimed[0] ? (t.rewardClaimed[0] = !0, this.badges.scale.set(0), this.game.add.tween(this.badges.scale).to({
                        x: 1,
                        y: 1
                    }, 300, Phaser.Easing.Back.Out, !0, 0)) : t.currentValue >= t.requiredValues[1] && !t.rewardClaimed[1] ? (t.rewardClaimed[1] = !0, this.badges.scale.set(0), this.game.add.tween(this.badges.scale).to({
                        x: 1,
                        y: 1
                    }, 300, Phaser.Easing.Back.Out, !0, 0)) : t.currentValue >= t.requiredValues[2] && !t.rewardClaimed[2] && (t.rewardClaimed[2] = !0, this.badges.scale.set(0), this.game.add.tween(this.badges.scale).to({
                        x: 1,
                        y: 1
                    }, 300, Phaser.Easing.Back.Out, !0, 0)), e.LocalStorageController.instance.save()), this.updateView()
                }
            }]), i
        }();
        e.AchievementPanel = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t, n, a, s, o) {
                var r;
                return _classCallCheck(this, i), (r = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, t.game))).achievementPanel = t, r.container = r.add(r.game.make.group()), r.backplate = r.container.add(r.game.make.sprite(0, 0, e.Settings.GAME_ATLAS, "buttonClaim0000")), r.backplate.anchor.setTo(.5, .5), r.backplate.inputEnabled = !0, r.backplate.events.onInputUp.add(s, o), r.backplate.overTween = e.App.instance.add.tween(r.container.scale).to({
                    x: 1.05,
                    y: 1.05
                }, 100), r.backplate.outTween = e.App.instance.add.tween(r.container.scale).to({
                    x: 1,
                    y: 1
                }, 100), r.backplate.downTween = e.App.instance.add.tween(r.container.scale).to({
                    x: .95,
                    y: .95
                }, 50).to({
                    x: 1,
                    y: 1
                }, 50), r.backplate.events.onInputOver.add(e.ButtonUtils.mouseOverHandler, _assertThisInitialized(r), 0), r.backplate.events.onInputOut.add(e.ButtonUtils.mouseOutHandler, _assertThisInitialized(r), 0), r.backplate.events.onInputDown.add(e.ButtonUtils.mouseDownHandler, _assertThisInitialized(r), 0), r.backplate.events.onInputDown.add(function() {
                    return e.SoundController.instance.playRewardClaimedSound()
                }, _assertThisInitialized(r)), r.rewardText = r.add(new e.BitmapTextField(n, e.Settings.GAME_ATLAS, "Gold", .55, .5, .5, 1)), r.rewardText.position.set(-17, -3), r
            }
            return _inherits(i, Phaser.Group), _createClass(i, [{
                key: "updateView",
                value: function(e) {
                    this.rewardText.changeText(e), this.game.tweens.removeFrom(this.scale), this.scale.set(1), this.game.add.tween(this.scale).to({
                        x: 1.04,
                        y: 1.04
                    }, 500, Phaser.Easing.Linear.None, !0, 0, -1, !0)
                }
            }]), i
        }();
        e.ButtonClaimReward = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t) {
                var n;
                return _classCallCheck(this, i), (n = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, t.game, null))).level = t, n.button = n.add(e.ButtonUtils.createSimpleButton(e.Settings.GAME_ATLAS, "buttonAchievements", 0, 0, 1, n.handleClick, _assertThisInitialized(n))), n.exclamationMark = n.add(n.game.make.sprite(25, 22, e.Settings.GAME_ATLAS)), n.exclamationMark.anchor.set(.5), n.exclamationMark.animations.add("twerking", Phaser.Animation.generateFrameNames("achievementsNotification", 0, 99, "", 4)).play(60, !0), n.exclamationMark.visible = e.AchievementsManager.instance.hasAvailableRewards(), n.achievementInformer = n.add(new e.AchievementInformer(_assertThisInitialized(n))), e.AchievementsManager.instance.onAchievementCompleted.add(n.handleAchievementCompleted, _assertThisInitialized(n)), n
            }
            return _inherits(i, Phaser.Group), _createClass(i, [{
                key: "destroy",
                value: function() {
                    e.AchievementsManager.instance.onAchievementCompleted.remove(this.handleAchievementCompleted, this), _get(_getPrototypeOf(i.prototype), "destroy", this).call(this)
                }
            }, {
                key: "handleAchievementCompleted",
                value: function(e) {
                    this.achievementInformer.show(e), 0 == this.exclamationMark.visible && (this.exclamationMark.visible = !0)
                }
            }, {
                key: "handleClick",
                value: function() {
                    this.achievementInformer.active && this.achievementInformer.hide(), this.exclamationMark.visible = !1, e.WindowManager.instance.showAchievements()
                }
            }, {
                key: "resizePortrait",
                value: function() {
                    this.achievementInformer.resizePortrait()
                }
            }, {
                key: "resizeSquared",
                value: function() {
                    this.achievementInformer.resizeSquared()
                }
            }, {
                key: "resizeLandscape",
                value: function() {
                    this.achievementInformer.resizeLandscape()
                }
            }, {
                key: "setScale",
                value: function(e) {
                    this.button.setScale(e)
                }
            }]), i
        }();
        e.ButtonAchievements = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t, n, a) {
                var s;
                return _classCallCheck(this, i), (s = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, t.game))).parentWindow = t, s.container = s.add(s.game.make.group()), s.button = s.container.add(e.ButtonUtils.createSimpleButton(e.Settings.GAME_ATLAS, "buttonClose", 0, 0, 1, n, a)), s
            }
            return _inherits(i, Phaser.Group), _createClass(i, [{
                key: "resize",
                value: function(e, t) {
                    this.position.set(this.parentWindow.windowManager.windowBounds.right + e, this.parentWindow.windowManager.windowBounds.top + t)
                }
            }]), i
        }();
        e.ButtonCloseWindow = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i() {
                var t;
                return _classCallCheck(this, i), (t = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e.App.instance, null))).isActive = !1, t.starsAmount = e.Settings.GET_STARS_BUTTON_REWARD_STARS_AMOUNT, t.button = t.add(e.ButtonUtils.createSimpleButton(e.Settings.GAME_ATLAS, "buttonGetStars", 0, 0, 1, t.getStarsClicked, _assertThisInitialized(t))), t.numStarsText = t.add(new e.BitmapTextField("+" + t.starsAmount, e.Settings.GAME_ATLAS, "Gold", .42, .5, .5, 1)), t.numStarsText.position.set(-20, 3), t.visible = !1, t.isActive = !1, t
            }
            return _inherits(i, Phaser.Group), _createClass(i, [{
                key: "getStarsClicked",
                value: function() {
                    var t = this;
                    e.Settings.ENABLE_API ? e.APIUtils.instance.hasRewardedVideo() && (e.Settings.GET_STARS_BUTTON_LAST_REWARD_TIMESTAMP = +(new Date).getTime(), e.APIUtils.instance.showRewardedVideo(function() {
                        return t.giveReward()
                    })) : (e.Settings.GET_STARS_BUTTON_LAST_REWARD_TIMESTAMP = +(new Date).getTime(), this.giveReward())
                }
            }, {
                key: "giveReward",
                value: function() {
                    e.StarsManager.instance.pickupStars(this.starsAmount), this.starsAmount += e.Settings.GET_STARS_BUTTON_REWARD_STARS_AMOUNT_STEP, this.numStarsText.changeText("+" + this.starsAmount, !0), this.hide()
                }
            }, {
                key: "activate",
                value: function() {
                    this.isActive = !0, this.visible = !0, this.button.inputEnabled = !0
                }
            }, {
                key: "hide",
                value: function() {
                    this.isActive = !1, this.visible = !1
                }
            }, {
                key: "update",
                value: function() {
                    _get(_getPrototypeOf(i.prototype), "update", this).call(this), !this.isActive && e.Settings.GET_STARS_BUTTON_ENABLED && e.Settings.ENABLE_API && +(new Date).getTime() - e.Settings.GET_STARS_BUTTON_LAST_REWARD_TIMESTAMP > 1e3 * e.Settings.GET_STARS_BUTTON_COOLDOWN && e.APIUtils.instance.hasRewardedVideo() && this.activate()
                }
            }]), i
        }();
        e.ButtonGetStars = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(e, t) {
                var n;
                return _classCallCheck(this, i), (n = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e.game, null))).results = e, n.buildContent(), n.buildIcon(t), n
            }
            return _inherits(i, Phaser.Group), _createClass(i, [{
                key: "buildContent",
                value: function() {
                    this.padLeft = this.add(this.game.make.sprite(5, 0, e.Settings.GAME_ATLAS, "resultsScorePad0000")), this.padLeft.anchor.set(0, .5), this.padLeft.scale.x = -1, this.padRight = this.add(this.game.make.sprite(0, 0, e.Settings.GAME_ATLAS, "resultsScorePad0000")), this.padRight.anchor.set(0, .5), this.textFieldLeft = this.add(new e.BitmapTextField("0", e.Settings.GAME_ATLAS, "Gold", .75, .5, .5, 1)), this.textFieldLeft.position.set(-90, 0), this.textFieldRight = this.add(new e.BitmapTextField("0", e.Settings.GAME_ATLAS, "Gold", .75, .5, .5, 1)), this.textFieldRight.position.set(107, 0)
                }
            }, {
                key: "buildIcon",
                value: function(t) {
                    this.icon = this.add(this.game.make.sprite(10, 0, e.Settings.GAME_ATLAS, t + "0000")), this.icon.anchor.set(.5)
                }
            }, {
                key: "show",
                value: function(e, t, i, n) {
                    var a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "",
                        s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "",
                        o = arguments.length > 6 ? arguments[6] : void 0,
                        r = arguments.length > 7 ? arguments[7] : void 0,
                        l = arguments.length > 8 ? arguments[8] : void 0;
                    this.resetTweens(), this.tweenTexts(e, t, i, n, a, s, r, l), this.animateAppearing(o)
                }
            }, {
                key: "tweenTexts",
                value: function(e, t, i, n, a, s, o, r) {
                    this.textFieldLeft.tweenTextAdvanced(a, e, t, r, o, !0), this.textFieldRight.tweenTextAdvanced(s, i, n, r, o, !0)
                }
            }, {
                key: "animateAppearing",
                value: function(e) {
                    var t = this;
                    this.icon.scale.set(.5), this.game.add.tween(this.icon.scale).to({
                        x: 1,
                        y: 1
                    }, 350, Phaser.Easing.Back.Out, !0, e + 100), this.icon.alpha = 0, this.game.add.tween(this.icon).to({
                        alpha: 1
                    }, 250, Phaser.Easing.Sinusoidal.Out, !0, e + 100), this.padLeft.scale.x = 0, this.game.add.tween(this.padLeft.scale).to({
                        x: -1
                    }, 450, Phaser.Easing.Back.Out, !0, e + 150), this.padRight.scale.x = 0, this.game.add.tween(this.padRight.scale).to({
                        x: 1
                    }, 450, Phaser.Easing.Back.Out, !0, e + 150), this.textFieldLeft.visible = !1, this.textFieldLeft.scale.set(.5), this.game.add.tween(this.textFieldLeft.scale).to({
                        x: .75,
                        y: .75
                    }, 450, Phaser.Easing.Back.Out, !0, e + 250).onStart.add(function() {
                        return t.textFieldLeft.visible = !0
                    }), this.textFieldRight.visible = !1, this.textFieldRight.scale.set(.5), this.game.add.tween(this.textFieldRight.scale).to({
                        x: .75,
                        y: .75
                    }, 450, Phaser.Easing.Back.Out, !0, e + 330).onStart.add(function() {
                        return t.textFieldRight.visible = !0
                    }), this.textFieldLeft.visible = !1, this.textFieldLeft.alpha = 0, this.game.add.tween(this.textFieldLeft).to({
                        alpha: 1
                    }, 500, Phaser.Easing.Linear.None, !0, e + 250).onStart.add(function() {
                        return t.textFieldLeft.visible = !0
                    }), this.textFieldRight.visible = !1, this.textFieldRight.alpha = 0, this.game.add.tween(this.textFieldRight).to({
                        alpha: 1
                    }, 500, Phaser.Easing.Linear.None, !0, e + 330).onStart.add(function() {
                        return t.textFieldRight.visible = !0
                    })
                }
            }, {
                key: "resetTweens",
                value: function() {
                    this.game.tweens.removeFrom(this.alpha), this.game.tweens.removeFrom(this.icon), this.game.tweens.removeFrom(this.icon.scale), this.game.tweens.removeFrom(this.padLeft.scale), this.game.tweens.removeFrom(this.padRight.scale), this.game.tweens.removeFrom(this.textFieldLeft), this.game.tweens.removeFrom(this.textFieldLeft.scale), this.game.tweens.removeFrom(this.textFieldRight), this.game.tweens.removeFrom(this.textFieldRight.scale), this.icon.scale.set(1), this.icon.alpha = 1, this.padLeft.scale.set(-1), this.padRight.scale.set(1), this.textFieldLeft.scale.set(.75), this.textFieldRight.scale.set(.75), this.textFieldLeft.visible = !0, this.textFieldRight.visible = !0
                }
            }]), i
        }();
        e.AbstractResultsCounter = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(e) {
            function t(e) {
                var i;
                return _classCallCheck(this, t), (i = _possibleConstructorReturn(this, _getPrototypeOf(t).call(this, e.game, null))).uiManager = e, i.level = e.level, i.buildChildren(), i
            }
            return _inherits(t, Phaser.Group), _createClass(t, [{
                key: "tweenIcon",
                value: function(e) {
                    e < 400 ? this.game.add.tween(this.icon.scale).to({
                        x: 1.075,
                        y: 1.075
                    }, 100, Phaser.Easing.Sinusoidal.Out, !1).to({
                        x: 1,
                        y: 1
                    }, 240, Phaser.Easing.Sinusoidal.In, !1).start() : this.game.add.tween(this.icon.scale).to({
                        x: 1.13,
                        y: 1.13
                    }, .25 * e, Phaser.Easing.Sinusoidal.Out, !1).to({
                        x: 1.15,
                        y: 1.15
                    }, .1 * e, Phaser.Easing.Sinusoidal.In, !1).to({
                        x: 1,
                        y: 1
                    }, .65 * e, Phaser.Easing.Sinusoidal.In, !1).start()
                }
            }]), t
        }();
        e.AbstractUICounter = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(e) {
                var t;
                return _classCallCheck(this, i), (t = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e.game, null))).starsAmount = 0, t.isActive = !0, t.results = e, t.buildContent(), t
            }
            return _inherits(i, Phaser.Group), _createClass(i, [{
                key: "buildContent",
                value: function() {
                    this.pad = this.add(this.game.make.sprite(10, 0, e.Settings.GAME_ATLAS, "resultsScorePad0000")), this.pad.anchor.set(0, .5), this.pad.scale.set(-.8, .9), this.textField = this.add(new e.BitmapTextField("+12", e.Settings.GAME_ATLAS, "Gold", .7, .5, .5, 1)), this.textField.position.set(-82, 0), this.buttonContainer = this.add(this.game.make.group()), this.buttonDoubleStars = this.buttonContainer.add(e.ButtonUtils.createSimpleButton(e.Settings.GAME_ATLAS, "buttonRewardedVideoSmall", 0, 0, 1, this.doubleStarsClicked, this))
                }
            }, {
                key: "doubleStarsClicked",
                value: function() {
                    var t = this;
                    this.isActive && e.APIUtils.instance.showRewardedVideo(function() {
                        return t.collapse()
                    })
                }
            }, {
                key: "show",
                value: function(e, t) {
                    var i = this;
                    this.resetTweens(), this.scale.set(1.2), this.isActive = !0, this.starsAmount = t, this.textField.changeText("+" + t), this.buttonContainer.scale.set(.5), this.game.add.tween(this.buttonContainer.scale).to({
                        x: 1.2,
                        y: 1.2
                    }, 300, Phaser.Easing.Back.Out, !0, e + 100), this.buttonContainer.alpha = 0, this.game.add.tween(this.buttonContainer).to({
                        alpha: 1
                    }, 250, Phaser.Easing.Sinusoidal.Out, !0, e + 100), this.pad.scale.x = 0, this.game.add.tween(this.pad.scale).to({
                        x: -.8
                    }, 250, Phaser.Easing.Back.Out, !0, e + 100), this.textField.visible = !1, this.textField.scale.set(.2), this.game.add.tween(this.textField.scale).to({
                        x: .7,
                        y: .7
                    }, 300, Phaser.Easing.Back.Out, !0, e + 200).onStart.add(function() {
                        return i.textField.visible = !0
                    })
                }
            }, {
                key: "collapse",
                value: function() {
                    var e = this;
                    this.resetTweens(), this.isActive = !1, this.results.addBonusStars(this.starsAmount), this.starsAmount = 0, this.game.add.tween(this.textField).to({
                        alpha: 0
                    }, 120, Phaser.Easing.Linear.None, !0), this.game.add.tween(this.textField.scale).to({
                        x: 0,
                        y: 0
                    }, 120, Phaser.Easing.Back.In, !0), this.game.add.tween(this.pad.scale).to({
                        x: 0
                    }, 200, Phaser.Easing.Sinusoidal.In, !0, 0), this.game.add.tween(this.buttonContainer.scale).to({
                        x: 0,
                        y: 0
                    }, 200, Phaser.Easing.Back.In, !0, 100).onComplete.add(function() {
                        return e.buttonContainer.visible = !1
                    })
                }
            }, {
                key: "resetTweens",
                value: function() {
                    this.game.tweens.removeFrom(this.alpha), this.game.tweens.removeFrom(this.textField), this.game.tweens.removeFrom(this.textField.scale), this.game.tweens.removeFrom(this.pad), this.game.tweens.removeFrom(this.pad.scale), this.game.tweens.removeFrom(this.buttonContainer, !1), this.game.tweens.removeFrom(this.buttonContainer.scale, !1), this.textField.alpha = 1, this.textField.visible = !0, this.textField.scale.set(.7), this.pad.scale.set(-.8, .9), this.buttonContainer.scale.set(1), this.buttonContainer.visible = !0
                }
            }]), i
        }();
        e.DoubleStarsButton = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i() {
                var t;
                return _classCallCheck(this, i), (t = _possibleConstructorReturn(this, _getPrototypeOf(i).apply(this, arguments))).lastScoreValue = 0, t.lastHighscoreValue = e.ScoreManager.instance.getMaxScores(), t
            }
            return _inherits(i, e.AbstractUICounter), _createClass(i, [{
                key: "buildChildren",
                value: function() {
                    this.pad = this.add(this.game.make.sprite(12, 0, e.Settings.GAME_ATLAS, "scorePad0000")), this.pad.anchor.set(0, .5), this.pad.scale.set(1.3), this.icon = this.add(this.game.make.sprite(5, 0, e.Settings.GAME_ATLAS, "uiIconCup0000")), this.icon.anchor.set(.5), this.icon.visible = !1, this.textField = this.add(new e.BitmapTextField("0", e.Settings.GAME_ATLAS, "Gold", .72, .5, .5, 1)), this.textField.position.set(100, 0), this.highscoreGroup = this.add(this.game.make.group()), this.highscoreGroup.position.set(106, 37), this.lastHighscoreValue = e.ScoreManager.instance.getMaxScores(), this.highscoreIcon = this.highscoreGroup.add(this.game.make.sprite(0, 0, e.Settings.GAME_ATLAS, "topScoreCrown0000")), this.highscoreIcon.anchor.set(1, .5), this.highscoreText = this.highscoreGroup.add(new e.BitmapTextField("" + this.lastHighscoreValue, e.Settings.GAME_ATLAS, "Gold", .42, 0, .5, 1)), this.highscoreText.position.set(0, 1), e.ScoreManager.instance.onScoreChanges.add(this.dispatchScoreChanged, this)
                }
            }, {
                key: "dispatchScoreChanged",
                value: function(t) {
                    if (this.lastScoreValue != t) {
                        var i = Phaser.Math.clamp(50 * Math.pow(Math.abs(t - this.lastScoreValue), .5), 250, 1e3);
                        this.textField.tweenText(this.lastScoreValue, t, i, 0), this.lastScoreValue = t, this.tweenIcon(i);
                        var n = Math.max(e.ScoreManager.instance.getMaxScores(), t);
                        this.lastHighscoreValue < n && (this.highscoreText.tweenText(this.lastHighscoreValue, n, i, 0), this.lastHighscoreValue = n)
                    }
                }
            }, {
                key: "update",
                value: function() {
                    if (this.highscoreGroup.visible) {
                        var e = this.highscoreText.getLocalBounds().width * this.highscoreText.scale.x;
                        this.highscoreIcon.x = -e / 2 - 2, this.highscoreText.x = -e / 2
                    }
                }
            }, {
                key: "destroy",
                value: function() {
                    e.ScoreManager.instance.onScoreChanges.remove(this.dispatchScoreChanged, this), _get(_getPrototypeOf(i.prototype), "destroy", this).call(this)
                }
            }]), i
        }();
        e.ScoreCounter = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(e) {
                var t;
                return _classCallCheck(this, i), (t = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e.game, null))).windowShop = e, t.buildChildren(), t
            }
            return _inherits(i, Phaser.Group), _createClass(i, [{
                key: "buildChildren",
                value: function() {
                    this.contentContainer = this.add(this.game.make.group()), this.contentContainer.scale.set(1.25), this.icon = this.contentContainer.add(this.game.make.sprite(1, 0, e.Settings.GAME_ATLAS, "uiIconStar0000")), this.icon.anchor.set(.5), this.icon.scale.set(.9), this.textField = this.contentContainer.add(new e.BitmapTextField("0", e.Settings.GAME_ATLAS, "Gold", .67, 0, .5, 1)), this.textField.position.set(40, 3), this.errorSmile = this.add(this.game.make.sprite(135, 5, e.Settings.GAME_ATLAS, "errorSmile0000")), this.errorSmile.anchor.set(.5), this.errorSmile.alpha = 0, this.updateStarsAmount(e.StarsManager.instance.getStarsAmount()), e.StarsManager.instance.onStarsAmountChanged.add(this.updateStarsAmount, this)
                }
            }, {
                key: "dispatchStarAdded",
                value: function(e) {
                    this.updateStarsAmount(e)
                }
            }, {
                key: "setStarsAmount",
                value: function(e) {
                    this.textField.changeText("" + e, !0)
                }
            }, {
                key: "updateStarsAmount",
                value: function(e) {
                    this.game.tweens.removeFrom(this.textField.scale), this.textField.changeText("" + e), this.textField.scale.set(0), this.game.add.tween(this.textField.scale).to({
                        x: .6,
                        y: .6
                    }, 190, Phaser.Easing.Back.Out, !0)
                }
            }, {
                key: "displayError",
                value: function() {
                    this.game.tweens.removeFrom(this.errorSmile), this.game.tweens.removeFrom(this.errorSmile.scale), this.errorSmile.alpha = 0, this.errorSmile.x = this.textField.x + this.textField.getLocalBounds().width * this.textField.scale.x + 80, this.errorSmile.y = 20, this.errorSmile.scale.set(0), this.game.add.tween(this.errorSmile).to({
                        alpha: .9
                    }, 120, Phaser.Easing.Sinusoidal.In, !1).to({
                        alpha: 0
                    }, 700, Phaser.Easing.Quintic.In, !1).start(), this.game.add.tween(this.errorSmile).to({
                        y: 2
                    }, 180, Phaser.Easing.Sinusoidal.In, !1).to({
                        y: -30
                    }, 700, Phaser.Easing.Linear.None, !1).start(), this.game.add.tween(this.errorSmile.scale).to({
                        x: 1.5,
                        y: 1.5
                    }, 240, Phaser.Easing.Elastic.Out, !1).to({
                        x: 1.65,
                        y: 1.65
                    }, 550, Phaser.Easing.Quadratic.In, !1).start()
                }
            }]), i
        }();
        e.ShopStarsCounter = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i() {
                return _classCallCheck(this, i), _possibleConstructorReturn(this, _getPrototypeOf(i).apply(this, arguments))
            }
            return _inherits(i, e.AbstractUICounter), _createClass(i, [{
                key: "buildChildren",
                value: function() {
                    this.pad = this.add(this.game.make.sprite(0, 0, e.Settings.GAME_ATLAS, "scorePad0000")), this.pad.anchor.set(0, .5), this.pad.scale.set(1.3), this.icon = this.add(this.game.make.sprite(5, 0, e.Settings.GAME_ATLAS, "uiIconStar0000")), this.icon.anchor.set(.5), this.textField = this.add(new e.BitmapTextField("0", e.Settings.GAME_ATLAS, "Gold", .72, .5, .5, 1)), this.textField.position.set(95, 0), this.buttonGetStars = this.add(new e.ButtonGetStars), this.buttonGetStars.position.set(124, 44), this.updateStarsAmount(e.StarsManager.instance.getStarsAmount()), e.StarsManager.instance.onStarAdded.add(this.dispatchStarAdded, this), e.StarsManager.instance.onStarsAmountChanged.add(this.updateStarsAmount, this)
                }
            }, {
                key: "playStarIncreasingTween",
                value: function() {
                    e.SoundController.instance.playStarReceivedSound(), this.game.add.tween(this.textField.scale).to({
                        x: .65,
                        y: .65
                    }, 140, Phaser.Easing.Sinusoidal.Out, !0, 0, 0, !0), this.game.add.tween(this.icon.scale).to({
                        x: 1.45,
                        y: 1.45
                    }, 80, Phaser.Easing.Sinusoidal.Out, !1).to({
                        x: .87,
                        y: .87
                    }, 200, Phaser.Easing.Sinusoidal.In, !1).to({
                        x: 1,
                        y: 1
                    }, 60, Phaser.Easing.Sinusoidal.Out, !1).start()
                }
            }, {
                key: "dispatchStarAdded",
                value: function(e) {
                    this.updateStarsAmount(e), this.playStarIncreasingTween()
                }
            }, {
                key: "updateStarsAmount",
                value: function(e) {
                    this.textField.changeText("" + e)
                }
            }, {
                key: "destroy",
                value: function() {
                    e.StarsManager.instance.onStarAdded.remove(this.dispatchStarAdded, this), e.StarsManager.instance.onStarsAmountChanged.remove(this.updateStarsAmount, this), _get(_getPrototypeOf(i.prototype), "destroy", this).call(this)
                }
            }]), i
        }();
        e.StarsCounter = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t) {
                var n;
                return _classCallCheck(this, i), (n = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, t.game))).padHeight = 70, n.storedMultiplierValue = 1, n.storedProgressValue = 0, n.uiManager = t, n.level = t.level, n.buildChildren(), e.ScoreManager.instance.onMultiplierChanges.add(n.handleMultiplierChange, _assertThisInitialized(n)), n
            }
            return _inherits(i, Phaser.Group), _createClass(i, [{
                key: "buildChildren",
                value: function() {
                    this.contentContainer = this.add(this.game.make.group()), this.padGrayscale = this.contentContainer.add(this.game.make.sprite(0, 0, e.Settings.ANIMATION_ATLAS, "multiplierPadGrey0000")), this.padGrayscale.anchor.set(.5), this.padGrayscale.scale.set(.75), this.textFieldGrayscale = this.contentContainer.add(new e.BitmapTextField("x" + this.storedMultiplierValue, e.Settings.GAME_ATLAS, "MultiplierGrey", 1.1, .5, .5, -2)), this.textFieldGrayscale.position.set(0, 0), this.padGold = this.contentContainer.add(this.game.make.sprite(0, 0, e.Settings.ANIMATION_ATLAS, "multiplierPad0000")), this.padGold.anchor.set(.5), this.padGold.scale.set(.75), this.padWhite = this.contentContainer.add(this.game.make.sprite(0, 0, e.Settings.ANIMATION_ATLAS, "multiplierPadWhite0000")), this.padWhite.anchor.set(.5), this.padWhite.alpha = 0, this.padWhite.scale.set(.75), this.textFieldGold = this.contentContainer.add(new e.BitmapTextField("x" + this.storedMultiplierValue, e.Settings.GAME_ATLAS, "Multiplier", 1.1, .5, .5, -2)), this.textFieldGold.position.set(0, 0), this.progressMask = this.contentContainer.add(this.game.make.graphics(0, this.padHeight / 2)), this.progressMask.beginFill(0, .5).drawRect(-this.padGold.width / 2, 0, this.padGold.width, this.padGold.height).endFill(), this.padGold.mask = this.progressMask, this.textFieldGold.mask = this.progressMask
                }
            }, {
                key: "handleMultiplierChange",
                value: function(t, i) {
                    var n = this;
                    if (this.storedMultiplierValue == t) this.game.add.tween(this.progressMask).to({
                        y: (.5 - i) * this.padHeight - 1
                    }, 500, Phaser.Easing.Sinusoidal.Out, !0), this.game.tweens.removeFrom(this.padWhite), this.game.add.tween(this.padWhite).to({
                        alpha: .5
                    }, 250, Phaser.Easing.Linear.None, !1).to({
                        alpha: 0
                    }, 250, Phaser.Easing.Linear.None, !1).start();
                    else if (t > this.storedMultiplierValue) {
                        e.AchievementsManager.instance.addValue(e.AchievementType.TOTAL_LEVEL_UPS, t - this.storedMultiplierValue), e.SoundController.instance.playlevelUpSound();
                        var a = 500 * Phaser.Math.clamp(1 - this.storedProgressValue, .1, .8);
                        this.game.add.tween(this.progressMask).to({
                            y: -.5 * this.padHeight - 1
                        }, a, Phaser.Easing.Sinusoidal.Out, !1).to({
                            y: .5 * this.padHeight - 1
                        }, 1, Phaser.Easing.Sinusoidal.Out, !1).to({
                            y: (.5 - i) * this.padHeight - 1
                        }, 500 - a + 1, Phaser.Easing.Sinusoidal.Out, !1).start(), this.game.time.events.add(a, function() {
                            return n.updateMultiplierTexts(t)
                        }), this.game.tweens.removeFrom(this.padWhite), this.game.add.tween(this.padWhite).to({
                            alpha: .6
                        }, a, Phaser.Easing.Linear.None, !1).to({
                            alpha: 0
                        }, 500 - a, Phaser.Easing.Linear.None, !1).start()
                    }
                    this.storedMultiplierValue = t, this.storedProgressValue = i
                }
            }, {
                key: "updateMultiplierTexts",
                value: function(e) {
                    this.textFieldGrayscale.changeText("x" + e), this.textFieldGold.changeText("x" + e)
                }
            }]), i
        }();
        e.MultiplierBar = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(e) {
                var t;
                return _classCallCheck(this, i), (t = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e.game))).padHeight = 70, t.storedMultiplierValue = 1, t.storedProgressValue = 0, t.results = e, t.buildChildren(), t
            }
            return _inherits(i, Phaser.Group), _createClass(i, [{
                key: "buildChildren",
                value: function() {
                    this.contentContainer = this.add(this.game.make.group()), this.padGrayscale = this.contentContainer.add(this.game.make.sprite(0, 0, e.Settings.ANIMATION_ATLAS, "multiplierPadGrey0000")), this.padGrayscale.anchor.set(.5), this.padGrayscale.scale.set(.75), this.textFieldGrayscale = this.contentContainer.add(new e.BitmapTextField("x" + this.storedMultiplierValue, e.Settings.GAME_ATLAS, "MultiplierGrey", 1.1, .5, .5, -2)), this.textFieldGrayscale.position.set(0, 0), this.padGold = this.contentContainer.add(this.game.make.sprite(0, 0, e.Settings.ANIMATION_ATLAS, "multiplierPad0000")), this.padGold.anchor.set(.5), this.padGold.scale.set(.75), this.textFieldGold = this.contentContainer.add(new e.BitmapTextField("x" + this.storedMultiplierValue, e.Settings.GAME_ATLAS, "Multiplier", 1.1, .5, .5, -2)), this.textFieldGold.position.set(0, 0), this.progressMask = this.contentContainer.add(this.game.make.graphics(0, this.padHeight / 2)), this.progressMask.beginFill(0, .5).drawRect(-this.padGold.width / 2, 0, this.padGold.width, this.padGold.height).endFill(), this.padGold.mask = this.progressMask, this.textFieldGold.mask = this.progressMask
                }
            }, {
                key: "setValue",
                value: function(e, t) {
                    this.updateMultiplierTexts(e), this.game.add.tween(this.progressMask).to({
                        y: (.5 - t) * this.padHeight - 1
                    }, 800, Phaser.Easing.Sinusoidal.Out, !0, 650), this.textFieldGrayscale.tweenTextAdvanced("x", 1, e, 800, 650, !1), this.textFieldGold.tweenTextAdvanced("x", 1, e, 800, 650, !1), this.storedMultiplierValue = e, this.storedProgressValue = t
                }
            }, {
                key: "updateMultiplierTexts",
                value: function(e) {
                    this.textFieldGrayscale.changeText("x" + e), this.textFieldGold.changeText("x" + e)
                }
            }]), i
        }();
        e.ResultsMultiplierBar = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t, n) {
                var a;
                return _classCallCheck(this, i), (a = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, t.game, null))).dragging = !1, a.available = !1, a.countdownActive = !1, a.startAngle = 270, a.endAngle = -90 - 1e-6, a.currentStep = {
                    value: 0
                }, a.iconDelta = {
                    x: 0,
                    y: 0
                }, a.powerupContainer = t, a.level = t.level, a.powerupType = n, a.available = e.PowerupManager.instance.isBought(a.powerupType), a.buildContent(), a.addListeners(), a
            }
            return _inherits(i, Phaser.Group), _createClass(i, [{
                key: "buildContent",
                value: function() {
                    this.countdownBar = this.add(this.game.make.sprite(0, 0, e.Settings.GAME_ATLAS, "itemPad0001")), this.countdownBar.anchor.set(.5), this.countdownBar.alpha = 0, this.countdownMask = this.add(this.game.make.graphics(-1, -3)), this.countdownMask.clear().beginFill(16777215, .5).arc(0, 0, 60, Phaser.Math.degToRad(this.startAngle), Phaser.Math.degToRad(this.endAngle + 360 * this.currentStep.value), !0, 180).endFill(), this.countdownBar.mask = this.countdownMask, this.pad = this.add(this.game.make.sprite(0, 0, e.Settings.GAME_ATLAS, "itemPad0000")), this.pad.anchor.set(.5), this.icon = this.add(this.game.make.sprite(0, 0, e.Settings.GAME_ATLAS, "icon" + this.powerupType + "0000")), this.icon.anchor.set(.5), this.mark = this.add(this.game.make.sprite(28, -26, e.Settings.GAME_ATLAS, this.isAvailable() ? "okaySign0000" : "plusSign0000")), this.mark.anchor.set(.5), this.tutorialHand = this.add(this.game.make.sprite(-4, 0, e.Settings.GAME_ATLAS, "tutorialHand0000")), this.tutorialHand.anchor.set(0, 0), this.tutorialHand.scale.set(.5), this.tutorialHand.angle = -24, this.tutorialHand.visible = !1, this.animateAppearing(), e.PowerupManager.instance.isBought(this.powerupType) && this.activate()
                }
            }, {
                key: "addListeners",
                value: function() {
                    e.PowerupManager.instance.onPowerupBought.add(this.handlePowerupBought, this), this.level.eventManager.onPowerupApplied.add(this.handlePowerupApplied, this, 999), this.pad.inputEnabled = !0, this.pad.input.pixelPerfectClick = !0, this.pad.input.pixelPerfectAlpha = 1, this.pad.events.onInputDown.add(this.handleInputDown, this), this.pad.events.onInputUp.add(this.handleInputUp, this)
                }
            }, {
                key: "animateAppearing",
                value: function() {
                    this.visible = !0, this.icon.scale.set(1), this.icon.position.set(0, 0), this.icon.visible = !0, this.scale.set(0), this.game.add.tween(this.scale).to({
                        x: 1,
                        y: 1
                    }, 240, Phaser.Easing.Circular.Out, !0, 0), this.game.tweens.removeFrom(this, !1), this.alpha = 0, this.y = 35, this.game.add.tween(this).to({
                        alpha: 1,
                        y: 0
                    }, 240, Phaser.Easing.Linear.None, !0)
                }
            }, {
                key: "handleInputDown",
                value: function(e, t) {
                    this.isAvailable() ? (this.dragging = !0, this.parent && this.parent.setChildIndex(this, this.parent.children.length - 1), this.game.tweens.removeFrom(this.iconDelta), this.iconDelta.x = 0, this.iconDelta.y = 0, this.game.add.tween(this.iconDelta).to(this.level.serviceManager.layoutService.getPowerupDraggingDelta(), 80, Phaser.Easing.Linear.None, !0), this.game.tweens.removeFrom(this.icon.scale), this.icon.scale.set(1), this.game.add.tween(this.icon.scale).to({
                        x: 1.5,
                        y: 1.5
                    }, 80, Phaser.Easing.Linear.None, !0), this.game.tweens.removeFrom(this.mark.scale), this.game.add.tween(this.mark.scale).to({
                        x: 0,
                        y: 0
                    }, 60, Phaser.Easing.Linear.None, !0), this.game.tweens.removeFrom(this.mark), this.game.add.tween(this.mark).to({
                        alpha: 0
                    }, 60, Phaser.Easing.Linear.None, !0), this.powerupContainer.pauseCountdowns()) : this.displayShop()
                }
            }, {
                key: "handleInputUp",
                value: function(e, t) {
                    if (this.isAvailable()) {
                        var i = this.getCurrentCell();
                        this.canBeApplied(i) ? this.applyPowerup(i) : (this.game.tweens.removeFrom(this.icon.scale), this.icon.scale.set(1), this.game.add.tween(this.icon.scale).to({
                            x: 1,
                            y: 1
                        }, 100, Phaser.Easing.Linear.None, !0), this.game.tweens.removeFrom(this.icon), this.game.add.tween(this.icon).to({
                            x: 0,
                            y: 0
                        }, 100, Phaser.Easing.Linear.None, !0)), this.dragging = !1, this.level.boardManager.getBoard().dispatchPowerupIsBeingDragged([]), this.game.tweens.removeFrom(this.mark.scale), this.game.add.tween(this.mark.scale).to({
                            x: 1,
                            y: 1
                        }, 60, Phaser.Easing.Linear.None, !0), this.game.tweens.removeFrom(this.mark), this.game.add.tween(this.mark).to({
                            alpha: 1
                        }, 60, Phaser.Easing.Linear.None, !0), this.powerupContainer.resumeCountdowns()
                    }
                }
            }, {
                key: "update",
                value: function() {
                    if (_get(_getPrototypeOf(i.prototype), "update", this).call(this), this.countdownActive && (e.WindowManager.instance.hasOpenedWindows() || this.powerupContainer.hasDraggingPowerups() || (this.currentStep.value += this.game.time.elapsedMS / e.Settings.POWERUP_USAGE_COUNTDOWN_WHEN_NO_MOVES_LEFT, this.currentStep.value > 1 && (this.currentStep.value = 0, this.countdownFinished())), this.countdownMask.clear().beginFill(16777215, .5).arc(0, 0, 70, Phaser.Math.degToRad(this.startAngle), Phaser.Math.degToRad(this.endAngle + 360 * this.currentStep.value), !0, 180).endFill()), this.level.gameStateManager.isGameActive() && this.dragging) {
                        var t = this.toLocal(this.game.input.activePointer.position, this.game.world),
                            n = t.x,
                            a = t.y;
                        this.icon.position.set(n + this.iconDelta.x, a + this.iconDelta.y), this.level.boardManager.getBoard().dispatchPowerupIsBeingDragged(this.getTargetCells(this.getCurrentCell()))
                    } else this.updateView()
                }
            }, {
                key: "pauseCountdown",
                value: function() {
                    this.countdownActive && (this.game.add.tween(this.tutorialHand).to({
                        alpha: 0
                    }, 70, Phaser.Easing.Linear.None, !0), this.game.add.tween(this.countdownBar).to({
                        alpha: 0
                    }, 80, Phaser.Easing.Linear.None, !0))
                }
            }, {
                key: "resumeCountdown",
                value: function() {
                    this.countdownActive && (this.game.add.tween(this.tutorialHand).to({
                        alpha: 1
                    }, 70, Phaser.Easing.Linear.None, !0), this.game.add.tween(this.countdownBar).to({
                        alpha: 1
                    }, 70, Phaser.Easing.Linear.None, !0))
                }
            }, {
                key: "isAvailable",
                value: function() {
                    return this.available
                }
            }, {
                key: "mayBeBought",
                value: function() {
                    return e.PowerupManager.instance.getPrice(this.powerupType) <= e.StarsManager.instance.getStarsAmount()
                }
            }, {
                key: "updateView",
                value: function() {
                    e.PowerupManager.instance.isBought(this.powerupType) ? (this.mark.visible = !0, this.mark.frameName = "okaySign0000") : (this.icon.frameName = "icon" + this.powerupType + "0000", this.mark.visible = !0, this.mark.frameName = "plusSign0000")
                }
            }, {
                key: "activate",
                value: function() {
                    this.available = !0, this.icon.scale.set(1), this.icon.position.set(0, 0), this.icon.visible = !0, this.mark.frameName = "okaySign0000"
                }
            }, {
                key: "deactivate",
                value: function() {
                    this.isAvailable() && (this.available = !1, this.game.tweens.removeFrom(this.icon.scale), this.icon.scale.set(0), this.icon.position.set(0, 0), this.mark.frameName = "plusSign0000", this.game.add.tween(this.icon.scale).to({
                        x: 1,
                        y: 1
                    }, 180, Phaser.Easing.Sinusoidal.Out, !0))
                }
            }, {
                key: "startCountdown",
                value: function() {
                    this.isAvailable() && (this.resetCountdown(), this.showTutorialHand(), this.countdownBar.visible = !0, this.countdownBar.alpha = 1, this.countdownActive = !0)
                }
            }, {
                key: "countdownFinished",
                value: function() {
                    this.resetCountdown(), this.level.eventManager.onPowerupUsageTimerExceeded.dispatch(), this.hideTutorialHand()
                }
            }, {
                key: "hideTutorialHand",
                value: function() {
                    var e = this;
                    this.game.tweens.removeFrom(this.tutorialHand), this.game.add.tween(this.tutorialHand).to({
                        alpha: 0
                    }, 250, Phaser.Easing.Linear.None, !0).onComplete.add(function() {
                        return e.tutorialHand.visible = !1
                    })
                }
            }, {
                key: "showTutorialHand",
                value: function() {
                    this.game.tweens.removeFrom(this.tutorialHand), this.tutorialHand.visible = !0, this.game.add.tween(this.tutorialHand).to({
                        alpha: 1
                    }, 250, Phaser.Easing.Linear.None, !0), this.game.add.tween(this.tutorialHand).to({
                        x: "-6",
                        y: "-6"
                    }, 300, Phaser.Easing.Linear.None, !0, 0, -1, !0)
                }
            }, {
                key: "handlePowerupApplied",
                value: function() {
                    this.resetCountdown(), this.hideTutorialHand()
                }
            }, {
                key: "resetCountdown",
                value: function() {
                    this.game.tweens.removeFrom(this.currentStep), this.game.tweens.removeFrom(this.countdownBar), this.currentStep.value = 0, this.countdownActive = !1, this.countdownBar.visible = !1, this.countdownBar.alpha = 1, this.countdownMask.clear()
                }
            }, {
                key: "displayShop",
                value: function() {
                    e.WindowManager.instance.showShop(this.powerupType)
                }
            }, {
                key: "getCurrentCell",
                value: function() {
                    var e = this.level.boardManager.getBoard().cellsContainer.toLocal(this.icon.position, this);
                    return this.level.boardManager.getBoard().getCellUnderPoint(e)
                }
            }, {
                key: "handlePowerupBought",
                value: function(e) {
                    e !== this.powerupType || this.isAvailable() || (this.activate(), this.powerupContainer.updatePowerups())
                }
            }, {
                key: "destroy",
                value: function() {
                    e.PowerupManager.instance.onPowerupBought.remove(this.handlePowerupBought, this), _get(_getPrototypeOf(i.prototype), "destroy", this).call(this)
                }
            }]), i
        }();
        e.AbstractPowerup = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t) {
                return _classCallCheck(this, i), _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, t, e.PowerupType.BOMB))
            }
            return _inherits(i, e.AbstractPowerup), _createClass(i, [{
                key: "getTargetCells",
                value: function(e) {
                    return e ? this.level.boardManager.getBoard().getCells().filter(function(t) {
                        return Math.abs(t.posX - e.posX) <= 1 && Math.abs(t.posY - e.posY) <= 1
                    }) : []
                }
            }, {
                key: "canBeApplied",
                value: function(e) {
                    return e && this.getTargetCells(e).some(function(e) {
                        return e.hasBlock()
                    })
                }
            }, {
                key: "applyPowerup",
                value: function(t) {
                    e.PowerupManager.instance.usePowerup(this.powerupType), e.AchievementsManager.instance.addValue(e.AchievementType.BOMB_EXPLOSIONS, 1), this.getTargetCells(t).forEach(function(e) {
                        return e.destroyBlock(0)
                    }), this.level.boardManager.getBoard().effectsContainer.add(new e.ExplosionEffect(t.x, t.y)), this.level.figureManager.updateFiguresApplicability(), this.deactivate(), this.level.eventManager.onPowerupApplied.dispatch(this.powerupType)
                }
            }]), i
        }();
        e.BombPowerup = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t) {
                return _classCallCheck(this, i), _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, t, e.PowerupType.LIGHTNING))
            }
            return _inherits(i, e.AbstractPowerup), _createClass(i, [{
                key: "getTargetCells",
                value: function(e) {
                    return e ? this.level.boardManager.getBoard().getCells().filter(function(t) {
                        return e.hasBlock() && t.hasBlock() && t.getBlock().color == e.getBlock().color
                    }) : []
                }
            }, {
                key: "canBeApplied",
                value: function(e) {
                    return e && e.hasBlock()
                }
            }, {
                key: "applyPowerup",
                value: function(t) {
                    var i = this;
                    e.PowerupManager.instance.usePowerup(this.powerupType);
                    var n = Phaser.ArrayUtils.shuffle(this.getTargetCells(t));
                    if (1 == n.length) this.level.boardManager.getBoard().effectsContainer.add(new e.LightningEffect(t, t).delayedStart(0)), this.game.time.events.add(50, function() {
                        return i.level.figureManager.updateFiguresApplicability()
                    });
                    else {
                        for (var a = 0, s = [t]; s;)
                            for (var o = 0, r = s; o < r.length; o++) {
                                var l = r[o],
                                    h = this.getNextPortionOfCells(n);
                                if (h) {
                                    var u = !0,
                                        c = !1,
                                        d = void 0;
                                    try {
                                        for (var g, p = h[Symbol.iterator](); !(u = (g = p.next()).done); u = !0) {
                                            var v = g.value;
                                            this.level.boardManager.getBoard().effectsContainer.add(new e.LightningEffect(l, v).delayedStart(a))
                                        }
                                    } catch (e) {
                                        c = !0, d = e
                                    } finally {
                                        try {
                                            u || null == p.return || p.return()
                                        } finally {
                                            if (c) throw d
                                        }
                                    }
                                    a += e.LightningEffect.TOTAL_FRAMES / e.LightningEffect.FPS * 1e3 + e.Settings.LIGHTING_DELAY_BETWEEN_STRIKES
                                }
                                s = h
                            }
                        this.game.time.events.add(a + 50, function() {
                            i.level.figureManager.updateFiguresApplicability(), i.level.eventManager.onPowerupApplied.dispatch(i.powerupType)
                        })
                    }
                    this.deactivate()
                }
            }, {
                key: "getNextPortionOfCells",
                value: function(t) {
                    if (0 == t.length) return null;
                    if (t.length < e.Settings.LIGHTING_MIN_TARGETS) return t.splice(0, t.length);
                    var i = e.Settings.LIGHTING_MIN_TARGETS + Math.floor(Math.random() * (e.Settings.LIGHTING_MAX_TARGETS + 1 - e.Settings.LIGHTING_MIN_TARGETS));
                    return t.splice(0, i > t.length ? t.length : i)
                }
            }]), i
        }();
        e.LightningPowerup = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(e) {
                var t;
                return _classCallCheck(this, i), (t = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e.game, null))).usedPowerups = [], t.uiManager = e, t.level = e.level, t.buildContent(), t
            }
            return _inherits(i, Phaser.Group), _createClass(i, [{
                key: "buildContent",
                value: function() {
                    this.lightningPowerup = this.add(new e.LightningPowerup(this)), this.lightningPowerup.position.set(0, 45), this.bombPowerup = this.add(new e.BombPowerup(this)), this.bombPowerup.position.set(0, -45), this.updatePowerups(), this.level.eventManager.onPowerupApplied.add(this.handlePowerupApplied, this)
                }
            }, {
                key: "updatePowerups",
                value: function() {
                    var e = this;
                    this.game.time.events.add(20, function() {
                        return e.resize()
                    })
                }
            }, {
                key: "hidePowerups",
                value: function() {
                    var e = this;
                    this.game.add.tween(this.bombPowerup).to({
                        y: "+50",
                        alpha: 0
                    }, 250, Phaser.Easing.Sinusoidal.Out, !0, 0).onComplete.add(function() {
                        return e.bombPowerup.visible = !1
                    }), this.game.add.tween(this.lightningPowerup).to({
                        y: "+50",
                        alpha: 0
                    }, 250, Phaser.Easing.Sinusoidal.Out, !0, 50).onComplete.add(function() {
                        return e.lightningPowerup.visible = !1
                    })
                }
            }, {
                key: "startCountdown",
                value: function() {
                    this.bombPowerup.startCountdown(), this.lightningPowerup.startCountdown()
                }
            }, {
                key: "pauseCountdowns",
                value: function() {
                    this.bombPowerup.pauseCountdown(), this.lightningPowerup.pauseCountdown()
                }
            }, {
                key: "resumeCountdowns",
                value: function() {
                    this.bombPowerup.resumeCountdown(), this.lightningPowerup.resumeCountdown()
                }
            }, {
                key: "hasDraggingPowerups",
                value: function() {
                    return this.lightningPowerup.dragging || this.bombPowerup.dragging
                }
            }, {
                key: "resize",
                value: function() {
                    e.CustomScaleManager.isPortrait() ? this.resizePortrait() : e.CustomScaleManager.isSquared() ? this.resizeSquared() : e.CustomScaleManager.isLandscape() && this.resizeLandscape()
                }
            }, {
                key: "resizeLandscape",
                value: function() {
                    var e = this.level.serviceManager.layoutService.getAvailablePowerupsContainerBounds();
                    this.position.set(e.x, e.y), this.scale.set(Math.max(Math.min(.6 * e.width / 200, 1.4), 1)), this.bombPowerup.position.set(-48, 0), this.lightningPowerup.position.set(48, 0)
                }
            }, {
                key: "resizePortrait",
                value: function() {
                    var e = this.level.serviceManager.layoutService.getAvailablePowerupsContainerBounds();
                    this.scale.set(Math.max(1, Math.min(e.height / 90, 1.35))), this.position.set(e.x, Math.min(e.y, e.y + e.height / 2 - 48 * this.scale.y)), this.bombPowerup.position.set(-47, 0), this.lightningPowerup.position.set(47, 0)
                }
            }, {
                key: "resizeSquared",
                value: function() {
                    var t = this.level.serviceManager.layoutService.getAvailablePowerupsContainerBounds();
                    this.position.set(t.x, t.y), this.scale.set(1 / Math.pow(e.CustomScaleManager.UPSCALE_FACTOR, .5)), this.bombPowerup.position.set(-48, 0), this.lightningPowerup.position.set(48, 0)
                }
            }, {
                key: "handlePowerupApplied",
                value: function(t) {
                    e.Analytics.instance.updateLevelData({
                        powerups: [t]
                    }), this.usedPowerups.push(t)
                }
            }]), i
        }();
        e.PowerupContainer = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t, n) {
                var a;
                return _classCallCheck(this, i), (a = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e.App.instance, t, n, "more_games"))).anchor.set(.5), a.inputEnabled = !0, a.events.onInputDown.add(a.publisherLogoClicked, _assertThisInitialized(a)), a
            }
            return _inherits(i, Phaser.Sprite), _createClass(i, [{
                key: "publisherLogoClicked",
                value: function() {
                    e.App.instance.navigateToSponsor()
                }
            }]), i
        }();
        e.PublisherLogo = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t) {
                var n;
                return _classCallCheck(this, i), (n = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, t.game, null))).resultsWindow = t, n.stamp = n.add(n.game.make.sprite(0, 0, e.Settings.GAME_ATLAS, "newBestIcon0000")), n.stamp.anchor.set(.5), n
            }
            return _inherits(i, Phaser.Group), _createClass(i, [{
                key: "show",
                value: function(e) {
                    var t = this;
                    this.game.time.events.add(e, function() {
                        return t.playStampTween()
                    })
                }
            }, {
                key: "playStampTween",
                value: function() {
                    var t = this;
                    this.visible = !0, this.scale.set(2.5), this.alpha = .45, this.game.add.tween(this).to({
                        alpha: 1
                    }, 250, Phaser.Easing.Linear.None, !0), this.game.add.tween(this.scale).to({
                        x: 1,
                        y: 1
                    }, 250, Phaser.Easing.Linear.None, !0).onComplete.add(function() {
                        t.parent.scale.set(.95, .95), t.game.add.tween(t.parent.scale).to({
                            x: 1,
                            y: 1
                        }, 320, Phaser.Easing.Back.Out, !0), t.parent && t.parent.parent && t.parent.parent.addChildAt(new e.BestScoreReachedEffectEmitter(0, -15, 120), 0)
                    }), this.game.time.events.add(160, function() {
                        return e.SoundController.instance.playStampSound()
                    })
                }
            }]), i
        }();
        e.NewRecordEffect = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(e) {
                var t;
                return _classCallCheck(this, i), (t = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e.game, null))).results = e, t.scale.set(1.25), t.buildContent(), t
            }
            return _inherits(i, Phaser.Group), _createClass(i, [{
                key: "buildContent",
                value: function() {
                    this.pad = this.add(this.game.make.sprite(12, 0, e.Settings.GAME_ATLAS, "scorePad0000")), this.pad.anchor.set(0, .5), this.pad.scale.set(1.3), this.textField = this.add(new e.BitmapTextField("0", e.Settings.GAME_ATLAS, "Gold", .72, .5, .5, 1)), this.textField.position.set(102, 0), this.highscoreGroup = this.add(this.game.make.group()), this.highscoreGroup.position.set(106, 37), this.highscoreIcon = this.highscoreGroup.add(this.game.make.sprite(0, 0, e.Settings.GAME_ATLAS, "topScoreCrown0000")), this.highscoreIcon.anchor.set(1, .5), this.highscoreText = this.highscoreGroup.add(new e.BitmapTextField("0", e.Settings.GAME_ATLAS, "Gold", .42, 0, .5, 1)), this.highscoreText.position.set(0, 1), this.icon = this.add(this.game.make.sprite(5, 10, e.Settings.GAME_ATLAS, "resultsIconCup0000")), this.icon.anchor.set(.5)
                }
            }, {
                key: "show",
                value: function(e, t, i, n) {
                    var a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "",
                        s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "",
                        o = arguments.length > 6 ? arguments[6] : void 0,
                        r = arguments.length > 7 ? arguments[7] : void 0,
                        l = arguments.length > 8 ? arguments[8] : void 0;
                    this.resetTweens(), this.tweenTexts(e, t, i, n, a, s, r, l), this.animateAppearing(o)
                }
            }, {
                key: "tweenTexts",
                value: function(e, t, i, n, a, s, o, r) {
                    this.highscoreText.changeText("" + i), this.textField.tweenTextAdvanced(a, e, t, r, o, !0), this.highscoreText.tweenTextAdvanced(s, i, n, r, o, !0)
                }
            }, {
                key: "animateAppearing",
                value: function(e) {
                    var t = this;
                    this.icon.scale.set(.5), this.game.add.tween(this.icon.scale).to({
                        x: 1,
                        y: 1
                    }, 350, Phaser.Easing.Back.Out, !0, e + 100), this.icon.alpha = 0, this.game.add.tween(this.icon).to({
                        alpha: 1
                    }, 250, Phaser.Easing.Sinusoidal.Out, !0, e + 100), this.pad.scale.x = 0, this.game.add.tween(this.pad.scale).to({
                        x: 1.3
                    }, 450, Phaser.Easing.Back.Out, !0, e + 150), this.textField.visible = !1, this.textField.scale.set(.5), this.game.add.tween(this.textField.scale).to({
                        x: .72,
                        y: .72
                    }, 450, Phaser.Easing.Back.Out, !0, e + 250).onStart.add(function() {
                        return t.textField.visible = !0
                    }), this.highscoreGroup.visible = !1, this.highscoreGroup.alpha = 0, this.game.add.tween(this.highscoreGroup).to({
                        alpha: 1
                    }, 300, Phaser.Easing.Sinusoidal.Out, !0, e + 400).onStart.add(function() {
                        return t.highscoreGroup.visible = !0
                    }), this.textField.visible = !1, this.textField.alpha = 0, this.game.add.tween(this.textField).to({
                        alpha: 1
                    }, 500, Phaser.Easing.Linear.None, !0, e + 250).onStart.add(function() {
                        return t.textField.visible = !0
                    })
                }
            }, {
                key: "resetTweens",
                value: function() {
                    this.game.tweens.removeFrom(this.alpha), this.game.tweens.removeFrom(this.icon), this.game.tweens.removeFrom(this.icon.scale), this.game.tweens.removeFrom(this.pad.scale), this.game.tweens.removeFrom(this.textField), this.game.tweens.removeFrom(this.textField.scale), this.game.tweens.removeFrom(this.highscoreGroup), this.icon.scale.set(1), this.icon.alpha = 1, this.pad.scale.set(1.3), this.textField.scale.set(1), this.textField.visible = !0, this.highscoreGroup.alpha = 1, this.highscoreGroup.visible = !0
                }
            }, {
                key: "showPanel",
                value: function(t, i, n, a) {
                    this.show(0, e.ScoreManager.instance.getCurrentScores(), a ? e.ScoreManager.instance.getPrevMaxScores() : e.ScoreManager.instance.getMaxScores(), e.ScoreManager.instance.getMaxScores(), "", "", t, t + i, n)
                }
            }, {
                key: "update",
                value: function() {
                    if (this.highscoreGroup.visible) {
                        var e = this.highscoreText.getLocalBounds().width * this.highscoreText.scale.x;
                        this.highscoreIcon.x = -e / 2 - 2, this.highscoreText.x = -e / 2
                    }
                }
            }]), i
        }();
        e.ResultsScoresPanel = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(e) {
                var t;
                return _classCallCheck(this, i), (t = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e.game, null))).results = e, t.scale.set(1.25), t.buildContent(), t
            }
            return _inherits(i, Phaser.Group), _createClass(i, [{
                key: "buildContent",
                value: function() {
                    this.pad = this.add(this.game.make.sprite(10, 0, e.Settings.GAME_ATLAS, "scorePad0000")), this.pad.anchor.set(0, .5), this.pad.scale.set(1.3), this.textField = this.add(new e.BitmapTextField("0", e.Settings.GAME_ATLAS, "Gold", .72, .5, .5, 1)), this.textField.position.set(100, 0), this.icon = this.add(this.game.make.sprite(10, 0, e.Settings.GAME_ATLAS, "resultsIconStar0000")), this.icon.anchor.set(.5)
                }
            }, {
                key: "show",
                value: function(e, t, i, n) {
                    var a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "",
                        s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "",
                        o = arguments.length > 6 ? arguments[6] : void 0,
                        r = arguments.length > 7 ? arguments[7] : void 0,
                        l = arguments.length > 8 ? arguments[8] : void 0;
                    this.resetTweens(), this.tweenTexts(e, t, i, n, a, s, r, l), this.animateAppearing(o)
                }
            }, {
                key: "tweenTexts",
                value: function(e, t, i, n, a, s, o, r) {
                    this.textField.tweenTextAdvanced(a, e, t, r, o, !0)
                }
            }, {
                key: "animateAppearing",
                value: function(e) {
                    var t = this;
                    this.icon.scale.set(.5), this.game.add.tween(this.icon.scale).to({
                        x: 1,
                        y: 1
                    }, 350, Phaser.Easing.Back.Out, !0, e + 100), this.icon.alpha = 0, this.game.add.tween(this.icon).to({
                        alpha: 1
                    }, 250, Phaser.Easing.Sinusoidal.Out, !0, e + 100), this.pad.scale.x = 0, this.game.add.tween(this.pad.scale).to({
                        x: 1.3
                    }, 450, Phaser.Easing.Back.Out, !0, e + 150), this.textField.visible = !1, this.textField.scale.set(.5), this.game.add.tween(this.textField.scale).to({
                        x: .72,
                        y: .72
                    }, 450, Phaser.Easing.Back.Out, !0, e + 250).onStart.add(function() {
                        return t.textField.visible = !0
                    }), this.textField.visible = !1, this.textField.alpha = 0, this.game.add.tween(this.textField).to({
                        alpha: 1
                    }, 500, Phaser.Easing.Linear.None, !0, e + 250).onStart.add(function() {
                        return t.textField.visible = !0
                    })
                }
            }, {
                key: "resetTweens",
                value: function() {
                    this.game.tweens.removeFrom(this.alpha), this.game.tweens.removeFrom(this.icon), this.game.tweens.removeFrom(this.icon.scale), this.game.tweens.removeFrom(this.pad.scale), this.game.tweens.removeFrom(this.textField), this.game.tweens.removeFrom(this.textField.scale), this.icon.scale.set(1), this.icon.alpha = 1, this.pad.scale.set(1.3), this.textField.scale.set(1), this.textField.visible = !0
                }
            }, {
                key: "showPanel",
                value: function(t, i, n) {
                    this.show(0, Math.max(0, e.StarsManager.instance.getStarsAmount()), 0, 0, "", "", t, t + i, n)
                }
            }]), i
        }();
        e.ResultsStarsPanel = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t) {
                var n;
                return _classCallCheck(this, i), (n = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, t.game, null))).countdownActive = !1, n.startAngle = 270, n.endAngle = -90 - 1e-6, n.currentStep = {
                    value: 0
                }, n.windowRevive = t, n.circle = n.add(n.game.make.sprite(0, 0, e.Settings.GAME_ATLAS, "reviveCircle0000")), n.circle.anchor.set(.5), n.circleMask = n.add(n.game.make.graphics(-1, -3)), n.circleMask.clear().beginFill(16777215, .5).arc(0, 0, 160, Phaser.Math.degToRad(n.startAngle), Phaser.Math.degToRad(n.endAngle + 360 * n.currentStep.value), !0, 180).endFill(), n.circle.mask = n.circleMask, n.heart = n.add(n.game.make.sprite(0, -25, e.Settings.GAME_ATLAS, "iconRevive0000")), n.heart.anchor.set(.5), n.timeLeftText = n.add(e.TextUtils.getText("9...", 0, 70, 65, "#FF5E40")), n
            }
            return _inherits(i, Phaser.Group), _createClass(i, [{
                key: "update",
                value: function() {
                    if (_get(_getPrototypeOf(i.prototype), "update", this).call(this), this.isActive()) {
                        var t = Math.ceil(10 * (1 - this.currentStep.value));
                        this.timeLeftText.setText("" + e.TextUtils.convertMSToMSS(1e3 * t)), this.circleMask.clear().beginFill(16777215, .5).arc(0, 0, 160, Phaser.Math.degToRad(this.startAngle), Phaser.Math.degToRad(this.endAngle + 360 * this.currentStep.value), !0, 180).endFill()
                    }
                }
            }, {
                key: "startCountdown",
                value: function() {
                    var t = this;
                    e.SoundController.instance.chokeMusicVolume(400), this.resetCountdown(), this.circle.visible = !0, this.circle.alpha = 1, this.heart.visible = !0, this.timeLeftText.visible = !0, this.countdownActive = !0, this.game.add.tween(this.currentStep).to({
                        value: 1
                    }, e.Settings.REVIVE_TIMER_DURATION, Phaser.Easing.Linear.None, !0).onComplete.add(this.stopCountdown, this), this.heart.scale.set(0), this.game.add.tween(this.heart.scale).to({
                        x: 1,
                        y: 1
                    }, 600, Phaser.Easing.Back.Out, !0).onComplete.add(function() {
                        return t.startHeartbeatAnimation()
                    })
                }
            }, {
                key: "startHeartbeatAnimation",
                value: function() {
                    this.game.tweens.removeFrom(this.heart.scale), this.heart.scale.set(1);
                    var t = this.game.add.tween(this.heart.scale).to({
                        x: 1.1,
                        y: 1.1
                    }, 100, Phaser.Easing.Sinusoidal.In, !1, 0).to({
                        x: 1,
                        y: 1
                    }, 310, Phaser.Easing.Sinusoidal.Out, !1).to({
                        x: 1.1,
                        y: 1.1
                    }, 100, Phaser.Easing.Sinusoidal.In, !1, 25).to({
                        x: 1,
                        y: 1
                    }, 140, Phaser.Easing.Sinusoidal.Out, !1).to({
                        x: 1,
                        y: 1
                    }, 650, Phaser.Easing.Sinusoidal.Out, !1).start().repeatAll(-1);
                    t.onLoop.add(function() {
                        return e.SoundController.instance.playHeartBeatSound()
                    }), t.onStart.add(function() {
                        return e.SoundController.instance.playHeartBeatSound()
                    })
                }
            }, {
                key: "stopCountdown",
                value: function() {
                    this.resetCountdown(), this.windowRevive.reviveFailed(!0)
                }
            }, {
                key: "animateDisappearing",
                value: function(t) {
                    var i = this;
                    e.SoundController.instance.restoreMusicVolume(600), this.game.add.tween(this).to({
                        alpha: 0
                    }, 200, Phaser.Easing.Linear.None, !0, t + 50).onComplete.add(function() {
                        i.heart.visible = !1, i.timeLeftText.visible = !1
                    }), this.game.add.tween(this.scale).to({
                        x: .6,
                        y: .6
                    }, 200, Phaser.Easing.Back.In, !0, t + 50), this.game.add.tween(this.circle).to({
                        alpha: 0
                    }, 200, Phaser.Easing.Sinusoidal.In, !0, t).onComplete.add(function() {
                        return i.circle.visible = !1
                    })
                }
            }, {
                key: "resetCountdown",
                value: function() {
                    this.game.tweens.removeFrom(this.currentStep), this.game.tweens.removeFrom(this.heart.scale), this.game.tweens.removeFrom(this.timeLeftText.scale), this.game.tweens.removeFrom(this.circle), this.timeLeftText.scale.set(1), this.heart.scale.set(1), this.currentStep.value = 0, this.countdownActive = !1, this.circle.visible = !1, this.circle.alpha = 1, this.circleMask.clear()
                }
            }, {
                key: "isActive",
                value: function() {
                    return this.countdownActive
                }
            }]), i
        }();
        e.ReviveCountdown = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i() {
                var t;
                return _classCallCheck(this, i), (t = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e.App.instance))).prevValue = .5, t.sliderDx = 0, t.buildChildren(), t.initValue(), t
            }
            return _inherits(i, Phaser.Group), _createClass(i, [{
                key: "buildChildren",
                value: function() {
                    this.buildScrollerContainer(), this.buildPad(), this.buildBar(), this.buildSlider(), this.buildShadow(), this.buildIcon(), this.addIconListeners()
                }
            }, {
                key: "setInitialValue",
                value: function(e) {
                    this.setValue(e, !0), this.prevValue = this.value
                }
            }, {
                key: "buildScrollerContainer",
                value: function() {
                    this.scrollerContainer = this.add(this.game.make.group()), this.scrollerContainer.position.set(58, 0)
                }
            }, {
                key: "buildPad",
                value: function() {
                    this.pad = this.scrollerContainer.add(this.game.make.sprite(0, 0, e.Settings.GAME_ATLAS, "musicControlPad0000")), this.pad.anchor.set(.5)
                }
            }, {
                key: "buildShadow",
                value: function() {
                    this.shadow = this.scrollerContainer.add(this.game.make.sprite(-100, -3, e.Settings.GAME_ATLAS, "controlBarShadow0000")), this.shadow.anchor.set(.5)
                }
            }, {
                key: "buildBar",
                value: function() {
                    this.bar = this.scrollerContainer.add(this.game.make.sprite(0, 0, e.Settings.GAME_ATLAS, "musicControlBar0000")), this.bar.anchor.set(.5), this.barMask = this.scrollerContainer.add(this.game.make.graphics(-this.pad.width / 2, 0)), this.barMask.clear().beginFill(0, .5).drawRect(0, -20, this.pad.width, 40).endFill(), this.bar.mask = this.barMask
                }
            }, {
                key: "buildSlider",
                value: function() {
                    this.slider = this.scrollerContainer.add(this.game.make.sprite(this.sliderDx, 0, e.Settings.GAME_ATLAS, "musicControlSlider0000")), this.slider.anchor.set(.2, .5), this.slider.hitArea = new Phaser.Rectangle(-60, -60, 120, 120), this.slider.inputEnabled = !0, this.slider.input.allowVerticalDrag = !1, this.slider.input.enableDrag(!1, !1, !1, 0, new Phaser.Rectangle(-this.pad.width / 2 + this.sliderDx, -this.slider.height, this.pad.width - this.sliderDx, 2 * this.slider.height)), this.slider.events.onDragUpdate.add(this.handleSliderDrag, this), this.slider.events.onDragStop.add(this.handleSliderDrag, this)
                }
            }, {
                key: "updateBarMask",
                value: function() {
                    this.barMask.clear().beginFill(0, .5).drawRect(0, -20, this.slider.x + this.pad.width / 2 + 20, 40).endFill()
                }
            }, {
                key: "handleSliderDrag",
                value: function() {
                    var e = this.slider.x / (this.pad.width - this.sliderDx - this.slider.width) + .5;
                    this.setValue(Phaser.Math.clamp(e, 0, 1))
                }
            }, {
                key: "addIconListeners",
                value: function() {
                    this.icon.inputEnabled = !0, this.icon.events.onInputDown.add(this.handleIconClicked, this)
                }
            }, {
                key: "handleIconClicked",
                value: function() {
                    0 == this.value ? this.setValue(this.prevValue) : (this.prevValue = this.value, this.setValue(0))
                }
            }, {
                key: "setValue",
                value: function(e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    this.value = e, this.slider.x = (e - .5) * (this.pad.width - this.sliderDx - this.slider.width), this.updateBarMask(), this.dispatchValueChanged(e, t)
                }
            }]), i
        }();
        e.AbstractUIScrollbar = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i() {
                return _classCallCheck(this, i), _possibleConstructorReturn(this, _getPrototypeOf(i).apply(this, arguments))
            }
            return _inherits(i, e.AbstractUIScrollbar), _createClass(i, [{
                key: "initValue",
                value: function() {
                    this.setInitialValue(e.SoundController.instance.getMusicVolume())
                }
            }, {
                key: "buildIcon",
                value: function() {
                    this.icon = this.add(this.game.make.sprite(-100, -5, e.Settings.GAME_ATLAS, "musicControlIcon0000")), this.icon.anchor.set(.5)
                }
            }, {
                key: "dispatchValueChanged",
                value: function(t, i) {
                    this.icon.frameName = 0 === this.value ? "musicControlIcon0001" : "musicControlIcon0000", e.SoundController.instance.setMusicVolume(t), e.Settings.ENABLE_API && !i && gradle.event('EVENT_VOLUMECHANGE', {
                        bgmVolume: Phaser.Math.roundTo(e.SoundController.instance.getMusicVolume(), -2),
                        sfxVolume: Phaser.Math.roundTo(e.SoundController.instance.getSFXVolume(), -2)
                    })
                }
            }]), i
        }();
        e.MusicControlScrollbar = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i() {
                return _classCallCheck(this, i), _possibleConstructorReturn(this, _getPrototypeOf(i).apply(this, arguments))
            }
            return _inherits(i, e.AbstractUIScrollbar), _createClass(i, [{
                key: "initValue",
                value: function() {
                    this.setInitialValue(e.SoundController.instance.getSFXVolume())
                }
            }, {
                key: "buildIcon",
                value: function() {
                    this.icon = this.add(this.game.make.sprite(-100, -5, e.Settings.GAME_ATLAS, "sfxControlIcon0000")), this.icon.anchor.set(.5)
                }
            }, {
                key: "dispatchValueChanged",
                value: function(t, i) {
                    this.icon.frameName = 0 === this.value ? "sfxControlIcon0001" : "sfxControlIcon0000", e.SoundController.instance.setSFXVolume(t), e.Settings.ENABLE_API && !i && gradle.event('EVENT_VOLUMECHANGE', {
                        bgmVolume: Phaser.Math.roundTo(e.SoundController.instance.getMusicVolume(), -2),
                        sfxVolume: Phaser.Math.roundTo(e.SoundController.instance.getSFXVolume(), -2)
                    })
                }
            }]), i
        }();
        e.SFXControlScrollbar = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(e, t) {
                var n;
                return _classCallCheck(this, i), (n = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e.game, null))).windowShop = e, n.powerupType = t, n.buildContent(), n
            }
            return _inherits(i, Phaser.Group), _createClass(i, [{
                key: "buildContent",
                value: function() {
                    this.scale.set(1.2), this.pad = this.add(this.game.make.sprite(-10, 0, e.Settings.GAME_ATLAS, "shopPricePadBig0000")), this.pad.anchor.set(.5), this.pad.inputEnabled = !0, this.pad.events.onInputDown.add(this.buyClicked, this), this.icon = this.add(this.game.make.sprite(-88, -10, e.Settings.GAME_ATLAS, "icon" + this.powerupType + "0000")), this.icon.anchor.set(.5), this.icon.scale.set(1.2), this.priceStar = this.add(this.game.make.sprite(50, -3, e.Settings.GAME_ATLAS, "iconStarShopBig0000")), this.priceStar.anchor.set(.5), this.priceText = this.add(new e.BitmapTextField("" + e.PowerupManager.instance.getPrice(this.powerupType), e.Settings.GAME_ATLAS, "Gold", .75, .5, .5, 1)), this.priceText.position.set(-16, -2), this.buttonBuy = this.add(e.ButtonUtils.createSimpleButton(e.Settings.GAME_ATLAS, "buttonBuyBig", 130, -5, 1, this.buyClicked, this, !1)), this.boughtMark = this.add(this.game.make.sprite(115, -5, e.Settings.GAME_ATLAS, "boughtMarkBig0000")), this.boughtMark.anchor.set(.5), this.boughtMark.scale.set(.75), this.boughtMark.visible = !1
                }
            }, {
                key: "show",
                value: function() {
                    this.boughtMark.visible = !1, this.pad.frameName = "shopPricePadBig0000", this.icon.x = -88, this.priceText.visible = !0, this.priceStar.visible = !0, this.buttonBuy.visible = this.buttonBuy.inputEnabled = !0, this.priceStar.frameName = "iconStarShopBig0000", this.icon.frameName = "icon" + this.powerupType + "0000", this.priceText.styleKey = "Gold", this.priceText.changeText("" + e.PowerupManager.instance.getPrice(this.powerupType), !0)
                }
            }, {
                key: "buyClicked",
                value: function() {
                    e.StarsManager.instance.getStarsAmount() >= e.PowerupManager.instance.getPrice(this.powerupType) ? (this.buttonBuy.inputEnabled = !1, this.buttonBuy.visible = !1, this.boughtMark.visible = !0, this.game.tweens.removeFrom(this.boughtMark.scale), this.boughtMark.scale.set(.2), this.game.add.tween(this.boughtMark.scale).to({
                        x: .75,
                        y: .75
                    }, 50, Phaser.Easing.Sinusoidal.Out, !0), e.SoundController.instance.playBuyingSound(), e.PowerupManager.instance.buy(this.powerupType), this.windowShop.powerupBought()) : this.displayError()
                }
            }, {
                key: "displayError",
                value: function() {
                    this.windowShop.starsCounter.displayError(), e.ColorUtils.bounceTint(this.priceStar, 16711680, 16777215, 350), this.priceText.children.forEach(function(t) {
                        return e.ColorUtils.bounceTint(t, 16711680, 16777215, 350)
                    }), e.SoundController.instance.playErrorSound()
                }
            }]), i
        }();
        e.ShopItem = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t, n) {
                var a;
                return _classCallCheck(this, i), (a = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e.App.instance))).iconFrameName = t, a.backplateType = n, a.buildContent(), a
            }
            return _inherits(i, Phaser.Group), _createClass(i, [{
                key: "buildContent",
                value: function() {
                    this.container = this.add(this.game.make.group()), this.plate = this.container.add(this.game.make.sprite(0, -5, e.Settings.GAME_ATLAS, "windowHeadingBackplate000" + this.backplateType)), this.plate.anchor.set(.5, 0), this.icon = this.container.add(this.game.make.sprite(0, 316, e.Settings.GAME_ATLAS, this.iconFrameName + "0000")), this.icon.anchor.set(.5)
                }
            }, {
                key: "animateAppearing",
                value: function(t) {
                    this.game.tweens.removeFrom(this.container), this.container.y = -450, this.game.add.tween(this.container).to({
                        y: -100
                    }, 350, Phaser.Easing.Back.Out, !0, t).onStart.add(function() {
                        return e.SoundController.instance.playPanelMovementSound()
                    }), this.icon.alpha = 0, this.icon.scale.set(.6), this.game.add.tween(this.icon).to({
                        alpha: 1
                    }, 250, Phaser.Easing.Sinusoidal.Out, !0, t + 100), this.game.add.tween(this.icon.scale).to({
                        x: 1,
                        y: 1
                    }, 300, Phaser.Easing.Back.Out, !0, t)
                }
            }, {
                key: "animateDisappearing",
                value: function(t) {
                    this.game.tweens.removeFrom(this.container), this.game.add.tween(this.container).to({
                        y: -450
                    }, 350, Phaser.Easing.Back.In, !0, t).onStart.add(function() {
                        return e.SoundController.instance.playPanelUpMovementSound()
                    })
                }
            }, {
                key: "resetTweens",
                value: function() {
                    this.game.tweens.removeFrom(this.container), this.game.tweens.removeFrom(this.icon), this.game.tweens.removeFrom(this.icon.scale)
                }
            }]), i
        }();
        e.WindowHeading = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function() {
            function e() {
                _classCallCheck(this, e)
            }
            return _createClass(e, null, [{
                key: "uniteArrays",
                value: function(e, t) {
                    return e.concat(t.filter(function(t) {
                        return -1 === e.indexOf(t)
                    }))
                }
            }, {
                key: "getRandomItem",
                value: function(e, t) {
                    return e[Math.floor(e.length * Math.pow(Math.random(), t))]
                }
            }]), e
        }();
        e.ArrayUtils = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function() {
            function t() {
                _classCallCheck(this, t)
            }
            return _createClass(t, null, [{
                key: "getLetter",
                value: function(t, i, n, a) {
                    var s = null;
                    switch (n) {
                        case "0":
                            s = "text" + t + "_0000" + a;
                            break;
                        case "1":
                            s = "text" + t + "_1000" + a;
                            break;
                        case "2":
                            s = "text" + t + "_2000" + a;
                            break;
                        case "3":
                            s = "text" + t + "_3000" + a;
                            break;
                        case "4":
                            s = "text" + t + "_4000" + a;
                            break;
                        case "5":
                            s = "text" + t + "_5000" + a;
                            break;
                        case "6":
                            s = "text" + t + "_6000" + a;
                            break;
                        case "7":
                            s = "text" + t + "_7000" + a;
                            break;
                        case "8":
                            s = "text" + t + "_8000" + a;
                            break;
                        case "9":
                            s = "text" + t + "_9000" + a;
                            break;
                        case ".":
                            s = "text" + t + "_point000" + a;
                            break;
                        case "+":
                            s = "text" + t + "_plus000" + a;
                            break;
                        case "*":
                            s = "text" + t + "_multiply000" + a;
                            break;
                        case "=":
                            s = "text" + t + "_equals000" + a;
                            break;
                        case "%":
                            s = "text" + t + "_percent000" + a;
                            break;
                        case "a":
                            s = "text" + t + "_a000" + a;
                            break;
                        case "b":
                            s = "text" + t + "_b000" + a;
                            break;
                        case "c":
                            s = "text" + t + "_c000" + a;
                            break;
                        case "d":
                            s = "text" + t + "_d000" + a;
                            break;
                        case "e":
                            s = "text" + t + "_e000" + a;
                            break;
                        case "f":
                            s = "text" + t + "_f000" + a;
                            break;
                        case "g":
                            s = "text" + t + "_g000" + a;
                            break;
                        case "h":
                            s = "text" + t + "_h000" + a;
                            break;
                        case "i":
                            s = "text" + t + "_i000" + a;
                            break;
                        case "j":
                            s = "text" + t + "_j000" + a;
                            break;
                        case "k":
                            s = "text" + t + "_k000" + a;
                            break;
                        case "l":
                            s = "text" + t + "_l000" + a;
                            break;
                        case "m":
                            s = "text" + t + "_m000" + a;
                            break;
                        case "n":
                            s = "text" + t + "_n000" + a;
                            break;
                        case "o":
                            s = "text" + t + "_o000" + a;
                            break;
                        case "p":
                            s = "text" + t + "_p000" + a;
                            break;
                        case "q":
                            s = "text" + t + "_q000" + a;
                            break;
                        case "r":
                            s = "text" + t + "_r000" + a;
                            break;
                        case "s":
                            s = "text" + t + "_s000" + a;
                            break;
                        case "t":
                            s = "text" + t + "_t000" + a;
                            break;
                        case "u":
                            s = "text" + t + "_u000" + a;
                            break;
                        case "v":
                            s = "text" + t + "_v000" + a;
                            break;
                        case "w":
                            s = "text" + t + "_w000" + a;
                            break;
                        case "x":
                            s = "text" + t + "_x000" + a;
                            break;
                        case "y":
                            s = "text" + t + "_y000" + a;
                            break;
                        case "z":
                            s = "text" + t + "_z000" + a;
                            break;
                        case "/":
                            s = "text" + t + "_slash000" + a;
                            break;
                        case " ":
                            s = "text" + t + "_z000" + a;
                            break;
                        case "_":
                            s = "text" + t + "_point000" + a;
                            break;
                        case "?":
                            s = "text" + t + "_question000" + a
                    }
                    if (!s) return null;
                    var o = new Phaser.Sprite(e.App.instance, 0, 0, i, s);
                    return o.anchor.setTo(0, 0), o.alpha = " " === n || "_" == n ? 0 : 1, o.scale.x = "_" === n ? .5 : 1, o
                }
            }]), t
        }();
        e.BitmapTextFactory = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function() {
            function t() {
                _classCallCheck(this, t)
            }
            return _createClass(t, null, [{
                key: "createButton",
                value: function(t, i, n, a, s, o) {
                    var r = new Phaser.Button(e.App.instance, n, a, t, s, o, i + "0001", i + "0000", i + "0002", i + "0000");
                    return r.anchor.setTo(.5, .5), r.input.pixelPerfectClick = !0, r.input.pixelPerfectAlpha = 1, r.input.useHandCursor = !0, r
                }
            }, {
                key: "createOneFrameButton",
                value: function(t, i, n, a, s, o) {
                    var r = new Phaser.Button(e.App.instance, n, a, t, s, o, i + "0000", i + "0000", i + "0000", i + "0000");
                    return r.anchor.setTo(.5, .5), r.input.pixelPerfectClick = !0, r.input.pixelPerfectAlpha = 1, r.input.useHandCursor = !0, r
                }
            }, {
                key: "createSimpleButton",
                value: function(i, n, a, s, o, r, l) {
                    var h = !(arguments.length > 7 && void 0 !== arguments[7]) || arguments[7],
                        u = new Phaser.Button(e.App.instance, a, s, i, r, l, n + "0000", n + "0000", n + "0000", n + "0000");
                    return u.anchor.setTo(.5, .5), u.scale.set(o), u.input.pixelPerfectClick = !0, u.input.pixelPerfectAlpha = 1, u.input.useHandCursor = !1, u.overTween = e.App.instance.add.tween(u.scale).to({
                        x: 1.05 * o,
                        y: 1.05 * o
                    }, 100), u.outTween = e.App.instance.add.tween(u.scale).to({
                        x: o,
                        y: o
                    }, 100), u.downTween = e.App.instance.add.tween(u.scale).to({
                        x: .95 * o,
                        y: .95 * o
                    }, 50).to({
                        x: o,
                        y: o
                    }, 50), u.events.onInputOver.add(t.mouseOverHandler, this, 0), u.events.onInputOut.add(t.mouseOutHandler, this, 0), u.events.onInputDown.add(t.mouseDownHandler, this, 0), h && u.events.onInputDown.add(function() {
                        return e.SoundController.instance.playClickSound()
                    }, 0), u.setScale = function(t) {
                        u.scale.set(t), u.overTween = e.App.instance.add.tween(u.scale).to({
                            x: 1.05 * t,
                            y: 1.05 * t
                        }, 100), u.outTween = e.App.instance.add.tween(u.scale).to({
                            x: t,
                            y: t
                        }, 100), u.downTween = e.App.instance.add.tween(u.scale).to({
                            x: .95 * t,
                            y: .95 * t
                        }, 50).to({
                            x: t,
                            y: t
                        }, 50)
                    }, u
                }
            }, {
                key: "mouseOverHandler",
                value: function(e) {
                    e.overTween.start()
                }
            }, {
                key: "mouseOutHandler",
                value: function(e) {
                    e.outTween.start()
                }
            }, {
                key: "mouseDownHandler",
                value: function(e) {
                    e.downTween.start()
                }
            }]), t
        }();
        e.ButtonUtils = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function() {
            function t() {
                _classCallCheck(this, t)
            }
            return _createClass(t, null, [{
                key: "tweenTint",
                value: function(t, i, n, a) {
                    var s = {
                        step: 0
                    };
                    e.App.instance.add.tween(s).to({
                        step: 100
                    }, a, Phaser.Easing.Linear.None, !0).onUpdateCallback(function() {
                        t.tint = Phaser.Color.interpolateColor(i, n, 100, s.step, 1)
                    }).onComplete.add(function() {
                        return t.tint = n
                    })
                }
            }, {
                key: "bounceTint",
                value: function(t, i, n, a) {
                    var s = {
                        step: 10
                    };
                    e.App.instance.add.tween(s).to({
                        step: 100
                    }, a, Phaser.Easing.Bounce.Out, !0).onUpdateCallback(function() {
                        t.tint = Phaser.Color.interpolateColor(i, n, 100, s.step, 1)
                    }).onComplete.add(function() {
                        return t.tint = n
                    })
                }
            }]), t
        }();
        e.ColorUtils = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function() {
            function t() {
                _classCallCheck(this, t), this.isLocalStorageSupported = !1, this.data = null, this.currentLocalStorage = null, this.currentLocalStorage = e.Settings.ENABLE_API ? window.localStorage : window.localStorage, this.data = {
                    maxScore: 0,
                    numStars: 0,
                    bombBought: !1,
                    lightningBought: !1,
                    achievements: null,
                    tutorialCompleted: !1,
                    sfxVolume: .5,
                    musicVolume: .5
                }
            }
            return _createClass(t, [{
                key: "getMaxScores",
                value: function() {
                    return this.data.maxScore
                }
            }, {
                key: "getNumStars",
                value: function() {
                    return this.data.numStars
                }
            }, {
                key: "getSFXVolume",
                value: function() {
                    return this.data.sfxVolume
                }
            }, {
                key: "getMusicVolume",
                value: function() {
                    return this.data.musicVolume
                }
            }, {
                key: "isBombBought",
                value: function() {
                    return this.data.bombBought
                }
            }, {
                key: "isLightningBought",
                value: function() {
                    return this.data.lightningBought
                }
            }, {
                key: "isTutorialCompleted",
                value: function() {
                    return this.data.tutorialCompleted
                }
            }, {
                key: "getAchievementsStates",
                value: function() {
                    return this.data.achievements || []
                }
            }, {
                key: "save",
                value: function() {
                    this.data.maxScore = e.ScoreManager.instance.getMaxScores(), this.data.numStars = e.StarsManager.instance.getStarsAmount(), this.data.achievements = e.AchievementsManager.instance.getAchievementsStates(), this.data.bombBought = e.PowerupManager.instance.isBought(e.PowerupType.BOMB), this.data.lightningBought = e.PowerupManager.instance.isBought(e.PowerupType.LIGHTNING), this.data.tutorialCompleted = e.Settings.TUTORIAL_COMPLETED, this.data.sfxVolume = e.SoundController.instance.getSFXVolume(), this.data.musicVolume = e.SoundController.instance.getMusicVolume(), this.isLocalStorageSupported && this.currentLocalStorage.setItem(t.STORAGE_NAME, JSON.stringify(this.data))
                }
            }, {
                key: "checkLocalStorageSupported",
                value: function() {
                    try {
                        this.isLocalStorageSupported = "localStorage" in window && null !== window.localStorage
                    } catch (e) {
                        this.isLocalStorageSupported = !1
                    }
                }
            }, {
                key: "loadSave",
                value: function() {
                    this.checkLocalStorageSupported(), this.isLocalStorageSupported && (this.currentLocalStorage.getItem(t.STORAGE_NAME) ? this.data = JSON.parse(this.currentLocalStorage.getItem(t.STORAGE_NAME)) : this.currentLocalStorage.setItem(t.STORAGE_NAME, JSON.stringify(this.data))), this.finalizeLoading()
                }
            }, {
                key: "finalizeLoading",
                value: function() {
                    e.SoundController.instance.setSFXVolume(this.getSFXVolume()), e.SoundController.instance.setMusicVolume(this.getMusicVolume()), e.Settings.TUTORIAL_COMPLETED = t.instance.isTutorialCompleted(), e.ScoreManager.instance.setMaxScores(t.instance.getMaxScores()), e.StarsManager.instance.setStarsAmount(t.instance.getNumStars(), !1), e.AchievementsManager.instance.loadAchievementsState(t.instance.getAchievementsStates()), e.PowerupManager.instance.setInitialState(e.PowerupType.BOMB, t.instance.isBombBought()), e.PowerupManager.instance.setInitialState(e.PowerupType.LIGHTNING, t.instance.isLightningBought())
                }
            }], [{
                key: "instance",
                get: function() {
                    return t._instance ? t._instance : t._instance = new t
                }
            }]), t
        }();
        t.STORAGE_NAME = e.Settings.LOCAL_STORAGE_KEY, e.LocalStorageController = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function() {
            function e() {
                _classCallCheck(this, e)
            }
            return _createClass(e, null, [{
                key: "init",
                value: function(t) {
                    e.texts = t
                }
            }, {
                key: "getText",
                value: function(t) {
                    return e.texts[t] ? e.texts[t] : "NO_TEXT"
                }
            }]), e
        }();
        e.LocalizationManager = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function() {
            function t() {
                _classCallCheck(this, t)
            }
            return _createClass(t, null, [{
                key: "getText",
                value: function(t, i, n, a, s) {
                    var o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : e.Settings.DEFAULT_FONT_FAMILY,
                        r = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null,
                        l = new Phaser.Text(e.App.instance, i, n, t, {
                            font: (r ? r + " " : "") + a + "px " + o,
                            fill: s,
                            align: "center"
                        });
                    return l.anchor.setTo(.5, .5), l
                }
            }, {
                key: "getBitmapText",
                value: function(t, i, n, a) {
                    var s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 16777215,
                        o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : e.Settings.DEFAULT_FONT_FAMILY,
                        r = new Phaser.BitmapText(e.App.instance, i, n, o, t, a, "center");
                    return r.anchor.setTo(.5, .5), r.tint = s, r
                }
            }, {
                key: "getShadowText",
                value: function(t, i, n, a, s) {
                    var o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "#000000",
                        r = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0,
                        l = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 2,
                        h = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : .5,
                        u = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : .5,
                        c = arguments.length > 10 && void 0 !== arguments[10] ? arguments[10] : e.Settings.DEFAULT_FONT_FAMILY,
                        d = arguments.length > 11 && void 0 !== arguments[11] ? arguments[11] : null,
                        g = new Phaser.Text(e.App.instance, i, n, t, {
                            font: (d ? d + " " : "") + a + "px " + c,
                            fill: s,
                            align: "center"
                        });
                    return g.anchor.setTo(h, u), g.setShadow(r, l, o, 0), g
                }
            }, {
                key: "getStyledText",
                value: function(t, i, n, a, s, o) {
                    var r = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 4,
                        l = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : e.Settings.DEFAULT_FONT_FAMILY,
                        h = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : null,
                        u = new Phaser.Text(e.App.instance, i, n, t, {
                            font: (h ? h + " " : "") + a + "px " + l,
                            fill: s,
                            stroke: o,
                            strokeThickness: r,
                            align: "center"
                        });
                    return u.setShadow(0, 2, o, 0), u.anchor.set(.5, .5), u
                }
            }, {
                key: "convertMSToHumanTime",
                value: function(e) {
                    var t = Math.floor(e / 1e3),
                        i = Math.floor(t / 60),
                        n = t - 60 * i;
                    return (i < 10 ? "0" : "") + i + ":" + (n < 10 ? "0" : "") + n
                }
            }, {
                key: "convertMSToMSS",
                value: function(e) {
                    var t = Math.floor(e / 1e3),
                        i = Math.floor(t / 60),
                        n = t - 60 * i;
                    return i + ":" + (n < 10 ? "0" : "") + n
                }
            }, {
                key: "normalizeTime",
                value: function(e) {
                    var t = e,
                        i = Math.floor(t / 3600);
                    t %= 3600;
                    var n = Math.floor(t / 60);
                    return (i < 10 ? "0" : "") + i + ":" + (n < 10 ? "0" : "") + n + ":" + ((t %= 60) < 10 ? "0" : "") + t
                }
            }]), t
        }();
        e.TextUtils = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t) {
                var n, a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e.Settings.WINDOW_BACKGROUND_ALPHA;
                return _classCallCheck(this, i), (n = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e.App.instance, null))).backgroundAlpha = e.Settings.WINDOW_BACKGROUND_ALPHA, n.windowManager = t, n.backgroundAlpha = a, n.visible = !1, n.buildBackground(), n
            }
            return _inherits(i, Phaser.Group), _createClass(i, [{
                key: "buildBackground",
                value: function() {
                    this.background = this.add(this.game.make.sprite(-50, -50, e.Settings.GAME_ATLAS, "blackSquare0000")), this.background.anchor.set(.5), this.background.width = this.game.world.width + 100, this.background.height = this.game.world.height + 100, this.background.alpha = this.backgroundAlpha, this.background.inputEnabled = !0, this.inputEnableChildren = !0
                }
            }, {
                key: "resize",
                value: function() {
                    this.position.set(0, 0), this.background.position.set(this.windowManager.windowBounds.centerX, this.windowManager.windowBounds.centerY), this.background.width = this.windowManager.windowBounds.width + 100, this.background.height = this.windowManager.windowBounds.height + 100, this.resizeContent()
                }
            }, {
                key: "show",
                value: function() {
                    this.visible = !0, this.resize()
                }
            }, {
                key: "hide",
                value: function() {
                    this.visible = !1
                }
            }, {
                key: "lockUpButtons",
                value: function() {
                    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
                    for (var n = 0; n < t.length; n++) t[n].inputEnabled = !1
                }
            }, {
                key: "unlockButtons",
                value: function() {
                    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
                    for (var n = 0; n < t.length; n++) t[n].inputEnabled = !0
                }
            }, {
                key: "destroy",
                value: function() {
                    _get(_getPrototypeOf(i.prototype), "destroy", this).call(this), this.background = null
                }
            }]), i
        }();
        e.AbstractWindow = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(e, t, n, a) {
                var s;
                return _classCallCheck(this, i), (s = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e, a))).headingBackplateType = t, s.headingIconFrameName = n, s.buildWindowBase(), s.buildAdditionalElements(), s.buildContent(), s
            }
            return _inherits(i, e.AbstractWindow), _createClass(i, [{
                key: "buildWindowBase",
                value: function() {
                    this.contentContainer = this.add(this.game.make.group()), this.windowHeading = this.contentContainer.add(new e.WindowHeading(this.headingIconFrameName, this.headingBackplateType))
                }
            }, {
                key: "buildAdditionalElements",
                value: function() {}
            }, {
                key: "resizeContent",
                value: function() {
                    this.contentContainer.position.set(this.windowManager.windowBounds.centerX, this.windowManager.windowBounds.top), this.contentContainer.scale.set(Math.min(1, this.windowManager.windowBounds.height / e.CustomScaleManager.ORIGINAL_HEIGHT)), this.windowHeading.position.set(0, this.windowManager.windowBounds.height / this.contentContainer.scale.y * .001)
                }
            }, {
                key: "show",
                value: function() {
                    _get(_getPrototypeOf(i.prototype), "show", this).call(this), this.resetTweens(), this.background.alpha = 0, this.game.add.tween(this.background).to({
                        alpha: this.backgroundAlpha
                    }, 300, Phaser.Easing.Circular.Out, !0, 0), this.windowHeading.animateAppearing(150), this.animateAppearing(200)
                }
            }, {
                key: "resetTweens",
                value: function() {
                    this.windowHeading.resetTweens()
                }
            }, {
                key: "hide",
                value: function() {
                    this.resetTweens(), _get(_getPrototypeOf(i.prototype), "hide", this).call(this)
                }
            }]), i
        }();
        e.DefaultWindow = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(e, t, n, a) {
                return _classCallCheck(this, i), _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, e, t, n, a))
            }
            return _inherits(i, e.DefaultWindow), _createClass(i, [{
                key: "buildAdditionalElements",
                value: function() {
                    this.buttonClose = this.add(new e.ButtonCloseWindow(this, this.closeClicked, this))
                }
            }, {
                key: "resizeContent",
                value: function() {
                    _get(_getPrototypeOf(i.prototype), "resizeContent", this).call(this), this.buttonClose.resize(-75, 75)
                }
            }, {
                key: "show",
                value: function() {
                    _get(_getPrototypeOf(i.prototype), "show", this).call(this), this.buttonClose.alpha = 1, this.buttonClose.scale.set(0), this.game.add.tween(this.buttonClose.scale).to({
                        x: 1,
                        y: 1
                    }, 350, Phaser.Easing.Back.Out, !0, 300)
                }
            }, {
                key: "animateDisappearing",
                value: function(e) {
                    var t = this,
                        i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                    this.windowHeading.animateDisappearing(e), this.game.tweens.removeFrom(this.buttonClose), this.game.add.tween(this.buttonClose).to({
                        y: "-100",
                        alpha: 0
                    }, 250, Phaser.Easing.Sinusoidal.In, !0, e), this.game.tweens.removeFrom(this.background), this.game.add.tween(this.background).to({
                        alpha: 0
                    }, 300, Phaser.Easing.Circular.In, !0, e + 100).onComplete.add(function() {
                        i && i(), t.hide()
                    })
                }
            }, {
                key: "resetTweens",
                value: function() {
                    _get(_getPrototypeOf(i.prototype), "resetTweens", this).call(this), this.game.tweens.removeFrom(this.buttonClose, !1), this.game.tweens.removeFrom(this.buttonClose.scale, !1)
                }
            }, {
                key: "closeClicked",
                value: function() {
                    this.onCloseClicked(), this.animateDisappearing(0)
                }
            }]), i
        }();
        e.CloseableWindow = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t) {
                var n;
                return _classCallCheck(this, i), n = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, t, e.WindowHeadingBackplateType.SILVER, "iconHeadingAchievements", e.Settings.WINDOW_BACKGROUND_ALPHA)), e.StarsManager.instance.onStarAdded.add(n.handleStarAdded, _assertThisInitialized(n)), n
            }
            return _inherits(i, e.CloseableWindow), _createClass(i, [{
                key: "buildContent",
                value: function() {
                    var t = this;
                    this.itemsContainer = this.contentContainer.add(this.game.make.group()), this.achievementPanels = new Map, Object.keys(e.AchievementType).filter(function(e) {
                        return !isNaN(+e)
                    }).map(function(e) {
                        return +e
                    }).forEach(function(i) {
                        t.achievementPanels.set(i, t.itemsContainer.add(new e.AchievementPanel(t, i, 185 * ((i - 1) % 3 - 1), 200 * (Math.floor((i - 1) / 3) - 1))))
                    })
                }
            }, {
                key: "resizeContent",
                value: function() {
                    _get(_getPrototypeOf(i.prototype), "resizeContent", this).call(this), this.itemsContainer.position.set(0, this.windowManager.windowBounds.height / this.contentContainer.scale.y * .55 + 90)
                }
            }, {
                key: "updateAchievementPanels",
                value: function() {
                    this.achievementPanels.forEach(function(e) {
                        return e.updateView()
                    })
                }
            }, {
                key: "show",
                value: function() {
                    _get(_getPrototypeOf(i.prototype), "show", this).call(this), e.Settings.ENABLE_API && gradle.event('SCREEN_OTHER', "ACHIEVEMENTS"), this.updateAchievementPanels()
                }
            }, {
                key: "animateAppearing",
                value: function(e) {
                    var t = this;
                    this.achievementPanels.forEach(function(i, n) {
                        i.alpha = 1, t.game.add.tween(i).from({
                            alpha: 0,
                            y: "-50"
                        }, 250, Phaser.Easing.Sinusoidal.Out, !0, e + 25 * n), i.scale.set(.8), t.game.add.tween(i.scale).to({
                            x: 1,
                            y: 1
                        }, 250, Phaser.Easing.Back.Out, !0, e + 25 * n)
                    })
                }
            }, {
                key: "animateDisappearing",
                value: function(t, n) {
                    var a = this;
                    _get(_getPrototypeOf(i.prototype), "animateDisappearing", this).call(this, t, n), this.achievementPanels.forEach(function(e, i) {
                        a.game.add.tween(e).to({
                            alpha: 0
                        }, 250, Phaser.Easing.Sinusoidal.Out, !0, t + 25 * i), a.game.add.tween(e.scale).to({
                            x: .55,
                            y: .55
                        }, 250, Phaser.Easing.Back.In, !0, t + 25 * i)
                    }), e.Settings.ENABLE_API && gradle.event('SCREEN_LEVEL')
                }
            }, {
                key: "resetTweens",
                value: function() {
                    _get(_getPrototypeOf(i.prototype), "resetTweens", this).call(this), this.game.tweens.removeFrom(this.itemsContainer, !1), this.game.tweens.removeFrom(this.itemsContainer.scale, !1)
                }
            }, {
                key: "handleStarAdded",
                value: function() {
                    if (this.achievementPanels) {
                        var t = this.achievementPanels.get(e.AchievementType.TOTAL_STARS);
                        t && t.updateView()
                    }
                }
            }, {
                key: "onCloseClicked",
                value: function() {}
            }, {
                key: "continueClicked",
                value: function() {
                    this.animateDisappearing(0, function() {})
                }
            }]), i
        }();
        e.WindowAchievements = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function() {
            function t() {
                _classCallCheck(this, t), this.containerWidth = e.CustomScaleManager.ORIGINAL_WIDTH, this.containerHeight = e.CustomScaleManager.ORIGINAL_HEIGHT, this.isInitialized = !1
            }
            return _createClass(t, [{
                key: "init",
                value: function() {
                    this.container = e.App.instance.stage.add(e.App.instance.make.group()), this.settings = this.container.add(new e.WindowSettings(this)), this.results = this.container.add(new e.WindowResults(this)), this.revive = this.container.add(new e.WindowRevive(this)), this.shop = this.container.add(new e.WindowShop(this)), this.achievements = this.container.add(new e.WindowAchievements(this)), this.isInitialized = !0, this.resize()
                }
            }, {
                key: "resize",
                value: function() {
                    this.isInitialized && (this.container.scale.set(e.CustomScaleManager.SCALE_X, e.CustomScaleManager.SCALE_Y), this.container.position.set(e.CustomScaleManager.WIDTH / 2 - this.containerWidth * e.CustomScaleManager.SCALE_X / 2, e.CustomScaleManager.HEIGHT / 2 - this.containerHeight * e.CustomScaleManager.SCALE_Y / 2), this.windowBounds = this.windowBounds || new e.WindowBounds, this.windowBounds.set(-(e.CustomScaleManager.WIDTH / e.CustomScaleManager.SCALE_X - this.containerWidth) / 2, (e.CustomScaleManager.WIDTH / e.CustomScaleManager.SCALE_X - this.containerWidth) / 2 + this.containerWidth, -(e.CustomScaleManager.HEIGHT / e.CustomScaleManager.SCALE_Y - this.containerHeight) / 2, (e.CustomScaleManager.HEIGHT / e.CustomScaleManager.SCALE_Y - this.containerHeight) / 2 + this.containerHeight), this.settings.resize(), this.results.resize(), this.revive.resize(), this.shop.resize(), this.achievements.resize())
                }
            }, {
                key: "hasOpenedWindows",
                value: function() {
                    return this.settings.visible || this.shop.visible || this.achievements.visible || this.revive.visible || this.results.visible
                }
            }, {
                key: "showSettings",
                value: function() {
                    this.settings.show()
                }
            }, {
                key: "showResults",
                value: function() {
                    this.results.show()
                }
            }, {
                key: "showRevive",
                value: function() {
                    this.revive.show()
                }
            }, {
                key: "showShop",
                value: function(e) {
                    this.shop.setPowerupType(e), this.shop.show()
                }
            }, {
                key: "showAchievements",
                value: function() {
                    this.achievements.show()
                }
            }, {
                key: "hideAll",
                value: function() {
                    this.settings.hide(), this.results.hide(), this.revive.hide(), this.shop.hide(), this.achievements.hide()
                }
            }], [{
                key: "instance",
                get: function() {
                    return t._instance ? t._instance : t._instance = new t
                }
            }]), t
        }();
        t._instance = null, e.WindowManager = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t) {
                return _classCallCheck(this, i), _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, t, e.WindowHeadingBackplateType.GOLD, "iconHeadingVictory", e.Settings.WINDOW_BACKGROUND_ALPHA))
            }
            return _inherits(i, e.DefaultWindow), _createClass(i, [{
                key: "buildContent",
                value: function() {
                    this.controlsContainer = this.contentContainer.add(this.game.make.group()), this.scoresPanel = this.controlsContainer.add(new e.ResultsScoresPanel(this)), this.starsPanel = this.controlsContainer.add(new e.ResultsStarsPanel(this)), this.doubleStarsButton = this.controlsContainer.add(new e.DoubleStarsButton(this)), this.recordEffect = this.controlsContainer.add(new e.NewRecordEffect(this)), this.scoresPanel.position.set(-80, -70), this.starsPanel.position.set(-80, 70), this.doubleStarsButton.position.set(200, 160), this.recordEffect.position.set(205, -63), this.buttonRestart = this.contentContainer.add(e.ButtonUtils.createSimpleButton(e.Settings.GAME_ATLAS, "buttonRestart", 0, 0, 1.35, this.restartClicked, this))
                }
            }, {
                key: "showButtons",
                value: function() {
                    this.buttonRestart.visible = !0, this.buttonRestart.alpha = 0, this.game.add.tween(this.buttonRestart).to({
                        alpha: 1
                    }, 350, Phaser.Easing.Linear.None, !0, 1e3)
                }
            }, {
                key: "animateAppearing",
                value: function() {
                    var t = this,
                        i = e.ScoreManager.instance.getCurrentScores(),
                        n = e.StarsManager.instance.getLastRoundStars(),
                        a = i > 0 ? Phaser.Math.clamp(Math.pow(i, .9), 450, 1500) : 0,
                        s = n > 0 ? Phaser.Math.clamp(75 * Math.pow(n, .85), 50, 1e3) : 0,
                        o = e.ScoreManager.instance.updateMaxScores(e.ScoreManager.instance.getCurrentScores());
                    e.Settings.ENABLE_API ? (gradle.event('SCREEN_GAMERESULT'), setTimeout(function() {
                        Promise.all([gradle.event("EVENT_LEVELFAIL", {
                            levelName: "",
                            reason: "dead"
                        }), gradle.event("EVENT_TOTALSCORE", {
                            totalScore: i
                        })]).then(function() {
                            return t.showButtons()
                        }, function() {
                            return t.showButtons()
                        })
                    }, 500)) : this.showButtons(), this.buttonRestart.visible = !1, this.scoresPanel.showPanel(200, 800, a, o), this.starsPanel.showPanel(400, 1050, s), e.APIUtils.instance.hasRewardedVideo() ? (this.doubleStarsButton.visible = !0, this.doubleStarsButton.show(1400, e.Settings.RESULTS_DOUBLE_STARS_REWARD)) : this.doubleStarsButton.visible = !1, o && this.recordEffect.show(800 + a + s)
                }
            }, {
                key: "addBonusStars",
                value: function(t) {
                    e.StarsManager.instance.addBonusStars(t), this.starsPanel.tweenTexts(e.StarsManager.instance.getStarsAmount() - t, e.StarsManager.instance.getStarsAmount(), e.StarsManager.instance.getStarsAmount() - t, e.StarsManager.instance.getStarsAmount(), "", "", 50, Phaser.Math.clamp(75 * t, 200, 1200))
                }
            }, {
                key: "resetTweens",
                value: function() {
                    _get(_getPrototypeOf(i.prototype), "resetTweens", this).call(this), this.game.tweens.removeFrom(this.buttonRestart), this.game.tweens.removeFrom(this.buttonRestart.scale), this.game.tweens.removeFrom(this.controlsContainer.scale), this.recordEffect.visible = !1
                }
            }, {
                key: "resizeContent",
                value: function() {
                    _get(_getPrototypeOf(i.prototype), "resizeContent", this).call(this), this.controlsContainer.position.set(0, this.windowManager.windowBounds.height / this.contentContainer.scale.y * .5), this.buttonRestart.position.set(5, this.windowManager.windowBounds.height / this.contentContainer.scale.y * .85)
                }
            }, {
                key: "hide",
                value: function() {
                    e.SoundController.instance.stopCountingSound(), _get(_getPrototypeOf(i.prototype), "hide", this).call(this)
                }
            }, {
                key: "restartClicked",
                value: function() {
                    e.SoundController.instance.stopCountingSound(), e.TransitionScreen.instance.changeState("Level")
                }
            }]), i
        }();
        e.WindowResults = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t) {
                var n;
                return _classCallCheck(this, i), (n = _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, t, e.WindowHeadingBackplateType.SILVER, "iconHeadingRevive", e.Settings.WINDOW_BACKGROUND_ALPHA))).isActive = !1, n
            }
            return _inherits(i, e.CloseableWindow), _createClass(i, [{
                key: "buildContent",
                value: function() {
                    this.controlsContainer = this.contentContainer.add(this.game.make.group()), this.reviveCountdown = this.controlsContainer.add(new e.ReviveCountdown(this)), this.reviveCountdown.position.set(0, 0), this.buttonWatchVideo = this.contentContainer.add(e.ButtonUtils.createSimpleButton(e.Settings.GAME_ATLAS, "buttonRevive", 0, 0, 1.35, this.watchVideoClicked, this))
                }
            }, {
                key: "resizeContent",
                value: function() {
                    _get(_getPrototypeOf(i.prototype), "resizeContent", this).call(this), this.controlsContainer.position.set(0, this.windowManager.windowBounds.height / this.contentContainer.scale.y * .55), this.buttonWatchVideo.position.set(10, this.windowManager.windowBounds.height / this.contentContainer.scale.y * .85)
                }
            }, {
                key: "show",
                value: function() {
                    _get(_getPrototypeOf(i.prototype), "show", this).call(this), e.Settings.ENABLE_API && gradle.event('SCREEN_BONUS'), this.reviveCountdown.startCountdown()
                }
            }, {
                key: "hide",
                value: function() {
                    this.reviveCountdown.resetCountdown(), _get(_getPrototypeOf(i.prototype), "hide", this).call(this)
                }
            }, {
                key: "onCloseClicked",
                value: function() {
                    this.reviveFailed(!1)
                }
            }, {
                key: "watchVideoClicked",
                value: function() {
                    var t = this;
                    e.APIUtils.instance.showRewardedVideo(function() {
                        return t.reviveSucceed()
                    })
                }
            }, {
                key: "reviveSucceed",
                value: function() {
                    var t = this;
                    this.isActive && this.animateDisappearing(0, function() {
                        t.game.state.getCurrentState() instanceof e.Level && t.game.state.getCurrentState().eventManager.onReviveApplied.dispatch()
                    })
                }
            }, {
                key: "reviveFailed",
                value: function(t) {
                    this.isActive && (t && this.animateDisappearing(30, null), this.game.state.getCurrentState() instanceof e.Level && this.game.state.getCurrentState().eventManager.onReviveFailed.dispatch())
                }
            }, {
                key: "animateAppearing",
                value: function(e) {
                    this.isActive = !0, this.reviveCountdown.alpha = 0, this.game.add.tween(this.reviveCountdown).to({
                        alpha: 1
                    }, 350, Phaser.Easing.Linear.None, !0, e + 130), this.reviveCountdown.scale.set(.6), this.game.add.tween(this.reviveCountdown.scale).to({
                        x: 1,
                        y: 1
                    }, 350, Phaser.Easing.Back.Out, !0, e + 130), this.buttonWatchVideo.inputEnabled = !0, this.game.tweens.removeFrom(this.buttonWatchVideo), this.buttonWatchVideo.alpha = 1, this.game.add.tween(this.buttonWatchVideo).from({
                        y: "70",
                        alpha: 0
                    }, 250, Phaser.Easing.Sinusoidal.Out, !0, e + 200)
                }
            }, {
                key: "animateDisappearing",
                value: function(t, n) {
                    this.isActive = !1, _get(_getPrototypeOf(i.prototype), "animateDisappearing", this).call(this, t, n), this.reviveCountdown.animateDisappearing(t), this.buttonWatchVideo.inputEnabled = !1, this.game.tweens.removeFrom(this.buttonWatchVideo), this.game.add.tween(this.buttonWatchVideo).to({
                        y: "100",
                        alpha: 0
                    }, 250, Phaser.Easing.Sinusoidal.In, !0, t), e.Settings.ENABLE_API && gradle.event('SCREEN_LEVEL')
                }
            }, {
                key: "resetTweens",
                value: function() {
                    _get(_getPrototypeOf(i.prototype), "resetTweens", this).call(this), this.game.tweens.removeFrom(this.controlsContainer, !1), this.game.tweens.removeFrom(this.controlsContainer.scale, !1), this.game.tweens.removeFrom(this.reviveCountdown, !1), this.game.tweens.removeFrom(this.reviveCountdown.scale, !1), this.game.tweens.removeFrom(this.buttonWatchVideo, !1)
                }
            }]), i
        }();
        e.WindowRevive = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t) {
                return _classCallCheck(this, i), _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, t, e.WindowHeadingBackplateType.SILVER, "iconHeadingSettings", e.Settings.WINDOW_BACKGROUND_ALPHA))
            }
            return _inherits(i, e.CloseableWindow), _createClass(i, [{
                key: "buildContent",
                value: function() {
                    this.controlsContainer = this.contentContainer.add(this.game.make.group()), this.sfxControl = this.controlsContainer.add(new e.SFXControlScrollbar), this.musicControl = this.controlsContainer.add(new e.MusicControlScrollbar), this.sfxControl.position.set(-25, -70), this.musicControl.position.set(-25, 70), this.buttonRestart = this.contentContainer.add(e.ButtonUtils.createSimpleButton(e.Settings.GAME_ATLAS, "buttonRestart", 0, 0, 1.12, this.restartClicked, this)), this.publisherLogo = this.contentContainer.add(new e.PublisherLogo(0, 0))
                }
            }, {
                key: "resizeContent",
                value: function() {
                    _get(_getPrototypeOf(i.prototype), "resizeContent", this).call(this), this.sfxControl.position.set(-25, -70), this.musicControl.position.set(-25, 70), this.controlsContainer.position.set(0, this.windowManager.windowBounds.height / this.contentContainer.scale.y * .53), this.buttonRestart.position.set(0, this.windowManager.windowBounds.height / this.contentContainer.scale.y * .76), this.publisherLogo.position.set(5, this.windowManager.windowBounds.height / this.contentContainer.scale.y * .92)
                }
            }, {
                key: "onCloseClicked",
                value: function() {
                    e.LocalStorageController.instance.save()
                }
            }, {
                key: "tutorialClicked",
                value: function() {
                    this.hide(), this.game.state.getCurrentState() instanceof e.Level && this.game.state.getCurrentState().tutorialManager.restartTutorial()
                }
            }, {
                key: "restartClicked",
                value: function() {
                    e.TransitionScreen.instance.changeState("Level")
                }
            }, {
                key: "animateAppearing",
                value: function() {
                    this.sfxControl.initValue(), this.musicControl.initValue(), this.sfxControl.alpha = 0, this.game.add.tween(this.sfxControl).to({
                        alpha: 1
                    }, 250, Phaser.Easing.Sinusoidal.Out, !0, 200), this.sfxControl.scale.set(.6), this.game.add.tween(this.sfxControl.scale).to({
                        x: 1,
                        y: 1
                    }, 250, Phaser.Easing.Sinusoidal.Out, !0, 200), this.musicControl.alpha = 0, this.game.add.tween(this.musicControl).to({
                        alpha: 1
                    }, 250, Phaser.Easing.Sinusoidal.Out, !0, 250), this.musicControl.scale.set(.6), this.game.add.tween(this.musicControl.scale).to({
                        x: 1,
                        y: 1
                    }, 250, Phaser.Easing.Sinusoidal.Out, !0, 250), this.buttonRestart.alpha = 0, this.game.add.tween(this.buttonRestart).to({
                        alpha: 1
                    }, 250, Phaser.Easing.Sinusoidal.Out, !0, 350), this.buttonRestart.scale.set(.6), this.game.add.tween(this.buttonRestart.scale).to({
                        x: 1.12,
                        y: 1.12
                    }, 250, Phaser.Easing.Sinusoidal.Out, !0, 350), this.publisherLogo.alpha = 0, this.game.add.tween(this.publisherLogo).to({
                        alpha: 1
                    }, 250, Phaser.Easing.Sinusoidal.Out, !0, 350), this.publisherLogo.scale.set(.28), this.game.add.tween(this.publisherLogo.scale).to({
                        x: .45,
                        y: .45
                    }, 250, Phaser.Easing.Sinusoidal.Out, !0, 350)
                }
            }, {
                key: "animateDisappearing",
                value: function(t, n) {
                    _get(_getPrototypeOf(i.prototype), "animateDisappearing", this).call(this, t, n), this.game.add.tween(this.sfxControl).to({
                        alpha: 0,
                        x: "-150"
                    }, 200, Phaser.Easing.Sinusoidal.InOut, !0, t + 100), this.game.add.tween(this.musicControl).to({
                        alpha: 0,
                        x: "+150"
                    }, 200, Phaser.Easing.Sinusoidal.InOut, !0, t + 100), this.game.tweens.removeFrom(this.buttonRestart), this.game.add.tween(this.buttonRestart).to({
                        y: "100",
                        alpha: 0
                    }, 250, Phaser.Easing.Sinusoidal.In, !0, t + 100), this.game.tweens.removeFrom(this.publisherLogo), this.game.add.tween(this.publisherLogo).to({
                        y: "100",
                        alpha: 0
                    }, 250, Phaser.Easing.Sinusoidal.In, !0, t + 50), e.Settings.ENABLE_API && gradle.event('SCREEN_LEVEL')
                }
            }, {
                key: "resetTweens",
                value: function() {
                    _get(_getPrototypeOf(i.prototype), "resetTweens", this).call(this), this.game.tweens.removeFrom(this.controlsContainer, !1), this.game.tweens.removeFrom(this.controlsContainer.scale, !1), this.game.tweens.removeFrom(this.buttonRestart, !1), this.game.tweens.removeFrom(this.sfxControl, !1), this.game.tweens.removeFrom(this.musicControl, !1), this.game.tweens.removeFrom(this.publisherLogo, !1)
                }
            }]), i
        }();
        e.WindowSettings = t
    }(BlockPuzzle || (BlockPuzzle = {})),
    function(e) {
        var t = function(t) {
            function i(t) {
                return _classCallCheck(this, i), _possibleConstructorReturn(this, _getPrototypeOf(i).call(this, t, e.WindowHeadingBackplateType.SILVER, "iconHeadingShop", e.Settings.WINDOW_BACKGROUND_ALPHA))
            }
            return _inherits(i, e.CloseableWindow), _createClass(i, [{
                key: "buildContent",
                value: function() {
                    this.itemsContainer = this.contentContainer.add(this.game.make.group()), this.itemsMap = new Map, this.itemsMap.set(e.PowerupType.BOMB, this.itemsContainer.add(new e.ShopItem(this, e.PowerupType.BOMB))), this.itemsMap.set(e.PowerupType.LIGHTNING, this.itemsContainer.add(new e.ShopItem(this, e.PowerupType.LIGHTNING))), this.buttonContinue = this.contentContainer.add(e.ButtonUtils.createSimpleButton(e.Settings.GAME_ATLAS, "buttonContinue", 0, 0, 1, this.continueClicked, this)), this.starsCounter = this.contentContainer.add(new e.ShopStarsCounter(this)), this.windowHeading.visible = !1, this.buttonContinue.visible = !1
                }
            }, {
                key: "resizeContent",
                value: function() {
                    _get(_getPrototypeOf(i.prototype), "resizeContent", this).call(this), this.itemsContainer.position.set(-22, this.windowManager.windowBounds.height / this.contentContainer.scale.y * .54), this.buttonContinue.position.set(-5, this.windowManager.windowBounds.height / this.contentContainer.scale.y * .85), this.starsCounter.position.set(-28 * e.CustomScaleManager.UPSCALE_FACTOR, this.windowManager.windowBounds.height / this.contentContainer.scale.y * .2), this.starsCounter.scale.set(e.CustomScaleManager.UPSCALE_FACTOR), this.currentItem && this.currentItem.scale.set(e.CustomScaleManager.UPSCALE_FACTOR)
                }
            }, {
                key: "setPowerupType",
                value: function(e) {
                    this.itemsMap.forEach(function(t) {
                        return t.visible = t.powerupType == e
                    }), this.currentItem = this.itemsMap.get(e)
                }
            }, {
                key: "show",
                value: function() {
                    _get(_getPrototypeOf(i.prototype), "show", this).call(this), e.Settings.ENABLE_API && gradle.event('SCREEN_SHOP'), this.starsCounter.visible = !0, this.updateData()
                }
            }, {
                key: "updateData",
                value: function() {
                    this.starsCounter.setStarsAmount(e.StarsManager.instance.getStarsAmount()), this.currentItem.show()
                }
            }, {
                key: "powerupBought",
                value: function() {
                    this.starsCounter.setStarsAmount(e.StarsManager.instance.getStarsAmount()), this.closeClicked()
                }
            }, {
                key: "animateAppearing",
                value: function(t) {
                    this.currentItem.alpha = 0, this.game.add.tween(this.currentItem).to({
                        alpha: 1
                    }, 200, Phaser.Easing.Sinusoidal.Out, !0, 200), this.currentItem.scale.set(.6), this.game.add.tween(this.currentItem.scale).to({
                        x: e.CustomScaleManager.UPSCALE_FACTOR,
                        y: e.CustomScaleManager.UPSCALE_FACTOR
                    }, 240, Phaser.Easing.Back.Out, !0, 200), this.game.tweens.removeFrom(this.starsCounter), this.starsCounter.alpha = 1, this.game.add.tween(this.starsCounter).from({
                        y: "-60",
                        alpha: 0
                    }, 250, Phaser.Easing.Sinusoidal.Out, !0, t), this.buttonContinue.inputEnabled = !0, this.game.tweens.removeFrom(this.buttonContinue), this.buttonContinue.alpha = 1, this.game.add.tween(this.buttonContinue).from({
                        y: "70",
                        alpha: 0
                    }, 250, Phaser.Easing.Sinusoidal.Out, !0, t + 50)
                }
            }, {
                key: "animateDisappearing",
                value: function(t, n) {
                    _get(_getPrototypeOf(i.prototype), "animateDisappearing", this).call(this, t, n), this.game.add.tween(this.currentItem).to({
                        alpha: 0
                    }, 160, Phaser.Easing.Sinusoidal.InOut, !0, t), this.game.tweens.removeFrom(this.starsCounter), this.game.add.tween(this.starsCounter).to({
                        y: "-60",
                        alpha: 0
                    }, 250, Phaser.Easing.Sinusoidal.In, !0, t), this.buttonContinue.inputEnabled = !1, this.game.tweens.removeFrom(this.buttonContinue), this.game.add.tween(this.buttonContinue).to({
                        y: "100",
                        alpha: 0
                    }, 250, Phaser.Easing.Sinusoidal.In, !0, t), e.Settings.ENABLE_API && gradle.event('SCREEN_LEVEL')
                }
            }, {
                key: "resetTweens",
                value: function() {
                    _get(_getPrototypeOf(i.prototype), "resetTweens", this).call(this), this.game.tweens.removeFrom(this.itemsContainer, !1), this.game.tweens.removeFrom(this.itemsContainer.scale, !1), this.game.tweens.removeFrom(this.buttonContinue, !1), this.game.tweens.removeFrom(this.starsCounter, !1), this.game.tweens.removeFrom(this.starsCounter.scale, !1), this.currentItem && (this.game.tweens.removeFrom(this.currentItem, !1), this.game.tweens.removeFrom(this.currentItem.scale, !1))
                }
            }, {
                key: "onCloseClicked",
                value: function() {}
            }, {
                key: "continueClicked",
                value: function() {
                    this.animateDisappearing(0, function() {})
                }
            }]), i
        }();
        e.WindowShop = t
    }(BlockPuzzle || (BlockPuzzle = {}));